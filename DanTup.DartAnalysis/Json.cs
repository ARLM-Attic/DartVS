// Code generated by UpdateJson.fsx. Do not hand-edit!

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace DanTup.DartAnalysis.Json
{
	public interface IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
	}

	/// <summary>
	/// A directive to begin overlaying the contents of a file.  The
	/// supplied content will be used for analysis in place of the
	/// file contents in the filesystem.
	/// </summary>
	public class AddContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type { get; set; }
		/// <summary>
		/// The new content of the file.
		/// </summary>
		[JsonProperty("content")]
		public string Content { get; set; }
	}

	/// <summary>
	/// An indication of an error, warning, or hint that was produced
	/// by the analysis.
	/// </summary>
	public class AnalysisError
	{
		/// <summary>
		/// The severity of the error.
		/// </summary>
		[JsonProperty("severity")]
		public AnalysisErrorSeverity Severity { get; set; }
		/// <summary>
		/// The type of the error.
		/// </summary>
		[JsonProperty("type")]
		public AnalysisErrorType Type { get; set; }
		/// <summary>
		/// The location associated with the error.
		/// </summary>
		[JsonProperty("location")]
		public Location Location { get; set; }
		/// <summary>
		/// The message to be displayed for this error. The message
		/// should indicate what is wrong with the code and why it is
		/// wrong.
		/// </summary>
		[JsonProperty("message")]
		public string Message { get; set; }
		/// <summary>
		/// The correction message to be displayed for this error. The
		/// correction message should indicate how the user can fix
		/// the error. The field is omitted if there is no correction
		/// message associated with the error code.
		/// </summary>
		[JsonProperty("correction")]
		public string Correction { get; set; }
	}

	/// <summary>
	/// A list of fixes associated with a specific error
	/// </summary>
	public class AnalysisErrorFixes
	{
		/// <summary>
		/// The error with which the fixes are associated.
		/// </summary>
		[JsonProperty("error")]
		public AnalysisError Error { get; set; }
		/// <summary>
		/// The fixes associated with the error.
		/// </summary>
		[JsonProperty("fixes")]
		public SourceChange[] Fixes { get; set; }
	}

	/// <summary>
	/// An enumeration of the possible severities of analysis
	/// errors.
	/// </summary>
	public enum AnalysisErrorSeverity
	{
		Info, Warning, Error
	}

	/// <summary>
	/// An enumeration of the possible types of analysis errors.
	/// </summary>
	public enum AnalysisErrorType
	{
		CheckedModeCompileTimeError, CompileTimeError, Hint, Lint, StaticTypeWarning, StaticWarning, SyntacticError, Todo
	}

	/// <summary>
	/// A set of options controlling what kind of analysis is to be
	/// performed. If the value of a field is omitted the value of the
	/// option will not be changed.
	/// </summary>
	public class AnalysisOptions
	{
		[Obsolete]
		[JsonProperty("enableAsync")]
		public bool EnableAsync { get; set; }
		[Obsolete]
		[JsonProperty("enableDeferredLoading")]
		public bool EnableDeferredLoading { get; set; }
		[Obsolete]
		[JsonProperty("enableEnums")]
		public bool EnableEnums { get; set; }
		/// <summary>
		/// True if the client wants to enable support for the
		/// proposed "null aware operators" feature.
		/// </summary>
		[JsonProperty("enableNullAwareOperators")]
		public bool EnableNullAwareOperators { get; set; }
		/// <summary>
		/// True if hints that are specific to dart2js should be
		/// generated. This option is ignored if generateHints is false.
		/// </summary>
		[JsonProperty("generateDart2jsHints")]
		public bool GenerateDart2jsHints { get; set; }
		/// <summary>
		/// True if hints should be generated as part of generating
		/// errors and warnings.
		/// </summary>
		[JsonProperty("generateHints")]
		public bool GenerateHints { get; set; }
		/// <summary>
		/// True if lints should be generated as part of generating
		/// errors and warnings.
		/// </summary>
		[JsonProperty("generateLints")]
		public bool GenerateLints { get; set; }
	}

	/// <summary>
	/// An enumeration of the services provided by the analysis
	/// domain.
	/// </summary>
	public enum AnalysisService
	{
		Folding, Highlights, Invalidate, Navigation, Occurrences, Outline, Overrides
	}

	/// <summary>
	/// An indication of the current state of analysis.
	/// </summary>
	public class AnalysisStatus
	{
		/// <summary>
		/// True if analysis is currently being performed.
		/// </summary>
		[JsonProperty("isAnalyzing")]
		public bool IsAnalyzing { get; set; }
		/// <summary>
		/// The name of the current target of analysis. This field is
		/// omitted if analyzing is false.
		/// </summary>
		[JsonProperty("analysisTarget")]
		public string AnalysisTarget { get; set; }
	}

	/// <summary>
	/// A directive to modify an existing file content overlay. One or more
	/// ranges of text are deleted from the old file content overlay and
	/// replaced with new text.
	/// </summary>
	public class ChangeContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type { get; set; }
		/// <summary>
		/// The edits to be applied to the file.
		/// </summary>
		[JsonProperty("edits")]
		public SourceEdit[] Edits { get; set; }
	}

	/// <summary>
	/// A suggestion for how to complete partially entered text. Many
	/// of the fields are optional, depending on the kind of element
	/// being suggested.
	/// </summary>
	public class CompletionSuggestion
	{
		/// <summary>
		/// The kind of element being suggested.
		/// </summary>
		[JsonProperty("kind")]
		public CompletionSuggestionKind Kind { get; set; }
		/// <summary>
		/// The relevance of this completion suggestion
		/// where a higher number indicates a higher relevance.
		/// </summary>
		[JsonProperty("relevance")]
		public int Relevance { get; set; }
		/// <summary>
		/// The identifier to be inserted if the suggestion is
		/// selected. If the suggestion is for a method or function,
		/// the client might want to additionally insert a template
		/// for the parameters. The information required in order to
		/// do so is contained in other fields.
		/// </summary>
		[JsonProperty("completion")]
		public string Completion { get; set; }
		/// <summary>
		/// The offset, relative to the beginning of the completion,
		/// of where the selection should be placed after insertion.
		/// </summary>
		[JsonProperty("selectionOffset")]
		public int SelectionOffset { get; set; }
		/// <summary>
		/// The number of characters that should be selected after
		/// insertion.
		/// </summary>
		[JsonProperty("selectionLength")]
		public int SelectionLength { get; set; }
		/// <summary>
		/// True if the suggested element is deprecated.
		/// </summary>
		[JsonProperty("isDeprecated")]
		public bool IsDeprecated { get; set; }
		/// <summary>
		/// True if the element is not known to be valid for the
		/// target. This happens if the type of the target is dynamic.
		/// </summary>
		[JsonProperty("isPotential")]
		public bool IsPotential { get; set; }
		/// <summary>
		/// An abbreviated version of the Dartdoc associated with the
		/// element being suggested, This field is omitted if there is
		/// no Dartdoc associated with the element.
		/// </summary>
		[JsonProperty("docSummary")]
		public string DocSummary { get; set; }
		/// <summary>
		/// The Dartdoc associated with the element being suggested,
		/// This field is omitted if there is no Dartdoc associated
		/// with the element.
		/// </summary>
		[JsonProperty("docComplete")]
		public string DocComplete { get; set; }
		/// <summary>
		/// The class that declares the element being suggested. This
		/// field is omitted if the suggested element is not a member
		/// of a class.
		/// </summary>
		[JsonProperty("declaringType")]
		public string DeclaringType { get; set; }
		/// <summary>
		/// Information about the element reference being suggested.
		/// </summary>
		[JsonProperty("element")]
		public Element Element { get; set; }
		/// <summary>
		/// The return type of the getter, function or method
		/// or the type of the field being suggested.
		/// This field is omitted if the suggested element
		/// is not a getter, function or method.
		/// </summary>
		[JsonProperty("returnType")]
		public string ReturnType { get; set; }
		/// <summary>
		/// The names of the parameters of the function or method
		/// being suggested. This field is omitted if the suggested
		/// element is not a setter, function or method.
		/// </summary>
		[JsonProperty("parameterNames")]
		public string[] ParameterNames { get; set; }
		/// <summary>
		/// The types of the parameters of the function or method
		/// being suggested. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("parameterTypes")]
		public string[] ParameterTypes { get; set; }
		/// <summary>
		/// The number of required parameters for the function or
		/// method being suggested. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("requiredParameterCount")]
		public int RequiredParameterCount { get; set; }
		/// <summary>
		/// True if the function or method being suggested has at
		/// least one named parameter. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("hasNamedParameters")]
		public bool HasNamedParameters { get; set; }
		/// <summary>
		/// The name of the optional parameter being suggested. This
		/// field is omitted if the suggestion is not the addition of
		/// an optional argument within an argument list.
		/// </summary>
		[JsonProperty("parameterName")]
		public string ParameterName { get; set; }
		/// <summary>
		/// The type of the options parameter being suggested. This
		/// field is omitted if the parameterName field is omitted.
		/// </summary>
		[JsonProperty("parameterType")]
		public string ParameterType { get; set; }
		/// <summary>
		/// The import to be added if the suggestion is out of scope
		/// and needs an import to be added to be in scope.
		/// </summary>
		[JsonProperty("importUri")]
		public string ImportUri { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of elements that can be included
	/// in a completion suggestion.
	/// </summary>
	public enum CompletionSuggestionKind
	{
		ArgumentList, Import, Identifier, Invocation, Keyword, NamedArgument, OptionalArgument, Parameter
	}

	/// <summary>
	/// Information about an element (something that can be declared
	/// in code).
	/// </summary>
	public class Element
	{
		/// <summary>
		/// The kind of the element.
		/// </summary>
		[JsonProperty("kind")]
		public ElementKind Kind { get; set; }
		/// <summary>
		/// The name of the element. This is typically used as the
		/// label in the outline.
		/// </summary>
		[JsonProperty("name")]
		public string Name { get; set; }
		/// <summary>
		/// The location of the name in the declaration of the
		/// element.
		/// </summary>
		[JsonProperty("location")]
		public Location Location { get; set; }
		/// <summary>
		/// A bit-map containing the following flags:
		/// </summary>
		[JsonProperty("flags")]
		public int Flags { get; set; }
		/// <summary>
		/// The parameter list for the element. If the element is not
		/// a method or function this field will not be defined. If
		/// the element doesn't have parameters (e.g. getter), this field
		/// will not be defined. If the element has zero parameters, this
		/// field will have a value of "()".
		/// </summary>
		[JsonProperty("parameters")]
		public string Parameters { get; set; }
		/// <summary>
		/// The return type of the element. If the element is not a
		/// method or function this field will not be defined. If the
		/// element does not have a declared return type, this field
		/// will contain an empty string.
		/// </summary>
		[JsonProperty("returnType")]
		public string ReturnType { get; set; }
		/// <summary>
		/// The type parameter list for the element. If the element doesn't
		/// have type parameters, this field will not be defined.
		/// </summary>
		[JsonProperty("typeParameters")]
		public string TypeParameters { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of elements.
	/// </summary>
	public enum ElementKind
	{
		Class, ClassTypeAlias, CompilationUnit, Constructor, Enum, EnumConstant, Field, Function, FunctionTypeAlias, Getter, Label, Library, LocalVariable, Method, Parameter, Prefix, Setter, TopLevelVariable, TypeParameter, UnitTestGroup, UnitTestTest, Unknown
	}

	/// <summary>
	/// A description of an executable file.
	/// </summary>
	public class ExecutableFile
	{
		/// <summary>
		/// The path of the executable file.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The kind of the executable file.
		/// </summary>
		[JsonProperty("kind")]
		public ExecutableKind Kind { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of executable files.
	/// </summary>
	public enum ExecutableKind
	{
		Client, Either, NotExecutable, Server
	}

	/// <summary>
	/// An enumeration of the services provided by the execution
	/// domain.
	/// </summary>
	public enum ExecutionService
	{
		LaunchData
	}

	/// <summary>
	/// An enumeration of the kinds of folding regions.
	/// </summary>
	public enum FoldingKind
	{
		Comment, ClassMember, Directives, DocumentationComment, TopLevelDeclaration
	}

	/// <summary>
	/// A description of a region that can be folded.
	/// </summary>
	public class FoldingRegion
	{
		/// <summary>
		/// The kind of the region.
		/// </summary>
		[JsonProperty("kind")]
		public FoldingKind Kind { get; set; }
		/// <summary>
		/// The offset of the region to be folded.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region to be folded.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	/// <summary>
	/// A description of a region that could have special highlighting
	/// associated with it.
	/// </summary>
	public class HighlightRegion
	{
		/// <summary>
		/// The type of highlight associated with the region.
		/// </summary>
		[JsonProperty("type")]
		public HighlightRegionType Type { get; set; }
		/// <summary>
		/// The offset of the region to be highlighted.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region to be highlighted.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of highlighting that can be
	/// applied to files.
	/// </summary>
	public enum HighlightRegionType
	{
		Annotation, BuiltIn, Class, CommentBlock, CommentDocumentation, CommentEndOfLine, Constructor, Directive, DynamicType, Enum, EnumConstant, Field, FieldStatic, Function, FunctionDeclaration, FunctionTypeAlias, GetterDeclaration, IdentifierDefault, ImportPrefix, Keyword, Label, LiteralBoolean, LiteralDouble, LiteralInteger, LiteralList, LiteralMap, LiteralString, LocalVariable, LocalVariableDeclaration, Method, MethodDeclaration, MethodDeclarationStatic, MethodStatic, Parameter, SetterDeclaration, TopLevelVariable, TypeNameDynamic, TypeParameter
	}

	/// <summary>
	/// The hover information associated with a specific location.
	/// </summary>
	public class HoverInformation
	{
		/// <summary>
		/// The offset of the range of characters that encompases the
		/// cursor position and has the same hover information as the
		/// cursor position.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the range of characters that encompases the
		/// cursor position and has the same hover information as the
		/// cursor position.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The path to the defining compilation unit of the library
		/// in which the referenced element is declared. This data is
		/// omitted if there is no referenced element, or if the
		/// element is declared inside an HTML file.
		/// </summary>
		[JsonProperty("containingLibraryPath")]
		public string ContainingLibraryPath { get; set; }
		/// <summary>
		/// The name of the library in which the referenced element is
		/// declared. This data is omitted if there is no referenced
		/// element, or if the element is declared inside an HTML
		/// file.
		/// </summary>
		[JsonProperty("containingLibraryName")]
		public string ContainingLibraryName { get; set; }
		/// <summary>
		/// A human-readable description of the class declaring the element
		/// being referenced. This data is omitted if there is no referenced
		/// element, or if the element is not a class member.
		/// </summary>
		[JsonProperty("containingClassDescription")]
		public string ContainingClassDescription { get; set; }
		/// <summary>
		/// The dartdoc associated with the referenced element. Other
		/// than the removal of the comment delimiters, including
		/// leading asterisks in the case of a block comment, the
		/// dartdoc is unprocessed markdown. This data is omitted if
		/// there is no referenced element, or if the element has no
		/// dartdoc.
		/// </summary>
		[JsonProperty("dartdoc")]
		public string Dartdoc { get; set; }
		/// <summary>
		/// A human-readable description of the element being
		/// referenced. This data is omitted if there is no referenced
		/// element.
		/// </summary>
		[JsonProperty("elementDescription")]
		public string ElementDescription { get; set; }
		/// <summary>
		/// A human-readable description of the kind of element being
		/// referenced (such as “class” or “function type
		/// alias”). This data is omitted if there is no referenced
		/// element.
		/// </summary>
		[JsonProperty("elementKind")]
		public string ElementKind { get; set; }
		/// <summary>
		/// A human-readable description of the parameter
		/// corresponding to the expression being hovered over. This
		/// data is omitted if the location is not in an argument to a
		/// function.
		/// </summary>
		[JsonProperty("parameter")]
		public string Parameter { get; set; }
		/// <summary>
		/// The name of the propagated type of the expression. This
		/// data is omitted if the location does not correspond to an
		/// expression or if there is no propagated type information.
		/// </summary>
		[JsonProperty("propagatedType")]
		public string PropagatedType { get; set; }
		/// <summary>
		/// The name of the static type of the expression. This data
		/// is omitted if the location does not correspond to an
		/// expression.
		/// </summary>
		[JsonProperty("staticType")]
		public string StaticType { get; set; }
	}

	/// <summary>
	/// A collection of positions that should be linked (edited
	/// simultaneously) for the purposes of updating code after a
	/// source change. For example, if a set of edits introduced a
	/// new variable name, the group would contain all of the
	/// positions of the variable name so that if the client wanted
	/// to let the user edit the variable name after the operation,
	/// all occurrences of the name could be edited simultaneously.
	/// </summary>
	public class LinkedEditGroup
	{
		/// <summary>
		/// The positions of the regions that should be edited
		/// simultaneously.
		/// </summary>
		[JsonProperty("positions")]
		public Position[] Positions { get; set; }
		/// <summary>
		/// The length of the regions that should be edited
		/// simultaneously.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// Pre-computed suggestions for what every region might
		/// want to be changed to.
		/// </summary>
		[JsonProperty("suggestions")]
		public LinkedEditSuggestion[] Suggestions { get; set; }
	}

	/// <summary>
	/// A suggestion of a value that could be used to replace all of
	/// the linked edit regions in a LinkedEditGroup.
	/// </summary>
	public class LinkedEditSuggestion
	{
		/// <summary>
		/// The value that could be used to replace all of the linked
		/// edit regions.
		/// </summary>
		[JsonProperty("value")]
		public string Value { get; set; }
		/// <summary>
		/// The kind of value being proposed.
		/// </summary>
		[JsonProperty("kind")]
		public LinkedEditSuggestionKind Kind { get; set; }
	}

	/// <summary>
	/// An enumeration of the kind of values that can be suggested
	/// for a linked edit.
	/// </summary>
	public enum LinkedEditSuggestionKind
	{
		Method, Parameter, Type, Variable
	}

	/// <summary>
	/// A location (character range) within a file.
	/// </summary>
	public class Location
	{
		/// <summary>
		/// The file containing the range.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the range.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the range.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The one-based index of the line containing the first
		/// character of the range.
		/// </summary>
		[JsonProperty("startLine")]
		public int StartLine { get; set; }
		/// <summary>
		/// The one-based index of the column containing the first
		/// character of the range.
		/// </summary>
		[JsonProperty("startColumn")]
		public int StartColumn { get; set; }
	}

	/// <summary>
	/// A description of a region from which the user can navigate to
	/// the declaration of an element.
	/// </summary>
	public class NavigationRegion
	{
		/// <summary>
		/// The offset of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The indexes of the targets (in the enclosing navigation response)
		/// to which the given region is bound. By opening the target, clients
		/// can implement one form of navigation.
		/// </summary>
		[JsonProperty("targets")]
		public int[] Targets { get; set; }
	}

	/// <summary>
	/// A description of a target to which the user can navigate.
	/// </summary>
	public class NavigationTarget
	{
		/// <summary>
		/// The kind of the element.
		/// </summary>
		[JsonProperty("kind")]
		public ElementKind Kind { get; set; }
		/// <summary>
		/// The index of the file (in the enclosing navigation response) to
		/// navigate to.
		/// </summary>
		[JsonProperty("fileIndex")]
		public int FileIndex { get; set; }
		/// <summary>
		/// The offset of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The one-based index of the line containing the first
		/// character of the region.
		/// </summary>
		[JsonProperty("startLine")]
		public int StartLine { get; set; }
		/// <summary>
		/// The one-based index of the column containing the first
		/// character of the region.
		/// </summary>
		[JsonProperty("startColumn")]
		public int StartColumn { get; set; }
	}

	/// <summary>
	/// A description of the references to a single element within a
	/// single file.
	/// </summary>
	public class Occurrences
	{
		/// <summary>
		/// The element that was referenced.
		/// </summary>
		[JsonProperty("element")]
		public Element Element { get; set; }
		/// <summary>
		/// The offsets of the name of the referenced element within
		/// the file.
		/// </summary>
		[JsonProperty("offsets")]
		public int[] Offsets { get; set; }
		/// <summary>
		/// The length of the name of the referenced element.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	/// <summary>
	/// An node in the outline structure of a file.
	/// </summary>
	public class Outline
	{
		/// <summary>
		/// A description of the element represented by this node.
		/// </summary>
		[JsonProperty("element")]
		public Element Element { get; set; }
		/// <summary>
		/// The offset of the first character of the element. This is
		/// different than the offset in the Element, which if the
		/// offset of the name of the element. It can be used, for
		/// example, to map locations in the file back to an outline.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the element.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The children of the node. The field will be omitted if the
		/// node has no children.
		/// </summary>
		[JsonProperty("children")]
		public Outline[] Children { get; set; }
	}

	/// <summary>
	/// A description of a member that overrides an inherited member.
	/// </summary>
	public class Override
	{
		/// <summary>
		/// The offset of the name of the overriding member.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the name of the overriding member.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The member inherited from a superclass that is overridden
		/// by the overriding member. The field is omitted if there is
		/// no superclass member, in which case there must be at least
		/// one interface member.
		/// </summary>
		[JsonProperty("superclassMember")]
		public OverriddenMember SuperclassMember { get; set; }
		/// <summary>
		/// The members inherited from interfaces that are overridden
		/// by the overriding member. The field is omitted if there
		/// are no interface members, in which case there must be a
		/// superclass member.
		/// </summary>
		[JsonProperty("interfaceMembers")]
		public OverriddenMember[] InterfaceMembers { get; set; }
	}

	/// <summary>
	/// A description of a member that is being overridden.
	/// </summary>
	public class OverriddenMember
	{
		/// <summary>
		/// The element that is being overridden.
		/// </summary>
		[JsonProperty("element")]
		public Element Element { get; set; }
		/// <summary>
		/// The name of the class in which the member is defined.
		/// </summary>
		[JsonProperty("className")]
		public string ClassName { get; set; }
	}

	/// <summary>
	/// A position within a file.
	/// </summary>
	public class Position
	{
		/// <summary>
		/// The file containing the position.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the position.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
	}

	/// <summary>
	/// An indication of the current state of pub execution.
	/// </summary>
	public class PubStatus
	{
		/// <summary>
		/// True if the server is currently running pub to produce a list of
		/// package directories.
		/// </summary>
		[JsonProperty("isListingPackageDirs")]
		public bool IsListingPackageDirs { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of refactorings that can be
	/// created.
	/// </summary>
	public enum RefactoringKind
	{
		ConvertGetterToMethod, ConvertMethodToGetter, ExtractLocalVariable, ExtractMethod, InlineLocalVariable, InlineMethod, MoveFile, Rename, SortMembers
	}

	/// <summary>
	/// A description of a parameter in a method refactoring.
	/// </summary>
	public class RefactoringMethodParameter
	{
		/// <summary>
		/// The unique identifier of the parameter.
		/// Clients may omit this field for the parameters they want to add.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
		/// <summary>
		/// The kind of the parameter.
		/// </summary>
		[JsonProperty("kind")]
		public RefactoringMethodParameterKind Kind { get; set; }
		/// <summary>
		/// The type that should be given to the parameter, or the return type
		/// of the parameter's function type.
		/// </summary>
		[JsonProperty("type")]
		public string Type { get; set; }
		/// <summary>
		/// The name that should be given to the parameter.
		/// </summary>
		[JsonProperty("name")]
		public string Name { get; set; }
		/// <summary>
		/// The parameter list of the parameter's function type.
		/// If the parameter is not of a function type, this field will
		/// not be defined. If the function type has zero parameters, this
		/// field will have a value of "()".
		/// </summary>
		[JsonProperty("parameters")]
		public string Parameters { get; set; }
	}

	/// <summary>
	/// An abstract superclass of all refactoring feedbacks.
	/// </summary>
	public class RefactoringFeedback
	{
	}

	/// <summary>
	/// An abstract superclass of all refactoring options.
	/// </summary>
	public class RefactoringOptions
	{
	}

	/// <summary>
	/// An enumeration of the kinds of parameters.
	/// </summary>
	public enum RefactoringMethodParameterKind
	{
		Required, Positional, Named
	}

	/// <summary>
	/// A description of a problem related to a refactoring.
	/// </summary>
	public class RefactoringProblem
	{
		/// <summary>
		/// The severity of the problem being represented.
		/// </summary>
		[JsonProperty("severity")]
		public RefactoringProblemSeverity Severity { get; set; }
		/// <summary>
		/// A human-readable description of the problem being
		/// represented.
		/// </summary>
		[JsonProperty("message")]
		public string Message { get; set; }
		/// <summary>
		/// The location of the problem being represented.
		/// This field is omitted unless there is a specific location
		/// associated with the problem (such as a location where an element
		/// being renamed will be shadowed).
		/// </summary>
		[JsonProperty("location")]
		public Location Location { get; set; }
	}

	/// <summary>
	/// An enumeration of the severities of problems that can be
	/// returned by the refactoring requests.
	/// </summary>
	public enum RefactoringProblemSeverity
	{
		Info, Warning, Error, Fatal
	}

	/// <summary>
	/// A directive to remove an existing file content overlay.
	/// After processing this directive, the file contents will once
	/// again be read from the file system.
	/// </summary>
	public class RemoveContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type { get; set; }
	}

	/// <summary>
	/// An indication of a problem with the execution of the server,
	/// typically in response to a request.
	/// </summary>
	public class RequestError
	{
		/// <summary>
		/// A code that uniquely identifies the error that occurred.
		/// </summary>
		[JsonProperty("code")]
		public RequestErrorCode Code { get; set; }
		/// <summary>
		/// A short description of the error.
		/// </summary>
		[JsonProperty("message")]
		public string Message { get; set; }
		/// <summary>
		/// The stack trace associated with processing the request,
		/// used for debugging the server.
		/// </summary>
		[JsonProperty("stackTrace")]
		public string StackTrace { get; set; }
	}

	/// <summary>
	/// An enumeration of the types of errors that can occur in the
	/// execution of the server.
	/// </summary>
	public enum RequestErrorCode
	{
		ContentModified, FormatInvalidFile, FormatWithErrors, GetErrorsInvalidFile, InvalidAnalysisRoot, InvalidExecutionContext, InvalidOverlayChange, InvalidParameter, InvalidRequest, NoIndexGenerated, RefactoringRequestCancelled, ServerAlreadyStarted, ServerError, SortMembersInvalidFile, SortMembersParseErrors, UnanalyzedPriorityFiles, UnknownRequest, UnknownSource, UnsupportedFeature
	}

	/// <summary>
	/// A single result from a search request.
	/// </summary>
	public class SearchResult
	{
		/// <summary>
		/// The location of the code that matched the search criteria.
		/// </summary>
		[JsonProperty("location")]
		public Location Location { get; set; }
		/// <summary>
		/// The kind of element that was found or the kind of
		/// reference that was found.
		/// </summary>
		[JsonProperty("kind")]
		public SearchResultKind Kind { get; set; }
		/// <summary>
		/// True if the result is a potential match but cannot be
		/// confirmed to be a match. For example, if all references to
		/// a method m defined in some class were requested, and a
		/// reference to a method m from an unknown class were found,
		/// it would be marked as being a potential match.
		/// </summary>
		[JsonProperty("isPotential")]
		public bool IsPotential { get; set; }
		/// <summary>
		/// The elements that contain the result, starting with the
		/// most immediately enclosing ancestor and ending with the
		/// library.
		/// </summary>
		[JsonProperty("path")]
		public Element[] Path { get; set; }
	}

	/// <summary>
	/// An enumeration of the kinds of search results returned by the
	/// search domain.
	/// </summary>
	public enum SearchResultKind
	{
		Declaration, Invocation, Read, ReadWrite, Reference, Unknown, Write
	}

	/// <summary>
	/// An enumeration of the services provided by the server domain.
	/// </summary>
	public enum ServerService
	{
		Status
	}

	/// <summary>
	/// A description of a set of edits that implement a single
	/// conceptual change.
	/// </summary>
	public class SourceChange
	{
		/// <summary>
		/// A human-readable description of the change to be applied.
		/// </summary>
		[JsonProperty("message")]
		public string Message { get; set; }
		/// <summary>
		/// A list of the edits used to effect the change, grouped by
		/// file.
		/// </summary>
		[JsonProperty("edits")]
		public SourceFileEdit[] Edits { get; set; }
		/// <summary>
		/// A list of the linked editing groups used to customize
		/// the changes that were made.
		/// </summary>
		[JsonProperty("linkedEditGroups")]
		public LinkedEditGroup[] LinkedEditGroups { get; set; }
		/// <summary>
		/// The position that should be selected after the edits
		/// have been applied.
		/// </summary>
		[JsonProperty("selection")]
		public Position Selection { get; set; }
	}

	/// <summary>
	/// A description of a single change to a single file.
	/// </summary>
	public class SourceEdit
	{
		/// <summary>
		/// The offset of the region to be modified.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region to be modified.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The code that is to replace the specified region in the
		/// original code.
		/// </summary>
		[JsonProperty("replacement")]
		public string Replacement { get; set; }
		/// <summary>
		/// An identifier that uniquely identifies this source edit from other
		/// edits in the same response. This field is omitted unless a
		/// containing structure needs to be able to identify the edit for
		/// some reason.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	/// <summary>
	/// A description of a set of changes to a single file.
	/// </summary>
	public class SourceFileEdit
	{
		/// <summary>
		/// The file containing the code to be modified.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The modification stamp of the file at the moment when the change
		/// was created, in milliseconds since the "Unix epoch". Will be -1 if
		/// the file did not exist and should be created. The client may use
		/// this field to make sure that the file was not changed since then,
		/// so it is safe to apply the change.
		/// </summary>
		[JsonProperty("fileStamp")]
		public long FileStamp { get; set; }
		/// <summary>
		/// A list of the edits used to effect the change.
		/// </summary>
		[JsonProperty("edits")]
		public SourceEdit[] Edits { get; set; }
	}

	/// <summary>
	/// A representation of a class in a type hierarchy.
	/// </summary>
	public class TypeHierarchyItem
	{
		/// <summary>
		/// The class element represented by this item.
		/// </summary>
		[JsonProperty("classElement")]
		public Element ClassElement { get; set; }
		/// <summary>
		/// The name to be displayed for the class. This field will be
		/// omitted if the display name is the same as the name of the
		/// element. The display name is different if there is
		/// additional type information to be displayed, such as type
		/// arguments.
		/// </summary>
		[JsonProperty("displayName")]
		public string DisplayName { get; set; }
		/// <summary>
		/// The member in the class corresponding to the member on
		/// which the hierarchy was requested. This field will be
		/// omitted if the hierarchy was not requested for a member or
		/// if the class does not have a corresponding member.
		/// </summary>
		[JsonProperty("memberElement")]
		public Element MemberElement { get; set; }
		/// <summary>
		/// The index of the item representing the superclass of
		/// this class. This field will be omitted if this item
		/// represents the class Object.
		/// </summary>
		[JsonProperty("superclass")]
		public int Superclass { get; set; }
		/// <summary>
		/// The indexes of the items representing the interfaces
		/// implemented by this class. The list will be empty if
		/// there are no implemented interfaces.
		/// </summary>
		[JsonProperty("interfaces")]
		public int[] Interfaces { get; set; }
		/// <summary>
		/// The indexes of the items representing the mixins
		/// referenced by this class. The list will be empty if
		/// there are no classes mixed in to this class.
		/// </summary>
		[JsonProperty("mixins")]
		public int[] Mixins { get; set; }
		/// <summary>
		/// The indexes of the items representing the subtypes of
		/// this class. The list will be empty if there are no
		/// subtypes or if this item represents a supertype of the
		/// pivot type.
		/// </summary>
		[JsonProperty("subclasses")]
		public int[] Subclasses { get; set; }
	}


	public class ServerSetSubscriptionsRequest
	{
		/// <summary>
		/// A list of the services being subscribed to.
		/// </summary>
		[JsonProperty("subscriptions")]
		public ServerService[] Subscriptions { get; set; }
	}

	public class AnalysisGetErrorsRequest
	{
		/// <summary>
		/// The file for which errors are being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
	}

	public class AnalysisGetHoverRequest
	{
		/// <summary>
		/// The file in which hover information is being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset for which hover information is being requested.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
	}

	public class AnalysisGetNavigationRequest
	{
		/// <summary>
		/// The file in which navigation information is being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the region for which navigation information is being
		/// requested.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region for which navigation information is being
		/// requested.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	public class AnalysisReanalyzeRequest
	{
		/// <summary>
		/// A list of the analysis roots that are to be re-analyzed.
		/// </summary>
		[JsonProperty("roots")]
		public string[] Roots { get; set; }
	}

	public class AnalysisSetAnalysisRootsRequest
	{
		/// <summary>
		/// A list of the files and directories that should be
		/// analyzed.
		/// </summary>
		[JsonProperty("included")]
		public string[] Included { get; set; }
		/// <summary>
		/// A list of the files and directories within the
		/// included directories that should not be analyzed.
		/// </summary>
		[JsonProperty("excluded")]
		public string[] Excluded { get; set; }
		/// <summary>
		/// A mapping from source directories to target directories
		/// that should override the normal package: URI resolution
		/// mechanism.  The analyzer will behave as though each
		/// source directory in the map contains a special
		/// pubspec.yaml file which resolves any package: URI to the
		/// corresponding path within the target directory.  The
		/// effect is the same as specifying the target directory as
		/// a "--package_root" parameter to the Dart VM when
		/// executing any Dart file inside the source directory.
		/// </summary>
		[JsonProperty("packageRoots")]
		public Dictionary<string, string> PackageRoots { get; set; }
	}

	public class AnalysisSetPriorityFilesRequest
	{
		/// <summary>
		/// The files that are to be a priority for analysis.
		/// </summary>
		[JsonProperty("files")]
		public string[] Files { get; set; }
	}

	public class AnalysisSetSubscriptionsRequest
	{
		/// <summary>
		/// A table mapping services to a list of the files being
		/// subscribed to the service.
		/// </summary>
		[JsonProperty("subscriptions")]
		public Dictionary<AnalysisService, string[]> Subscriptions { get; set; }
	}

	public class AnalysisUpdateContentRequest
	{
		/// <summary>
		/// A table mapping the files whose content has changed to a
		/// description of the content change.
		/// </summary>
		[JsonProperty("files")]
		public Dictionary<string, IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay> Files { get; set; }
	}

	public class AnalysisUpdateOptionsRequest
	{
		/// <summary>
		/// The options that are to be used to control analysis.
		/// </summary>
		[JsonProperty("options")]
		public AnalysisOptions Options { get; set; }
	}

	public class CompletionGetSuggestionsRequest
	{
		/// <summary>
		/// The file containing the point at which suggestions are
		/// to be made.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset within the file at which suggestions are to
		/// be made.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
	}

	public class SearchFindElementReferencesRequest
	{
		/// <summary>
		/// The file containing the declaration of or reference to
		/// the element used to define the search.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset within the file of the declaration of or
		/// reference to the element.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// True if potential matches are to be included in the
		/// results.
		/// </summary>
		[JsonProperty("includePotential")]
		public bool IncludePotential { get; set; }
	}

	public class SearchFindMemberDeclarationsRequest
	{
		/// <summary>
		/// The name of the declarations to be found.
		/// </summary>
		[JsonProperty("name")]
		public string Name { get; set; }
	}

	public class SearchFindMemberReferencesRequest
	{
		/// <summary>
		/// The name of the references to be found.
		/// </summary>
		[JsonProperty("name")]
		public string Name { get; set; }
	}

	public class SearchFindTopLevelDeclarationsRequest
	{
		/// <summary>
		/// The regular expression used to match the names of the
		/// declarations to be found.
		/// </summary>
		[JsonProperty("pattern")]
		public string Pattern { get; set; }
	}

	public class SearchGetTypeHierarchyRequest
	{
		/// <summary>
		/// The file containing the declaration or reference to the
		/// type for which a hierarchy is being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the name of the type within the file.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
	}

	public class EditFormatRequest
	{
		/// <summary>
		/// The file containing the code to be formatted.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the current selection in the file.
		/// </summary>
		[JsonProperty("selectionOffset")]
		public int SelectionOffset { get; set; }
		/// <summary>
		/// The length of the current selection in the file.
		/// </summary>
		[JsonProperty("selectionLength")]
		public int SelectionLength { get; set; }
	}

	public class EditGetAssistsRequest
	{
		/// <summary>
		/// The file containing the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	public class EditGetAvailableRefactoringsRequest
	{
		/// <summary>
		/// The file containing the code on which the refactoring
		/// would be based.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the code on which the refactoring would be
		/// based.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the code on which the refactoring would be
		/// based.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
	}

	public class EditGetFixesRequest
	{
		/// <summary>
		/// The file containing the errors for which fixes are being
		/// requested.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset used to select the errors for which fixes
		/// will be returned.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
	}

	public class EditGetRefactoringRequest
	{
		/// <summary>
		/// The kind of refactoring to be performed.
		/// </summary>
		[JsonProperty("kind")]
		public RefactoringKind Kind { get; set; }
		/// <summary>
		/// The file containing the code involved in the
		/// refactoring.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the region involved in the refactoring.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the region involved in the refactoring.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// True if the client is only requesting that the values of
		/// the options be validated and no change be generated.
		/// </summary>
		[JsonProperty("validateOnly")]
		public bool ValidateOnly { get; set; }
		/// <summary>
		/// Data used to provide values provided by the user. The
		/// structure of the data is dependent on the kind of
		/// refactoring being performed. The data that is expected is
		/// documented in the section titled Refactorings, labeled as
		/// “Options”. This field can be omitted if the refactoring
		/// does not require any options or if the values of those
		/// options are not known.
		/// </summary>
		[JsonProperty("options")]
		public RefactoringOptions Options { get; set; }
	}

	public class EditSortMembersRequest
	{
		/// <summary>
		/// The Dart file to sort.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
	}

	public class ExecutionCreateContextRequest
	{
		/// <summary>
		/// The path of the Dart or HTML file that will be launched, or the
		/// path of the directory containing the file.
		/// </summary>
		[JsonProperty("contextRoot")]
		public string ContextRoot { get; set; }
	}

	public class ExecutionDeleteContextRequest
	{
		/// <summary>
		/// The identifier of the execution context that is to be deleted.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class ExecutionMapUriRequest
	{
		/// <summary>
		/// The identifier of the execution context in which the URI is to be
		/// mapped.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
		/// <summary>
		/// The path of the file to be mapped into a URI.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The URI to be mapped into a file path.
		/// </summary>
		[JsonProperty("uri")]
		public string Uri { get; set; }
	}

	public class ExecutionSetSubscriptionsRequest
	{
		/// <summary>
		/// A list of the services being subscribed to.
		/// </summary>
		[JsonProperty("subscriptions")]
		public ExecutionService[] Subscriptions { get; set; }
	}


	public class ServerGetVersionResponse
	{
		/// <summary>
		/// The version number of the analysis server.
		/// </summary>
		[JsonProperty("version")]
		public string Version { get; set; }
	}

	public class AnalysisGetErrorsResponse
	{
		/// <summary>
		/// The errors associated with the file.
		/// </summary>
		[JsonProperty("errors")]
		public AnalysisError[] Errors { get; set; }
	}

	public class AnalysisGetHoverResponse
	{
		/// <summary>
		/// The hover information associated with the
		/// location. The list will be empty if no information
		/// could be determined for the location. The list can
		/// contain multiple items if the file is being analyzed
		/// in multiple contexts in conflicting ways (such as a
		/// part that is included in multiple libraries).
		/// </summary>
		[JsonProperty("hovers")]
		public HoverInformation[] Hovers { get; set; }
	}

	public class AnalysisGetLibraryDependenciesResponse
	{
		/// <summary>
		/// A list of the paths of library elements referenced by
		/// files in existing analysis roots.
		/// </summary>
		[JsonProperty("libraries")]
		public string[] Libraries { get; set; }
		/// <summary>
		/// A mapping from context source roots to package maps which map
		/// package names to source directories for use in client-side
		/// package URI resolution.
		/// </summary>
		[JsonProperty("packageMap")]
		public Dictionary<string, Dictionary<string, string[]>> PackageMap { get; set; }
	}

	public class AnalysisGetNavigationResponse
	{
		/// <summary>
		/// A list of the paths of files that are referenced by the navigation
		/// targets.
		/// </summary>
		[JsonProperty("files")]
		public string[] Files { get; set; }
		/// <summary>
		/// A list of the navigation targets that are referenced by the
		/// navigation regions.
		/// </summary>
		[JsonProperty("targets")]
		public NavigationTarget[] Targets { get; set; }
		/// <summary>
		/// A list of the navigation regions within the requested region of
		/// the file.
		/// </summary>
		[JsonProperty("regions")]
		public NavigationRegion[] Regions { get; set; }
	}

	public class AnalysisUpdateContentResponse
	{
	}

	public class CompletionGetSuggestionsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// completion request.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class SearchFindElementReferencesResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
		/// <summary>
		/// The element referenced or defined at the given offset
		/// and whose references will be returned in the search
		/// results.
		/// </summary>
		[JsonProperty("element")]
		public Element Element { get; set; }
	}

	public class SearchFindMemberDeclarationsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class SearchFindMemberReferencesResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class SearchFindTopLevelDeclarationsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class SearchGetTypeHierarchyResponse
	{
		/// <summary>
		/// A list of the types in the requested hierarchy. The
		/// first element of the list is the item representing the
		/// type for which the hierarchy was requested. The index of
		/// other elements of the list is unspecified, but
		/// correspond to the integers used to reference supertype
		/// and subtype items within the items.
		/// </summary>
		[JsonProperty("hierarchyItems")]
		public TypeHierarchyItem[] HierarchyItems { get; set; }
	}

	public class EditFormatResponse
	{
		/// <summary>
		/// The edit(s) to be applied in order to format the code. The list
		/// will be empty if the code was already formatted (there are no
		/// changes).
		/// </summary>
		[JsonProperty("edits")]
		public SourceEdit[] Edits { get; set; }
		/// <summary>
		/// The offset of the selection after formatting the code.
		/// </summary>
		[JsonProperty("selectionOffset")]
		public int SelectionOffset { get; set; }
		/// <summary>
		/// The length of the selection after formatting the code.
		/// </summary>
		[JsonProperty("selectionLength")]
		public int SelectionLength { get; set; }
	}

	public class EditGetAssistsResponse
	{
		/// <summary>
		/// The assists that are available at the given location.
		/// </summary>
		[JsonProperty("assists")]
		public SourceChange[] Assists { get; set; }
	}

	public class EditGetAvailableRefactoringsResponse
	{
		/// <summary>
		/// The kinds of refactorings that are valid for the given
		/// selection.
		/// </summary>
		[JsonProperty("kinds")]
		public RefactoringKind[] Kinds { get; set; }
	}

	public class EditGetFixesResponse
	{
		/// <summary>
		/// The fixes that are available for the errors at the given offset.
		/// </summary>
		[JsonProperty("fixes")]
		public AnalysisErrorFixes[] Fixes { get; set; }
	}

	public class EditGetRefactoringResponse
	{
		/// <summary>
		/// The initial status of the refactoring, i.e. problems related to
		/// the context in which the refactoring is requested.
		/// The array will be empty if there are no known problems.
		/// </summary>
		[JsonProperty("initialProblems")]
		public RefactoringProblem[] InitialProblems { get; set; }
		/// <summary>
		/// The options validation status, i.e. problems in the given options,
		/// such as light-weight validation of a new name, flags
		/// compatibility, etc.
		/// The array will be empty if there are no known problems.
		/// </summary>
		[JsonProperty("optionsProblems")]
		public RefactoringProblem[] OptionsProblems { get; set; }
		/// <summary>
		/// The final status of the refactoring, i.e. problems identified in
		/// the result of a full, potentially expensive validation and / or
		/// change creation.
		/// The array will be empty if there are no known problems.
		/// </summary>
		[JsonProperty("finalProblems")]
		public RefactoringProblem[] FinalProblems { get; set; }
		/// <summary>
		/// Data used to provide feedback to the user. The structure
		/// of the data is dependent on the kind of refactoring
		/// being created. The data that is returned is documented
		/// in the section titled Refactorings, labeled as
		/// “Feedback”.
		/// </summary>
		[JsonProperty("feedback")]
		public RefactoringFeedback Feedback { get; set; }
		/// <summary>
		/// The changes that are to be applied to affect the
		/// refactoring. This field will be omitted if there are
		/// problems that prevent a set of changes from being
		/// computed, such as having no options specified for a
		/// refactoring that requires them, or if only validation
		/// was requested.
		/// </summary>
		[JsonProperty("change")]
		public SourceChange Change { get; set; }
		/// <summary>
		/// The ids of source edits that are not known to be valid. An edit is
		/// not known to be valid if there was insufficient type information
		/// for the server to be able to determine whether or not the code
		/// needs to be modified, such as when a member is being renamed and
		/// there is a reference to a member from an unknown type. This field
		/// will be omitted if the change field is omitted or if there are no
		/// potential edits for the refactoring.
		/// </summary>
		[JsonProperty("potentialEdits")]
		public string[] PotentialEdits { get; set; }
	}

	public class EditSortMembersResponse
	{
		/// <summary>
		/// The file edit that is to be applied to the given file to effect
		/// the sorting.
		/// </summary>
		[JsonProperty("edit")]
		public SourceFileEdit Edit { get; set; }
	}

	public class ExecutionCreateContextResponse
	{
		/// <summary>
		/// The identifier used to refer to the execution context that was
		/// created.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
	}

	public class ExecutionMapUriResponse
	{
		/// <summary>
		/// The file to which the URI was mapped. This field is omitted if the
		/// uri field was not given in the request.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The URI to which the file path was mapped. This field is omitted
		/// if the file field was not given in the request.
		/// </summary>
		[JsonProperty("uri")]
		public string Uri { get; set; }
	}


	[AnalysisNotification("server.connected")]
	public class ServerConnectedNotification
	{
		/// <summary>
		/// The version number of the analysis server.
		/// </summary>
		[JsonProperty("version")]
		public string Version { get; set; }
	}

	[AnalysisNotification("server.error")]
	public class ServerErrorNotification
	{
		/// <summary>
		/// True if the error is a fatal error, meaning that the
		/// server will shutdown automatically after sending this
		/// notification.
		/// </summary>
		[JsonProperty("isFatal")]
		public bool IsFatal { get; set; }
		/// <summary>
		/// The error message indicating what kind of error was
		/// encountered.
		/// </summary>
		[JsonProperty("message")]
		public string Message { get; set; }
		/// <summary>
		/// The stack trace associated with the generation of the
		/// error, used for debugging the server.
		/// </summary>
		[JsonProperty("stackTrace")]
		public string StackTrace { get; set; }
	}

	[AnalysisNotification("server.status")]
	public class ServerStatusNotification
	{
		/// <summary>
		/// The current status of analysis, including whether
		/// analysis is being performed and if so what is being
		/// analyzed.
		/// </summary>
		[JsonProperty("analysis")]
		public AnalysisStatus Analysis { get; set; }
		/// <summary>
		/// The current status of pub execution, indicating whether we are
		/// currently running pub.
		/// </summary>
		[JsonProperty("pub")]
		public PubStatus Pub { get; set; }
	}

	[AnalysisNotification("analysis.errors")]
	public class AnalysisErrorsNotification
	{
		/// <summary>
		/// The file containing the errors.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The errors contained in the file.
		/// </summary>
		[JsonProperty("errors")]
		public AnalysisError[] Errors { get; set; }
	}

	[AnalysisNotification("analysis.flushResults")]
	public class AnalysisFlushResultsNotification
	{
		/// <summary>
		/// The files that are no longer being analyzed.
		/// </summary>
		[JsonProperty("files")]
		public string[] Files { get; set; }
	}

	[AnalysisNotification("analysis.folding")]
	public class AnalysisFoldingNotification
	{
		/// <summary>
		/// The file containing the folding regions.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The folding regions contained in the file.
		/// </summary>
		[JsonProperty("regions")]
		public FoldingRegion[] Regions { get; set; }
	}

	[AnalysisNotification("analysis.highlights")]
	public class AnalysisHighlightsNotification
	{
		/// <summary>
		/// The file containing the highlight regions.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The highlight regions contained in the file. Each
		/// highlight region represents a particular syntactic or
		/// semantic meaning associated with some range. Note that
		/// the highlight regions that are returned can overlap
		/// other highlight regions if there is more than one
		/// meaning associated with a particular region.
		/// </summary>
		[JsonProperty("regions")]
		public HighlightRegion[] Regions { get; set; }
	}

	[AnalysisNotification("analysis.invalidate")]
	public class AnalysisInvalidateNotification
	{
		/// <summary>
		/// The file whose information has been invalidated.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The offset of the invalidated region.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset { get; set; }
		/// <summary>
		/// The length of the invalidated region.
		/// </summary>
		[JsonProperty("length")]
		public int Length { get; set; }
		/// <summary>
		/// The delta to be applied to the offsets in information that follows
		/// the invalidated region in order to update it so that it doesn't
		/// need to be re-requested.
		/// </summary>
		[JsonProperty("delta")]
		public int Delta { get; set; }
	}

	[AnalysisNotification("analysis.navigation")]
	public class AnalysisNavigationNotification
	{
		/// <summary>
		/// The file containing the navigation regions.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The navigation regions contained in the file.
		/// The regions are sorted by their offsets.
		/// Each navigation region represents a list of targets
		/// associated with some range. The lists will usually
		/// contain a single target, but can contain more in the
		/// case of a part that is included in multiple libraries
		/// or in Dart code that is compiled against multiple
		/// versions of a package. Note that the navigation
		/// regions that are returned do not overlap other
		/// navigation regions.
		/// </summary>
		[JsonProperty("regions")]
		public NavigationRegion[] Regions { get; set; }
		/// <summary>
		/// The navigation targets referenced in the file.
		/// They are referenced by NavigationRegions by their
		/// index in this array.
		/// </summary>
		[JsonProperty("targets")]
		public NavigationTarget[] Targets { get; set; }
		/// <summary>
		/// The files containing navigation targets referenced in the file.
		/// They are referenced by NavigationTargets by their
		/// index in this array.
		/// </summary>
		[JsonProperty("files")]
		public string[] Files { get; set; }
	}

	[AnalysisNotification("analysis.occurrences")]
	public class AnalysisOccurrencesNotification
	{
		/// <summary>
		/// The file in which the references occur.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The occurrences of references to elements within the
		/// file.
		/// </summary>
		[JsonProperty("occurrences")]
		public Occurrences[] Occurrences { get; set; }
	}

	[AnalysisNotification("analysis.outline")]
	public class AnalysisOutlineNotification
	{
		/// <summary>
		/// The file with which the outline is associated.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The outline associated with the file.
		/// </summary>
		[JsonProperty("outline")]
		public Outline Outline { get; set; }
	}

	[AnalysisNotification("analysis.overrides")]
	public class AnalysisOverridesNotification
	{
		/// <summary>
		/// The file with which the overrides are associated.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The overrides associated with the file.
		/// </summary>
		[JsonProperty("overrides")]
		public Override[] Overrides { get; set; }
	}

	[AnalysisNotification("completion.results")]
	public class CompletionResultsNotification
	{
		/// <summary>
		/// The id associated with the completion.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
		/// <summary>
		/// The offset of the start of the text to be
		/// replaced. This will be different than the offset used
		/// to request the completion suggestions if there was a
		/// portion of an identifier before the original
		/// offset. In particular, the replacementOffset will be
		/// the offset of the beginning of said identifier.
		/// </summary>
		[JsonProperty("replacementOffset")]
		public int ReplacementOffset { get; set; }
		/// <summary>
		/// The length of the text to be replaced if the remainder
		/// of the identifier containing the cursor is to be
		/// replaced when the suggestion is applied (that is, the
		/// number of characters in the existing identifier).
		/// </summary>
		[JsonProperty("replacementLength")]
		public int ReplacementLength { get; set; }
		/// <summary>
		/// The completion suggestions being reported.  The
		/// notification contains all possible completions at the
		/// requested cursor position, even those that do not match
		/// the characters the user has already typed.  This allows
		/// the client to respond to further keystrokes from the
		/// user without having to make additional requests.
		/// </summary>
		[JsonProperty("results")]
		public CompletionSuggestion[] Results { get; set; }
		/// <summary>
		/// True if this is that last set of results that will be
		/// returned for the indicated completion.
		/// </summary>
		[JsonProperty("isLast")]
		public bool IsLast { get; set; }
	}

	[AnalysisNotification("search.results")]
	public class SearchResultsNotification
	{
		/// <summary>
		/// The id associated with the search.
		/// </summary>
		[JsonProperty("id")]
		public string Id { get; set; }
		/// <summary>
		/// The search results being reported.
		/// </summary>
		[JsonProperty("results")]
		public SearchResult[] Results { get; set; }
		/// <summary>
		/// True if this is that last set of results that will be
		/// returned for the indicated search.
		/// </summary>
		[JsonProperty("isLast")]
		public bool IsLast { get; set; }
	}

	[AnalysisNotification("execution.launchData")]
	public class ExecutionLaunchDataNotification
	{
		/// <summary>
		/// The file for which launch data is being provided. This will either
		/// be a Dart library or an HTML file.
		/// </summary>
		[JsonProperty("file")]
		public string File { get; set; }
		/// <summary>
		/// The kind of the executable file. This field is omitted if the file
		/// is not a Dart file.
		/// </summary>
		[JsonProperty("kind")]
		public ExecutableKind Kind { get; set; }
		/// <summary>
		/// A list of the Dart files that are referenced by the file. This
		/// field is omitted if the file is not an HTML file.
		/// </summary>
		[JsonProperty("referencedFiles")]
		public string[] ReferencedFiles { get; set; }
	}


}