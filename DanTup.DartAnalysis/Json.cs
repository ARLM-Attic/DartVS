// Code generated by UpdateJson.fsx. Do not hand-edit!

using System.Collections.Generic;
using Newtonsoft.Json;

namespace DanTup.DartAnalysis.Json
{
	public interface IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
	}

	/// <summary>
	/// A directive to begin overlaying the contents of a file.  The
	/// supplied content will be used for analysis in place of the
	/// file contents in the filesystem.
	/// </summary>
	public class AddContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type;
		/// <summary>
		/// The new content of the file.
		/// </summary>
		[JsonProperty("content")]
		public string Content;
	}

	/// <summary>
	/// An indication of an error, warning, or hint that was produced
	/// by the analysis.
	/// </summary>
	public class AnalysisError
	{
		/// <summary>
		/// The severity of the error.
		/// </summary>
		[JsonProperty("severity")]
		public ErrorSeverity Severity;
		/// <summary>
		/// The type of the error.
		/// </summary>
		[JsonProperty("type")]
		public ErrorType Type;
		/// <summary>
		/// The location associated with the error.
		/// </summary>
		[JsonProperty("location")]
		public Location Location;
		/// <summary>
		/// The message to be displayed for this error. The message
		/// should indicate what is wrong with the code and why it is
		/// wrong.
		/// </summary>
		[JsonProperty("message")]
		public string Message;
		/// <summary>
		/// The correction message to be displayed for this error. The
		/// correction message should indicate how the user can fix
		/// the error. The field is omitted if there is no correction
		/// message associated with the error code.
		/// </summary>
		[JsonProperty("correction")]
		public string Correction;
	}

	/// <summary>
	/// A set of options controlling what kind of analysis is to be
	/// performed. If the value of a field is omitted the value of the
	/// option will not be changed.
	/// </summary>
	public class AnalysisOptions
	{
		/// <summary>
		/// True if the client wants to enable support for the
		/// proposed async feature.
		/// </summary>
		[JsonProperty("enableAsync")]
		public bool EnableAsync;
		/// <summary>
		/// True if the client wants to enable support for the
		/// proposed deferred loading feature.
		/// </summary>
		[JsonProperty("enableDeferredLoading")]
		public bool EnableDeferredLoading;
		/// <summary>
		/// True if the client wants to enable support for the
		/// proposed enum feature.
		/// </summary>
		[JsonProperty("enableEnums")]
		public bool EnableEnums;
		/// <summary>
		/// True if hints that are specific to dart2js should be
		/// generated. This option is ignored if generateHints is false.
		/// </summary>
		[JsonProperty("generateDart2jsHints")]
		public bool GenerateDart2jsHints;
		/// <summary>
		/// True is hints should be generated as part of generating
		/// errors and warnings.
		/// </summary>
		[JsonProperty("generateHints")]
		public bool GenerateHints;
	}

	/// <summary>
	/// An enumeration of the services provided by the analysis
	/// domain.
	/// </summary>
	public enum AnalysisService
	{
		Folding, Highlights, Navigation, Occurrences, Outline, Overrides
	}

	/// <summary>
	/// An indication of the current state of analysis.
	/// </summary>
	public class AnalysisStatus
	{
		/// <summary>
		/// True if analysis is currently being performed.
		/// </summary>
		[JsonProperty("analyzing")]
		public bool Analyzing;
		/// <summary>
		/// The name of the current target of analysis. This field is
		/// omitted if analyzing is false.
		/// </summary>
		[JsonProperty("analysisTarget")]
		public string AnalysisTarget;
	}

	/// <summary>
	/// A directive to modify an existing file content overlay. One or more
	/// ranges of text are deleted from the old file content overlay and
	/// replaced with new text.
	/// </summary>
	public class ChangeContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type;
		/// <summary>
		/// The edits to be applied to the file.
		/// </summary>
		[JsonProperty("edits")]
		public SourceEdit[] Edits;
	}

	/// <summary>
	/// An enumeration of the relevance of a completion
	/// suggestion.
	/// </summary>
	public enum CompletionRelevance
	{
		Low, Default, High
	}

	/// <summary>
	/// A suggestion for how to complete partially entered text. Many
	/// of the fields are optional, depending on the kind of element
	/// being suggested.
	/// </summary>
	public class CompletionSuggestion
	{
		/// <summary>
		/// The kind of element being suggested.
		/// </summary>
		[JsonProperty("kind")]
		public CompletionSuggestionKind Kind;
		/// <summary>
		/// The relevance of this completion suggestion.
		/// </summary>
		[JsonProperty("relevance")]
		public CompletionRelevance Relevance;
		/// <summary>
		/// The identifier to be inserted if the suggestion is
		/// selected. If the suggestion is for a method or function,
		/// the client might want to additionally insert a template
		/// for the parameters. The information required in order to
		/// do so is contained in other fields.
		/// </summary>
		[JsonProperty("completion")]
		public string Completion;
		/// <summary>
		/// The offset, relative to the beginning of the completion,
		/// of where the selection should be placed after insertion.
		/// </summary>
		[JsonProperty("selectionOffset")]
		public int SelectionOffset;
		/// <summary>
		/// The number of characters that should be selected after
		/// insertion.
		/// </summary>
		[JsonProperty("selectionLength")]
		public int SelectionLength;
		/// <summary>
		/// True if the suggested element is deprecated.
		/// </summary>
		[JsonProperty("isDeprecated")]
		public bool IsDeprecated;
		/// <summary>
		/// True if the element is not known to be valid for the
		/// target. This happens if the type of the target is dynamic.
		/// </summary>
		[JsonProperty("isPotential")]
		public bool IsPotential;
		/// <summary>
		/// An abbreviated version of the Dartdoc associated with the
		/// element being suggested, This field is omitted if there is
		/// no Dartdoc associated with the element.
		/// </summary>
		[JsonProperty("docSummary")]
		public string DocSummary;
		/// <summary>
		/// The Dartdoc associated with the element being suggested,
		/// This field is omitted if there is no Dartdoc associated
		/// with the element.
		/// </summary>
		[JsonProperty("docComplete")]
		public string DocComplete;
		/// <summary>
		/// The class that declares the element being suggested. This
		/// field is omitted if the suggested element is not a member
		/// of a class.
		/// </summary>
		[JsonProperty("declaringType")]
		public string DeclaringType;
		/// <summary>
		/// The return type of the getter, function or method being
		/// suggested. This field is omitted if the suggested element
		/// is not a getter, function or method.
		/// </summary>
		[JsonProperty("returnType")]
		public string ReturnType;
		/// <summary>
		/// The names of the parameters of the function or method
		/// being suggested. This field is omitted if the suggested
		/// element is not a setter, function or method.
		/// </summary>
		[JsonProperty("parameterNames")]
		public string[] ParameterNames;
		/// <summary>
		/// The types of the parameters of the function or method
		/// being suggested. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("parameterTypes")]
		public string[] ParameterTypes;
		/// <summary>
		/// The number of required parameters for the function or
		/// method being suggested. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("requiredParameterCount")]
		public int RequiredParameterCount;
		/// <summary>
		/// The number of positional parameters for the function or
		/// method being suggested. This field is omitted if the
		/// parameterNames field is omitted.
		/// </summary>
		[JsonProperty("positionalParameterCount")]
		public int PositionalParameterCount;
		/// <summary>
		/// The name of the optional parameter being suggested. This
		/// field is omitted if the suggestion is not the addition of
		/// an optional argument within an argument list.
		/// </summary>
		[JsonProperty("parameterName")]
		public string ParameterName;
		/// <summary>
		/// The type of the options parameter being suggested. This
		/// field is omitted if the parameterName field is omitted.
		/// </summary>
		[JsonProperty("parameterType")]
		public string ParameterType;
	}

	/// <summary>
	/// An enumeration of the kinds of elements that can be included
	/// in a completion suggestion.
	/// </summary>
	public enum CompletionSuggestionKind
	{
		ArgumentList, Class, ClassAlias, Constructor, Field, Function, FunctionTypeAlias, Getter, Import, LibraryPrefix, LocalVariable, Method, MethodName, NamedArgument, OptionalArgument, Parameter, Setter, TopLevelVariable, TypeParameter
	}

	/// <summary>
	/// An enumeration of the services provided by the debug
	/// domain.
	/// </summary>
	public enum DebugService
	{
		LaunchData
	}

	/// <summary>
	/// Information about an element (something that can be declared
	/// in code).
	/// </summary>
	public class Element
	{
		/// <summary>
		/// The kind of the element.
		/// </summary>
		[JsonProperty("kind")]
		public ElementKind Kind;
		/// <summary>
		/// The name of the element. This is typically used as the
		/// label in the outline.
		/// </summary>
		[JsonProperty("name")]
		public string Name;
		/// <summary>
		/// The location of the name in the declaration of the
		/// element.
		/// </summary>
		[JsonProperty("location")]
		public Location Location;
		/// <summary>
		/// A bit-map containing the following flags:
		/// </summary>
		[JsonProperty("flags")]
		public int Flags;
		/// <summary>
		/// The parameter list for the element. If the element is not
		/// a method or function this field will not be defined. If
		/// the element has zero parameters, this field will have a
		/// value of "()".
		/// </summary>
		[JsonProperty("parameters")]
		public string Parameters;
		/// <summary>
		/// The return type of the element. If the element is not a
		/// method or function this field will not be defined. If the
		/// element does not have a declared return type, this field
		/// will contain an empty string.
		/// </summary>
		[JsonProperty("returnType")]
		public string ReturnType;
	}

	/// <summary>
	/// An enumeration of the kinds of elements.
	/// </summary>
	public enum ElementKind
	{
		Class, ClassTypeAlias, CompilationUnit, Constructor, Getter, Field, Function, FunctionTypeAlias, Library, LocalVariable, Method, Setter, TopLevelVariable, TypeParameter, Unknown, UnitTestGroup, UnitTestTest
	}

	/// <summary>
	/// An indication of a problem with the execution of the server,
	/// typically in response to a request. The error codes that can
	/// be returned are documented in the section titled Errors.
	/// </summary>
	public class Error
	{
		/// <summary>
		/// A code that uniquely identifies the error that occurred.
		/// </summary>
		[JsonProperty("code")]
		public string Code;
		/// <summary>
		/// A short description of the error.
		/// </summary>
		[JsonProperty("message")]
		public string Message;
		/// <summary>
		/// Additional data related to the error. This field is
		/// omitted if there is no additional data available.
		/// </summary>
		[JsonProperty("data")]
		public object Data;
	}

	/// <summary>
	/// A list of fixes associated with a specific error
	/// </summary>
	public class ErrorFixes
	{
		/// <summary>
		/// The error with which the fixes are associated.
		/// </summary>
		[JsonProperty("error")]
		public AnalysisError Error;
		/// <summary>
		/// The fixes associated with the error.
		/// </summary>
		[JsonProperty("fixes")]
		public SourceChange[] Fixes;
	}

	/// <summary>
	/// An enumeration of the possible severities of analysis
	/// errors.
	/// </summary>
	public enum ErrorSeverity
	{
		Info, Warning, Error
	}

	/// <summary>
	/// An enumeration of the possible types of analysis errors.
	/// </summary>
	public enum ErrorType
	{
		CompileTimeError, Hint, StaticTypeWarning, StaticWarning, SyntacticError, Todo
	}

	/// <summary>
	/// A description of an executable file.
	/// </summary>
	public class ExecutableFile
	{
		/// <summary>
		/// The path of the executable file.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the region to be highlighted.
		/// </summary>
		[JsonProperty("offset")]
		public ExecutableKind Offset;
	}

	/// <summary>
	/// An enumeration of the kinds of executable files.
	/// </summary>
	public enum ExecutableKind
	{
		Client, Either, Server
	}

	/// <summary>
	/// An enumeration of the kinds of folding regions.
	/// </summary>
	public enum FoldingKind
	{
		Comment, ClassMember, Directives, DocumentationComment, TopLevelDeclaration
	}

	/// <summary>
	/// A description of a region that can be folded.
	/// </summary>
	public class FoldingRegion
	{
		/// <summary>
		/// The kind of the region.
		/// </summary>
		[JsonProperty("kind")]
		public FoldingKind Kind;
		/// <summary>
		/// The offset of the region to be folded.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the region to be folded.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
	}

	/// <summary>
	/// A description of a region that could have special highlighting
	/// associated with it.
	/// </summary>
	public class HighlightRegion
	{
		/// <summary>
		/// The type of highlight associated with the region.
		/// </summary>
		[JsonProperty("type")]
		public HighlightRegionType Type;
		/// <summary>
		/// The offset of the region to be highlighted.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the region to be highlighted.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
	}

	/// <summary>
	/// An enumeration of the kinds of highlighting that can be
	/// applied to files.
	/// </summary>
	public enum HighlightRegionType
	{
		Annotation, BuiltIn, Class, CommentBlock, CommentDocumentation, CommentEndOfLine, Constructor, Directive, DynamicType, Field, FieldStatic, Function, FunctionDeclaration, FunctionTypeAlias, GetterDeclaration, IdentifierDefault, ImportPrefix, Keyword, LiteralBoolean, LiteralDouble, LiteralInteger, LiteralList, LiteralMap, LiteralString, LocalVariable, LocalVariableDeclaration, Method, MethodDeclaration, MethodDeclarationStatic, MethodStatic, Parameter, SetterDeclaration, TopLevelVariable, TypeNameDynamic, TypeParameter
	}

	/// <summary>
	/// The hover information associated with a specific location.
	/// </summary>
	public class HoverInformation
	{
		/// <summary>
		/// The offset of the range of characters that encompases the
		/// cursor position and has the same hover information as the
		/// cursor position.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the range of characters that encompases the
		/// cursor position and has the same hover information as the
		/// cursor position.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The path to the defining compilation unit of the library
		/// in which the referenced element is declared. This data is
		/// omitted if there is no referenced element.
		/// </summary>
		[JsonProperty("containingLibraryPath")]
		public string ContainingLibraryPath;
		/// <summary>
		/// The name of the library in which the referenced element is
		/// declared. This data is omitted if there is no referenced
		/// element.
		/// </summary>
		[JsonProperty("containingLibraryName")]
		public string ContainingLibraryName;
		/// <summary>
		/// The dartdoc associated with the referenced element. Other
		/// than the removal of the comment delimiters, including
		/// leading asterisks in the case of a block comment, the
		/// dartdoc is unprocessed markdown. This data is omitted if
		/// there is no referenced element.
		/// </summary>
		[JsonProperty("dartdoc")]
		public string Dartdoc;
		/// <summary>
		/// A human-readable description of the element being
		/// referenced. This data is omitted if there is no referenced
		/// element.
		/// </summary>
		[JsonProperty("elementDescription")]
		public string ElementDescription;
		/// <summary>
		/// A human-readable description of the kind of element being
		/// referenced (such as “class” or “function type
		/// alias”). This data is omitted if there is no referenced
		/// element.
		/// </summary>
		[JsonProperty("elementKind")]
		public string ElementKind;
		/// <summary>
		/// A human-readable description of the parameter
		/// corresponding to the expression being hovered over. This
		/// data is omitted if the location is not in an argument to a
		/// function.
		/// </summary>
		[JsonProperty("parameter")]
		public string Parameter;
		/// <summary>
		/// The name of the propagated type of the expression. This
		/// data is omitted if the location does not correspond to an
		/// expression or if there is no propagated type information.
		/// </summary>
		[JsonProperty("propagatedType")]
		public string PropagatedType;
		/// <summary>
		/// The name of the static type of the expression. This data
		/// is omitted if the location does not correspond to an
		/// expression.
		/// </summary>
		[JsonProperty("staticType")]
		public string StaticType;
	}

	/// <summary>
	/// A collection of positions that should be linked (edited
	/// simultaneously) for the purposes of updating code after a
	/// source change. For example, if a set of edits introduced a
	/// new variable name, the group would contain all of the
	/// positions of the variable name so that if the client wanted
	/// to let the user edit the variable name after the operation,
	/// all occurrences of the name could be edited simultaneously.
	/// </summary>
	public class LinkedEditGroup
	{
		/// <summary>
		/// The positions of the regions that should be edited
		/// simultaneously.
		/// </summary>
		[JsonProperty("positions")]
		public Position[] Positions;
		/// <summary>
		/// The length of the regions that should be edited
		/// simultaneously.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// Pre-computed suggestions for what every region might
		/// want to be changed to.
		/// </summary>
		[JsonProperty("suggestions")]
		public LinkedEditSuggestion[] Suggestions;
	}

	/// <summary>
	/// A suggestion of a value that could be used to replace all of
	/// the linked edit regions in a LinkedEditGroup.
	/// </summary>
	public class LinkedEditSuggestion
	{
		/// <summary>
		/// The value that could be used to replace all of the linked
		/// edit regions.
		/// </summary>
		[JsonProperty("value")]
		public string Value;
		/// <summary>
		/// The kind of value being proposed.
		/// </summary>
		[JsonProperty("kind")]
		public LinkedEditSuggestionKind Kind;
	}

	/// <summary>
	/// An enumeration of the kind of values that can be suggested
	/// for a linked edit.
	/// </summary>
	public enum LinkedEditSuggestionKind
	{
		Method, Parameter, Type, Variable
	}

	/// <summary>
	/// A location (character range) within a file.
	/// </summary>
	public class Location
	{
		/// <summary>
		/// The file containing the range.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the range.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the range.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The one-based index of the line containing the first
		/// character of the range.
		/// </summary>
		[JsonProperty("startLine")]
		public int StartLine;
		/// <summary>
		/// The one-based index of the column containing the first
		/// character of the range.
		/// </summary>
		[JsonProperty("startColumn")]
		public int StartColumn;
	}

	/// <summary>
	/// A description of a region from which the user can navigate to
	/// the declaration of an element.
	/// </summary>
	public class NavigationRegion
	{
		/// <summary>
		/// The offset of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the region from which the user can navigate.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The elements to which the given region is bound. By
		/// opening the declaration of the elements, clients can
		/// implement one form of navigation.
		/// </summary>
		[JsonProperty("targets")]
		public Element[] Targets;
	}

	/// <summary>
	/// A description of the references to a single element within a
	/// single file.
	/// </summary>
	public class Occurrences
	{
		/// <summary>
		/// The element that was referenced.
		/// </summary>
		[JsonProperty("element")]
		public Element Element;
		/// <summary>
		/// The offsets of the name of the referenced element within
		/// the file.
		/// </summary>
		[JsonProperty("offsets")]
		public int[] Offsets;
		/// <summary>
		/// The length of the name of the referenced element.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
	}

	/// <summary>
	/// An node in the outline structure of a file.
	/// </summary>
	public class Outline
	{
		/// <summary>
		/// A description of the element represented by this node.
		/// </summary>
		[JsonProperty("element")]
		public Element Element;
		/// <summary>
		/// The offset of the first character of the element. This is
		/// different than the offset in the Element, which if the
		/// offset of the name of the element. It can be used, for
		/// example, to map locations in the file back to an outline.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the element.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The children of the node. The field will be omitted if the
		/// node has no children.
		/// </summary>
		[JsonProperty("children")]
		public Outline[] Children;
	}

	/// <summary>
	/// A description of a member that overrides an inherited member.
	/// </summary>
	public class Override
	{
		/// <summary>
		/// The offset of the name of the overriding member.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the name of the overriding member.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The member inherited from a superclass that is overridden
		/// by the overriding member. The field is omitted if there is
		/// no superclass member, in which case there must be at least
		/// one interface member.
		/// </summary>
		[JsonProperty("superclassMember")]
		public OverriddenMember SuperclassMember;
		/// <summary>
		/// The members inherited from interfaces that are overridden
		/// by the overriding member. The field is omitted if there
		/// are no interface members, in which case there must be a
		/// superclass member.
		/// </summary>
		[JsonProperty("interfaceMembers")]
		public OverriddenMember[] InterfaceMembers;
	}

	/// <summary>
	/// A description of a member that is being overridden.
	/// </summary>
	public class OverriddenMember
	{
		/// <summary>
		/// The element that is being overridden.
		/// </summary>
		[JsonProperty("element")]
		public Element Element;
		/// <summary>
		/// The name of the class in which the member is defined.
		/// </summary>
		[JsonProperty("className")]
		public string ClassName;
	}

	/// <summary>
	/// A description of a parameter.
	/// </summary>
	public class Parameter
	{
		/// <summary>
		/// The type that should be given to the parameter.
		/// </summary>
		[JsonProperty("type")]
		public string Type;
		/// <summary>
		/// The name that should be given to the parameter.
		/// </summary>
		[JsonProperty("name")]
		public string Name;
	}

	/// <summary>
	/// A position within a file.
	/// </summary>
	public class Position
	{
		/// <summary>
		/// The file containing the position.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the position.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
	}

	/// <summary>
	/// An enumeration of the kinds of refactorings that can be
	/// created.
	/// </summary>
	public enum RefactoringKind
	{
		ConvertGetterToMethod, ConvertMethodToGetter, ExtractLocalVariable, ExtractMethod, InlineLocalVariable, InlineMethod, Rename
	}

	/// <summary>
	/// A description of a problem related to a refactoring.
	/// </summary>
	public class RefactoringProblem
	{
		/// <summary>
		/// The severity of the problem being represented.
		/// </summary>
		[JsonProperty("severity")]
		public RefactoringProblemSeverity Severity;
		/// <summary>
		/// A human-readable description of the problem being
		/// represented.
		/// </summary>
		[JsonProperty("message")]
		public string Message;
		/// <summary>
		/// The location of the problem being represented.
		/// </summary>
		[JsonProperty("location")]
		public Location Location;
	}

	/// <summary>
	/// An enumeration of the severities of problems that can be
	/// returned by the refactoring requests.
	/// </summary>
	public enum RefactoringProblemSeverity
	{
		Info, Warning, Error, Fatal
	}

	/// <summary>
	/// A directive to remove an existing file content overlay.
	/// After processing this directive, the file contents will once
	/// again be read from the file system.
	/// </summary>
	public class RemoveContentOverlay : IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay
	{
		[JsonProperty("type")]
		public string Type;
	}

	/// <summary>
	/// A single result from a search request.
	/// </summary>
	public class SearchResult
	{
		/// <summary>
		/// The location of the code that matched the search criteria.
		/// </summary>
		[JsonProperty("location")]
		public Location Location;
		/// <summary>
		/// The kind of element that was found or the kind of
		/// reference that was found.
		/// </summary>
		[JsonProperty("kind")]
		public SearchResultKind Kind;
		/// <summary>
		/// True if the result is a potential match but cannot be
		/// confirmed to be a match. For example, if all references to
		/// a method m defined in some class were requested, and a
		/// reference to a method m from an unknown class were found,
		/// it would be marked as being a potential match.
		/// </summary>
		[JsonProperty("isPotential")]
		public bool IsPotential;
		/// <summary>
		/// The elements that contain the result, starting with the
		/// most immediately enclosing ancestor and ending with the
		/// library.
		/// </summary>
		[JsonProperty("path")]
		public Element[] Path;
	}

	/// <summary>
	/// An enumeration of the kinds of search results returned by the
	/// search domain.
	/// </summary>
	public enum SearchResultKind
	{
		Declaration, Invocation, Read, ReadWrite, Reference, Write
	}

	/// <summary>
	/// An enumeration of the services provided by the server domain.
	/// </summary>
	public enum ServerService
	{
		Status
	}

	/// <summary>
	/// A description of a set of edits that implement a single
	/// conceptual change.
	/// </summary>
	public class SourceChange
	{
		/// <summary>
		/// A human-readable description of the change to be applied.
		/// </summary>
		[JsonProperty("message")]
		public string Message;
		/// <summary>
		/// A list of the edits used to effect the change, grouped by
		/// file.
		/// </summary>
		[JsonProperty("edits")]
		public SourceFileEdit[] Edits;
		/// <summary>
		/// A list of the linked editing groups used to customize
		/// the changes that were made.
		/// </summary>
		[JsonProperty("linkedEditGroups")]
		public LinkedEditGroup[] LinkedEditGroups;
		/// <summary>
		/// The position that should be selected after the edits
		/// have been applied.
		/// </summary>
		[JsonProperty("selection")]
		public Position Selection;
	}

	/// <summary>
	/// A description of a single change to a single file.
	/// </summary>
	public class SourceEdit
	{
		/// <summary>
		/// The offset of the region to be modified.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the region to be modified.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// The code that is to replace the specified region in the
		/// original code.
		/// </summary>
		[JsonProperty("replacement")]
		public string Replacement;
	}

	/// <summary>
	/// A description of a set of changes to a single file.
	/// </summary>
	public class SourceFileEdit
	{
		/// <summary>
		/// The file containing the code to be modified.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// A list of the edits used to effect the change.
		/// </summary>
		[JsonProperty("edits")]
		public SourceEdit[] Edits;
	}

	/// <summary>
	/// A representation of a class in a type hierarchy.
	/// </summary>
	public class TypeHierarchyItem
	{
		/// <summary>
		/// The class element represented by this item.
		/// </summary>
		[JsonProperty("classElement")]
		public Element ClassElement;
		/// <summary>
		/// The name to be displayed for the class. This field will be
		/// omitted if the display name is the same as the name of the
		/// element. The display name is different if there is
		/// additional type information to be displayed, such as type
		/// arguments.
		/// </summary>
		[JsonProperty("displayName")]
		public string DisplayName;
		/// <summary>
		/// The member in the class corresponding to the member on
		/// which the hierarchy was requested. This field will be
		/// omitted if the hierarchy was not requested for a member or
		/// if the class does not have a corresponding member.
		/// </summary>
		[JsonProperty("memberElement")]
		public Element MemberElement;
		/// <summary>
		/// The index of the item representing the superclass of
		/// this class. This field will be omitted if this item
		/// represents the class Object.
		/// </summary>
		[JsonProperty("superclass")]
		public int Superclass;
		/// <summary>
		/// The indexes of the items representing the interfaces
		/// implemented by this class. The list will be empty if
		/// there are no implemented interfaces.
		/// </summary>
		[JsonProperty("interfaces")]
		public int[] Interfaces;
		/// <summary>
		/// The indexes of the items representing the mixins
		/// referenced by this class. The list will be empty if
		/// there are no classes mixed in to this class.
		/// </summary>
		[JsonProperty("mixins")]
		public int[] Mixins;
		/// <summary>
		/// The indexes of the items representing the subtypes of
		/// this class. The list will be empty if there are no
		/// subtypes or if this item represents a supertype of the
		/// pivot type.
		/// </summary>
		[JsonProperty("subclasses")]
		public int[] Subclasses;
	}


	[AnalysisMethod("server.setSubscriptions")]
	public class ServerSetSubscriptionsRequest
	{
		/// <summary>
		/// A list of the services being subscribed to.
		/// </summary>
		[JsonProperty("subscriptions")]
		public ServerService[] Subscriptions;
	}

	[AnalysisMethod("analysis.getErrors")]
	public class AnalysisGetErrorsRequest
	{
		/// <summary>
		/// The file for which errors are being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File;
	}

	[AnalysisMethod("analysis.getHover")]
	public class AnalysisGetHoverRequest
	{
		/// <summary>
		/// The file in which hover information is being
		/// requested.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset for which hover information is being
		/// requested.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
	}

	[AnalysisMethod("analysis.setAnalysisRoots")]
	public class AnalysisSetAnalysisRootsRequest
	{
		/// <summary>
		/// A list of the files and directories that should be
		/// analyzed.
		/// </summary>
		[JsonProperty("included")]
		public string[] Included;
		/// <summary>
		/// A list of the files and directories within the
		/// included directories that should not be analyzed.
		/// </summary>
		[JsonProperty("excluded")]
		public string[] Excluded;
	}

	[AnalysisMethod("analysis.setPriorityFiles")]
	public class AnalysisSetPriorityFilesRequest
	{
		/// <summary>
		/// The files that are to be a priority for analysis.
		/// </summary>
		[JsonProperty("files")]
		public string[] Files;
	}

	[AnalysisMethod("analysis.setSubscriptions")]
	public class AnalysisSetSubscriptionsRequest
	{
		/// <summary>
		/// A table mapping services to a list of the files being
		/// subscribed to the service.
		/// </summary>
		[JsonProperty("subscriptions")]
		public Dictionary<AnalysisService, string[]> Subscriptions;
	}

	[AnalysisMethod("analysis.updateContent")]
	public class AnalysisUpdateContentRequest
	{
		/// <summary>
		/// A table mapping the files whose content has changed to a
		/// description of the content change.
		/// </summary>
		[JsonProperty("files")]
		public Dictionary<string, IAddContentOverlayOrChangeContentOverlayOrRemoveContentOverlay> Files;
	}

	[AnalysisMethod("analysis.updateOptions")]
	public class AnalysisUpdateOptionsRequest
	{
		/// <summary>
		/// The options that are to be used to control analysis.
		/// </summary>
		[JsonProperty("options")]
		public AnalysisOptions Options;
	}

	[AnalysisMethod("completion.getSuggestions")]
	public class CompletionGetSuggestionsRequest
	{
		/// <summary>
		/// The file containing the point at which suggestions are
		/// to be made.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset within the file at which suggestions are to
		/// be made.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
	}

	[AnalysisMethod("search.findElementReferences")]
	public class SearchFindElementReferencesRequest
	{
		/// <summary>
		/// The file containing the declaration of or reference to
		/// the element used to define the search.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset within the file of the declaration of or
		/// reference to the element.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// True if potential matches are to be included in the
		/// results.
		/// </summary>
		[JsonProperty("includePotential")]
		public bool IncludePotential;
	}

	[AnalysisMethod("search.findMemberDeclarations")]
	public class SearchFindMemberDeclarationsRequest
	{
		/// <summary>
		/// The name of the declarations to be found.
		/// </summary>
		[JsonProperty("name")]
		public string Name;
	}

	[AnalysisMethod("search.findMemberReferences")]
	public class SearchFindMemberReferencesRequest
	{
		/// <summary>
		/// The name of the references to be found.
		/// </summary>
		[JsonProperty("name")]
		public string Name;
	}

	[AnalysisMethod("search.findTopLevelDeclarations")]
	public class SearchFindTopLevelDeclarationsRequest
	{
		/// <summary>
		/// The regular expression used to match the names of the
		/// declarations to be found.
		/// </summary>
		[JsonProperty("pattern")]
		public string Pattern;
	}

	[AnalysisMethod("search.getTypeHierarchy")]
	public class SearchGetTypeHierarchyRequest
	{
		/// <summary>
		/// The file containing the declaration or reference to the
		/// type for which a hierarchy is being requested.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the name of the type within the file.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
	}

	[AnalysisMethod("edit.getAssists")]
	public class EditGetAssistsRequest
	{
		/// <summary>
		/// The file containing the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the code for which assists are being
		/// requested.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
	}

	[AnalysisMethod("edit.getAvailableRefactorings")]
	public class EditGetAvailableRefactoringsRequest
	{
		/// <summary>
		/// The file containing the code on which the refactoring
		/// would be based.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the code on which the refactoring would be
		/// based.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the code on which the refactoring would be
		/// based.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
	}

	[AnalysisMethod("edit.getFixes")]
	public class EditGetFixesRequest
	{
		/// <summary>
		/// The file containing the errors for which fixes are being
		/// requested.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset used to select the errors for which fixes
		/// will be returned.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
	}

	[AnalysisMethod("edit.getRefactoring")]
	public class EditGetRefactoringRequest
	{
		/// <summary>
		/// The identifier of the kind of refactoring to be
		/// performed.
		/// </summary>
		[JsonProperty("kindId")]
		public RefactoringKind KindId;
		/// <summary>
		/// The file containing the code involved in the
		/// refactoring.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The offset of the region involved in the refactoring.
		/// </summary>
		[JsonProperty("offset")]
		public int Offset;
		/// <summary>
		/// The length of the region involved in the refactoring.
		/// </summary>
		[JsonProperty("length")]
		public int Length;
		/// <summary>
		/// True if the client is only requesting that the values of
		/// the options be validated and no change be generated.
		/// </summary>
		[JsonProperty("validateOnly")]
		public bool ValidateOnly;
		/// <summary>
		/// Data used to provide values provided by the user. The
		/// structure of the data is dependent on the kind of
		/// refactoring being performed. The data that is expected is
		/// documented in the section titled Refactorings, labeled as
		/// “Options”. This field can be omitted if the refactoring
		/// does not require any options or if the values of those
		/// options are not known.
		/// </summary>
		[JsonProperty("options")]
		public object Options;
	}

	[AnalysisMethod("debug.createContext")]
	public class DebugCreateContextRequest
	{
		/// <summary>
		/// The path of the Dart or HTML file that will be launched.
		/// </summary>
		[JsonProperty("contextRoot")]
		public string ContextRoot;
	}

	[AnalysisMethod("debug.deleteContext")]
	public class DebugDeleteContextRequest
	{
		/// <summary>
		/// The identifier of the debugging context that is to be
		/// deleted.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	[AnalysisMethod("debug.mapUri")]
	public class DebugMapUriRequest
	{
		/// <summary>
		/// The identifier of the debugging context in which the URI
		/// is to be mapped.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
		/// <summary>
		/// The path of the file to be mapped into a URI.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The URI to be mapped into a file path.
		/// </summary>
		[JsonProperty("uri")]
		public string Uri;
	}

	[AnalysisMethod("debug.setSubscriptions")]
	public class DebugSetSubscriptionsRequest
	{
		/// <summary>
		/// A list of the services being subscribed to.
		/// </summary>
		[JsonProperty("subscriptions")]
		public DebugService[] Subscriptions;
	}


	public class ServerGetVersionResponse
	{
		/// <summary>
		/// The version number of the analysis server.
		/// </summary>
		[JsonProperty("version")]
		public string Version;
	}

	public class AnalysisGetErrorsResponse
	{
		/// <summary>
		/// The errors associated with the file.
		/// </summary>
		[JsonProperty("errors")]
		public AnalysisError[] Errors;
	}

	public class AnalysisGetHoverResponse
	{
		/// <summary>
		/// The hover information associated with the
		/// location. The list will be empty if no information
		/// could be determined for the location. The list can
		/// contain multiple items if the file is being analyzed
		/// in multiple contexts in conflicting ways (such as a
		/// part that is included in multiple libraries).
		/// </summary>
		[JsonProperty("hovers")]
		public HoverInformation[] Hovers;
	}

	public class CompletionGetSuggestionsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// completion request.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	public class SearchFindElementReferencesResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
		/// <summary>
		/// The element referenced or defined at the given offset
		/// and whose references will be returned in the search
		/// results.
		/// </summary>
		[JsonProperty("element")]
		public Element Element;
	}

	public class SearchFindMemberDeclarationsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	public class SearchFindMemberReferencesResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	public class SearchFindTopLevelDeclarationsResponse
	{
		/// <summary>
		/// The identifier used to associate results with this
		/// search request.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	public class SearchGetTypeHierarchyResponse
	{
		/// <summary>
		/// A list of the types in the requested hierarchy. The
		/// first element of the list is the item representing the
		/// type for which the hierarchy was requested. The index of
		/// other elements of the list is unspecified, but
		/// correspond to the integers used to reference supertype
		/// and subtype items within the items.
		/// </summary>
		[JsonProperty("hierarchyItems")]
		public TypeHierarchyItem[] HierarchyItems;
	}

	public class EditGetAssistsResponse
	{
		/// <summary>
		/// The assists that are available at the given location.
		/// </summary>
		[JsonProperty("assists")]
		public SourceChange[] Assists;
	}

	public class EditGetAvailableRefactoringsResponse
	{
		/// <summary>
		/// The kinds of refactorings that are valid for the given
		/// selection.
		/// </summary>
		[JsonProperty("kinds")]
		public RefactoringKind[] Kinds;
	}

	public class EditGetFixesResponse
	{
		/// <summary>
		/// The fixes that are available for each of the analysis
		/// errors. There is a one-to-one correspondence between the
		/// analysis errors in the request and the lists of changes
		/// in the response. In particular, it is always the case
		/// that errors.length == fixes.length and that fixes[i] is
		/// the list of fixes for the error in errors[i]. The list
		/// of changes corresponding to an error can be empty if
		/// there are no fixes available for that error.
		/// </summary>
		[JsonProperty("fixes")]
		public ErrorFixes[] Fixes;
	}

	public class EditGetRefactoringResponse
	{
		/// <summary>
		/// The status of the refactoring. The array will be empty
		/// if there are no known problems.
		/// </summary>
		[JsonProperty("status")]
		public RefactoringProblem[] Status;
		/// <summary>
		/// Data used to provide feedback to the user. The structure
		/// of the data is dependent on the kind of refactoring
		/// being created. The data that is returned is documented
		/// in the section titled Refactorings, labeled as
		/// “Feedback”.
		/// </summary>
		[JsonProperty("feedback")]
		public object Feedback;
		/// <summary>
		/// The changes that are to be applied to affect the
		/// refactoring. This field will be omitted if there are
		/// problems that prevent a set of changed from being
		/// computed, such as having no options specified for a
		/// refactoring that requires them, or if only validation
		/// was requested.
		/// </summary>
		[JsonProperty("change")]
		public SourceChange Change;
	}

	public class DebugCreateContextResponse
	{
		/// <summary>
		/// The identifier used to refer to the debugging context
		/// that was created.
		/// </summary>
		[JsonProperty("id")]
		public string Id;
	}

	public class DebugMapUriResponse
	{
		/// <summary>
		/// The file to which the URI was mapped. This field is
		/// omitted if the uri field was not given in the request.
		/// </summary>
		[JsonProperty("file")]
		public string File;
		/// <summary>
		/// The URI to which the file path was mapped. This field is
		/// omitted if the file field was not given in the request.
		/// </summary>
		[JsonProperty("uri")]
		public string Uri;
	}


}