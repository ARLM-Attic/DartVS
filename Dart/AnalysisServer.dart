import "dart:async" as p;
import "dart:collection" as A_p;
import "dart:convert" as B_p;
import "dart:io" as C_p;
import "dart:math" as D_p;
import "dart:typed_data" as E_p;
void main(List<String> args) {
  Driver driver = new Driver();
  driver.start(args);
}
class Driver {
  static const BINARY_NAME = 'server';
  static const String HELP_OPTION = "help";
  static const String PORT_OPTION = "port";
  static const String LOG_FILE_OPTION = "log";
  static const String SDK_OPTION = 'sdk';
  SocketServer socketServer;
  HttpAnalysisServer httpServer;
  StdioAnalysisServer stdioServer;
  Driver() {}
  void start(List<String> args) {
    ArgParser parser = new ArgParser();
    parser.addFlag(HELP_OPTION, help: "print this help message without starting a server", defaultsTo: false, negatable: false);
    parser.addOption(PORT_OPTION, help: "[port] the port on which the server will listen");
    parser.addOption(LOG_FILE_OPTION, help: "[path] file to log debugging messages to");
    parser.addOption(SDK_OPTION, help: "[path] path to the sdk");
    ArgResults results = parser.parse(args);
    if (results[HELP_OPTION]) {
      _printUsage(parser);
      return;
    }
    if (results[LOG_FILE_OPTION] != null) {
      try {
        C_p.File A_file = new C_p.File(results[LOG_FILE_OPTION]);
        C_p.IOSink A_sink = A_file.openWrite();
        A_Logger.root.onRecord.listen((LogRecord record) {
          A_sink.writeln(record);
        });
      } catch (exception) {
        print('Could not open log file: ${exception}');
        C_p.exitCode = 1;
        return;
      }
    }
    int A_port;
    bool serve_http = false;
    if (results[PORT_OPTION] != null) {
      serve_http = true;
      try {
        A_port = int.parse(results[PORT_OPTION]);
      }on FormatException   {
        print('Invalid port number: ${results[PORT_OPTION]}');
        print('');
        _printUsage(parser);
        C_p.exitCode = 1;
        return;
      }
    }
    DartSdk A_defaultSdk;
    if (results[SDK_OPTION] != null) {
      A_defaultSdk = new DirectoryBasedDartSdk(new JavaFile(results[SDK_OPTION]));
    } else {
      A_defaultSdk = DirectoryBasedDartSdk.defaultSdk;
    }
    socketServer = new SocketServer(A_defaultSdk);
    httpServer = new HttpAnalysisServer(socketServer);
    stdioServer = new StdioAnalysisServer(socketServer);
    if (serve_http) {
      httpServer.serveHttp(A_port);
    }
    stdioServer.serveStdio().then((H__) {
      if (serve_http) {
        httpServer.close();
      }
      C_p.exit(0);
    });
  }
  void _printUsage(ArgParser parser) {
    print('Usage: ${BINARY_NAME} [flags]');
    print('');
    print('Supported flags are:');
    print(parser.getUsage());
  }
}
class HttpAnalysisServer {
  SocketServer socketServer;
  GetHandler getHandler;
  HttpAnalysisServer(this.socketServer);
  p.Future<C_p.HttpServer> _server;
  void _handleServer(C_p.HttpServer httServer) {
    httServer.listen((C_p.HttpRequest request) {
      List<String> updateValues = request.headers[C_p.HttpHeaders.UPGRADE];
      if (updateValues != null && updateValues.indexOf('websocket') >= 0) {
        C_p.WebSocketTransformer.upgrade(request).then((C_p.WebSocket websocket) {
          _handleWebSocket(websocket);
        });
      } else if (request.method == 'GET') {
        _handleGetRequest(request);
      } else {
        _returnUnknownRequest(request);
      }
    });
  }
  void _handleGetRequest(C_p.HttpRequest request) {
    if (getHandler == null) {
      getHandler = new GetHandler(socketServer);
    }
    getHandler.handleGetRequest(request);
  }
  void _handleWebSocket(C_p.WebSocket A_socket) {
    socketServer.createAnalysisServer(new WebSocketServerChannel(A_socket));
  }
  void _returnUnknownRequest(C_p.HttpRequest request) {
    C_p.HttpResponse A_response = request.response;
    A_response.statusCode = C_p.HttpStatus.NOT_FOUND;
    A_response.headers.add(C_p.HttpHeaders.CONTENT_TYPE, "text/plain");
    A_response.write('Not found');
    A_response.close();
  }
  void serveHttp(int A_port) {
    _server = C_p.HttpServer.bind(C_p.InternetAddress.LOOPBACK_IP_V4, A_port);
    _server.then(_handleServer);
  }
  void close() {
    _server.then((C_p.HttpServer server) {
      server.close();
    });
  }
}
class AnalysisLogger implements Logger {
  final A_Logger baseLogger = new A_Logger('analysis.server');
  void logError(String A_message) {
    baseLogger.severe(A_message);
  }
  void logError2(String A_message, Exception exception) {
    baseLogger.severe(A_message, exception);
  }
  void logInformation(String A_message) {
    baseLogger.info(A_message);
  }
  void logInformation2(String A_message, Exception exception) {
    baseLogger.info(A_message, exception);
  }
}
class AnalysisServerContextDirectoryManager extends ContextDirectoryManager {
  final AnalysisServer analysisServer;
  AnalysisOptionsImpl defaultOptions = new AnalysisOptionsImpl();
  AnalysisServerContextDirectoryManager(this.analysisServer, ResourceProvider resourceProvider, PackageMapProvider packageMapProvider) : super(resourceProvider, packageMapProvider);
  void addContext(Folder folder, Map<String, List<Folder>> packageMap) {
    AnalysisContext context = AnalysisEngine.A_instance.createAnalysisContext();
    analysisServer.folderMap[folder] = context;
    context.sourceFactory = _createSourceFactory(packageMap);
    context.analysisOptions = new AnalysisOptionsImpl.C_con1(defaultOptions);
    analysisServer.schedulePerformAnalysisOperation(context);
  }
  void applyChangesToContext(Folder contextFolder, ChangeSet changeSet) {
    AnalysisContext context = analysisServer.folderMap[contextFolder];
    if (context != null) {
      context.applyChanges(changeSet);
      analysisServer.schedulePerformAnalysisOperation(context);
    }
  }
  void removeContext(Folder folder) {
    AnalysisContext context = analysisServer.folderMap.remove(folder);
    analysisServer.sendContextAnalysisCancelledNotifications(context, 'Context was removed');
  }
  void updateContextPackageMap(Folder contextFolder, Map<String, List<Folder>> packageMap) {
    AnalysisContext context = analysisServer.folderMap[contextFolder];
    context.sourceFactory = _createSourceFactory(packageMap);
    analysisServer.schedulePerformAnalysisOperation(context);
  }
  SourceFactory _createSourceFactory(Map<String, List<Folder>> packageMap) {
    List<UriResolver> resolvers = <UriResolver>[new DartUriResolver(analysisServer.A_defaultSdk), new ResourceUriResolver(resourceProvider), new PackageMapUriResolver(resourceProvider, packageMap)];
    return new SourceFactory(resolvers);
  }
}
class AnalysisServer {
  final ServerCommunicationChannel channel;
  final ResourceProvider resourceProvider;
  final Index index;
  SearchEngine searchEngine;
  AnalysisServerContextDirectoryManager contextDirectoryManager;
  bool running;
  bool statusAnalyzing = false;
  List<RequestHandler> handlers;
  final DartSdk A_defaultSdk;
  final Map<Folder, AnalysisContext> folderMap = new A_p.HashMap<Folder,AnalysisContext>();
  ServerOperationQueue operationQueue;
  Set<ServerService> serverServices = new A_p.HashSet<ServerService>();
  Map<AnalysisService, Set<String>> analysisServices = new A_p.HashMap<AnalysisService,Set<String>>();
  Map<AnalysisContext, p.Completer> contextAnalysisDoneCompleters = new A_p.HashMap<AnalysisContext,p.Completer>();
  bool rethrowExceptions;
  AnalysisServer(this.channel, this.resourceProvider, PackageMapProvider packageMapProvider, this.index, this.A_defaultSdk, {this.rethrowExceptions: true}) {
    searchEngine = createSearchEngine(index);
    operationQueue = new ServerOperationQueue(this);
    contextDirectoryManager = new AnalysisServerContextDirectoryManager(this, resourceProvider, packageMapProvider);
    AnalysisEngine.A_instance.logger = new AnalysisLogger();
    running = true;
    Notification notification = new Notification(SERVER_CONNECTED);
    channel.sendNotification(notification);
    channel.listen(handleRequest, onDone: done, onError: error);
  }
  void scheduleOperation(ServerOperation operation) {
    bool wasEmpty = operationQueue.isEmpty;
    addOperation(operation);
    if (wasEmpty) {
      _schedulePerformOperation();
    }
  }
  void schedulePerformAnalysisOperation(AnalysisContext context) {
    scheduleOperation(new PerformAnalysisOperation(context, false));
  }
  void sendNotification(Notification notification) {
    channel.sendNotification(notification);
  }
  void sendResponse(Response A_response) {
    channel.sendResponse(A_response);
  }
  void setPriorityFiles(Request request, List<String> files) {
    Map<AnalysisContext, List<Source>> sourceMap = new A_p.HashMap<AnalysisContext,List<Source>>();
    List<String> unanalyzed = new List<String>();
    files.forEach((A_file) {
      AnalysisContext analysisContext = getAnalysisContext(A_file);
      if (analysisContext == null) {
        unanalyzed.add(A_file);
      } else {
        List<Source> sourceList = sourceMap[analysisContext];
        if (sourceList == null) {
          sourceList = <Source>[];
          sourceMap[analysisContext] = sourceList;
        }
        sourceList.add(getSource(A_file));
      }
    });
    if (unanalyzed.isNotEmpty) {
      StringBuffer A_buffer = new StringBuffer();
      A_buffer.writeAll(unanalyzed, ', ');
      throw new RequestFailure(new Response.unanalyzedPriorityFiles(request, A_buffer.toString()));
    }
    folderMap.forEach((Folder folder, AnalysisContext context) {
      List<Source> sourceList = sourceMap[context];
      if (sourceList == null) {
        sourceList = Source.F_EMPTY_ARRAY;
      }
      context.analysisPriorityOrder = sourceList;
    });
  }
  void updateOptions(List<OptionUpdater> optionUpdaters) {
    folderMap.forEach((Folder folder, AnalysisContext context) {
      AnalysisOptionsImpl options = new AnalysisOptionsImpl.C_con1(context.analysisOptions);
      optionUpdaters.forEach((OptionUpdater optionUpdater) {
        optionUpdater(options);
      });
      context.analysisOptions = options;
    });
    AnalysisOptionsImpl options = contextDirectoryManager.defaultOptions;
    optionUpdaters.forEach((OptionUpdater optionUpdater) {
      optionUpdater(options);
    });
  }
  void addOperation(ServerOperation operation) {
    operationQueue.add(operation);
  }
  void done() {
    index.stop();
    running = false;
  }
  void error(argument) {
    running = false;
  }
  void handleRequest(Request request) {
    int count = handlers.length;
    for (int i = 0; i < count; i++) {
      try {
        Response A_response = handlers[i].handleRequest(request);
        if (A_response == Response.DELAYED_RESPONSE) {
          return;
        }
        if (A_response != null) {
          channel.sendResponse(A_response);
          return;
        }
      }on RequestFailure  catch (exception) {
        channel.sendResponse(exception.response);
        return;
      }
    }
    channel.sendResponse(new Response.unknownRequest(request));
  }
  bool hasAnalysisSubscription(AnalysisService service, String A_file) {
    Set<String> files = analysisServices[service];
    return files != null && files.contains(A_file);
  }
  bool shouldSendErrorsNotificationFor(String A_file) {
    return contextDirectoryManager.isInAnalysisRoot(A_file);
  }
  bool isPriorityContext(AnalysisContext context) {
    return false;
  }
  void performOperation() {
    if (!running) {
      operationQueue.clear();
      return;
    }
    ServerOperation operation = operationQueue.take();
    sendStatusNotification(operation);
    try {
      operation.perform(this);
    } catch (exception, A_stackTrace) {
      AnalysisEngine.A_instance.logger.logError("${exception}\n${A_stackTrace}");
      if (rethrowExceptions) {
        throw new AnalysisException('Unexpected exception during analysis', new CaughtException(exception, A_stackTrace));
      }
      _sendServerErrorNotification(exception, A_stackTrace);
      shutdown();
    } finally {
      if (!operationQueue.isEmpty) {
        _schedulePerformOperation();
      } else {
        sendStatusNotification(null);
      }
    }
  }
  void sendStatusNotification(ServerOperation operation) {
    bool isAnalyzing = operation != null;
    if (statusAnalyzing == isAnalyzing) {
      return;
    }
    statusAnalyzing = isAnalyzing;
    Notification notification = new Notification(SERVER_STATUS);
    Map<String, Object> analysis = new A_p.HashMap();
    analysis['analyzing'] = isAnalyzing;
    notification.params['analysis'] = analysis;
    channel.sendNotification(notification);
  }
  void setAnalysisRoots(String requestId, List<String> includedPaths, List<String> excludedPaths) {
    try {
      contextDirectoryManager.setRoots(includedPaths, excludedPaths);
    }on UnimplementedError  catch (e) {
      throw new RequestFailure(new Response.unsupportedFeature(requestId, e.message));
    }
  }
  void updateContent(Map<String, ContentChange> changes) {
    changes.forEach((A_file, A_change) {
      AnalysisContext analysisContext = getAnalysisContext(A_file);
      if (analysisContext != null) {
        Source A_source = getSource(A_file);
        if (A_change.offset == null) {
          analysisContext.setContents(A_source, A_change.content);
        } else {
          analysisContext.setChangedContents(A_source, A_change.content, A_change.offset, A_change.oldLength, A_change.newLength);
        }
        schedulePerformAnalysisOperation(analysisContext);
      }
    });
  }
  void setAnalysisSubscriptions(Map<AnalysisService, Set<String>> subscriptions) {
    subscriptions.forEach((service, Set<String> newFiles) {
      Set<String> oldFiles = analysisServices[service];
      Set<String> todoFiles = oldFiles != null ? newFiles.difference(oldFiles) : newFiles;
      for (String A_file in todoFiles) {
        Source A_source = getSource(A_file);
        AnalysisContext context = getAnalysisContext(A_file);
        if (context == null) {
          continue;
        }
        if (AnalysisEngine.isDartFileName(A_file)) {
          CompilationUnit dartUnit = getResolvedCompilationUnitToResendNotification(A_file);
          if (dartUnit != null) {
            switch (service) {
              case AnalysisService.HIGHLIGHTS:
                sendAnalysisNotificationHighlights(this, A_file, dartUnit);
                break;

              case AnalysisService.NAVIGATION:
                sendAnalysisNotificationNavigation(this, A_file, dartUnit);
                break;

              case AnalysisService.OCCURRENCES:
                sendAnalysisNotificationOccurrences(this, A_file, dartUnit);
                break;

              case AnalysisService.OUTLINE:
                sendAnalysisNotificationOutline(this, context, A_source, dartUnit);
                break;

              case AnalysisService.OVERRIDES:
                sendAnalysisNotificationOverrides(this, A_file, dartUnit);
                break;
            }
          }
        }
      }
    });
    this.analysisServices = subscriptions;
  }
  AnalysisContext getAnalysisContext(String A_path) {
    for (Folder folder in folderMap.keys) {
      if (A_path.startsWith(folder.path)) {
        return folderMap[folder];
      }
    }
    {
      Source A_source = getSource(A_path);
      for (AnalysisContext context in folderMap.values) {
        SourceKind kind = context.getKindOf(A_source);
        if (kind != null) {
          return context;
        }
      }
    }
    return null;
  }
  Source getSource(String A_path) {
    {
      Uri A_uri = resourceProvider.pathContext.A_toUri(A_path);
      Source sdkSource = A_defaultSdk.fromFileUri(A_uri);
      if (sdkSource != null) {
        return sdkSource;
      }
    }
    A_File A_file = resourceProvider.getResource(A_path);
    return A_file.createSource();
  }
  CompilationUnit getResolvedCompilationUnitToResendNotification(String A_path) {
    AnalysisContext context = getAnalysisContext(A_path);
    if (context == null) {
      return null;
    }
    Source unitSource = getSource(A_path);
    List<Source> librarySources = context.getLibrariesContaining(unitSource);
    if (librarySources.isEmpty) {
      return null;
    }
    Source librarySource = librarySources[0];
    if (context.getLibraryElement(librarySource) == null) {
      return null;
    }
    return context.resolveCompilationUnit2(unitSource, librarySource);
  }
  AnalysisErrorInfo getErrors(String A_file) {
    AnalysisContext context = getAnalysisContext(A_file);
    if (context == null) {
      return null;
    }
    Source A_source = getSource(A_file);
    return context.getErrors(A_source);
  }
  List<CompilationUnit> getResolvedCompilationUnits(String A_path) {
    List<CompilationUnit> units = <CompilationUnit>[];
    AnalysisContext context = getAnalysisContext(A_path);
    if (context == null) {
      return units;
    }
    Source unitSource = getSource(A_path);
    List<Source> librarySources = context.getLibrariesContaining(unitSource);
    for (Source librarySource in librarySources) {
      CompilationUnit unit = context.getResolvedCompilationUnit2(unitSource, librarySource);
      if (unit != null) {
        units.add(unit);
      }
    }
    return units;
  }
  List<A_Element> getElementsAtOffset(String A_path, int A_offset) {
    List<CompilationUnit> units = getResolvedCompilationUnits(A_path);
    List<A_Element> elements = <A_Element>[];
    for (CompilationUnit unit in units) {
      AstNode node = new NodeLocator.con1(A_offset).searchWithin(unit);
      A_Element A_element = ElementLocator.locateWithOffset(node, A_offset);
      if (A_element != null) {
        elements.add(A_element);
      }
    }
    return elements;
  }
  p.Future onFileAnalysisComplete(String A_file) {
    AnalysisContext context = getAnalysisContext(A_file);
    if (context == null) {
      return new p.Future.value();
    }
    schedulePerformAnalysisOperation(context);
    p.Completer completer = contextAnalysisDoneCompleters[context];
    if (completer == null) {
      completer = new p.Completer();
      contextAnalysisDoneCompleters[context] = completer;
    }
    return completer.future;
  }
  void sendContextAnalysisDoneNotifications(AnalysisContext context) {
    p.Completer completer = contextAnalysisDoneCompleters.remove(context);
    if (completer != null) {
      completer.complete();
    }
  }
  void sendContextAnalysisCancelledNotifications(AnalysisContext context, String A_message) {
    p.Completer completer = contextAnalysisDoneCompleters.remove(context);
    if (completer != null) {
      completer.completeError(A_message);
    }
  }
  void shutdown() {
    running = false;
    if (index != null) {
      index.clear();
      index.stop();
    }
    new p.Future(channel.close);
  }
  void _schedulePerformOperation() {
    new p.Future(performOperation);
  }
  void _sendServerErrorNotification(exception, A_stackTrace) {
    String exceptionString;
    if (exception != null) {
      exceptionString = exception.toString();
    } else {
      exceptionString = 'null exception';
    }
    String stackTraceString;
    if (A_stackTrace != null) {
      stackTraceString = A_stackTrace.toString();
    } else {
      stackTraceString = 'null stackTrace';
    }
    Notification notification = new Notification(SERVER_ERROR);
    notification.setParameter(FATAL, true);
    notification.setParameter(A_MESSAGE, exceptionString);
    notification.setParameter(STACK_TRACE, stackTraceString);
    channel.sendNotification(notification);
  }
}
class AnalysisService extends Enum2<AnalysisService> {
  static const HIGHLIGHTS = const AnalysisService('HIGHLIGHTS', 1);
  static const NAVIGATION = const AnalysisService('NAVIGATION', 2);
  static const OCCURRENCES = const AnalysisService('OCCURRENCES', 3);
  static const OUTLINE = const AnalysisService('OUTLINE', 4);
  static const OVERRIDES = const AnalysisService('OVERRIDES', 5);
  static const List<AnalysisService> VALUES = const[HIGHLIGHTS, NAVIGATION, OCCURRENCES, OUTLINE, OVERRIDES];
  const AnalysisService(String A_name, int ordinal) : super(A_name, ordinal);
}
typedef void OptionUpdater(AnalysisOptionsImpl options);
class ServerService extends Enum2<ServerService> {
  static const ServerService STATUS = const ServerService('STATUS', 0);
  static const List<ServerService> VALUES = const[STATUS];
  const ServerService(String A_name, int ordinal) : super(A_name, ordinal);
}
abstract class ServerCommunicationChannel {
  void listen(void onRequest(Request request), {Function onError, void onDone()});
  void sendNotification(Notification notification);
  void sendResponse(Response A_response);
  void close();
}
class WebSocketServerChannel implements ServerCommunicationChannel {
  final C_p.WebSocket socket;
  WebSocketServerChannel(this.socket);
  void listen(void onRequest(Request request), {void onError(), void onDone()}) {
    socket.listen((A_data) => readRequest(A_data, onRequest), onError: onError, onDone: onDone);
  }
  void sendNotification(Notification notification) {
    socket.add(B_p.JSON.encode(notification.toJson()));
  }
  void sendResponse(Response A_response) {
    socket.add(B_p.JSON.encode(A_response.toJson()));
  }
  void readRequest(Object A_data, void onRequest(Request request)) {
    if (A_data is String) {
      Request request = new Request.A_fromString(A_data);
      if (request == null) {
        sendResponse(new Response.invalidRequestFormat());
        return;
      }
      onRequest(request);
    } else if (A_data is List<int>) {
      sendResponse(new Response.invalidRequestFormat());
    } else {
      sendResponse(new Response.invalidRequestFormat());
    }
  }
  void close() {
    socket.close(C_p.WebSocketStatus.NORMAL_CLOSURE);
  }
}
class ByteStreamServerChannel implements ServerCommunicationChannel {
  final p.Stream input;
  final C_p.IOSink output;
  final p.Completer A__closed = new p.Completer();
  ByteStreamServerChannel(this.input, this.output);
  p.Future get closed {
    return A__closed.future;
  }
  void listen(void onRequest(Request request), {Function onError, void onDone()}) {
    input.transform((new B_p.Utf8Codec()).decoder).transform(new B_p.LineSplitter()).listen((String A_data) => _readRequest(A_data, onRequest), onError: onError, onDone: () {
      close();
      onDone();
    });
  }
  void sendNotification(Notification notification) {
    if (A__closed.isCompleted) {
      return;
    }
    output.writeln(B_p.JSON.encode(notification.toJson()));
  }
  void sendResponse(Response A_response) {
    if (A__closed.isCompleted) {
      return;
    }
    output.writeln(B_p.JSON.encode(A_response.toJson()));
  }
  void _readRequest(Object A_data, void onRequest(Request request)) {
    if (A__closed.isCompleted) {
      return;
    }
    Request request = new Request.A_fromString(A_data);
    if (request == null) {
      sendResponse(new Response.invalidRequestFormat());
      return;
    }
    onRequest(request);
  }
  void close() {
    if (!A__closed.isCompleted) {
      A__closed.complete();
    }
  }
}
Iterable concat(Iterable<Iterable> iterables) => iterables.expand((A_x) => A_x);
List concatToList(Iterable<Iterable> iterables) => concat(iterables).toList();
class DartUnitHighlightsComputer {
  final CompilationUnit _unit;
  final List<HighlightRegion> _regions = <HighlightRegion>[];
  DartUnitHighlightsComputer(this._unit);
  List<HighlightRegion> compute() {
    _unit.accept(new _DartUnitHighlightsComputerVisitor(this));
    _addCommentRanges();
    return _regions;
  }
  void _addCommentRanges() {
    A_Token token = _unit.beginToken;
    while (token != null && token.type != A_TokenType.A_EOF) {
      A_Token commentToken = token.precedingComments;
      while (commentToken != null) {
        HighlightType highlightType = null;
        if (commentToken.type == A_TokenType.MULTI_LINE_COMMENT) {
          if (commentToken.lexeme.startsWith('/**')) {
            highlightType = HighlightType.COMMENT_DOCUMENTATION;
          } else {
            highlightType = HighlightType.COMMENT_BLOCK;
          }
        }
        if (commentToken.type == A_TokenType.SINGLE_LINE_COMMENT) {
          highlightType = HighlightType.COMMENT_END_OF_LINE;
        }
        if (highlightType != null) {
          _addRegion_token(commentToken, highlightType);
        }
        commentToken = commentToken.next;
      }
      token = token.next;
    }
  }
  void _addIdentifierRegion(SimpleIdentifier node) {
    if (_addIdentifierRegion_keyword(node)) {
      return;
    }
    if (_addIdentifierRegion_class(node)) {
      return;
    }
    if (_addIdentifierRegion_constructor(node)) {
      return;
    }
    if (_addIdentifierRegion_dynamicType(node)) {
      return;
    }
    if (_addIdentifierRegion_getterSetterDeclaration(node)) {
      return;
    }
    if (_addIdentifierRegion_field(node)) {
      return;
    }
    if (_addIdentifierRegion_function(node)) {
      return;
    }
    if (_addIdentifierRegion_functionTypeAlias(node)) {
      return;
    }
    if (_addIdentifierRegion_importPrefix(node)) {
      return;
    }
    if (_addIdentifierRegion_localVariable(node)) {
      return;
    }
    if (_addIdentifierRegion_method(node)) {
      return;
    }
    if (_addIdentifierRegion_parameter(node)) {
      return;
    }
    if (_addIdentifierRegion_topLevelVariable(node)) {
      return;
    }
    if (_addIdentifierRegion_typeParameter(node)) {
      return;
    }
    _addRegion_node(node, HighlightType.IDENTIFIER_DEFAULT);
  }
  void _addIdentifierRegion_annotation(Annotation node) {
    ArgumentList A_arguments = node.arguments;
    if (A_arguments == null) {
      _addRegion_node(node, HighlightType.ANNOTATION);
    } else {
      _addRegion_nodeStart_tokenEnd(node, A_arguments.beginToken, HighlightType.ANNOTATION);
      _addRegion_token(A_arguments.endToken, HighlightType.ANNOTATION);
    }
  }
  bool _addIdentifierRegion_class(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! ClassElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.CLASS);
  }
  bool _addIdentifierRegion_constructor(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! ConstructorElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.CONSTRUCTOR);
  }
  bool _addIdentifierRegion_dynamicType(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! VariableElement) {
      return false;
    }
    if (node.propagatedType != null) {
      return false;
    }
    DartType staticType = node.staticType;
    if (staticType == null || !staticType.isDynamic) {
      return false;
    }
    return _addRegion_node(node, HighlightType.DYNAMIC_TYPE);
  }
  bool _addIdentifierRegion_field(SimpleIdentifier node) {
    A_Element A_element = node.bestElement;
    if (A_element is FieldFormalParameterElement) {
      A_element = (A_element as FieldFormalParameterElement).field;
    }
    if (A_element is FieldElement) {
      if ((A_element as FieldElement).isStatic) {
        return _addRegion_node(node, HighlightType.FIELD_STATIC);
      } else {
        return _addRegion_node(node, HighlightType.FIELD);
      }
    }
    if (A_element is PropertyAccessorElement) {
      if ((A_element as PropertyAccessorElement).isStatic) {
        return _addRegion_node(node, HighlightType.FIELD_STATIC);
      } else {
        return _addRegion_node(node, HighlightType.FIELD);
      }
    }
    return false;
  }
  bool _addIdentifierRegion_function(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! FunctionElement) {
      return false;
    }
    HighlightType A_type;
    if (node.inDeclarationContext()) {
      A_type = HighlightType.FUNCTION_DECLARATION;
    } else {
      A_type = HighlightType.FUNCTION;
    }
    return _addRegion_node(node, A_type);
  }
  bool _addIdentifierRegion_functionTypeAlias(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! FunctionTypeAliasElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.FUNCTION_TYPE_ALIAS);
  }
  bool _addIdentifierRegion_getterSetterDeclaration(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    if (!(A_parent is MethodDeclaration || A_parent is FunctionDeclaration)) {
      return false;
    }
    A_Element A_element = node.staticElement;
    if (A_element is! PropertyAccessorElement) {
      return false;
    }
    PropertyAccessorElement propertyAccessorElement = A_element as PropertyAccessorElement;
    if (propertyAccessorElement.isGetter) {
      return _addRegion_node(node, HighlightType.GETTER_DECLARATION);
    } else {
      return _addRegion_node(node, HighlightType.SETTER_DECLARATION);
    }
  }
  bool _addIdentifierRegion_importPrefix(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! PrefixElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.IMPORT_PREFIX);
  }
  bool _addIdentifierRegion_keyword(SimpleIdentifier node) {
    String A_name = node.name;
    if (A_name == "void") {
      return _addRegion_node(node, HighlightType.KEYWORD);
    }
    return false;
  }
  bool _addIdentifierRegion_localVariable(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! LocalVariableElement) {
      return false;
    }
    HighlightType A_type;
    if (node.inDeclarationContext()) {
      A_type = HighlightType.LOCAL_VARIABLE_DECLARATION;
    } else {
      A_type = HighlightType.LOCAL_VARIABLE;
    }
    return _addRegion_node(node, A_type);
  }
  bool _addIdentifierRegion_method(SimpleIdentifier node) {
    A_Element A_element = node.bestElement;
    if (A_element is! MethodElement) {
      return false;
    }
    MethodElement methodElement = A_element as MethodElement;
    bool A_isStatic = methodElement.isStatic;
    HighlightType A_type;
    if (node.inDeclarationContext()) {
      if (A_isStatic) {
        A_type = HighlightType.METHOD_DECLARATION_STATIC;
      } else {
        A_type = HighlightType.METHOD_DECLARATION;
      }
    } else {
      if (A_isStatic) {
        A_type = HighlightType.METHOD_STATIC;
      } else {
        A_type = HighlightType.A_METHOD;
      }
    }
    return _addRegion_node(node, A_type);
  }
  bool _addIdentifierRegion_parameter(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! ParameterElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.PARAMETER);
  }
  bool _addIdentifierRegion_topLevelVariable(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! TopLevelVariableElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.TOP_LEVEL_VARIABLE);
  }
  bool _addIdentifierRegion_typeParameter(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is! TypeParameterElement) {
      return false;
    }
    return _addRegion_node(node, HighlightType.TYPE_PARAMETER);
  }
  void _addRegion(int A_offset, int A_length, HighlightType A_type) {
    _regions.add(new HighlightRegion(A_offset, A_length, A_type));
  }
  bool _addRegion_node(AstNode node, HighlightType A_type) {
    int A_offset = node.offset;
    int A_length = node.length;
    _addRegion(A_offset, A_length, A_type);
    return true;
  }
  void _addRegion_nodeStart_tokenEnd(AstNode a, A_Token b, HighlightType A_type) {
    int A_offset = a.offset;
    int A_end = b.end;
    _addRegion(A_offset, A_end - A_offset, A_type);
  }
  void _addRegion_token(A_Token token, HighlightType A_type) {
    if (token != null) {
      int A_offset = token.offset;
      int A_length = token.length;
      _addRegion(A_offset, A_length, A_type);
    }
  }
  void _addRegion_tokenStart_tokenEnd(A_Token a, A_Token b, HighlightType A_type) {
    int A_offset = a.offset;
    int A_end = b.end;
    _addRegion(A_offset, A_end - A_offset, A_type);
  }
}
class HighlightRegion implements HasToJson {
  final int offset;
  final int length;
  final HighlightType type;
  HighlightRegion(this.offset, this.length, this.type);
  Map<String, Object> toJson() {
    Map<String, Object> json = <String, Object>{};
    json[OFFSET] = offset;
    json[LENGTH] = length;
    json[TYPE] = type.name;
    return json;
  }
  String toString() => toJson().toString();
}
class HighlightType {
  static const HighlightType ANNOTATION = const HighlightType('ANNOTATION');
  static const HighlightType BUILT_IN = const HighlightType('BUILT_IN');
  static const HighlightType CLASS = const HighlightType('CLASS');
  static const HighlightType COMMENT_BLOCK = const HighlightType('COMMENT_BLOCK');
  static const HighlightType COMMENT_DOCUMENTATION = const HighlightType('COMMENT_DOCUMENTATION');
  static const HighlightType COMMENT_END_OF_LINE = const HighlightType('COMMENT_END_OF_LINE');
  static const HighlightType CONSTRUCTOR = const HighlightType('CONSTRUCTOR');
  static const HighlightType DYNAMIC_TYPE = const HighlightType('DYNAMIC_TYPE');
  static const HighlightType FIELD = const HighlightType('FIELD');
  static const HighlightType FIELD_STATIC = const HighlightType('FIELD_STATIC');
  static const HighlightType FUNCTION_DECLARATION = const HighlightType('FUNCTION_DECLARATION');
  static const HighlightType FUNCTION = const HighlightType('FUNCTION');
  static const HighlightType FUNCTION_TYPE_ALIAS = const HighlightType('FUNCTION_TYPE_ALIAS');
  static const HighlightType GETTER_DECLARATION = const HighlightType('GETTER_DECLARATION');
  static const HighlightType KEYWORD = const HighlightType('KEYWORD');
  static const HighlightType IDENTIFIER_DEFAULT = const HighlightType('IDENTIFIER_DEFAULT');
  static const HighlightType IMPORT_PREFIX = const HighlightType('IMPORT_PREFIX');
  static const HighlightType LITERAL_BOOLEAN = const HighlightType('LITERAL_BOOLEAN');
  static const HighlightType LITERAL_DOUBLE = const HighlightType('LITERAL_DOUBLE');
  static const HighlightType LITERAL_INTEGER = const HighlightType('LITERAL_INTEGER');
  static const HighlightType LITERAL_STRING = const HighlightType('LITERAL_STRING');
  static const HighlightType LOCAL_VARIABLE_DECLARATION = const HighlightType('LOCAL_VARIABLE_DECLARATION');
  static const HighlightType LOCAL_VARIABLE = const HighlightType('LOCAL_VARIABLE');
  static const HighlightType METHOD_DECLARATION = const HighlightType('METHOD_DECLARATION');
  static const HighlightType METHOD_DECLARATION_STATIC = const HighlightType('METHOD_DECLARATION_STATIC');
  static const HighlightType A_METHOD = const HighlightType('METHOD');
  static const HighlightType METHOD_STATIC = const HighlightType('METHOD_STATIC');
  static const HighlightType PARAMETER = const HighlightType('PARAMETER');
  static const HighlightType SETTER_DECLARATION = const HighlightType('SETTER_DECLARATION');
  static const HighlightType TOP_LEVEL_VARIABLE = const HighlightType('TOP_LEVEL_VARIABLE');
  static const HighlightType TYPE_NAME_DYNAMIC = const HighlightType('TYPE_NAME_DYNAMIC');
  static const HighlightType TYPE_PARAMETER = const HighlightType('TYPE_PARAMETER');
  final String name;
  const HighlightType(this.name);
  String toString() => name;
}
class _DartUnitHighlightsComputerVisitor extends RecursiveAstVisitor<Object> {
  final DartUnitHighlightsComputer computer;
  _DartUnitHighlightsComputerVisitor(this.computer);
  Object visitAnnotation(Annotation node) {
    computer._addIdentifierRegion_annotation(node);
    return super.visitAnnotation(node);
  }
  Object visitAsExpression(AsExpression node) {
    computer._addRegion_token(node.asOperator, HighlightType.BUILT_IN);
    return super.visitAsExpression(node);
  }
  Object visitBooleanLiteral(BooleanLiteral node) {
    computer._addRegion_node(node, HighlightType.LITERAL_BOOLEAN);
    return super.visitBooleanLiteral(node);
  }
  Object visitCatchClause(CatchClause node) {
    computer._addRegion_token(node.onKeyword, HighlightType.BUILT_IN);
    return super.visitCatchClause(node);
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    computer._addRegion_token(node.abstractKeyword, HighlightType.BUILT_IN);
    return super.visitClassDeclaration(node);
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    computer._addRegion_token(node.externalKeyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.factoryKeyword, HighlightType.BUILT_IN);
    return super.visitConstructorDeclaration(node);
  }
  Object visitDoubleLiteral(DoubleLiteral node) {
    computer._addRegion_node(node, HighlightType.LITERAL_DOUBLE);
    return super.visitDoubleLiteral(node);
  }
  Object visitExportDirective(ExportDirective node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitExportDirective(node);
  }
  Object visitFieldDeclaration(FieldDeclaration node) {
    computer._addRegion_token(node.staticKeyword, HighlightType.BUILT_IN);
    return super.visitFieldDeclaration(node);
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    computer._addRegion_token(node.externalKeyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.propertyKeyword, HighlightType.BUILT_IN);
    return super.visitFunctionDeclaration(node);
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitFunctionTypeAlias(node);
  }
  Object visitHideCombinator(HideCombinator node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitHideCombinator(node);
  }
  Object visitImplementsClause(ImplementsClause node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitImplementsClause(node);
  }
  Object visitImportDirective(ImportDirective node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.deferredToken, HighlightType.BUILT_IN);
    computer._addRegion_token(node.asToken, HighlightType.BUILT_IN);
    return super.visitImportDirective(node);
  }
  Object visitIntegerLiteral(IntegerLiteral node) {
    computer._addRegion_node(node, HighlightType.LITERAL_INTEGER);
    return super.visitIntegerLiteral(node);
  }
  Object visitLibraryDirective(LibraryDirective node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitLibraryDirective(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    computer._addRegion_token(node.externalKeyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.modifierKeyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.operatorKeyword, HighlightType.BUILT_IN);
    computer._addRegion_token(node.propertyKeyword, HighlightType.BUILT_IN);
    return super.visitMethodDeclaration(node);
  }
  Object visitNativeClause(NativeClause node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitNativeClause(node);
  }
  Object visitNativeFunctionBody(NativeFunctionBody node) {
    computer._addRegion_token(node.nativeToken, HighlightType.BUILT_IN);
    return super.visitNativeFunctionBody(node);
  }
  Object visitPartDirective(PartDirective node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitPartDirective(node);
  }
  Object visitPartOfDirective(PartOfDirective node) {
    computer._addRegion_tokenStart_tokenEnd(node.partToken, node.ofToken, HighlightType.BUILT_IN);
    return super.visitPartOfDirective(node);
  }
  Object visitShowCombinator(ShowCombinator node) {
    computer._addRegion_token(node.keyword, HighlightType.BUILT_IN);
    return super.visitShowCombinator(node);
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    computer._addIdentifierRegion(node);
    return super.visitSimpleIdentifier(node);
  }
  Object visitSimpleStringLiteral(SimpleStringLiteral node) {
    computer._addRegion_node(node, HighlightType.LITERAL_STRING);
    return super.visitSimpleStringLiteral(node);
  }
  Object visitTypeName(TypeName node) {
    DartType A_type = node.type;
    if (A_type != null) {
      if (A_type.isDynamic && node.name.name == "dynamic") {
        computer._addRegion_node(node, HighlightType.TYPE_NAME_DYNAMIC);
        return null;
      }
    }
    return super.visitTypeName(node);
  }
}
String _removeDartDocDelimiters(String str) {
  if (str == null) {
    return null;
  }
  if (str.startsWith('/**')) {
    str = str.substring(3);
  }
  if (str.endsWith("*/")) {
    str = str.substring(0, str.length - 2);
  }
  str = str.trim();
  List<String> lines = str.split('\n');
  StringBuffer sb = new StringBuffer();
  bool firstLine = true;
  for (String line in lines) {
    line = line.trim();
    if (line.startsWith("*")) {
      line = line.substring(1);
      if (line.startsWith(" ")) {
        line = line.substring(1);
      }
    } else if (line.startsWith("///")) {
      line = line.substring(3);
      if (line.startsWith(" ")) {
        line = line.substring(1);
      }
    }
    if (!firstLine) {
      sb.write('\n');
    }
    firstLine = false;
    sb.write(line);
  }
  str = sb.toString();
  return str;
}
class DartUnitHoverComputer {
  final CompilationUnit A__unit;
  final int _offset;
  DartUnitHoverComputer(this.A__unit, this._offset);
  Hover compute() {
    AstNode node = new NodeLocator.con1(_offset).searchWithin(A__unit);
    if (node is Expression) {
      Hover hover = new Hover(node.offset, node.length);
      A_Element A_element = ElementLocator.locateWithOffset(node, _offset);
      if (A_element != null) {
        if (A_element is PropertyAccessorElement) {
          PropertyAccessorElement accessor = A_element;
          if (accessor.isSynthetic) {
            A_element = accessor.variable;
          }
        }
        hover.elementDescription = A_element.toString();
        hover.elementKind = A_element.kind.displayName;
        LibraryElement library = A_element.library;
        if (library != null) {
          hover.containingLibraryName = library.name;
          hover.containingLibraryPath = library.source.fullName;
        }
        String dartDoc = A_element.computeDocumentationComment();
        dartDoc = _removeDartDocDelimiters(dartDoc);
        hover.dartDoc = dartDoc;
      }
      hover.parameter = _safeToString(node.bestParameterElement);
      hover.staticType = _safeToString(node.staticType);
      hover.propagatedType = _safeToString(node.propagatedType);
      return hover;
    }
    return null;
  }
  static _safeToString(obj) => obj != null ? obj.toString() : null;
}
class Hover implements HasToJson {
  final int offset;
  final int length;
  String containingLibraryName;
  String containingLibraryPath;
  String dartDoc;
  String elementDescription;
  String elementKind;
  String parameter;
  String propagatedType;
  String staticType;
  Hover(this.offset, this.length);
  Map<String, Object> toJson() {
    Map<String, Object> json = new A_p.HashMap<String,Object>();
    json[OFFSET] = offset;
    json[LENGTH] = length;
    if (containingLibraryName != null) {
      json[CONTAINING_LIBRARY_NAME] = containingLibraryName;
    }
    if (containingLibraryName != null) {
      json[CONTAINING_LIBRARY_PATH] = containingLibraryPath;
    }
    if (dartDoc != null) {
      json[DART_DOC] = dartDoc;
    }
    if (elementDescription != null) {
      json[ELEMENT_DESCRIPTION] = elementDescription;
    }
    if (elementKind != null) {
      json[ELEMENT_KIND] = elementKind;
    }
    if (parameter != null) {
      json[C_PARAMETER] = parameter;
    }
    if (propagatedType != null) {
      json[PROPAGATED_TYPE] = propagatedType;
    }
    if (staticType != null) {
      json[STATIC_TYPE] = staticType;
    }
    return json;
  }
}
class DartUnitNavigationComputer {
  final CompilationUnit B__unit;
  final List<Map<String, Object>> A__regions = <Map<String, Object>>[];
  DartUnitNavigationComputer(this.B__unit);
  List<Map<String, Object>> compute() {
    B__unit.accept(new _DartUnitNavigationComputerVisitor(this));
    return new List.from(A__regions);
  }
  void A__addRegion(int A_offset, int A_length, A_Element A_element) {
    if (A_element == null || A_element == DynamicElementImpl.instance) {
      return;
    }
    if (A_element is FieldFormalParameterElement) {
      A_element = (A_element as FieldFormalParameterElement).field;
    }
    var elementJson = new Element.A_fromEngine(A_element).toJson();
    A__regions.add({OFFSET: A_offset, LENGTH: A_length, TARGETS: [elementJson]});
  }
  void _addRegionForNode(AstNode node, A_Element A_element) {
    int A_offset = node.offset;
    int A_length = node.length;
    A__addRegion(A_offset, A_length, A_element);
  }
  void _addRegionForToken(A_Token token, A_Element A_element) {
    int A_offset = token.offset;
    int A_length = token.length;
    A__addRegion(A_offset, A_length, A_element);
  }
  void _addRegion_nodeStart_nodeEnd(AstNode a, AstNode b, A_Element A_element) {
    int A_offset = a.offset;
    int A_length = b.end - A_offset;
    A__addRegion(A_offset, A_length, A_element);
  }
  void _addRegion_nodeStart_nodeStart(AstNode a, AstNode b, A_Element A_element) {
    int A_offset = a.offset;
    int A_length = b.offset - A_offset;
    A__addRegion(A_offset, A_length, A_element);
  }
  void _addRegion_tokenStart_nodeEnd(A_Token a, AstNode b, A_Element A_element) {
    int A_offset = a.offset;
    int A_length = b.end - A_offset;
    A__addRegion(A_offset, A_length, A_element);
  }
}
class _DartUnitNavigationComputerVisitor extends RecursiveAstVisitor {
  final DartUnitNavigationComputer computer;
  _DartUnitNavigationComputerVisitor(this.computer);
  visitAssignmentExpression(AssignmentExpression node) {
    computer._addRegionForToken(node.operator, node.bestElement);
    return super.visitAssignmentExpression(node);
  }
  visitBinaryExpression(BinaryExpression node) {
    computer._addRegionForToken(node.operator, node.bestElement);
    return super.visitBinaryExpression(node);
  }
  visitConstructorDeclaration(ConstructorDeclaration node) {
    {
      AstNode firstNode = node.returnType;
      AstNode lastNode = node.name;
      if (lastNode == null) {
        lastNode = firstNode;
      }
      if (firstNode != null && lastNode != null) {
        computer._addRegion_nodeStart_nodeEnd(firstNode, lastNode, node.element);
      }
    }
    return super.visitConstructorDeclaration(node);
  }
  visitExportDirective(ExportDirective node) {
    ExportElement exportElement = node.element;
    if (exportElement != null) {
      A_Element A_element = exportElement.exportedLibrary;
      computer._addRegion_tokenStart_nodeEnd(node.keyword, node.uri, A_element);
    }
    return super.visitExportDirective(node);
  }
  visitImportDirective(ImportDirective node) {
    ImportElement importElement = node.element;
    if (importElement != null) {
      A_Element A_element = importElement.importedLibrary;
      computer._addRegion_tokenStart_nodeEnd(node.keyword, node.uri, A_element);
    }
    return super.visitImportDirective(node);
  }
  visitIndexExpression(IndexExpression node) {
    computer._addRegionForToken(node.rightBracket, node.bestElement);
    return super.visitIndexExpression(node);
  }
  visitInstanceCreationExpression(InstanceCreationExpression node) {
    A_Element A_element = node.staticElement;
    if (A_element != null && A_element.isSynthetic) {
      A_element = A_element.enclosingElement;
    }
    computer._addRegion_nodeStart_nodeStart(node, node.argumentList, A_element);
    return super.visitInstanceCreationExpression(node);
  }
  visitPartDirective(PartDirective node) {
    computer._addRegion_tokenStart_nodeEnd(node.keyword, node.uri, node.element);
    return super.visitPartDirective(node);
  }
  visitPartOfDirective(PartOfDirective node) {
    computer._addRegion_tokenStart_nodeEnd(node.keyword, node.libraryName, node.element);
    return super.visitPartOfDirective(node);
  }
  visitPostfixExpression(PostfixExpression node) {
    computer._addRegionForToken(node.operator, node.bestElement);
    return super.visitPostfixExpression(node);
  }
  visitPrefixExpression(PrefixExpression node) {
    computer._addRegionForToken(node.operator, node.bestElement);
    return super.visitPrefixExpression(node);
  }
  visitSimpleIdentifier(SimpleIdentifier node) {
    if (node.parent is ConstructorDeclaration) {} else {
      computer._addRegionForNode(node, node.bestElement);
    }
    return super.visitSimpleIdentifier(node);
  }
}
class DartUnitOccurrencesComputer {
  final CompilationUnit C__unit;
  final Map<A_Element, List<int>> _elementsOffsets = new A_p.HashMap<A_Element,List<int>>();
  DartUnitOccurrencesComputer(this.C__unit);
  List<Occurrences> compute() {
    C__unit.accept(new _DartUnitOccurrencesComputerVisitor(this));
    List<Occurrences> occurrences = <Occurrences>[];
    _elementsOffsets.forEach((engineElement, offsets) {
      var serverElement = new Element.A_fromEngine(engineElement);
      var A_length = engineElement.displayName.length;
      occurrences.add(new Occurrences(serverElement, offsets, A_length));
    });
    return occurrences;
  }
  void _addOccurrence(A_Element A_element, int A_offset) {
    if (A_element == null || A_element == DynamicElementImpl.instance) {
      return;
    }
    A_element = _canonicalizeElement(A_element);
    List<int> offsets = _elementsOffsets[A_element];
    if (offsets == null) {
      offsets = <int>[];
      _elementsOffsets[A_element] = offsets;
    }
    offsets.add(A_offset);
  }
  A_Element _canonicalizeElement(A_Element A_element) {
    if (A_element is FieldFormalParameterElement) {
      A_element = (A_element as FieldFormalParameterElement).field;
    }
    if (A_element is PropertyAccessorElement) {
      A_element = (A_element as PropertyAccessorElement).variable;
    }
    if (A_element is Member) {
      A_element = (A_element as Member).baseElement;
    }
    return A_element;
  }
}
class Occurrences implements HasToJson {
  final Element element;
  final List<int> offsets;
  final int length;
  Occurrences(this.element, this.offsets, this.length);
  Map<String, Object> toJson() {
    Map<String, Object> json = new A_p.HashMap<String,Object>();
    json[A_ELEMENT] = element.toJson();
    json[OFFSETS] = offsets;
    json[LENGTH] = length;
    return json;
  }
  String toString() => toJson().toString();
}
class _DartUnitOccurrencesComputerVisitor extends RecursiveAstVisitor {
  final DartUnitOccurrencesComputer computer;
  _DartUnitOccurrencesComputerVisitor(this.computer);
  visitSimpleIdentifier(SimpleIdentifier node) {
    A_Element A_element = node.bestElement;
    if (A_element != null) {
      computer._addOccurrence(A_element, node.offset);
    }
    return super.visitSimpleIdentifier(node);
  }
}
class DartUnitOutlineComputer {
  final CompilationUnit D__unit;
  String file;
  LineInfo lineInfo;
  DartUnitOutlineComputer(AnalysisContext context, Source A_source, this.D__unit) {
    file = A_source.fullName;
    lineInfo = context.getLineInfo(A_source);
  }
  Outline compute() {
    Outline unitOutline = _newUnitOutline();
    for (CompilationUnitMember unitMember in D__unit.declarations) {
      if (unitMember is ClassDeclaration) {
        ClassDeclaration classDeclaration = unitMember;
        Outline classOutline = _newClassOutline(unitOutline, classDeclaration);
        for (ClassMember classMember in classDeclaration.members) {
          if (classMember is ConstructorDeclaration) {
            ConstructorDeclaration constructorDeclaration = classMember;
            _newConstructorOutline(classOutline, constructorDeclaration);
          }
          if (classMember is FieldDeclaration) {
            FieldDeclaration fieldDeclaration = classMember;
            VariableDeclarationList fields = fieldDeclaration.fields;
            if (fields != null) {
              TypeName fieldType = fields.type;
              String fieldTypeName = fieldType != null ? fieldType.toSource() : '';
              for (VariableDeclaration field in fields.variables) {
                _newVariableOutline(classOutline, fieldTypeName, ElementKind.A_FIELD, field, fieldDeclaration.isStatic);
              }
            }
          }
          if (classMember is MethodDeclaration) {
            MethodDeclaration methodDeclaration = classMember;
            _newMethodOutline(classOutline, methodDeclaration);
          }
        }
      }
      if (unitMember is TopLevelVariableDeclaration) {
        TopLevelVariableDeclaration fieldDeclaration = unitMember;
        VariableDeclarationList fields = fieldDeclaration.variables;
        if (fields != null) {
          TypeName fieldType = fields.type;
          String fieldTypeName = fieldType != null ? fieldType.toSource() : '';
          for (VariableDeclaration field in fields.variables) {
            _newVariableOutline(unitOutline, fieldTypeName, ElementKind.A_TOP_LEVEL_VARIABLE, field, false);
          }
        }
      }
      if (unitMember is FunctionDeclaration) {
        FunctionDeclaration functionDeclaration = unitMember;
        _newFunctionOutline(unitOutline, functionDeclaration, true);
      }
      if (unitMember is ClassTypeAlias) {
        ClassTypeAlias alias = unitMember;
        _newClassTypeAlias(unitOutline, alias);
      }
      if (unitMember is FunctionTypeAlias) {
        FunctionTypeAlias alias = unitMember;
        _newFunctionTypeAliasOutline(unitOutline, alias);
      }
    }
    return unitOutline;
  }
  void _addLocalFunctionOutlines(Outline A_parent, FunctionBody body) {
    body.accept(new _LocalFunctionOutlinesVisitor(this, A_parent));
  }
  Location _getLocationNode(AstNode node) {
    int A_offset = node.offset;
    int A_length = node.length;
    return _getLocationOffsetLength(A_offset, A_length);
  }
  Location _getLocationOffsetLength(int A_offset, int A_length) {
    LineInfo_Location lineLocation = lineInfo.getLocation(A_offset);
    int startLine = lineLocation.lineNumber;
    int startColumn = lineLocation.columnNumber;
    return new Location(file, A_offset, A_length, startLine, startColumn);
  }
  _SourceRegion _getSourceRegion(AstNode node) {
    int endOffset = node.end;
    int firstOffset;
    List<AstNode> siblings;
    AstNode A_parent = node.parent;
    if (A_parent is VariableDeclarationList) {
      VariableDeclarationList variableList = A_parent as VariableDeclarationList;
      List<VariableDeclaration> variables = variableList.variables;
      int variableIndex = variables.indexOf(node);
      if (variableIndex == variables.length - 1) {
        endOffset = variableList.parent.end;
      }
      if (variableIndex == 0) {
        node = A_parent.parent;
        A_parent = node.parent;
      } else if (variableIndex >= 1) {
        firstOffset = variables[variableIndex - 1].end;
        return new _SourceRegion(firstOffset, endOffset - firstOffset);
      }
    }
    if (A_parent is CompilationUnit) {
      firstOffset = 0;
      siblings = (A_parent as CompilationUnit).declarations;
    } else if (A_parent is ClassDeclaration) {
      ClassDeclaration classDeclaration = A_parent as ClassDeclaration;
      firstOffset = classDeclaration.leftBracket.end;
      siblings = classDeclaration.members;
    } else {
      int A_offset = node.offset;
      return new _SourceRegion(A_offset, endOffset - A_offset);
    }
    int A_index = siblings.indexOf(node);
    if (A_index == 0) {
      return new _SourceRegion(firstOffset, endOffset - firstOffset);
    }
    int prevSiblingEnd = siblings[A_index - 1].end;
    return new _SourceRegion(prevSiblingEnd, endOffset - prevSiblingEnd);
  }
  Outline _newClassOutline(Outline A_parent, ClassDeclaration classDeclaration) {
    SimpleIdentifier nameNode = classDeclaration.name;
    String A_name = nameNode.name;
    _SourceRegion sourceRegion = _getSourceRegion(classDeclaration);
    Element A_element = new Element(ElementKind.A_CLASS, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(classDeclaration), isAbstract: classDeclaration.isAbstract);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
    return outline;
  }
  void _newClassTypeAlias(Outline A_parent, ClassTypeAlias alias) {
    SimpleIdentifier nameNode = alias.name;
    String A_name = nameNode.name;
    _SourceRegion sourceRegion = _getSourceRegion(alias);
    Element A_element = new Element(ElementKind.CLASS_TYPE_ALIAS, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(alias), isAbstract: alias.isAbstract);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
  }
  void _newConstructorOutline(Outline A_parent, ConstructorDeclaration constructor) {
    Identifier A_returnType = constructor.returnType;
    String A_name = A_returnType.name;
    int A_offset = A_returnType.offset;
    int A_length = A_returnType.length;
    SimpleIdentifier constructorNameNode = constructor.name;
    bool isPrivate = false;
    if (constructorNameNode != null) {
      String constructorName = constructorNameNode.name;
      isPrivate = Identifier.isPrivateName(constructorName);
      A_name += '.${constructorName}';
      A_offset = constructorNameNode.offset;
      A_length = constructorNameNode.length;
    }
    _SourceRegion sourceRegion = _getSourceRegion(constructor);
    FormalParameterList A_parameters = constructor.parameters;
    String parametersStr = A_parameters != null ? A_parameters.toSource() : '';
    Element A_element = new Element(ElementKind.A_CONSTRUCTOR, A_name, _getLocationOffsetLength(A_offset, A_length), isPrivate, _isDeprecated(constructor), parameters: parametersStr);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
    _addLocalFunctionOutlines(outline, constructor.body);
  }
  void _newFunctionOutline(Outline A_parent, FunctionDeclaration A_function, bool A_isStatic) {
    TypeName A_returnType = A_function.returnType;
    SimpleIdentifier nameNode = A_function.name;
    String A_name = nameNode.name;
    FunctionExpression functionExpression = A_function.functionExpression;
    FormalParameterList A_parameters = functionExpression.parameters;
    ElementKind kind;
    if (A_function.isGetter) {
      kind = ElementKind.A_GETTER;
    } else if (A_function.isSetter) {
      kind = ElementKind.A_SETTER;
    } else {
      kind = ElementKind.A_FUNCTION;
    }
    _SourceRegion sourceRegion = _getSourceRegion(A_function);
    String parametersStr = A_parameters != null ? A_parameters.toSource() : '';
    String returnTypeStr = A_returnType != null ? A_returnType.toSource() : '';
    Element A_element = new Element(kind, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(A_function), parameters: parametersStr, returnType: returnTypeStr, isStatic: A_isStatic);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
    _addLocalFunctionOutlines(outline, functionExpression.body);
  }
  void _newFunctionTypeAliasOutline(Outline A_parent, FunctionTypeAlias alias) {
    TypeName A_returnType = alias.returnType;
    SimpleIdentifier nameNode = alias.name;
    String A_name = nameNode.name;
    _SourceRegion sourceRegion = _getSourceRegion(alias);
    FormalParameterList A_parameters = alias.parameters;
    String parametersStr = A_parameters != null ? A_parameters.toSource() : '';
    String returnTypeStr = A_returnType != null ? A_returnType.toSource() : '';
    Element A_element = new Element(ElementKind.A_FUNCTION_TYPE_ALIAS, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(alias), parameters: parametersStr, returnType: returnTypeStr);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
  }
  void _newMethodOutline(Outline A_parent, MethodDeclaration A_method) {
    TypeName A_returnType = A_method.returnType;
    SimpleIdentifier nameNode = A_method.name;
    String A_name = nameNode.name;
    FormalParameterList A_parameters = A_method.parameters;
    ElementKind kind;
    if (A_method.isGetter) {
      kind = ElementKind.A_GETTER;
    } else if (A_method.isSetter) {
      kind = ElementKind.A_SETTER;
    } else {
      kind = ElementKind.B_METHOD;
    }
    _SourceRegion sourceRegion = _getSourceRegion(A_method);
    String parametersStr = A_parameters != null ? A_parameters.toSource() : '';
    String returnTypeStr = A_returnType != null ? A_returnType.toSource() : '';
    Element A_element = new Element(kind, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(A_method), parameters: parametersStr, returnType: returnTypeStr, isAbstract: A_method.isAbstract, isStatic: A_method.isStatic);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
    _addLocalFunctionOutlines(outline, A_method.body);
  }
  Outline _newUnitOutline() {
    Element A_element = new Element(ElementKind.COMPILATION_UNIT, '<unit>', _getLocationNode(D__unit), false, false);
    return new Outline(A_element, D__unit.offset, D__unit.length);
  }
  void _newVariableOutline(Outline A_parent, String typeName, ElementKind kind, VariableDeclaration variable, bool A_isStatic) {
    SimpleIdentifier nameNode = variable.name;
    String A_name = nameNode.name;
    _SourceRegion sourceRegion = _getSourceRegion(variable);
    Element A_element = new Element(kind, A_name, _getLocationNode(nameNode), Identifier.isPrivateName(A_name), _isDeprecated(variable), returnType: typeName, isStatic: A_isStatic, isConst: variable.isConst, isFinal: variable.isFinal);
    Outline outline = new Outline(A_element, sourceRegion.offset, sourceRegion.length);
    A_parent.children.add(outline);
  }
  static bool _isDeprecated(Declaration declaration) {
    A_Element A_element = declaration.element;
    return A_element != null && A_element.isDeprecated;
  }
}
class Outline implements HasToJson {
  final List<Outline> children = <Outline>[];
  final Element element;
  final int length;
  final int offset;
  Outline(this.element, this.offset, this.length);
  Map<String, Object> toJson() {
    Map<String, Object> json = {A_ELEMENT: element.toJson(), OFFSET: offset, LENGTH: length};
    if (children.isNotEmpty) {
      json[CHILDREN] = children.map((child) => child.toJson()).toList();
    }
    return json;
  }
}
class _LocalFunctionOutlinesVisitor extends RecursiveAstVisitor {
  final DartUnitOutlineComputer outlineComputer;
  final Outline parent;
  _LocalFunctionOutlinesVisitor(this.outlineComputer, this.parent);
  visitFunctionDeclaration(FunctionDeclaration node) {
    outlineComputer._newFunctionOutline(parent, node, false);
  }
}
class _SourceRegion {
  final int length;
  final int offset;
  _SourceRegion(this.offset, this.length);
}
class DartUnitOverridesComputer {
  final CompilationUnit E__unit;
  final List<Override> _overrides = <Override>[];
  ClassElement _currentClass;
  DartUnitOverridesComputer(this.E__unit);
  List<Override> compute() {
    for (CompilationUnitMember unitMember in E__unit.declarations) {
      if (unitMember is ClassDeclaration) {
        _currentClass = unitMember.element;
        for (ClassMember classMember in unitMember.members) {
          if (classMember is MethodDeclaration) {
            SimpleIdentifier nameNode = classMember.name;
            _addOverride(nameNode.offset, nameNode.length, nameNode.name);
          }
          if (classMember is FieldDeclaration) {
            List<VariableDeclaration> fields = classMember.fields.variables;
            for (VariableDeclaration field in fields) {
              SimpleIdentifier nameNode = field.name;
              _addOverride(nameNode.offset, nameNode.length, nameNode.name);
            }
          }
        }
      }
    }
    return _overrides.map((A_override) => A_override.toJson()).toList();
  }
  void _addOverride(int A_offset, int A_length, String A_name) {
    A_Element superEngineElement;
    {
      InterfaceType superType = _currentClass.supertype;
      if (superType != null) {
        superEngineElement = _lookupMember(superType.element, A_name);
      }
    }
    List<A_Element> interfaceEngineElements = <A_Element>[];
    for (InterfaceType interfaceType in _currentClass.interfaces) {
      ClassElement interfaceElement = interfaceType.element;
      A_Element interfaceMember = _lookupMember(interfaceElement, A_name);
      if (interfaceMember != null) {
        interfaceEngineElements.add(interfaceMember);
      }
    }
    if (superEngineElement != null || interfaceEngineElements.isNotEmpty) {
      OverriddenMember superMember = superEngineElement != null ? OverriddenMember.fromEngine(superEngineElement) : null;
      List<OverriddenMember> interfaceMembers = interfaceEngineElements.map(OverriddenMember.fromEngine).toList();
      _overrides.add(new Override(A_offset, A_length, superMember, interfaceMembers));
    }
  }
  static A_Element _lookupMember(ClassElement classElement, String A_name) {
    if (classElement == null) {
      return null;
    }
    LibraryElement library = classElement.library;
    A_Element member = classElement.lookUpMethod(A_name, library);
    if (member != null) {
      return member;
    }
    member = classElement.lookUpGetter(A_name, library);
    if (member != null) {
      return member;
    }
    member = classElement.lookUpSetter(A_name + '=', library);
    if (member != null) {
      return member;
    }
    return null;
  }
}
class OverriddenMember implements HasToJson {
  final Element element;
  final String className;
  OverriddenMember(this.element, this.className);
  Map<String, Object> toJson() {
    return {A_ELEMENT: element.toJson(), CLASS_NAME: className};
  }
  String toString() => toJson().toString();
  static OverriddenMember fromEngine(A_Element member) {
    Element A_element = new Element.A_fromEngine(member);
    String A_className = member.enclosingElement.displayName;
    return new OverriddenMember(A_element, A_className);
  }
}
class Override implements HasToJson {
  final int offset;
  final int length;
  final OverriddenMember superclassMember;
  final List<OverriddenMember> interfaceMembers;
  Override(this.offset, this.length, this.superclassMember, this.interfaceMembers);
  Map<String, Object> toJson() {
    Map<String, Object> json = <String, Object>{};
    json[OFFSET] = offset;
    json[LENGTH] = length;
    if (superclassMember != null) {
      json[SUPER_CLASS_MEMBER] = superclassMember.toJson();
    }
    if (interfaceMembers != null && interfaceMembers.isNotEmpty) {
      json[INTERFACE_MEMBERS] = objectToJson(interfaceMembers);
    }
    return json;
  }
  String toString() => toJson().toString();
}
Map<String, Object> engineElementToJson(A_Element A_element) {
  return new Element.A_fromEngine(A_element).toJson();
}
class Element {
  static const int FLAG_ABSTRACT = 0x01;
  static const int FLAG_CONST = 0x02;
  static const int FLAG_FINAL = 0x04;
  static const int FLAG_STATIC = 0x08;
  static const int FLAG_PRIVATE = 0x10;
  static const int FLAG_DEPRECATED = 0x20;
  final ElementKind kind;
  final String name;
  final Location location;
  final String parameters;
  final String returnType;
  final bool isAbstract;
  final bool isConst;
  final bool isFinal;
  final bool isStatic;
  final bool isPrivate;
  final bool isDeprecated;
  Element(this.kind, this.name, this.location, this.isPrivate, this.isDeprecated, {this.parameters, this.returnType, this.isAbstract: false, this.isConst: false, this.isFinal: false, this.isStatic: false});
  factory Element.A_fromEngine(A_Element A_element) {
    String A_name = A_element.displayName;
    String elementParameters = _getParametersString(A_element);
    String elementReturnType = _getReturnTypeString(A_element);
    return new Element(ElementKind.valueOfEngine(A_element.kind), A_name, new Location.fromElement(A_element), A_element.isPrivate, A_element.isDeprecated, parameters: elementParameters, returnType: elementReturnType, isAbstract: _isAbstract(A_element), isConst: _isConst(A_element), isFinal: _isFinal(A_element), isStatic: _isStatic(A_element));
  }
  int get flags {
    int A_flags = 0;
    if (isAbstract) A_flags |= FLAG_ABSTRACT;
    if (isConst) A_flags |= FLAG_CONST;
    if (isFinal) A_flags |= FLAG_FINAL;
    if (isStatic) A_flags |= FLAG_STATIC;
    if (isPrivate) A_flags |= FLAG_PRIVATE;
    if (isDeprecated) A_flags |= FLAG_DEPRECATED;
    return A_flags;
  }
  Map<String, Object> toJson() {
    Map<String, Object> json = {KIND: kind.name, NAME: name, A_LOCATION: location.toJson(), FLAGS: flags};
    if (parameters != null) {
      json[PARAMETERS] = parameters;
    }
    if (returnType != null) {
      json[RETURN_TYPE] = returnType;
    }
    return json;
  }
  String toString() => toJson().toString();
  static Map<String, Object> asJson(Element A_element) {
    return A_element.toJson();
  }
  static String _getParametersString(A_Element A_element) {
    if (A_element is ExecutableElement) {
      var sb = new StringBuffer();
      String closeOptionalString = '';
      for (var parameter in A_element.parameters) {
        if (sb.isNotEmpty) {
          sb.write(', ');
        }
        if (closeOptionalString.isEmpty) {
          if (parameter.kind == ParameterKind.NAMED) {
            sb.write('{');
            closeOptionalString = '}';
          }
          if (parameter.kind == ParameterKind.POSITIONAL) {
            sb.write('[');
            closeOptionalString = ']';
          }
        }
        sb.write(parameter.toString());
      }
      sb.write(closeOptionalString);
      return '(' + sb.toString() + ')';
    } else {
      return null;
    }
  }
  static String _getReturnTypeString(A_Element A_element) {
    if ((A_element is ExecutableElement)) {
      return A_element.returnType.toString();
    } else {
      return null;
    }
  }
  static bool _isAbstract(A_Element A_element) {
    if (A_element is ClassElement) {
      return A_element.isAbstract;
    }
    if (A_element is MethodElement) {
      return A_element.isAbstract;
    }
    if (A_element is PropertyAccessorElement) {
      return A_element.isAbstract;
    }
    return false;
  }
  static bool _isConst(A_Element A_element) {
    if (A_element is ConstructorElement) {
      return A_element.isConst;
    }
    if (A_element is VariableElement) {
      return A_element.isConst;
    }
    return false;
  }
  static bool _isFinal(A_Element A_element) {
    if (A_element is VariableElement) {
      return A_element.isFinal;
    }
    return false;
  }
  static bool _isStatic(A_Element A_element) {
    if (A_element is ExecutableElement) {
      return A_element.isStatic;
    }
    if (A_element is PropertyInducingElement) {
      return A_element.isStatic;
    }
    return false;
  }
}
class ElementKind {
  static const A_CLASS = const ElementKind('CLASS');
  static const CLASS_TYPE_ALIAS = const ElementKind('CLASS_TYPE_ALIAS');
  static const COMPILATION_UNIT = const ElementKind('COMPILATION_UNIT');
  static const A_CONSTRUCTOR = const ElementKind('CONSTRUCTOR');
  static const A_FIELD = const ElementKind('FIELD');
  static const A_FUNCTION = const ElementKind('FUNCTION');
  static const A_FUNCTION_TYPE_ALIAS = const ElementKind('FUNCTION_TYPE_ALIAS');
  static const A_GETTER = const ElementKind('GETTER');
  static const LIBRARY = const ElementKind('LIBRARY');
  static const A_LOCAL_VARIABLE = const ElementKind('LOCAL_VARIABLE');
  static const B_METHOD = const ElementKind('METHOD');
  static const A_PARAMETER = const ElementKind('PARAMETER');
  static const A_SETTER = const ElementKind('SETTER');
  static const A_TOP_LEVEL_VARIABLE = const ElementKind('TOP_LEVEL_VARIABLE');
  static const A_TYPE_PARAMETER = const ElementKind('TYPE_PARAMETER');
  static const A_UNKNOWN = const ElementKind('UNKNOWN');
  final String name;
  const ElementKind(this.name);
  String toString() => name;
  static ElementKind valueOfEngine(A_ElementKind kind) {
    if (kind == A_ElementKind.C_CLASS) {
      return A_CLASS;
    }
    if (kind == A_ElementKind.A_COMPILATION_UNIT) {
      return COMPILATION_UNIT;
    }
    if (kind == A_ElementKind.C_CONSTRUCTOR) {
      return A_CONSTRUCTOR;
    }
    if (kind == A_ElementKind.C_FIELD) {
      return A_FIELD;
    }
    if (kind == A_ElementKind.C_FUNCTION) {
      return A_FUNCTION;
    }
    if (kind == A_ElementKind.C_FUNCTION_TYPE_ALIAS) {
      return A_FUNCTION_TYPE_ALIAS;
    }
    if (kind == A_ElementKind.C_GETTER) {
      return A_GETTER;
    }
    if (kind == A_ElementKind.A_LIBRARY) {
      return LIBRARY;
    }
    if (kind == A_ElementKind.B_LOCAL_VARIABLE) {
      return A_LOCAL_VARIABLE;
    }
    if (kind == A_ElementKind.E_METHOD) {
      return B_METHOD;
    }
    if (kind == A_ElementKind.E_PARAMETER) {
      return A_PARAMETER;
    }
    if (kind == A_ElementKind.C_SETTER) {
      return A_SETTER;
    }
    if (kind == A_ElementKind.C_TOP_LEVEL_VARIABLE) {
      return A_TOP_LEVEL_VARIABLE;
    }
    if (kind == A_ElementKind.B_TYPE_PARAMETER) {
      return A_TYPE_PARAMETER;
    }
    return A_UNKNOWN;
  }
}
class Location {
  final String file;
  final int offset;
  final int length;
  final int startLine;
  final int startColumn;
  Location(this.file, this.offset, this.length, this.startLine, this.startColumn);
  factory Location.fromElement(A_Element A_element) {
    Source A_source = A_element.source;
    LineInfo lineInfo = A_element.context.getLineInfo(A_source);
    String A_name = A_element.displayName;
    int A_offset = A_element.nameOffset;
    int A_length = A_name != null ? A_name.length : 0;
    LineInfo_Location lineLocation = lineInfo.getLocation(A_offset);
    int A_startLine = lineLocation.lineNumber;
    int A_startColumn = lineLocation.columnNumber;
    if (A_element is CompilationUnitElement) {
      A_offset = 0;
      A_length = 0;
      A_startLine = 1;
      A_startColumn = 1;
    }
    return new Location(A_source.fullName, A_offset, A_length, A_startLine, A_startColumn);
  }
  factory Location.fromOffset(A_Element A_element, int A_offset, int A_length) {
    Source A_source = A_element.source;
    LineInfo lineInfo = A_element.context.getLineInfo(A_source);
    LineInfo_Location lineLocation = lineInfo.getLocation(A_offset);
    int A_startLine = lineLocation.lineNumber;
    int A_startColumn = lineLocation.columnNumber;
    return new Location(A_source.fullName, A_offset, A_length, A_startLine, A_startColumn);
  }
  Map<String, Object> toJson() {
    return {A_FILE: file, OFFSET: offset, LENGTH: length, START_LINE: startLine, START_COLUMN: startColumn};
  }
  String toString() {
    return 'Location(file=${file}; offset=${offset}; length=${length}; ' 'startLine=${startLine}; startColumn=${startColumn})';
  }
}
List<Map<String, Object>> engineErrorInfoToJson(AnalysisErrorInfo A_info) {
  return engineErrorsToJson(A_info.lineInfo, A_info.errors);
}
List<Map<String, Object>> engineErrorsToJson(LineInfo lineInfo, List<A_AnalysisError> B_errors) {
  return B_errors.map((A_AnalysisError A_error) {
    return new AnalysisError.B_fromEngine(lineInfo, A_error).toJson();
  }).toList();
}
class AnalysisError implements HasToJson {
  final String severity;
  final String type;
  final Location location;
  final String message;
  final String correction;
  AnalysisError(this.severity, this.type, this.location, this.message, this.correction);
  factory AnalysisError.B_fromEngine(LineInfo lineInfo, A_AnalysisError A_error) {
    ErrorCode A_errorCode = A_error.errorCode;
    Location A_location;
    {
      String A_file = A_error.source.fullName;
      int A_offset = A_error.offset;
      int A_length = A_error.length;
      int startLine = -1;
      int startColumn = -1;
      if (lineInfo != null) {
        LineInfo_Location lineLocation = lineInfo.getLocation(A_offset);
        if (lineLocation != null) {
          startLine = lineLocation.lineNumber;
          startColumn = lineLocation.columnNumber;
        }
      }
      A_location = new Location(A_file, A_offset, A_length, startLine, startColumn);
    }
    String A_severity = A_errorCode.errorSeverity.toString();
    String A_type = A_errorCode.type.toString();
    String A_message = A_error.message;
    String A_correction = A_error.correction;
    return new AnalysisError(A_severity, A_type, A_location, A_message, A_correction);
  }
  Map<String, Object> toJson() {
    Map<String, Object> json = {SEVERITY: severity, TYPE: type, A_LOCATION: location.toJson(), A_MESSAGE: message};
    if (correction != null) {
      json[CORRECTION] = correction;
    }
    return json;
  }
  String toString() {
    return 'AnalysisError(location=${location} message=${message}; ' 'severity=${severity}; type=${type}; correction=${correction}';
  }
}
const String SERVER_GET_VERSION = 'server.getVersion';
const String SERVER_SHUTDOWN = 'server.shutdown';
const String SERVER_SET_SUBSCRIPTIONS = 'server.setSubscriptions';
const String SERVER_CONNECTED = 'server.connected';
const String SERVER_ERROR = 'server.error';
const String SERVER_STATUS = 'server.status';
const String ANALYSIS_GET_ERRORS = 'analysis.getErrors';
const String ANALYSIS_GET_HOVER = 'analysis.getHover';
const String ANALYSIS_SET_ANALYSIS_ROOTS = 'analysis.setAnalysisRoots';
const String ANALYSIS_SET_PRIORITY_FILES = 'analysis.setPriorityFiles';
const String ANALYSIS_SET_SUBSCRIPTIONS = 'analysis.setSubscriptions';
const String ANALYSIS_UPDATE_CONTENT = 'analysis.updateContent';
const String ANALYSIS_UPDATE_OPTIONS = 'analysis.updateOptions';
const String ANALYSIS_ERRORS = 'analysis.errors';
const String ANALYSIS_HIGHLIGHTS = 'analysis.highlights';
const String ANALYSIS_NAVIGATION = 'analysis.navigation';
const String ANALYSIS_OCCURRENCES = 'analysis.occurrences';
const String ANALYSIS_OUTLINE = 'analysis.outline';
const String ANALYSIS_OVERRIDES = 'analysis.overrides';
const String COMPLETION_GET_SUGGESTIONS = 'completion.getSuggestions';
const String COMPLETION_RESULTS = 'completion.results';
const String SEARCH_FIND_ELEMENT_REFERENCES = 'search.findElementReferences';
const String SEARCH_FIND_MEMBER_DECLARATIONS = 'search.findMemberDeclarations';
const String SEARCH_FIND_MEMBER_REFERENCES = 'search.findMemberReferences';
const String SEARCH_FIND_TOP_LEVEL_DECLARATIONS = 'search.findTopLevelDeclarations';
const String SEARCH_GET_TYPE_HIERARCHY = 'search.getTypeHierarchy';
const String SEARCH_RESULTS = 'search.results';
const String EDIT_APPLY_REFACTORING = 'edit.applyRefactoring';
const String EDIT_CREATE_REFACTORING = 'edit.createRefactoring';
const String EDIT_DELETE_REFACTORING = 'edit.deleteRefactoring';
const String EDIT_GET_ASSISTS = 'edit.getAssists';
const String EDIT_GET_FIXES = 'edit.getFixes';
const String EDIT_GET_REFACTORINGS = 'edit.getRefactorings';
const String EDIT_SET_REFACTORING_OPTIONS = 'edit.setRefactoringOptions';
const String ANALYZE_ANGULAR = 'analyzeAngular';
const String ANALYZE_POLYMER = 'analyzePolymer';
const String ENABLE_ASYNC = 'enableAsync';
const String ENABLE_DEFERRED_LOADING = 'enableDeferredLoading';
const String ENABLE_ENUMS = 'enableEnums';
const String GENERATE_DART2JS_HINTS = 'generateDart2jsHints';
const String GENERATE_HINTS = 'generateHints';
class _ContextDirectoryInfo {
  p.StreamSubscription<WatchEvent> changeSubscription;
  Map<String, Source> sources = new A_p.HashMap<String,Source>();
  Set<String> packageMapDependencies;
}
abstract class ContextDirectoryManager {
  static const String PUBSPEC_NAME = 'pubspec.yaml';
  Map<Folder, _ContextDirectoryInfo> _currentDirectoryInfo = new A_p.HashMap<Folder,_ContextDirectoryInfo>();
  final ResourceProvider resourceProvider;
  final PackageMapProvider packageMapProvider;
  ContextDirectoryManager(this.resourceProvider, this.packageMapProvider);
  void setRoots(List<String> includedPaths, List<String> excludedPaths) {
    Set<Folder> includedFolders = new A_p.HashSet<Folder>();
    for (int i = 0; i < includedPaths.length; i++) {
      String A_path = includedPaths[i];
      Resource resource = resourceProvider.getResource(A_path);
      if (resource is Folder) {
        includedFolders.add(resource);
      } else {
        throw new UnimplementedError('${A_path} is not a folder. ' 'Only support for folder analysis is implemented currently.');
      }
    }
    if (excludedPaths.isNotEmpty) {
      throw new UnimplementedError('Excluded paths are not supported yet');
    }
    Set<Folder> excludedFolders = new A_p.HashSet<Folder>();
    Set<Folder> currentFolders = _currentDirectoryInfo.keys.toSet();
    Set<Folder> newFolders = includedFolders.difference(currentFolders);
    Set<Folder> oldFolders = currentFolders.difference(includedFolders);
    for (Folder folder in oldFolders) {
      _destroyContext(folder);
    }
    for (Folder folder in newFolders) {
      _createContext(folder);
    }
  }
  void _createContext(Folder folder) {
    _ContextDirectoryInfo A_info = new _ContextDirectoryInfo();
    _currentDirectoryInfo[folder] = A_info;
    A_info.changeSubscription = folder.changes.listen((WatchEvent event) {
      _handleWatchEvent(folder, A_info, event);
    });
    A_File pubspecFile = folder.getChild(PUBSPEC_NAME);
    PackageMapInfo packageMapInfo = packageMapProvider.computePackageMap(folder);
    A_info.packageMapDependencies = packageMapInfo.dependencies;
    addContext(folder, packageMapInfo.packageMap);
    ChangeSet changeSet = new ChangeSet();
    _addSourceFiles(changeSet, folder, A_info);
    applyChangesToContext(folder, changeSet);
  }
  void _destroyContext(Folder folder) {
    _currentDirectoryInfo[folder].changeSubscription.cancel();
    _currentDirectoryInfo.remove(folder);
    removeContext(folder);
  }
  void _handleWatchEvent(Folder folder, _ContextDirectoryInfo A_info, WatchEvent event) {
    switch (event.type) {
      case ChangeType.ADD:
        if (_isInPackagesDir(event.path, folder)) {
          break;
        }
        Resource resource = resourceProvider.getResource(event.path);
        if (resource is A_File) {
          A_File A_file = resource;
          if (_shouldFileBeAnalyzed(A_file)) {
            ChangeSet changeSet = new ChangeSet();
            Source A_source = A_file.createSource();
            changeSet.addedSource(A_source);
            applyChangesToContext(folder, changeSet);
            A_info.sources[event.path] = A_source;
          }
        }
        break;

      case ChangeType.REMOVE:
        Source A_source = A_info.sources[event.path];
        if (A_source != null) {
          ChangeSet changeSet = new ChangeSet();
          changeSet.removedSource(A_source);
          applyChangesToContext(folder, changeSet);
          A_info.sources.remove(event.path);
        }
        break;

      case ChangeType.A_MODIFY:
        Source A_source = A_info.sources[event.path];
        if (A_source != null) {
          ChangeSet changeSet = new ChangeSet();
          changeSet.changedSource(A_source);
          applyChangesToContext(folder, changeSet);
        }
        break;
    }
    if (A_info.packageMapDependencies.contains(event.path)) {
      PackageMapInfo packageMapInfo = packageMapProvider.computePackageMap(folder);
      A_info.packageMapDependencies = packageMapInfo.dependencies;
      updateContextPackageMap(folder, packageMapInfo.packageMap);
    }
  }
  bool _isInPackagesDir(String A_path, Folder folder) {
    String relativePath = resourceProvider.pathContext.A_relative(A_path, from: folder.path);
    List<String> pathParts = resourceProvider.pathContext.split(relativePath);
    for (int i = 0; i < pathParts.length - 1; i++) {
      if (pathParts[i] == 'packages') {
        return true;
      }
    }
    return false;
  }
  static void _addSourceFiles(ChangeSet changeSet, Folder folder, _ContextDirectoryInfo A_info) {
    List<Resource> children = folder.A_getChildren();
    for (Resource child in children) {
      if (child is A_File) {
        if (_shouldFileBeAnalyzed(child)) {
          Source A_source = child.createSource();
          changeSet.addedSource(A_source);
          A_info.sources[child.path] = A_source;
        }
      } else if (child is Folder) {
        if (child.shortName == 'packages') {
          continue;
        }
        _addSourceFiles(changeSet, child, A_info);
      }
    }
  }
  static bool _shouldFileBeAnalyzed(A_File A_file) {
    if (!(AnalysisEngine.isDartFileName(A_file.path) || AnalysisEngine.isHtmlFileName(A_file.path))) {
      return false;
    }
    return A_file.exists;
  }
  bool isInAnalysisRoot(String A_path) {
    for (Folder A_root in _currentDirectoryInfo.keys) {
      if (A_root.contains(A_path)) {
        return true;
      }
    }
    return false;
  }
  void addContext(Folder folder, Map<String, List<Folder>> packageMap);
  void applyChangesToContext(Folder contextFolder, ChangeSet changeSet);
  void removeContext(Folder folder);
  void updateContextPackageMap(Folder contextFolder, Map<String, List<Folder>> packageMap);
}
class AnalysisDomainHandler implements RequestHandler {
  final AnalysisServer server;
  SearchEngine searchEngine;
  AnalysisDomainHandler(this.server) {
    searchEngine = server.searchEngine;
  }
  Response getErrors(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    server.onFileAnalysisComplete(A_file).then((I__) {
      Response A_response = new Response(request.id);
      AnalysisErrorInfo errorInfo = server.getErrors(A_file);
      if (errorInfo == null) {
        A_response.setResult(ERRORS, []);
      } else {
        A_response.setResult(ERRORS, engineErrorInfoToJson(errorInfo));
      }
      server.sendResponse(A_response);
    }).catchError((A_message) {
      if (A_message is! String) {
        AnalysisEngine.A_instance.logger.logError('Illegal error message during getErrors: ${A_message}');
        A_message = '';
      }
      Response A_response = new Response.getErrorsError(request, A_message);
      A_response.setResult(ERRORS, []);
      server.sendResponse(A_response);
    });
    return Response.DELAYED_RESPONSE;
  }
  Response getHover(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    int A_offset = request.getRequiredParameter(OFFSET).asInt();
    List<Hover> hovers = <Hover>[];
    List<CompilationUnit> units = server.getResolvedCompilationUnits(A_file);
    for (CompilationUnit unit in units) {
      Hover hoverInformation = new DartUnitHoverComputer(unit, A_offset).compute();
      if (hoverInformation != null) {
        hovers.add(hoverInformation);
      }
    }
    Response A_response = new Response(request.id);
    A_response.setResult(HOVERS, hovers);
    return A_response;
  }
  Response handleRequest(Request request) {
    try {
      String requestName = request.method;
      if (requestName == ANALYSIS_GET_ERRORS) {
        return getErrors(request);
      } else if (requestName == ANALYSIS_GET_HOVER) {
        return getHover(request);
      } else if (requestName == ANALYSIS_SET_ANALYSIS_ROOTS) {
        return setAnalysisRoots(request);
      } else if (requestName == ANALYSIS_SET_PRIORITY_FILES) {
        return setPriorityFiles(request);
      } else if (requestName == ANALYSIS_SET_SUBSCRIPTIONS) {
        return setSubscriptions(request);
      } else if (requestName == ANALYSIS_UPDATE_CONTENT) {
        return updateContent(request);
      } else if (requestName == ANALYSIS_UPDATE_OPTIONS) {
        return updateOptions(request);
      }
    }on RequestFailure  catch (exception) {
      return exception.response;
    }
    return null;
  }
  Response setAnalysisRoots(Request request) {
    RequestDatum includedDatum = request.getRequiredParameter(INCLUDED);
    List<String> includedPaths = includedDatum.asStringList();
    RequestDatum excludedDatum = request.getRequiredParameter(EXCLUDED);
    List<String> excludedPaths = excludedDatum.asStringList();
    server.setAnalysisRoots(request.id, includedPaths, excludedPaths);
    return new Response(request.id);
  }
  Response setPriorityFiles(Request request) {
    RequestDatum filesDatum = request.getRequiredParameter(FILES);
    List<String> files = filesDatum.asStringList();
    server.setPriorityFiles(request, files);
    return new Response(request.id);
  }
  Response setSubscriptions(Request request) {
    Map<AnalysisService, Set<String>> subMap;
    {
      RequestDatum subDatum = request.getRequiredParameter(SUBSCRIPTIONS);
      Map<String, List<String>> subStringMap = subDatum.asStringListMap();
      subMap = new A_p.HashMap<AnalysisService,Set<String>>();
      subStringMap.forEach((String serviceName, List<String> paths) {
        AnalysisService service = Enum2.valueOf(AnalysisService.VALUES, serviceName);
        if (service == null) {
          throw new RequestFailure(new Response.unknownAnalysisService(request, serviceName));
        }
        subMap[service] = new A_p.HashSet.from(paths);
      });
    }
    server.setAnalysisSubscriptions(subMap);
    return new Response(request.id);
  }
  Response updateContent(Request request) {
    var changes = new A_p.HashMap<String,ContentChange>();
    RequestDatum filesDatum = request.getRequiredParameter(FILES);
    filesDatum.forEachMap((A_file, changeDatum) {
      var A_change = new ContentChange();
      A_change.content = changeDatum[CONTENT].isNull ? null : changeDatum[CONTENT].asString();
      if (changeDatum.hasKey(OFFSET)) {
        A_change.offset = changeDatum[OFFSET].asInt();
        A_change.oldLength = changeDatum[OLD_LENGTH].asInt();
        A_change.newLength = changeDatum[NEW_LENGTH].asInt();
      }
      changes[A_file] = A_change;
    });
    server.updateContent(changes);
    return new Response(request.id);
  }
  Response updateOptions(Request request) {
    RequestDatum optionsDatum = request.getRequiredParameter(OPTIONS);
    List<OptionUpdater> updaters = new List<OptionUpdater>();
    optionsDatum.forEachMap((String optionName, RequestDatum optionDatum) {
      if (optionName == ANALYZE_ANGULAR) {
        bool optionValue = optionDatum.asBool();
        updaters.add((AnalysisOptionsImpl options) {
          options.analyzeAngular = optionValue;
        });
      } else if (optionName == ANALYZE_POLYMER) {
        bool optionValue = optionDatum.asBool();
        updaters.add((AnalysisOptionsImpl options) {
          options.analyzePolymer = optionValue;
        });
      } else if (optionName == ENABLE_ASYNC) {} else if (optionName == ENABLE_DEFERRED_LOADING) {
        bool optionValue = optionDatum.asBool();
        updaters.add((AnalysisOptionsImpl options) {
          options.enableDeferredLoading = optionValue;
        });
      } else if (optionName == ENABLE_ENUMS) {} else if (optionName == GENERATE_DART2JS_HINTS) {
        bool optionValue = optionDatum.asBool();
        updaters.add((AnalysisOptionsImpl options) {
          options.dart2jsHint = optionValue;
        });
      } else if (optionName == GENERATE_HINTS) {
        bool optionValue = optionDatum.asBool();
        updaters.add((AnalysisOptionsImpl options) {
          options.hint = optionValue;
        });
      } else {
        throw new RequestFailure(new Response.unknownOptionName(request, optionName));
      }
    });
    server.updateOptions(updaters);
    return new Response(request.id);
  }
}
class ContentChange {
  String content;
  int offset;
  int oldLength;
  int newLength;
}
class CompletionDomainHandler implements RequestHandler {
  final AnalysisServer server;
  int _nextCompletionId = 0;
  CompletionDomainHandler(this.server);
  Response handleRequest(Request request) {
    try {
      String requestName = request.method;
      if (requestName == COMPLETION_GET_SUGGESTIONS) {
        return processRequest(request);
      }
    }on RequestFailure  catch (exception) {
      return exception.response;
    }
    return null;
  }
  Response processRequest(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    int A_offset = request.getRequiredParameter(OFFSET).asInt();
    String completionId = (_nextCompletionId++).toString();
    CompletionManager.A_create(server.getAnalysisContext(A_file), server.getSource(A_file), A_offset, server.searchEngine).results().listen((CompletionResult result) {
      sendCompletionNotification(completionId, result.replacementOffset, result.replacementLength, result.suggestions, result.last);
    });
    return new Response(request.id)
        ..setResult(A_ID, completionId);
  }
  void sendCompletionNotification(String completionId, int replacementOffset, int replacementLength, Iterable<CompletionSuggestion> results, bool isLast) {
    Notification notification = new Notification(COMPLETION_RESULTS);
    notification.setParameter(A_ID, completionId);
    notification.setParameter(REPLACEMENT_OFFSET, replacementOffset);
    notification.setParameter(REPLACEMENT_LENGTH, replacementLength);
    notification.setParameter(RESULTS, results);
    notification.setParameter(LAST, isLast);
    server.sendNotification(notification);
  }
}
class ServerDomainHandler implements RequestHandler {
  final AnalysisServer server;
  ServerDomainHandler(this.server);
  Response getVersion(Request request) {
    Response A_response = new Response(request.id);
    A_response.setResult(VERSION, '0.0.1');
    return A_response;
  }
  Response handleRequest(Request request) {
    try {
      String requestName = request.method;
      if (requestName == SERVER_GET_VERSION) {
        return getVersion(request);
      } else if (requestName == SERVER_SET_SUBSCRIPTIONS) {
        return setSubscriptions(request);
      } else if (requestName == SERVER_SHUTDOWN) {
        return shutdown(request);
      }
    }on RequestFailure  catch (exception) {
      return exception.response;
    }
    return null;
  }
  Response setSubscriptions(Request request) {
    RequestDatum subDatum = request.getRequiredParameter(SUBSCRIPTIONS);
    server.serverServices = subDatum.asEnumSet(ServerService.VALUES);
    return new Response(request.id);
  }
  Response shutdown(Request request) {
    server.shutdown();
    Response A_response = new Response(request.id);
    return A_response;
  }
}
class EditDomainHandler implements RequestHandler {
  final AnalysisServer server;
  SearchEngine searchEngine;
  EditDomainHandler(this.server) {
    searchEngine = server.searchEngine;
  }
  Response applyRefactoring(Request request) {
    RequestDatum idDatum = request.getRequiredParameter(A_ID);
    String A_id = idDatum.asString();
    return null;
  }
  Response createRefactoring(Request request) {
    RequestDatum kindDatum = request.getRequiredParameter(KIND);
    String kind = kindDatum.asString();
    RequestDatum fileDatum = request.getRequiredParameter(A_FILE);
    String A_file = fileDatum.asString();
    RequestDatum offsetDatum = request.getRequiredParameter(OFFSET);
    int A_offset = offsetDatum.asInt();
    RequestDatum lengthDatum = request.getRequiredParameter(LENGTH);
    int A_length = lengthDatum.asInt();
    return null;
  }
  Response deleteRefactoring(Request request) {
    RequestDatum idDatum = request.getRequiredParameter(A_ID);
    String A_id = idDatum.asString();
    return null;
  }
  Response getAssists(Request request) {
    RequestDatum fileDatum = request.getRequiredParameter(A_FILE);
    String A_file = fileDatum.asString();
    RequestDatum offsetDatum = request.getRequiredParameter(OFFSET);
    int A_offset = offsetDatum.asInt();
    RequestDatum lengthDatum = request.getRequiredParameter(LENGTH);
    int A_length = lengthDatum.asInt();
    return null;
  }
  Response getFixes(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    int A_offset = request.getRequiredParameter(OFFSET).asInt();
    List<ErrorFixes> errorFixesList = <ErrorFixes>[];
    List<CompilationUnit> units = server.getResolvedCompilationUnits(A_file);
    for (CompilationUnit unit in units) {
      AnalysisErrorInfo errorInfo = server.getErrors(A_file);
      if (errorInfo != null) {
        for (A_AnalysisError A_error in errorInfo.errors) {
          List<Fix> fixes = computeFixes(searchEngine, unit, A_error);
          if (fixes.isNotEmpty) {
            AnalysisError serverError = new AnalysisError.B_fromEngine(errorInfo.lineInfo, A_error);
            ErrorFixes errorFixes = new ErrorFixes(serverError);
            errorFixesList.add(errorFixes);
            fixes.forEach((fix) {
              return errorFixes.addFix(fix);
            });
          }
        }
      }
    }
    return new Response(request.id)
        ..setResult(FIXES, errorFixesList);
  }
  Response getRefactorings(Request request) {
    RequestDatum fileDatum = request.getRequiredParameter(A_FILE);
    String A_file = fileDatum.asString();
    RequestDatum offsetDatum = request.getRequiredParameter(OFFSET);
    int A_offset = offsetDatum.asInt();
    RequestDatum lengthDatum = request.getRequiredParameter(LENGTH);
    int A_length = lengthDatum.asInt();
    return null;
  }
  Response handleRequest(Request request) {
    try {
      String requestName = request.method;
      if (requestName == EDIT_APPLY_REFACTORING) {
        return applyRefactoring(request);
      } else if (requestName == EDIT_CREATE_REFACTORING) {
        return createRefactoring(request);
      } else if (requestName == EDIT_DELETE_REFACTORING) {
        return deleteRefactoring(request);
      } else if (requestName == EDIT_GET_ASSISTS) {
        return getAssists(request);
      } else if (requestName == EDIT_GET_FIXES) {
        return getFixes(request);
      } else if (requestName == EDIT_GET_REFACTORINGS) {
        return getRefactorings(request);
      } else if (requestName == EDIT_SET_REFACTORING_OPTIONS) {
        return setRefactoringOptions(request);
      }
    }on RequestFailure  catch (exception) {
      return exception.response;
    }
    return null;
  }
  Response setRefactoringOptions(Request request) {
    RequestDatum idDatum = request.getRequiredParameter(A_ID);
    String A_id = idDatum.asString();
    return null;
  }
}
class ErrorFixes implements HasToJson {
  final AnalysisError error;
  final List<Change> fixes = <Change>[];
  ErrorFixes(this.error);
  void addFix(Fix fix) {
    Change A_change = fix.change;
    fixes.add(A_change);
  }
  Map<String, Object> toJson() {
    return {A_ERROR: error.toJson(), FIXES: objectToJson(fixes)};
  }
  String toString() => 'ErrorFixes(error=${error}, fixes=${fixes})';
}
class GetHandler {
  static const String STATUS_PATH = '/status';
  SocketServer A__server;
  GetHandler(SocketServer this.A__server);
  void handleGetRequest(C_p.HttpRequest request) {
    String A_path = request.uri.path;
    if (A_path == STATUS_PATH) {
      _returnServerStatus(request);
    } else {
      A__returnUnknownRequest(request);
    }
  }
  void _returnServerStatus(C_p.HttpRequest request) {
    C_p.HttpResponse A_response = request.response;
    A_response.statusCode = C_p.HttpStatus.OK;
    A_response.headers.add(C_p.HttpHeaders.CONTENT_TYPE, "text/html");
    A_response.write('<html>');
    A_response.write('<head>');
    A_response.write('<title>Dart Analysis Server - Status</title>');
    A_response.write('</head>');
    A_response.write('<body>');
    A_response.write('<h1>Analysis Server</h1>');
    if (A__server.analysisServer == null) {
      A_response.write('<p>Not running</p>');
    } else {
      A_response.write('<p>Running</p>');
      A_response.write('<h1>Analysis Contexts</h1>');
      A_response.write('<h2>Summary</h2>');
      A_response.write('<table>');
      _writeRow(A_response, ['Context', 'ERROR', 'FLUSHED', 'IN_PROCESS', 'INVALID', 'VALID'], true);
      A_response.write('</table>');
    }
    A_response.write('</body>');
    A_response.write('</html>');
    A_response.close();
  }
  void A__returnUnknownRequest(C_p.HttpRequest request) {
    C_p.HttpResponse A_response = request.response;
    A_response.statusCode = C_p.HttpStatus.NOT_FOUND;
    A_response.headers.add(C_p.HttpHeaders.CONTENT_TYPE, "text/plain");
    A_response.write('Not found');
    A_response.close();
  }
  void _writeRow(C_p.HttpResponse A_response, List<Object> columns, [bool header = false]) {
    if (header) {
      A_response.write('<th>');
    } else {
      A_response.write('<tr>');
    }
    columns.forEach((Object A_value) {
      A_response.write('<td>');
      A_response.write(A_value);
      A_response.write('</td>');
    });
    if (header) {
      A_response.write('</th>');
    } else {
      A_response.write('</tr>');
    }
  }
}
class ServerOperationPriority {
  final int ordinal;
  final String name;
  static const int COUNT = 4;
  static const ServerOperationPriority ANALYSIS_CONTINUE = const ServerOperationPriority.A__(0, "ANALYSIS_CONTINUE");
  static const ServerOperationPriority ANALYSIS = const ServerOperationPriority.A__(1, "ANALYSIS");
  String toString() => name;
  const ServerOperationPriority.A__(this.ordinal, this.name);
}
abstract class ServerOperation {
  ServerOperationPriority get priority;
  void perform(AnalysisServer server);
}
void sendAnalysisNotificationErrors(AnalysisServer server, String A_file, LineInfo lineInfo, List<A_AnalysisError> B_errors) {
  Notification notification = new Notification(ANALYSIS_ERRORS);
  notification.setParameter(A_FILE, A_file);
  notification.setParameter(ERRORS, engineErrorsToJson(lineInfo, B_errors));
  server.sendNotification(notification);
}
void sendAnalysisNotificationHighlights(AnalysisServer server, String A_file, CompilationUnit dartUnit) {
  Notification notification = new Notification(ANALYSIS_HIGHLIGHTS);
  notification.setParameter(A_FILE, A_file);
  notification.setParameter(REGIONS, new DartUnitHighlightsComputer(dartUnit).compute());
  server.sendNotification(notification);
}
void sendAnalysisNotificationNavigation(AnalysisServer server, String A_file, CompilationUnit dartUnit) {
  Notification notification = new Notification(ANALYSIS_NAVIGATION);
  notification.setParameter(A_FILE, A_file);
  notification.setParameter(REGIONS, new DartUnitNavigationComputer(dartUnit).compute());
  server.sendNotification(notification);
}
void sendAnalysisNotificationOccurrences(AnalysisServer server, String A_file, CompilationUnit dartUnit) {
  Notification notification = new Notification(ANALYSIS_OCCURRENCES);
  notification.setParameter(A_FILE, A_file);
  notification.setParameter(A_OCCURRENCES, new DartUnitOccurrencesComputer(dartUnit).compute());
  server.sendNotification(notification);
}
void sendAnalysisNotificationOutline(AnalysisServer server, AnalysisContext context, Source A_source, CompilationUnit dartUnit) {
  Notification notification = new Notification(ANALYSIS_OUTLINE);
  notification.setParameter(A_FILE, A_source.fullName);
  notification.setParameter(A_OUTLINE, new DartUnitOutlineComputer(context, A_source, dartUnit).compute());
  server.sendNotification(notification);
}
void sendAnalysisNotificationOverrides(AnalysisServer server, String A_file, CompilationUnit dartUnit) {
  Notification notification = new Notification(ANALYSIS_OVERRIDES);
  notification.setParameter(A_FILE, A_file);
  notification.setParameter(A_OVERRIDES, new DartUnitOverridesComputer(dartUnit).compute());
  server.sendNotification(notification);
}
class PerformAnalysisOperation extends ServerOperation {
  final AnalysisContext context;
  final bool isContinue;
  PerformAnalysisOperation(this.context, this.isContinue);
  ServerOperationPriority get priority {
    if (isContinue) {
      return ServerOperationPriority.ANALYSIS_CONTINUE;
    } else {
      return ServerOperationPriority.ANALYSIS;
    }
  }
  void perform(AnalysisServer server) {
    AnalysisResult result = context.performAnalysisTask();
    List<ChangeNotice> notices = result.changeNotices;
    if (notices == null) {
      server.sendContextAnalysisDoneNotifications(context);
      return;
    }
    sendNotices(server, notices);
    updateIndex(server.index, notices);
    server.addOperation(new PerformAnalysisOperation(context, true));
  }
  void sendNotices(AnalysisServer server, List<ChangeNotice> notices) {
    for (int i = 0; i < notices.length; i++) {
      ChangeNotice notice = notices[i];
      Source A_source = notice.source;
      String A_file = A_source.fullName;
      CompilationUnit dartUnit = notice.compilationUnit;
      if (dartUnit != null) {
        if (server.hasAnalysisSubscription(AnalysisService.HIGHLIGHTS, A_file)) {
          sendAnalysisNotificationHighlights(server, A_file, dartUnit);
        }
        if (server.hasAnalysisSubscription(AnalysisService.NAVIGATION, A_file)) {
          sendAnalysisNotificationNavigation(server, A_file, dartUnit);
        }
        if (server.hasAnalysisSubscription(AnalysisService.OCCURRENCES, A_file)) {
          sendAnalysisNotificationOccurrences(server, A_file, dartUnit);
        }
        if (server.hasAnalysisSubscription(AnalysisService.OUTLINE, A_file)) {
          sendAnalysisNotificationOutline(server, context, A_source, dartUnit);
        }
        if (server.hasAnalysisSubscription(AnalysisService.OVERRIDES, A_file)) {
          sendAnalysisNotificationOverrides(server, A_file, dartUnit);
        }
      }
      if (server.shouldSendErrorsNotificationFor(A_file)) {
        sendAnalysisNotificationErrors(server, A_file, notice.lineInfo, notice.errors);
      }
    }
  }
  void updateIndex(Index A_index, List<ChangeNotice> notices) {
    if (A_index == null) {
      return;
    }
    for (ChangeNotice notice in notices) {
      {
        CompilationUnit dartUnit = notice.compilationUnit;
        if (dartUnit != null) {
          A_index.indexUnit(context, dartUnit);
        }
      }
      {
        HtmlUnit htmlUnit = notice.htmlUnit;
        if (htmlUnit != null) {
          A_index.A_indexHtmlUnit(context, htmlUnit);
        }
      }
    }
  }
}
class ServerOperationQueue {
  final List<ServerOperationPriority> _analysisPriorities = [ServerOperationPriority.ANALYSIS_CONTINUE, ServerOperationPriority.ANALYSIS];
  final AnalysisServer B__server;
  final List<A_p.Queue<ServerOperation>> _queues = <A_p.Queue<ServerOperation>>[];
  ServerOperationQueue(this.B__server) {
    for (int i = 0; i < ServerOperationPriority.COUNT; i++) {
      var queue = new A_p.DoubleLinkedQueue<ServerOperation>();
      _queues.add(queue);
    }
  }
  void add(ServerOperation operation) {
    int queueIndex = operation.priority.ordinal;
    A_p.Queue<ServerOperation> queue = _queues[queueIndex];
    queue.addLast(operation);
  }
  void clear() {
    for (A_p.Queue<ServerOperation> queue in _queues) {
      queue.clear();
    }
  }
  bool get isEmpty {
    return _queues.every((queue) => queue.isEmpty);
  }
  ServerOperation take() {
    for (ServerOperationPriority priority in _analysisPriorities) {
      A_p.Queue<ServerOperation> queue = _queues[priority.ordinal];
      for (PerformAnalysisOperation operation in queue) {
        if (B__server.isPriorityContext(operation.context)) {
          queue.remove(operation);
          return operation;
        }
      }
    }
    for (A_p.Queue<ServerOperation> queue in _queues) {
      if (!queue.isEmpty) {
        return queue.removeFirst();
      }
    }
    return null;
  }
}
class PackageMapInfo {
  Map<String, List<Folder>> packageMap;
  Set<String> dependencies;
  PackageMapInfo(this.packageMap, this.dependencies);
}
abstract class PackageMapProvider {
  PackageMapInfo computePackageMap(Folder folder);
}
class PubPackageMapProvider implements PackageMapProvider {
  static const String PUB_LIST_COMMAND = 'list-package-dirs';
  static const String PUBSPEC_LOCK_NAME = 'pubspec.lock';
  final ResourceProvider resourceProvider;
  final DirectoryBasedDartSdk sdk;
  PubPackageMapProvider(this.resourceProvider, this.sdk);
  PackageMapInfo computePackageMap(Folder folder) {
    String A_executable = sdk.pubExecutable.getAbsolutePath();
    C_p.ProcessResult result;
    try {
      result = C_p.Process.runSync(A_executable, [PUB_LIST_COMMAND], workingDirectory: folder.path);
    }on C_p.ProcessException  catch (exception, A_stackTrace) {
      AnalysisEngine.A_instance.logger.logInformation("Error running pub ${PUB_LIST_COMMAND}\n${exception}\n${A_stackTrace}");
    }
    if (result.exitCode != 0) {
      AnalysisEngine.A_instance.logger.logInformation("pub ${PUB_LIST_COMMAND} failed: exit code ${result.exitCode}");
      return A__error(folder);
    }
    try {
      return parsePackageMap(result.stdout, folder);
    } catch (exception, A_stackTrace) {
      AnalysisEngine.A_instance.logger.logError("Malformed output from pub ${PUB_LIST_COMMAND}\n${exception}\n${A_stackTrace}");
    }
    return A__error(folder);
  }
  PackageMapInfo parsePackageMap(String jsonText, Folder folder) {
    Map<String, List<Folder>> packageMap = new A_p.HashMap<String,List<Folder>>();
    Map obj = B_p.JSON.decode(jsonText);
    Map packages = obj['packages'];
    processPaths(String packageName, List paths) {
      List<Folder> folders = <Folder>[];
      for (var A_path in paths) {
        if (A_path is String) {
          Resource resource = folder.getChild(A_path);
          if (resource is Folder) {
            folders.add(resource);
          }
        }
      }
      if (folders.isNotEmpty) {
        packageMap[packageName] = folders;
      }
    }
    packages.forEach((A_key, A_value) {
      if (A_value is String) {
        processPaths(A_key, [A_value]);
      } else if (A_value is List) {
        processPaths(A_key, A_value);
      }
    });
    Set<String> dependencies = new Set<String>();
    List inputFiles = obj['input_files'];
    if (inputFiles != null) {
      for (var A_path in inputFiles) {
        if (A_path is String) {
          dependencies.add(folder.canonicalizePath(A_path));
        }
      }
    }
    return new PackageMapInfo(packageMap, dependencies);
  }
  PackageMapInfo A__error(Folder folder) {
    List<String> dependencies = <String>[B_join(folder.path, PUBSPEC_LOCK_NAME)];
    return new PackageMapInfo(null, dependencies.toSet());
  }
}
abstract class Enum2<A_E extends Enum2> implements Comparable<A_E> {
  final String name;
  final int ordinal;
  const Enum2(this.name, this.ordinal);
  int get hashCode => ordinal;
  String toString() => name;
  int compareTo(A_E other) => ordinal - other.ordinal;
  static Enum2 valueOf(List<Enum2> C_values, String A_name) {
    for (int i = 0; i < C_values.length; i++) {
      Enum2 A_value = C_values[i];
      if (A_value.name == A_name) {
        return A_value;
      }
    }
    return null;
  }
}
class Request {
  static const String ID = 'id';
  static const String C_METHOD = 'method';
  static const String PARAMS = 'params';
  final String id;
  final String method;
  final Map<String, Object> params = new A_p.HashMap<String,Object>();
  static const B_p.JsonDecoder DECODER = const B_p.JsonDecoder(null);
  Request(this.id, this.method);
  factory Request.A_fromString(String A_data) {
    try {
      var result = DECODER.convert(A_data);
      if (result is! Map) {
        return null;
      }
      var A_id = result[Request.ID];
      var A_method = result[Request.C_METHOD];
      if (A_id is! String || A_method is! String) {
        return null;
      }
      var A_params = result[Request.PARAMS];
      Request request = new Request(A_id, A_method);
      if (A_params is Map) {
        A_params.forEach((String A_key, Object A_value) {
          request.setParameter(A_key, A_value);
        });
      } else if (A_params != null) {
        return null;
      }
      return request;
    } catch (exception) {
      return null;
    }
  }
  RequestDatum getRequiredParameter(String A_name) {
    if (!params.containsKey(A_name)) {
      throw new RequestFailure(new Response.missingRequiredParameter(this, A_name));
    }
    return new RequestDatum(this, A_name, params[A_name]);
  }
  void setParameter(String A_name, Object A_value) {
    params[A_name] = A_value;
  }
  Map<String, Object> toJson() {
    Map<String, Object> jsonObject = new A_p.HashMap<String,Object>();
    jsonObject[ID] = id;
    jsonObject[C_METHOD] = method;
    if (params.isNotEmpty) {
      jsonObject[PARAMS] = params;
    }
    return jsonObject;
  }
}
class RequestDatum {
  final Request request;
  final String path;
  final dynamic datum;
  RequestDatum(this.request, this.path, this.datum);
  RequestDatum operator[](String A_key) {
    Map<String, Object> A_map = _asMap();
    if (!A_map.containsKey(A_key)) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "contain key '${A_key}'"));
    }
    return new RequestDatum(request, "${path}.${A_key}", A_map[A_key]);
  }
  bool hasKey(String A_key) {
    return _asMap().containsKey(A_key);
  }
  void forEachMap(void f(String key, RequestDatum value)) {
    _asMap().forEach((String A_key, A_value) {
      f(A_key, new RequestDatum(request, "${path}.${A_key}", A_value));
    });
  }
  int asInt() {
    if (datum is int) {
      return datum;
    } else if (datum is String) {
      return int.parse(datum, onError: (String A_value) {
        throw new RequestFailure(new Response.invalidParameter(request, path, "be an integer"));
      });
    }
    throw new RequestFailure(new Response.invalidParameter(request, path, "be an integer"));
  }
  bool asBool() {
    if (datum is bool) {
      return datum;
    } else if (datum == 'true') {
      return true;
    } else if (datum == 'false') {
      return false;
    }
    throw new RequestFailure(new Response.invalidParameter(request, datum, "be a boolean"));
  }
  bool get isList {
    return datum == null || datum is List;
  }
  List _asList() {
    if (!isList) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "be a list"));
    }
    if (datum == null) {
      return [];
    } else {
      return datum;
    }
  }
  String asString() {
    if (datum is! String) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "be a string"));
    }
    return datum;
  }
  bool get isStringList {
    if (!isList) {
      return false;
    }
    for (var A_element in _asList()) {
      if (A_element is! String) {
        return false;
      }
    }
    return true;
  }
  List<String> asStringList() {
    if (!isStringList) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "be a list of strings"));
    }
    return _asList();
  }
  Set<Enum2> asEnumSet(List<Enum2> allValues) {
    Set C_values = new Set();
    for (String A_name in asStringList()) {
      Enum2 A_value = Enum2.valueOf(allValues, A_name);
      if (A_value == null) {
        throw new RequestFailure(new Response.invalidParameter(request, path, "be a list of names from the list ${allValues}"));
      }
      C_values.add(A_value);
    }
    return C_values;
  }
  bool get isMap {
    return datum == null || datum is Map;
  }
  Map<String, Object> _asMap() {
    if (!isMap) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "be a map"));
    }
    if (datum == null) {
      return {};
    } else {
      return datum;
    }
  }
  bool get isStringListMap {
    if (!isMap) {
      return false;
    }
    for (var A_value in _asMap().values) {
      if (A_value is! List) {
        return false;
      }
      for (var listItem in A_value) {
        if (listItem is! String) {
          return false;
        }
      }
    }
    return true;
  }
  Map<String, List<String>> asStringListMap() {
    if (!isStringListMap) {
      throw new RequestFailure(new Response.invalidParameter(request, path, "be a string list map"));
    }
    return _asMap();
  }
  bool get isNull => datum == null;
}
class Response {
  static final Response DELAYED_RESPONSE = new Response('DELAYED_RESPONSE');
  static const String ID = 'id';
  static const String ERROR = 'error';
  static const String RESULT = 'result';
  final String id;
  final RequestError error;
  final Map<String, Object> result = new A_p.HashMap<String,Object>();
  Response(this.id, [this.error]);
  Response.invalidParameter(Request request, String A_path, String expectation) : this(request.id, new RequestError('INVALID_PARAMETER', "Expected parameter ${A_path} to ${expectation}"));
  Response.invalidRequestFormat() : this('', new RequestError('INVALID_REQUEST', 'Invalid request'));
  Response.missingRequiredParameter(Request request, String A_parameterName) : this(request.id, new RequestError('MISSING_PARAMETER', 'Missing required parameter: ${A_parameterName}'));
  Response.unknownRequest(Request request) : this(request.id, new RequestError('UNKNOWN_REQUEST', 'Unknown request'));
  Response.unsupportedFeature(String requestId, String A_message) : this(requestId, new RequestError('UNSUPPORTED_FEATURE', A_message));
  Response.unknownAnalysisService(Request request, String A_name) : this(request.id, new RequestError('UNKNOWN_ANALYSIS_SERVICE', 'Unknown analysis service: "${A_name}"'));
  Response.unanalyzedPriorityFiles(Request request, String fileNames) : this(request.id, new RequestError('UNANALYZED_PRIORITY_FILES', "Unanalyzed files cannot be a priority: '${fileNames}'"));
  Response.unknownOptionName(Request request, String optionName) : this(request.id, new RequestError('UNKNOWN_OPTION_NAME', 'Unknown analysis option: "${optionName}"'));
  Response.getErrorsError(Request request, String A_message) : this(request.id, new RequestError('GET_ERRORS_ERROR', 'Error during `analysis.getErrors`: ${A_message}.'));
  void setResult(String A_name, Object A_value) {
    result[A_name] = _toJson(A_value);
  }
  Map<String, Object> toJson() {
    Map<String, Object> jsonObject = new A_p.HashMap<String,Object>();
    jsonObject[ID] = id;
    if (error != null) {
      jsonObject[ERROR] = error.toJson();
    }
    if (!result.isEmpty) {
      jsonObject[RESULT] = result;
    }
    return jsonObject;
  }
}
class RequestError {
  static const String CODE = 'code';
  static const String DATA = 'data';
  static const String MESSAGE = 'message';
  static const String CODE_SERVER_ALREADY_STARTED = 'SERVER_ALREADY_STARTED';
  final String code;
  final String message;
  final Map<String, Object> data = new A_p.HashMap<String,Object>();
  RequestError(this.code, this.message);
  RequestError.serverAlreadyStarted() : this(CODE_SERVER_ALREADY_STARTED, "Server already started");
  Map<String, Object> toJson() {
    Map<String, Object> jsonObject = new A_p.HashMap<String,Object>();
    jsonObject[CODE] = code;
    jsonObject[MESSAGE] = message;
    if (!data.isEmpty) {
      jsonObject[DATA] = data;
    }
    return jsonObject;
  }
  String toString() => toJson().toString();
}
class Notification {
  static const String EVENT = 'event';
  static const String PARAMS = 'params';
  final String event;
  final Map<String, Object> params = new A_p.HashMap<String,Object>();
  Notification(this.event);
  void setParameter(String A_name, Object A_value) {
    params[A_name] = _toJson(A_value);
  }
  Map<String, Object> toJson() {
    Map<String, Object> jsonObject = {};
    jsonObject[EVENT] = event;
    if (!params.isEmpty) {
      jsonObject[PARAMS] = params;
    }
    return jsonObject;
  }
}
abstract class RequestHandler {
  Response handleRequest(Request request);
}
class RequestFailure implements Exception {
  final Response response;
  RequestFailure(this.response);
}
_toJson(Object A_value) {
  if (A_value is HasToJson) {
    return A_value.toJson();
  }
  if (A_value is Iterable) {
    return A_value.map((item) => _toJson(item)).toList();
  }
  return A_value;
}
class ElementReferencesComputer {
  final SearchEngine searchEngine;
  ElementReferencesComputer(this.searchEngine);
  p.Future<List<SearchResult>> compute(A_Element A_element, bool withPotential) {
    var futureGroup = new _ConcatFutureGroup<SearchResult>();
    futureGroup.add(_findElementsReferences(A_element));
    if (withPotential && _isMemberElement(A_element)) {
      String A_name = A_element.displayName;
      var matchesFuture = searchEngine.searchMemberReferences(A_name);
      var resultsFuture = matchesFuture.then((List<SearchMatch> matches) {
        return matches.where((match) => !match.isResolved).map(toResult);
      });
      futureGroup.add(resultsFuture);
    }
    return futureGroup.future;
  }
  p.Future<List<SearchResult>> _findElementsReferences(A_Element A_element) {
    return _getRefElements(A_element).then((Iterable<A_Element> refElements) {
      var futureGroup = new _ConcatFutureGroup<SearchResult>();
      for (A_Element refElement in refElements) {
        if (_isVariableLikeElement(refElement)) {
          SearchResult searchResult = _newDeclarationResult(refElement);
          futureGroup.add(searchResult);
        }
        futureGroup.add(_findSingleElementReferences(refElement));
      }
      return futureGroup.future;
    });
  }
  p.Future<List<SearchResult>> _findSingleElementReferences(A_Element A_element) {
    p.Future<List<SearchMatch>> matchesFuture = searchEngine.searchReferences(A_element);
    return matchesFuture.then((List<SearchMatch> matches) {
      return matches.map(toResult).toList();
    });
  }
  p.Future<Iterable<A_Element>> _getRefElements(A_Element A_element) {
    if (A_element is ClassMemberElement) {
      return getHierarchyMembers(searchEngine, A_element);
    }
    return new p.Future.value([A_element]);
  }
  SearchResult _newDeclarationResult(A_Element refElement) {
    int nameOffset = refElement.nameOffset;
    int nameLength = refElement.name.length;
    SearchMatch searchMatch = new SearchMatch(MatchKind.A_DECLARATION, refElement, new SourceRange(nameOffset, nameLength), true, false);
    return new SearchResult.fromMatch(searchMatch);
  }
  static SearchResult toResult(SearchMatch match) {
    return new SearchResult.fromMatch(match);
  }
  static bool _isMemberElement(A_Element A_element) {
    return A_element.enclosingElement is ClassElement;
  }
  static bool _isVariableLikeElement(A_Element A_element) {
    if (A_element is LocalVariableElement) {
      return true;
    }
    if (A_element is ParameterElement) {
      return true;
    }
    if (A_element is PropertyInducingElement) {
      return !A_element.isSynthetic;
    }
    return false;
  }
}
class _ConcatFutureGroup<B_E> {
  final List<p.Future<List<B_E>>> _futures = <p.Future<List<B_E>>>[];
  p.Future<List<B_E>> get future {
    return p.Future.wait(_futures).then(concatToList);
  }
  void add(A_value) {
    if (A_value is p.Future) {
      _futures.add(A_value);
    } else {
      _futures.add(new p.Future.value(<B_E>[A_value]));
    }
  }
}
class SearchDomainHandler implements RequestHandler {
  final AnalysisServer server;
  SearchEngine searchEngine;
  int _nextSearchId = 0;
  SearchDomainHandler(this.server) {
    searchEngine = server.searchEngine;
  }
  Response findElementReferences(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    int A_offset = request.getRequiredParameter(OFFSET).asInt();
    bool includePotential = request.getRequiredParameter(INCLUDE_POTENTIAL).asBool();
    List<A_Element> elements = server.getElementsAtOffset(A_file, A_offset);
    elements = elements.map((A_Element A_element) {
      if (A_element is FieldFormalParameterElement) {
        return A_element.field;
      }
      if (A_element is PropertyAccessorElement) {
        return A_element.variable;
      }
      return A_element;
    }).toList();
    String searchId = (_nextSearchId++).toString();
    elements.forEach((A_Element A_element) {
      var computer = new ElementReferencesComputer(searchEngine);
      var A_future = computer.compute(A_element, includePotential);
      A_future.then((List<SearchResult> results) {
        bool isLast = identical(A_element, elements.last);
        _sendSearchNotification(searchId, isLast, results);
      });
    });
    if (elements.isEmpty) {
      new p.Future.microtask(() {
        _sendSearchNotification(searchId, true, []);
      });
    }
    Response A_response = new Response(request.id);
    A_response.setResult(A_ID, searchId);
    if (elements.isNotEmpty) {
      var serverElement = new Element.A_fromEngine(elements[0]);
      A_response.setResult(A_ELEMENT, serverElement);
    }
    return A_response;
  }
  Response findMemberDeclarations(Request request) {
    String A_name = request.getRequiredParameter(NAME).asString();
    String searchId = (_nextSearchId++).toString();
    {
      var matchesFuture = searchEngine.searchMemberDeclarations(A_name);
      matchesFuture.then((List<SearchMatch> matches) {
        _sendSearchNotification(searchId, true, matches.map(A_toResult));
      });
    }
    return new Response(request.id)
        ..setResult(A_ID, searchId);
  }
  Response findMemberReferences(Request request) {
    String A_name = request.getRequiredParameter(NAME).asString();
    String searchId = (_nextSearchId++).toString();
    {
      var matchesFuture = searchEngine.searchMemberReferences(A_name);
      matchesFuture.then((List<SearchMatch> matches) {
        _sendSearchNotification(searchId, true, matches.map(A_toResult));
      });
    }
    return new Response(request.id)
        ..setResult(A_ID, searchId);
  }
  Response findTopLevelDeclarations(Request request) {
    String A_pattern = request.getRequiredParameter(PATTERN).asString();
    String searchId = (_nextSearchId++).toString();
    {
      var matchesFuture = searchEngine.searchTopLevelDeclarations(A_pattern);
      matchesFuture.then((List<SearchMatch> matches) {
        _sendSearchNotification(searchId, true, matches.map(A_toResult));
      });
    }
    return new Response(request.id)
        ..setResult(A_ID, searchId);
  }
  Response getTypeHierarchy(Request request) {
    String A_file = request.getRequiredParameter(A_FILE).asString();
    int A_offset = request.getRequiredParameter(OFFSET).asInt();
    List<A_Element> elements = server.getElementsAtOffset(A_file, A_offset);
    if (elements.isEmpty) {
      return new Response(request.id);
    }
    A_Element A_element = elements.first;
    TypeHierarchyComputer computer = new TypeHierarchyComputer(searchEngine);
    computer.compute(A_element).then((List<TypeHierarchyItem> items) {
      Response A_response = new Response(request.id);
      A_response.setResult(HIERARCHY_ITEMS, objectToJson(items));
      server.sendResponse(A_response);
    });
    return Response.DELAYED_RESPONSE;
  }
  Response handleRequest(Request request) {
    try {
      String requestName = request.method;
      if (requestName == SEARCH_FIND_ELEMENT_REFERENCES) {
        return findElementReferences(request);
      } else if (requestName == SEARCH_FIND_MEMBER_DECLARATIONS) {
        return findMemberDeclarations(request);
      } else if (requestName == SEARCH_FIND_MEMBER_REFERENCES) {
        return findMemberReferences(request);
      } else if (requestName == SEARCH_FIND_TOP_LEVEL_DECLARATIONS) {
        return findTopLevelDeclarations(request);
      } else if (requestName == SEARCH_GET_TYPE_HIERARCHY) {
        return getTypeHierarchy(request);
      }
    }on RequestFailure  catch (exception) {
      return exception.response;
    }
    return null;
  }
  void _sendSearchNotification(String searchId, bool isLast, Iterable<SearchResult> results) {
    Notification notification = new Notification(SEARCH_RESULTS);
    notification.setParameter(A_ID, searchId);
    notification.setParameter(LAST, isLast);
    notification.setParameter(RESULTS, results);
    server.sendNotification(notification);
  }
  static SearchResult A_toResult(SearchMatch match) {
    return new SearchResult.fromMatch(match);
  }
}
class SearchResult implements HasToJson {
  final SearchResultKind kind;
  final bool isPotential;
  final Location location;
  final List<Element> path;
  SearchResult(this.kind, this.isPotential, this.location, this.path);
  factory SearchResult.fromMatch(SearchMatch match) {
    SearchResultKind A_kind = new SearchResultKind.C_fromEngine(match.kind);
    Location A_location = new Location.fromOffset(match.element, match.sourceRange.offset, match.sourceRange.length);
    List<Element> A_path = _computePath(match.element);
    return new SearchResult(A_kind, !match.isResolved, A_location, A_path);
  }
  Map<String, Object> toJson() {
    return {KIND: kind.name, IS_POTENTIAL: isPotential, A_LOCATION: location.toJson(), PATH: path.map(Element.asJson).toList()};
  }
  String toString() => toJson().toString();
  static List<Element> _computePath(A_Element A_element) {
    List<Element> A_path = <Element>[];
    while (A_element != null) {
      A_path.add(new Element.A_fromEngine(A_element));
      A_element = A_element.enclosingElement;
    }
    return A_path;
  }
}
class SearchResultKind {
  static const DECLARATION = const SearchResultKind('DECLARATION');
  static const A_READ = const SearchResultKind('READ');
  static const READ_WRITE = const SearchResultKind('READ_WRITE');
  static const A_WRITE = const SearchResultKind('WRITE');
  static const INVOCATION = const SearchResultKind('INVOCATION');
  static const REFERENCE = const SearchResultKind('REFERENCE');
  static const B_UNKNOWN = const SearchResultKind('UNKNOWN');
  final String name;
  const SearchResultKind(this.name);
  factory SearchResultKind.C_fromEngine(MatchKind kind) {
    if (kind == MatchKind.A_DECLARATION) {
      return DECLARATION;
    }
    if (kind == MatchKind.B_READ) {
      return A_READ;
    }
    if (kind == MatchKind.A_READ_WRITE) {
      return READ_WRITE;
    }
    if (kind == MatchKind.B_WRITE) {
      return A_WRITE;
    }
    if (kind == MatchKind.A_INVOCATION) {
      return INVOCATION;
    }
    if (kind == MatchKind.A_REFERENCE) {
      return REFERENCE;
    }
    return B_UNKNOWN;
  }
  String toString() => name;
}
class TypeHierarchyComputer {
  final SearchEngine _searchEngine;
  A_ElementKind _pivotKind;
  String _pivotName;
  final List<TypeHierarchyItem> _items = <TypeHierarchyItem>[];
  final Map<A_Element, TypeHierarchyItem> _elementItemMap = new A_p.HashMap<A_Element,TypeHierarchyItem>();
  TypeHierarchyComputer(this._searchEngine);
  p.Future<List<TypeHierarchyItem>> compute(A_Element A_element) {
    _pivotKind = A_element.kind;
    _pivotName = A_element.name;
    if (A_element is ExecutableElement && A_element.enclosingElement is ClassElement) {
      A_element = A_element.enclosingElement;
    }
    if (A_element is ClassElement) {
      InterfaceType A_type = A_element.type;
      _createSuperItem(A_type);
      return _createSubclasses(_items[0], A_type).then((J__) {
        return new p.Future.value(_items);
      });
    }
    return new p.Future.value([]);
  }
  p.Future _createSubclasses(TypeHierarchyItem item, InterfaceType A_type) {
    var A_future = getDirectSubClasses(_searchEngine, A_type.element);
    return A_future.then((Set<ClassElement> subElements) {
      List<TypeHierarchyItem> subItems = <TypeHierarchyItem>[];
      for (ClassElement subElement in subElements) {
        TypeHierarchyItem subItem = _elementItemMap[subElement];
        if (subItem != null) {
          int A_id = _items.indexOf(subItem);
          subItem.subclasses.add(A_id);
          continue;
        }
        ExecutableElement subMemberElement = _findMemberElement(subElement);
        subItem = new TypeHierarchyItem(_items.length, subElement, subMemberElement, null, item.id, <int>[], <int>[]);
        _elementItemMap[subElement] = subItem;
        _items.add(subItem);
        item.subclasses.add(subItem.id);
        subItems.add(subItem);
      }
      return p.Future.forEach(subItems, (TypeHierarchyItem subItem) {
        InterfaceType A_subType = subItem.classElement.type;
        return _createSubclasses(subItem, A_subType);
      });
    });
  }
  int _createSuperItem(InterfaceType A_type) {
    TypeHierarchyItem item = _elementItemMap[A_type.element];
    if (item != null) {
      return _items.indexOf(item);
    }
    {
      String displayName = null;
      if (A_type.typeArguments.isNotEmpty) {
        displayName = A_type.toString();
      }
      ClassElement classElement = A_type.element;
      ExecutableElement memberElement = _findMemberElement(classElement);
      item = new TypeHierarchyItem(_items.length, classElement, memberElement, displayName, null, <int>[], <int>[]);
      _elementItemMap[classElement] = item;
      _items.add(item);
    }
    {
      InterfaceType superType = A_type.superclass;
      if (superType != null) {
        item.superclass = _createSuperItem(superType);
      }
    }
    A_type.mixins.forEach((InterfaceType A_type) {
      int A_id = _createSuperItem(A_type);
      item.mixins.add(A_id);
    });
    A_type.interfaces.forEach((InterfaceType A_type) {
      int A_id = _createSuperItem(A_type);
      item.interfaces.add(A_id);
    });
    return item.id;
  }
  ExecutableElement _findMemberElement(ClassElement classElement) {
    if (_pivotKind == A_ElementKind.E_METHOD) {
      return classElement.getMethod(_pivotName);
    }
    if (_pivotKind == A_ElementKind.C_GETTER) {
      return classElement.getGetter(_pivotName);
    }
    if (_pivotKind == A_ElementKind.C_SETTER) {
      return classElement.getSetter(_pivotName);
    }
    return null;
  }
}
class TypeHierarchyItem implements HasToJson {
  final int id;
  final ClassElement classElement;
  final A_Element memberElement;
  final String displayName;
  int superclass;
  final List<int> mixins;
  final List<int> interfaces;
  final List<int> subclasses = <int>[];
  TypeHierarchyItem(this.id, this.classElement, this.memberElement, this.displayName, this.superclass, this.mixins, this.interfaces);
  Map<String, Object> toJson() {
    Map<String, Object> json = {};
    json[CLASS_ELEMENT] = engineElementToJson(classElement);
    if (memberElement != null) {
      json[MEMBER_ELEMENT] = engineElementToJson(memberElement);
    }
    if (displayName != null) {
      json[DISPLAY_NAME] = displayName;
    }
    if (superclass != null) {
      json[SUPERCLASS] = objectToJson(superclass);
    }
    json[INTERFACES] = objectToJson(interfaces);
    json[MIXINS] = objectToJson(mixins);
    json[SUBCLASSES] = objectToJson(subclasses);
    return json;
  }
}
Index _createIndex() {
  Index A_index = createLocalFileIndex();
  A_index.run();
  return A_index;
}
class SocketServer {
  AnalysisServer analysisServer;
  final DirectoryBasedDartSdk A_defaultSdk;
  SocketServer(this.A_defaultSdk);
  void createAnalysisServer(ServerCommunicationChannel serverChannel) {
    if (analysisServer != null) {
      RequestError A_error = new RequestError.serverAlreadyStarted();
      serverChannel.sendResponse(new Response('', A_error));
      serverChannel.listen((Request request) {
        serverChannel.sendResponse(new Response(request.id, A_error));
      });
      return;
    }
    PhysicalResourceProvider resourceProvider = PhysicalResourceProvider.A_INSTANCE;
    analysisServer = new AnalysisServer(serverChannel, resourceProvider, new PubPackageMapProvider(resourceProvider, A_defaultSdk), _createIndex(), A_defaultSdk, rethrowExceptions: false);
    _initializeHandlers(analysisServer);
  }
  void _initializeHandlers(AnalysisServer server) {
    server.handlers = [new ServerDomainHandler(server), new AnalysisDomainHandler(server), new EditDomainHandler(server), new SearchDomainHandler(server), new CompletionDomainHandler(server)];
  }
}
class StdioAnalysisServer {
  SocketServer socketServer;
  StdioAnalysisServer(this.socketServer);
  p.Future serveStdio() {
    ByteStreamServerChannel serverChannel = new ByteStreamServerChannel(C_p.stdin, C_p.stdout);
    socketServer.createAnalysisServer(serverChannel);
    return serverChannel.closed;
  }
}
abstract class CompletionComputer {
  p.Future<List<CompletionSuggestion>> compute();
}
abstract class CompletionManager {
  p.StreamController<CompletionResult> controller;
  void compute();
  p.Stream<CompletionResult> results() {
    controller = new p.StreamController<CompletionResult>(onListen: () {
      p.scheduleMicrotask(compute);
    });
    return controller.stream;
  }
  static CompletionManager A_create(AnalysisContext context, Source A_source, int A_offset, SearchEngine searchEngine) {
    if (context != null) {
      if (AnalysisEngine.isDartFileName(A_source.shortName)) {
        return new DartCompletionManager(context, A_source, A_offset, searchEngine);
      }
    }
    return new NoOpCompletionManager(A_source, A_offset);
  }
}
class CompletionResult {
  final int replacementLength;
  final int replacementOffset;
  final List<CompletionSuggestion> suggestions;
  final bool last;
  CompletionResult(this.replacementOffset, this.replacementLength, this.suggestions, this.last);
}
class DartCompletionManager extends CompletionManager {
  final AnalysisContext context;
  final Source source;
  final int offset;
  final SearchEngine searchEngine;
  DartCompletionManager(this.context, this.source, this.offset, this.searchEngine);
  void compute() {
    LibraryElement library = context.computeLibraryElement(source);
    CompilationUnit unit = context.resolveCompilationUnit(source, library);
    TopLevelComputer computer = new TopLevelComputer(searchEngine, unit);
    computer.compute().then((List<CompletionSuggestion> suggestions) {
      controller.add(new CompletionResult(offset, 0, suggestions, true));
    });
  }
}
class NoOpCompletionManager extends CompletionManager {
  final Source source;
  final int offset;
  NoOpCompletionManager(this.source, this.offset);
  void compute() {
    controller.add(new CompletionResult(offset, 0, [], true));
  }
}
class CompletionRelevance {
  static const CompletionRelevance LOW = const CompletionRelevance('LOW');
  static const CompletionRelevance DEFAULT = const CompletionRelevance('DEFAULT');
  final String name;
  const CompletionRelevance(this.name);
  toString() => 'CompletionRelevance.${name}';
}
class CompletionSuggestion implements HasToJson {
  final CompletionSuggestionKind kind;
  final CompletionRelevance relevance;
  final String completion;
  final int selectionOffset;
  final int selectionLength;
  final bool isDeprecated;
  final bool isPotential;
  CompletionSuggestion(this.kind, this.relevance, this.completion, this.selectionOffset, this.selectionLength, this.isDeprecated, this.isPotential);
  Map<String, Object> toJson() {
    return {KIND: kind.name, RELEVANCE: relevance.name, COMPLETION: completion, SELECTION_OFFSET: selectionOffset, SELECTION_LENGTH: selectionLength, IS_DEPRECATED: isDeprecated, IS_POTENTIAL: isPotential};
  }
}
class CompletionSuggestionKind {
  static const CompletionSuggestionKind B_CLASS = const CompletionSuggestionKind('CLASS');
  static const CompletionSuggestionKind B_CONSTRUCTOR = const CompletionSuggestionKind('CONSTRUCTOR');
  static const CompletionSuggestionKind B_FIELD = const CompletionSuggestionKind('FIELD');
  static const CompletionSuggestionKind B_FUNCTION = const CompletionSuggestionKind('FUNCTION');
  static const CompletionSuggestionKind B_FUNCTION_TYPE_ALIAS = const CompletionSuggestionKind('FUNCTION_TYPE_ALIAS');
  static const CompletionSuggestionKind B_GETTER = const CompletionSuggestionKind('GETTER');
  static const CompletionSuggestionKind IMPORT = const CompletionSuggestionKind('IMPORT');
  static const CompletionSuggestionKind D_METHOD = const CompletionSuggestionKind('METHOD');
  static const CompletionSuggestionKind B_PARAMETER = const CompletionSuggestionKind('PARAMETER');
  static const CompletionSuggestionKind B_SETTER = const CompletionSuggestionKind('SETTER');
  static const CompletionSuggestionKind B_TOP_LEVEL_VARIABLE = const CompletionSuggestionKind('TOP_LEVEL_VARIABLE');
  static const CompletionSuggestionKind VARIABLE = const CompletionSuggestionKind('VARIABLE');
  final String name;
  const CompletionSuggestionKind(this.name);
  String toString() => name;
  static CompletionSuggestionKind fromElementKind(A_ElementKind kind) {
    if (kind == A_ElementKind.C_CLASS) return B_CLASS;
    if (kind == A_ElementKind.C_CONSTRUCTOR) return B_CONSTRUCTOR;
    if (kind == A_ElementKind.C_FIELD) return B_FIELD;
    if (kind == A_ElementKind.C_FUNCTION) return B_FUNCTION;
    if (kind == A_ElementKind.C_FUNCTION_TYPE_ALIAS) return B_FUNCTION_TYPE_ALIAS;
    if (kind == A_ElementKind.C_GETTER) return B_GETTER;
    if (kind == A_ElementKind.A_IMPORT) return IMPORT;
    if (kind == A_ElementKind.B_LOCAL_VARIABLE) return VARIABLE;
    if (kind == A_ElementKind.E_METHOD) return D_METHOD;
    if (kind == A_ElementKind.E_PARAMETER) return B_PARAMETER;
    if (kind == A_ElementKind.C_SETTER) return B_SETTER;
    if (kind == A_ElementKind.C_TOP_LEVEL_VARIABLE) return B_TOP_LEVEL_VARIABLE;
    throw new ArgumentError('Unknown CompletionSuggestionKind for: ${kind}');
  }
}
const String CHILDREN = 'children';
const String CLASS_ELEMENT = 'classElement';
const String CLASS_NAME = 'className';
const String COMPLETION = 'completion';
const String CONTAINING_LIBRARY_NAME = 'containingLibraryName';
const String CONTAINING_LIBRARY_PATH = 'containingLibraryPath';
const String CONTENT = 'content';
const String CORRECTION = 'correction';
const String DART_DOC = 'dartdoc';
const String DISPLAY_NAME = 'displayName';
const String EDITS = 'edits';
const String A_ELEMENT = 'element';
const String ELEMENT_DESCRIPTION = 'elementDescription';
const String ELEMENT_KIND = 'elementKind';
const String EXCLUDED = 'excluded';
const String A_ERROR = 'error';
const String ERRORS = 'errors';
const String FATAL = 'fatal';
const String A_FILE = 'file';
const String FILES = 'files';
const String FIXES = 'fixes';
const String FLAGS = 'flags';
const String HIERARCHY_ITEMS = 'hierarchyItems';
const String HOVERS = 'hovers';
const String A_ID = 'id';
const String INCLUDE_POTENTIAL = 'includePotential';
const String INCLUDED = 'included';
const String INTERFACE_MEMBERS = 'interfaceMembers';
const String INTERFACES = 'interfaces';
const String IS_DEPRECATED = 'isDeprecated';
const String IS_POTENTIAL = 'isPotential';
const String KIND = 'kind';
const String LAST = 'last';
const String LENGTH = 'length';
const String LINKED_EDIT_GROUPS = 'linkedEditGroups';
const String A_LOCATION = 'location';
const String MEMBER_ELEMENT = 'memberElement';
const String A_MESSAGE = 'message';
const String MIXINS = 'mixins';
const String NAME = 'name';
const String NEW_LENGTH = 'newLength';
const String A_OCCURRENCES = 'occurrences';
const String OFFSET = 'offset';
const String OFFSETS = 'offsets';
const String OLD_LENGTH = 'oldLength';
const String OPTIONS = 'options';
const String A_OUTLINE = 'outline';
const String A_OVERRIDES = 'overrides';
const String C_PARAMETER = 'parameter';
const String PARAMETERS = 'parameters';
const String PATH = 'path';
const String PATTERN = 'pattern';
const String POSITIONS = 'positions';
const String PROPAGATED_TYPE = 'propagatedType';
const String REGIONS = 'regions';
const String RELEVANCE = 'relevance';
const String REPLACEMENT = 'relacement';
const String REPLACEMENT_OFFSET = 'replacementOffset';
const String REPLACEMENT_LENGTH = 'replacementLength';
const String RETURN_TYPE = 'returnType';
const String RESULTS = 'results';
const String SELECTION = 'selection';
const String SEVERITY = 'severity';
const String SELECTION_LENGTH = 'selectionLength';
const String SELECTION_OFFSET = 'selectionOffset';
const String STACK_TRACE = 'stackTrace';
const String START_COLUMN = 'startColumn';
const String START_LINE = 'startLine';
const String STATIC_TYPE = 'staticType';
const String SUBCLASSES = 'subclasses';
const String SUBSCRIPTIONS = 'subscriptions';
const String SUGGESTIONS = 'suggestions';
const String SUPERCLASS = 'superclass';
const String SUPER_CLASS_MEMBER = 'superclassMember';
const String TARGETS = 'targets';
const String TYPE = 'type';
const String VALUE = 'value';
const String VERSION = 'version';
class Change implements HasToJson {
  final String message;
  final List<FileEdit> edits = <FileEdit>[];
  final List<LinkedEditGroup> linkedEditGroups = <LinkedEditGroup>[];
  Position selection;
  Change(this.message);
  void add(FileEdit edit) {
    edits.add(edit);
  }
  void addLinkedEditGroup(LinkedEditGroup linkedEditGroup) {
    linkedEditGroups.add(linkedEditGroup);
  }
  Map<String, Object> toJson() {
    Map<String, Object> json = {A_MESSAGE: message, EDITS: objectToJson(edits), LINKED_EDIT_GROUPS: objectToJson(linkedEditGroups)};
    if (selection != null) {
      json[SELECTION] = selection.toJson();
    }
    return json;
  }
  String toString() => 'Change(message=${message}, edits=${edits}, ' 'linkedEditGroups=${linkedEditGroups}, selection=${selection})';
}
class Edit implements HasToJson {
  final int offset;
  final int length;
  final String replacement;
  Edit(this.offset, this.length, this.replacement);
  int get end => offset + length;
  bool operator==(other) {
    if (other is Edit) {
      return other.offset == offset && other.length == length && other.replacement == replacement;
    }
    return false;
  }
  Map<String, Object> toJson() {
    return {OFFSET: offset, LENGTH: length, REPLACEMENT: replacement};
  }
  String toString() => "Edit(offset=${offset}, length=${length}, replacement=:>${replacement}<:)";
}
class FileEdit implements HasToJson {
  final String file;
  final List<Edit> edits = <Edit>[];
  FileEdit(this.file);
  void add(Edit edit) {
    edits.add(edit);
  }
  Map<String, Object> toJson() {
    return {A_FILE: file, EDITS: objectToJson(edits)};
  }
  String toString() => "FileEdit(file=${file}, edits=${edits})";
}
class LinkedEditGroup implements HasToJson {
  final String id;
  int length;
  final List<Position> positions = <Position>[];
  final List<LinkedEditSuggestion> suggestions = <LinkedEditSuggestion>[];
  LinkedEditGroup(this.id);
  void addPosition(Position A_position, int A_length) {
    positions.add(A_position);
    this.length = A_length;
  }
  void addSuggestion(LinkedEditSuggestion suggestion) {
    suggestions.add(suggestion);
  }
  Map<String, Object> toJson() {
    return {A_ID: id, LENGTH: length, POSITIONS: objectToJson(positions), SUGGESTIONS: objectToJson(suggestions)};
  }
  String toString() => 'LinkedEditGroup(id=${id}, length=${length}, ' 'positions=${positions}, suggestions=${suggestions})';
}
class LinkedEditSuggestion implements HasToJson {
  final LinkedEditSuggestionKind kind;
  final String value;
  LinkedEditSuggestion(this.kind, this.value);
  bool operator==(other) {
    if (other is LinkedEditSuggestion) {
      return other.kind == kind && other.value == value;
    }
    return false;
  }
  Map<String, Object> toJson() {
    return {KIND: kind.name, VALUE: value};
  }
  String toString() => '(kind=${kind}, value=${value})';
}
class LinkedEditSuggestionKind {
  static const D_PARAMETER = const LinkedEditSuggestionKind('PARAMETER');
  static const A_TYPE = const LinkedEditSuggestionKind('TYPE');
  final String name;
  const LinkedEditSuggestionKind(this.name);
  String toString() => name;
}
class Position implements HasToJson {
  final String file;
  final int offset;
  Position(this.file, this.offset);
  int get hashCode {
    int hash = file.hashCode;
    hash = hash * 31 + offset;
    return hash;
  }
  bool operator==(other) {
    if (other is Position) {
      return other.file == file && other.offset == offset;
    }
    return false;
  }
  Map<String, Object> toJson() {
    return {A_FILE: file, OFFSET: offset};
  }
  String toString() => 'Position(file=${file}, offset=${offset})';
}
List<Fix> computeFixes(SearchEngine searchEngine, CompilationUnit unit, A_AnalysisError A_error) {
  Source A_source = unit.element.source;
  String A_file = A_source.fullName;
  var processor = new FixProcessor(searchEngine, A_source, A_file, unit, A_error);
  return processor.compute();
}
class Fix {
  final FixKind kind;
  final Change change;
  Fix(this.kind, this.change);
  String toString() {
    return '[kind=${kind}, change=${change}]';
  }
}
class FixKind {
  static const ADD_SUPER_CONSTRUCTOR_INVOCATION = const FixKind('ADD_SUPER_CONSTRUCTOR_INVOCATION', 50, "Add super constructor %s invocation");
  static const CHANGE_TO = const FixKind('CHANGE_TO', 51, "Change to '%s'");
  static const CHANGE_TO_STATIC_ACCESS = const FixKind('CHANGE_TO_STATIC_ACCESS', 50, "Change access to static using '%s'");
  static const CREATE_CLASS = const FixKind('CREATE_CLASS', 50, "Create class '%s'");
  static const CREATE_CONSTRUCTOR = const FixKind('CREATE_CONSTRUCTOR', 50, "Create constructor '%s'");
  static const CREATE_CONSTRUCTOR_SUPER = const FixKind('CREATE_CONSTRUCTOR_SUPER', 50, "Create constructor to call %s");
  static const CREATE_FUNCTION = const FixKind('CREATE_FUNCTION', 49, "Create function '%s'");
  static const CREATE_METHOD = const FixKind('CREATE_METHOD', 50, "Create method '%s'");
  static const CREATE_MISSING_OVERRIDES = const FixKind('CREATE_MISSING_OVERRIDES', 50, "Create %d missing override(s)");
  static const CREATE_NO_SUCH_METHOD = const FixKind('CREATE_NO_SUCH_METHOD', 49, "Create 'noSuchMethod' method");
  static const IMPORT_LIBRARY_PREFIX = const FixKind('IMPORT_LIBRARY_PREFIX', 51, "Use imported library '%s' with prefix '%s'");
  static const IMPORT_LIBRARY_PROJECT = const FixKind('IMPORT_LIBRARY_PROJECT', 51, "Import library '%s'");
  static const IMPORT_LIBRARY_SDK = const FixKind('IMPORT_LIBRARY_SDK', 51, "Import library '%s'");
  static const IMPORT_LIBRARY_SHOW = const FixKind('IMPORT_LIBRARY_SHOW', 51, "Update library '%s' import");
  static const INSERT_SEMICOLON = const FixKind('INSERT_SEMICOLON', 50, "Insert ';'");
  static const MAKE_CLASS_ABSTRACT = const FixKind('MAKE_CLASS_ABSTRACT', 50, "Make class '%s' abstract");
  static const REMOVE_PARAMETERS_IN_GETTER_DECLARATION = const FixKind('REMOVE_PARAMETERS_IN_GETTER_DECLARATION', 50, "Remove parameters in getter declaration");
  static const REMOVE_PARENTHESIS_IN_GETTER_INVOCATION = const FixKind('REMOVE_PARENTHESIS_IN_GETTER_INVOCATION', 50, "Remove parentheses in getter invocation");
  static const REMOVE_UNNECASSARY_CAST = const FixKind('REMOVE_UNNECASSARY_CAST', 50, "Remove unnecessary cast");
  static const REMOVE_UNUSED_IMPORT = const FixKind('REMOVE_UNUSED_IMPORT', 50, "Remove unused import");
  static const REPLACE_BOOLEAN_WITH_BOOL = const FixKind('REPLACE_BOOLEAN_WITH_BOOL', 50, "Replace 'boolean' with 'bool'");
  static const USE_CONST = const FixKind('USE_CONST', 50, "Change to constant");
  static const USE_EFFECTIVE_INTEGER_DIVISION = const FixKind('USE_EFFECTIVE_INTEGER_DIVISION', 50, "Use effective integer division ~/");
  static const USE_EQ_EQ_NULL = const FixKind('USE_EQ_EQ_NULL', 50, "Use == null instead of 'is Null'");
  static const USE_NOT_EQ_NULL = const FixKind('USE_NOT_EQ_NULL', 50, "Use != null instead of 'is! Null'");
  final name;
  final int relevance;
  final String message;
  const FixKind(this.name, this.relevance, this.message);
  String toString() => name;
}
abstract class Index {
  void clear();
  p.Future<List<A_Location>> getRelationships(A_Element A_element, Relationship relationship);
  void A_indexHtmlUnit(AnalysisContext context, HtmlUnit unit);
  void indexUnit(AnalysisContext context, CompilationUnit unit);
  void removeContext(AnalysisContext context);
  void removeSource(AnalysisContext context, Source A_source);
  void removeSources(AnalysisContext context, SourceContainer container);
  void run();
  void stop();
}
class IndexConstants {
  static final Relationship ANGULAR_REFERENCE = Relationship.getRelationship("angular-reference");
  static final Relationship ANGULAR_CLOSING_TAG_REFERENCE = Relationship.getRelationship("angular-closing-tag-reference");
  static final Relationship DEFINES = Relationship.getRelationship("defines");
  static final Relationship IS_EXTENDED_BY = Relationship.getRelationship("is-extended-by");
  static final Relationship IS_IMPLEMENTED_BY = Relationship.getRelationship("is-implemented-by");
  static final Relationship IS_MIXED_IN_BY = Relationship.getRelationship("is-mixed-in-by");
  static final Relationship IS_READ_BY = Relationship.getRelationship("is-read-by");
  static final Relationship IS_READ_WRITTEN_BY = Relationship.getRelationship("is-read-written-by");
  static final Relationship IS_WRITTEN_BY = Relationship.getRelationship("is-written-by");
  static final Relationship IS_INVOKED_BY = Relationship.getRelationship("is-invoked-by");
  static final Relationship IS_REFERENCED_BY = Relationship.getRelationship("is-referenced-by");
  static final Relationship NAME_IS_DEFINED_BY = Relationship.getRelationship("name-is-defined-by");
}
class A_Location {
  static const int _FLAG_QUALIFIED = 1 << 0;
  static const int _FLAG_RESOLVED = 1 << 1;
  static const List<A_Location> EMPTY_ARRAY = const<A_Location>[];
  final A_Element element;
  final int offset;
  final int length;
  int _flags;
  A_Location(this.element, this.offset, this.length, {bool isQualified: false, bool isResolved: true}) {
    if (element == null) {
      throw new ArgumentError("element location cannot be null");
    }
    _flags = 0;
    if (isQualified) {
      _flags |= _FLAG_QUALIFIED;
    }
    if (isResolved) {
      _flags |= _FLAG_RESOLVED;
    }
  }
  bool get isQualified => (_flags & _FLAG_QUALIFIED) != 0;
  bool get isResolved => (_flags & _FLAG_RESOLVED) != 0;
  String toString() {
    String flagsStr = '';
    if (isQualified) {
      flagsStr += ' qualified';
    }
    if (isResolved) {
      flagsStr += ' resolved';
    }
    return '[${offset} - ${(offset + length)}) ${flagsStr} in ${element}';
  }
}
class LocationWithData<D> extends A_Location {
  final D data;
  LocationWithData(A_Location A_location, this.data) : super(A_location.element, A_location.offset, A_location.length);
}
class NameElement extends ElementImpl {
  NameElement(String A_name) : super("name:${A_name}", -1);
  A_ElementKind get kind => A_ElementKind.A_NAME;
  accept(ElementVisitor visitor) => null;
}
class Relationship {
  static Map<String, Relationship> _RELATIONSHIP_MAP = {};
  final String identifier;
  Relationship(this.identifier);
  String toString() => identifier;
  static Relationship getRelationship(String A_identifier) {
    Relationship relationship = _RELATIONSHIP_MAP[A_identifier];
    if (relationship == null) {
      relationship = new Relationship(A_identifier);
      _RELATIONSHIP_MAP[A_identifier] = relationship;
    }
    return relationship;
  }
}
class UniverseElement extends ElementImpl {
  static final UniverseElement INSTANCE = new UniverseElement.B__();
  UniverseElement.B__() : super("--universe--", -1);
  A_ElementKind get kind => A_ElementKind.UNIVERSE;
  accept(ElementVisitor visitor) => null;
}
abstract class IndexStore {
  bool aboutToIndexDart(AnalysisContext context, CompilationUnitElement unitElement);
  bool aboutToIndexHtml(AnalysisContext context, HtmlElement htmlElement);
  void clear();
  void doneIndex();
  p.Future<List<A_Location>> getRelationships(A_Element A_element, Relationship relationship);
  void recordRelationship(A_Element A_element, Relationship relationship, A_Location A_location);
  void removeContext(AnalysisContext context);
  void removeSource(AnalysisContext context, Source A_source);
  void removeSources(AnalysisContext context, SourceContainer container);
}
Index createLocalFileIndex() {
  var fileManager = new TemporaryFolderFileManager();
  var stringCodec = new StringCodec();
  var nodeManager = new FileNodeManager(fileManager, AnalysisEngine.A_instance.logger, stringCodec, new ContextCodec(), new ElementCodec(stringCodec), new RelationshipCodec(stringCodec));
  return new LocalIndex(nodeManager);
}
abstract class HasToJson {
  Map<String, Object> toJson();
}
objectToJson(Object A_value) {
  if (A_value is HasToJson) {
    return A_value.toJson();
  }
  if (A_value is Iterable) {
    return A_value.map((item) => objectToJson(item)).toList();
  }
  return A_value;
}
List<A_Element> getChildren(A_Element A_parent, [String A_name]) {
  List<A_Element> children = <A_Element>[];
  A_parent.visitChildren(new _ElementVisitorAdapter((A_Element A_element) {
    if (A_name == null || A_element.displayName == A_name) {
      children.add(A_element);
    }
  }));
  return children;
}
List<A_Element> getClassMembers(ClassElement clazz, [String A_name]) {
  List<A_Element> members = <A_Element>[];
  clazz.visitChildren(new _ElementVisitorAdapter((A_Element A_element) {
    if (A_element.isSynthetic) {
      return;
    }
    if (A_element is ConstructorElement) {
      return;
    }
    if (A_name != null && A_element.displayName != A_name) {
      return;
    }
    if (A_element is ExecutableElement) {
      members.add(A_element);
    }
    if (A_element is FieldElement) {
      members.add(A_element);
    }
  }));
  return members;
}
p.Future<Set<ClassElement>> getDirectSubClasses(SearchEngine searchEngine, ClassElement seed) {
  return searchEngine.searchSubtypes(seed).then((List<SearchMatch> matches) {
    Set<ClassElement> subClasses = new A_p.HashSet<ClassElement>();
    for (SearchMatch match in matches) {
      ClassElement subClass = match.element;
      if (subClass.context == seed.context) {
        subClasses.add(subClass);
      }
    }
    return subClasses;
  });
}
p.Future<Set<ClassMemberElement>> getHierarchyMembers(SearchEngine searchEngine, ClassMemberElement member) {
  Set<ClassMemberElement> result = new A_p.HashSet<ClassMemberElement>();
  if (member is ConstructorElement) {
    result.add(member);
    return new p.Future.value(result);
  }
  String A_name = member.displayName;
  ClassElement memberClass = member.enclosingElement;
  List<p.Future> futures = <p.Future>[];
  Set<ClassElement> searchClasses = getSuperClasses(memberClass);
  searchClasses.add(memberClass);
  for (ClassElement superClass in searchClasses) {
    if (getClassMembers(superClass, A_name).isEmpty) {
      continue;
    }
    var subClassFuture = getSubClasses(searchEngine, superClass);
    var membersFuture = subClassFuture.then((Set<ClassElement> subClasses) {
      subClasses.add(superClass);
      for (ClassElement subClass in subClasses) {
        List<A_Element> subClassMembers = getChildren(subClass, A_name);
        for (A_Element member in subClassMembers) {
          if (member is ClassMemberElement) {
            result.add(member);
          }
        }
      }
    });
    futures.add(membersFuture);
  }
  return p.Future.wait(futures).then((K__) {
    return result;
  });
}
List<A_Element> getMembers(ClassElement clazz) {
  List<A_Element> members = <A_Element>[];
  members.addAll(getClassMembers(clazz));
  Set<ClassElement> superClasses = getSuperClasses(clazz);
  for (ClassElement superClass in superClasses) {
    members.addAll(getClassMembers(superClass));
  }
  return members;
}
p.Future<Set<ClassElement>> getSubClasses(SearchEngine searchEngine, ClassElement seed) {
  Set<ClassElement> subs = new A_p.HashSet<ClassElement>();
  List<ClassElement> queue = new List<ClassElement>();
  queue.add(seed);
  addSubClasses() {
    while (queue.isNotEmpty) {
      ClassElement clazz = queue.removeLast();
      if (subs.add(clazz)) {
        return getDirectSubClasses(searchEngine, clazz).then((directSubs) {
          queue.addAll(directSubs);
          return new p.Future(addSubClasses);
        });
      }
    }
    subs.remove(seed);
    return subs;
  }
  return new p.Future(addSubClasses);
}
Set<ClassElement> getSuperClasses(ClassElement seed) {
  Set<ClassElement> result = new A_p.HashSet<ClassElement>();
  List<ClassElement> queue = new List<ClassElement>();
  queue.add(seed);
  while (!queue.isEmpty) {
    ClassElement B_current = queue.removeLast();
    if (!result.add(B_current)) {
      continue;
    }
    {
      InterfaceType superType = B_current.supertype;
      if (superType != null) {
        queue.add(superType.element);
      }
    }
    for (InterfaceType intf in B_current.interfaces) {
      queue.add(intf.element);
    }
  }
  result.remove(seed);
  return result;
}
typedef void _ElementProcessor(A_Element element);
class _ElementVisitorAdapter extends GeneralizingElementVisitor {
  final _ElementProcessor processor;
  _ElementVisitorAdapter(this.processor);
  void visitElement(A_Element A_element) {
    processor(A_element);
  }
}
SearchEngine createSearchEngine(Index A_index) {
  return new SearchEngineImpl(A_index);
}
class MatchKind {
  static const MatchKind A_ANGULAR_REFERENCE = const MatchKind('ANGULAR_REFERENCE');
  static const MatchKind A_ANGULAR_CLOSING_TAG_REFERENCE = const MatchKind('ANGULAR_CLOSING_TAG_REFERENCE');
  static const MatchKind A_DECLARATION = const MatchKind('DECLARATION');
  static const MatchKind B_READ = const MatchKind('READ');
  static const MatchKind A_READ_WRITE = const MatchKind('READ_WRITE');
  static const MatchKind B_WRITE = const MatchKind('WRITE');
  static const MatchKind A_INVOCATION = const MatchKind('INVOCATION');
  static const MatchKind A_REFERENCE = const MatchKind('REFERENCE');
  final String name;
  const MatchKind(this.name);
  String toString() => name;
}
abstract class SearchEngine {
  p.Future<List<SearchMatch>> searchMemberDeclarations(String A_name);
  p.Future<List<SearchMatch>> searchMemberReferences(String A_name);
  p.Future<List<SearchMatch>> searchReferences(A_Element A_element);
  p.Future<List<SearchMatch>> searchSubtypes(ClassElement A_type);
  p.Future<List<SearchMatch>> searchTopLevelDeclarations(String A_pattern);
}
class SearchMatch {
  final MatchKind kind;
  final A_Element element;
  final SourceRange sourceRange;
  final bool isResolved;
  final bool isQualified;
  SearchMatch(this.kind, this.element, this.sourceRange, this.isResolved, this.isQualified);
  int get hashCode => JavaArrays.makeHashCode([element, sourceRange, kind]);
  bool operator==(Object object) {
    if (identical(object, this)) {
      return true;
    }
    if (object is SearchMatch) {
      return kind == object.kind && isResolved == object.isResolved && isQualified == object.isQualified && sourceRange == object.sourceRange && element == object.element;
    }
    return false;
  }
  String toString() {
    StringBuffer A_buffer = new StringBuffer();
    A_buffer.write("SearchMatch(kind=");
    A_buffer.write(kind);
    A_buffer.write(", element=");
    A_buffer.write(element.displayName);
    A_buffer.write(", range=");
    A_buffer.write(sourceRange);
    A_buffer.write(", isResolved=");
    A_buffer.write(isResolved);
    A_buffer.write(", isQualified=");
    A_buffer.write(isQualified);
    A_buffer.write(")");
    return A_buffer.toString();
  }
}
class TopLevelComputer extends CompletionComputer {
  final SearchEngine searchEngine;
  final CompilationUnit unit;
  TopLevelComputer(this.searchEngine, this.unit);
  p.Future<List<CompletionSuggestion>> compute() {
    var A_future = searchEngine.searchTopLevelDeclarations('');
    return A_future.then((List<SearchMatch> matches) {
      var visibleLibraries = new Set<LibraryElement>();
      var unitLibrary = unit.element.library;
      visibleLibraries.add(unitLibrary);
      visibleLibraries.addAll(unitLibrary.importedLibraries);
      var suggestions = new List<CompletionSuggestion>();
      matches.forEach((SearchMatch match) {
        if (match.kind == MatchKind.A_DECLARATION) {
          A_Element A_element = match.element;
          if (A_element.isPublic || A_element.library == unitLibrary) {
            String completion = A_element.displayName;
            var relevance = visibleLibraries.contains(A_element.library) ? CompletionRelevance.DEFAULT : CompletionRelevance.LOW;
            suggestions.add(new CompletionSuggestion(CompletionSuggestionKind.fromElementKind(A_element.kind), relevance, completion, completion.length, 0, A_element.isDeprecated, false));
          }
        }
      });
      return suggestions;
    });
  }
}
typedef bool Predicate<C_E>(C_E argument);
class FixProcessor {
  static const int MAX_LEVENSHTEIN_DISTANCE = 3;
  final SearchEngine searchEngine;
  final Source source;
  final String file;
  final CompilationUnit unit;
  final A_AnalysisError error;
  CompilationUnitElement unitElement;
  Source unitSource;
  LibraryElement unitLibraryElement;
  String unitLibraryFile;
  String unitLibraryFolder;
  final List<Edit> edits = <Edit>[];
  final Map<String, LinkedEditGroup> linkedPositionGroups = <String, LinkedEditGroup>{};
  Position exitPosition = null;
  final List<Fix> fixes = <Fix>[];
  CorrectionUtils utils;
  int errorOffset;
  int errorLength;
  int errorEnd;
  AstNode node;
  AstNode coveredNode;
  FixProcessor(this.searchEngine, this.source, this.file, this.unit, this.error) {
    unitElement = unit.element;
    unitSource = unitElement.source;
    unitLibraryElement = unitElement.library;
    unitLibraryFile = unitLibraryElement.source.fullName;
    unitLibraryFolder = dirname(unitLibraryFile);
  }
  DartType get coreTypeBool => _getCoreType("bool");
  String get eol => utils.endOfLine;
  List<Fix> compute() {
    utils = new CorrectionUtils(unit);
    errorOffset = error.offset;
    errorLength = error.length;
    errorEnd = errorOffset + errorLength;
    node = new NodeLocator.con1(errorOffset).searchWithin(unit);
    coveredNode = new NodeLocator.con2(errorOffset, errorOffset + errorLength).searchWithin(unit);
    ErrorCode A_errorCode = error.errorCode;
    if (A_errorCode == StaticWarningCode.UNDEFINED_CLASS_BOOLEAN) {
      _addFix_boolInsteadOfBoolean();
    }
    if (A_errorCode == CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE) {
      _addFix_replaceWithConstInstanceCreation();
    }
    if (A_errorCode == CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT) {
      _addFix_createConstructorSuperExplicit();
    }
    if (A_errorCode == CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT) {
      _addFix_createConstructorSuperImplicit();
    }
    if (A_errorCode == CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT) {
      _addFix_createConstructorSuperExplicit();
    }
    if (A_errorCode == HintCode.DIVISION_OPTIMIZATION) {
      _addFix_useEffectiveIntegerDivision();
    }
    if (A_errorCode == HintCode.TYPE_CHECK_IS_NOT_NULL) {
      _addFix_isNotNull();
    }
    if (A_errorCode == HintCode.TYPE_CHECK_IS_NULL) {
      _addFix_isNull();
    }
    if (A_errorCode == HintCode.UNNECESSARY_CAST) {
      _addFix_removeUnnecessaryCast();
    }
    if (A_errorCode == HintCode.UNUSED_IMPORT) {
      _addFix_removeUnusedImport();
    }
    if (A_errorCode == ParserErrorCode.EXPECTED_TOKEN) {
      _addFix_insertSemicolon();
    }
    if (A_errorCode == ParserErrorCode.GETTER_WITH_PARAMETERS) {
      _addFix_removeParameters_inGetterDeclaration();
    }
    if (A_errorCode == StaticWarningCode.CONCRETE_CLASS_WITH_ABSTRACT_MEMBER) {
      _addFix_makeEnclosingClassAbstract();
    }
    if (A_errorCode == StaticWarningCode.EXTRA_POSITIONAL_ARGUMENTS) {
      _addFix_createConstructor_insteadOfSyntheticDefault();
    }
    if (A_errorCode == StaticWarningCode.NEW_WITH_UNDEFINED_CONSTRUCTOR) {
      _addFix_createConstructor_named();
    }
    if (A_errorCode == StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE || A_errorCode == StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO || A_errorCode == StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE || A_errorCode == StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR || A_errorCode == StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS) {
      _addFix_makeEnclosingClassAbstract();
      AnalysisErrorWithProperties errorWithProperties = error as AnalysisErrorWithProperties;
      Object property = errorWithProperties.getProperty(ErrorProperty.UNIMPLEMENTED_METHODS);
      List<ExecutableElement> missingOverrides = property as List<ExecutableElement>;
      _addFix_createMissingOverrides(missingOverrides);
      _addFix_createNoSuchMethod();
    }
    if (A_errorCode == StaticWarningCode.UNDEFINED_CLASS) {
      _addFix_importLibrary_withType();
      _addFix_createClass();
      _addFix_undefinedClass_useSimilar();
    }
    if (A_errorCode == StaticWarningCode.UNDEFINED_IDENTIFIER) {
      _addFix_createFunction_forFunctionType();
      _addFix_importLibrary_withType();
      _addFix_importLibrary_withTopLevelVariable();
    }
    if (A_errorCode == StaticTypeWarningCode.INSTANCE_ACCESS_TO_STATIC_MEMBER) {
      _addFix_useStaticAccess_method();
      _addFix_useStaticAccess_property();
    }
    if (A_errorCode == StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION) {
      _addFix_removeParentheses_inGetterInvocation();
    }
    if (A_errorCode == StaticTypeWarningCode.UNDEFINED_FUNCTION) {
      _addFix_importLibrary_withFunction();
      _addFix_undefinedFunction_useSimilar();
      _addFix_undefinedFunction_create();
    }
    if (A_errorCode == StaticTypeWarningCode.UNDEFINED_GETTER) {
      _addFix_createFunction_forFunctionType();
    }
    if (A_errorCode == HintCode.UNDEFINED_METHOD || A_errorCode == StaticTypeWarningCode.UNDEFINED_METHOD) {
      _addFix_undefinedMethod_useSimilar();
      _addFix_undefinedMethod_create();
      _addFix_undefinedFunction_create();
    }
    return fixes;
  }
  void _addFix(FixKind kind, List args, {String fixFile}) {
    if (fixFile == null) {
      fixFile = file;
    }
    FileEdit fileEdit = new FileEdit(file);
    edits.forEach((edit) => fileEdit.add(edit));
    String A_message = JavaString.A_format(kind.message, args);
    Change A_change = new Change(A_message);
    A_change.add(fileEdit);
    linkedPositionGroups.values.forEach((A_group) => A_change.addLinkedEditGroup(A_group));
    A_change.selection = exitPosition;
    Fix fix = new Fix(kind, A_change);
    fixes.add(fix);
    edits.clear();
    linkedPositionGroups.clear();
    exitPosition = null;
  }
  void _addFix_boolInsteadOfBoolean() {
    SourceRange A_range = rangeError(error);
    _addReplaceEdit(A_range, "bool");
    _addFix(FixKind.REPLACE_BOOLEAN_WITH_BOOL, []);
  }
  void _addFix_createClass() {
    if (_mayBeTypeIdentifier(node)) {
      String A_name = (node as SimpleIdentifier).name;
      CompilationUnitMember enclosingMember = node.getAncestor((A_node) => A_node is CompilationUnitMember);
      int A_offset = enclosingMember.end;
      String prefix = "";
      SourceBuilder sb = new SourceBuilder(file, A_offset);
      {
        sb.append("${eol}${eol}");
        sb.append(prefix);
        sb.append("class ");
        {
          sb.startPosition("NAME");
          sb.append(A_name);
          sb.endPosition();
        }
        sb.append(" {");
        sb.append(eol);
        sb.append("}");
      }
      _insertBuilder(sb);
      _addLinkedPosition("NAME", rangeNode(node));
      _addFix(FixKind.CREATE_CLASS, [A_name]);
    }
  }
  void _addFix_createConstructorSuperExplicit() {
    ConstructorDeclaration targetConstructor = node.parent as ConstructorDeclaration;
    ClassDeclaration targetClassNode = targetConstructor.parent as ClassDeclaration;
    ClassElement targetClassElement = targetClassNode.element;
    ClassElement superClassElement = targetClassElement.supertype.element;
    List<ConstructorElement> superConstructors = superClassElement.constructors;
    for (ConstructorElement superConstructor in superConstructors) {
      String constructorName = superConstructor.name;
      if (Identifier.isPrivateName(constructorName)) {
        continue;
      }
      SourceBuilder sb;
      {
        List<ConstructorInitializer> initializers = targetConstructor.initializers;
        if (initializers.isEmpty) {
          int insertOffset = targetConstructor.parameters.end;
          sb = new SourceBuilder(file, insertOffset);
          sb.append(" : ");
        } else {
          ConstructorInitializer lastInitializer = initializers[initializers.length - 1];
          int insertOffset = lastInitializer.end;
          sb = new SourceBuilder(file, insertOffset);
          sb.append(", ");
        }
      }
      sb.append("super");
      if (!StringUtils.B_isEmpty(constructorName)) {
        sb.append(".");
        sb.append(constructorName);
      }
      sb.append("(");
      bool firstParameter = true;
      for (ParameterElement parameter in superConstructor.parameters) {
        if (parameter.parameterKind != ParameterKind.REQUIRED) {
          break;
        }
        if (firstParameter) {
          firstParameter = false;
        } else {
          sb.append(", ");
        }
        DartType parameterType = parameter.type;
        sb.startPosition(parameter.name);
        sb.append(getDefaultValueCode(parameterType));
        sb.endPosition();
      }
      sb.append(")");
      _insertBuilder(sb);
      String proposalName = _getConstructorProposalName(superConstructor);
      _addFix(FixKind.ADD_SUPER_CONSTRUCTOR_INVOCATION, [proposalName]);
    }
  }
  void _addFix_createConstructorSuperImplicit() {
    ClassDeclaration targetClassNode = node.parent as ClassDeclaration;
    ClassElement targetClassElement = targetClassNode.element;
    ClassElement superClassElement = targetClassElement.supertype.element;
    String targetClassName = targetClassElement.name;
    List<ConstructorElement> superConstructors = superClassElement.constructors;
    for (ConstructorElement superConstructor in superConstructors) {
      String constructorName = superConstructor.name;
      if (Identifier.isPrivateName(constructorName)) {
        continue;
      }
      SourceBuilder parametersBuffer = new SourceBuilder.A_buffer();
      SourceBuilder argumentsBuffer = new SourceBuilder.A_buffer();
      bool firstParameter = true;
      for (ParameterElement parameter in superConstructor.parameters) {
        if (parameter.parameterKind != ParameterKind.REQUIRED) {
          break;
        }
        if (firstParameter) {
          firstParameter = false;
        } else {
          parametersBuffer.append(', ');
          argumentsBuffer.append(', ');
        }
        String A_parameterName = parameter.displayName;
        if (A_parameterName.length > 1 && A_parameterName.startsWith('_')) {
          A_parameterName = A_parameterName.substring(1);
        }
        _appendParameterSource(parametersBuffer, parameter.type, A_parameterName);
        argumentsBuffer.append(A_parameterName);
      }
      _ConstructorLocation targetLocation = _prepareNewConstructorLocation(targetClassNode);
      SourceBuilder sb = new SourceBuilder(file, targetLocation.A__offset);
      {
        String A_indent = utils.getIndent(1);
        sb.append(targetLocation._prefix);
        sb.append(A_indent);
        sb.append(targetClassName);
        if (!constructorName.isEmpty) {
          sb.startPosition('NAME');
          sb.append('.');
          sb.append(constructorName);
          sb.endPosition();
        }
        sb.append("(");
        sb.append(parametersBuffer.toString());
        sb.append(') : super');
        if (!constructorName.isEmpty) {
          sb.append('.');
          sb.append(constructorName);
        }
        sb.append('(');
        sb.append(argumentsBuffer.toString());
        sb.append(');');
        sb.append(targetLocation._suffix);
      }
      _insertBuilder(sb);
      String proposalName = _getConstructorProposalName(superConstructor);
      _addFix(FixKind.CREATE_CONSTRUCTOR_SUPER, [proposalName]);
    }
  }
  void _addFix_createConstructor_insteadOfSyntheticDefault() {
    TypeName typeName = null;
    ConstructorName constructorName = null;
    InstanceCreationExpression instanceCreation = null;
    if (node is SimpleIdentifier) {
      if (node.parent is TypeName) {
        typeName = node.parent as TypeName;
        if (typeName.name == node && typeName.parent is ConstructorName) {
          constructorName = typeName.parent as ConstructorName;
          {
            ConstructorElement constructorElement = constructorName.staticElement;
            if (constructorElement == null || !constructorElement.isDefaultConstructor || !constructorElement.isSynthetic) {
              return;
            }
          }
          if (constructorName.parent is InstanceCreationExpression) {
            instanceCreation = constructorName.parent as InstanceCreationExpression;
            if (instanceCreation.constructorName != constructorName) {
              return;
            }
          }
        }
      }
    }
    if (instanceCreation == null) {
      return;
    }
    DartType targetType = typeName.type;
    if (targetType is! InterfaceType) {
      return;
    }
    ClassElement targetElement = targetType.element as ClassElement;
    String targetFile = targetElement.source.fullName;
    ClassDeclaration targetClass = targetElement.node;
    _ConstructorLocation targetLocation = _prepareNewConstructorLocation(targetClass);
    SourceBuilder sb = new SourceBuilder(targetFile, targetLocation.A__offset);
    {
      String A_indent = "  ";
      sb.append(targetLocation._prefix);
      sb.append(A_indent);
      sb.append(targetElement.name);
      _addFix_undefinedMethod_create_parameters(sb, instanceCreation.argumentList);
      sb.append(") {${eol}${A_indent}}");
      sb.append(targetLocation._suffix);
    }
    _insertBuilder(sb);
    _addFix(FixKind.CREATE_CONSTRUCTOR, [constructorName], fixFile: targetFile);
  }
  void _addFix_createConstructor_named() {
    SimpleIdentifier A_name = null;
    ConstructorName constructorName = null;
    InstanceCreationExpression instanceCreation = null;
    if (node is SimpleIdentifier) {
      A_name = node as SimpleIdentifier;
      if (A_name.parent is ConstructorName) {
        constructorName = A_name.parent as ConstructorName;
        if (constructorName.name == A_name) {
          if (constructorName.parent is InstanceCreationExpression) {
            instanceCreation = constructorName.parent as InstanceCreationExpression;
            if (instanceCreation.constructorName != constructorName) {
              return;
            }
          }
        }
      }
    }
    if (instanceCreation == null) {
      return;
    }
    DartType targetType = constructorName.type.type;
    if (targetType is! InterfaceType) {
      return;
    }
    ClassElement targetElement = targetType.element as ClassElement;
    String targetFile = targetElement.source.fullName;
    ClassDeclaration targetClass = targetElement.node;
    _ConstructorLocation targetLocation = _prepareNewConstructorLocation(targetClass);
    SourceBuilder sb = new SourceBuilder(targetFile, targetLocation.A__offset);
    {
      String A_indent = "  ";
      sb.append(targetLocation._prefix);
      sb.append(A_indent);
      sb.append(targetElement.name);
      sb.append(".");
      {
        sb.startPosition("NAME");
        sb.append(A_name.name);
        sb.endPosition();
      }
      _addFix_undefinedMethod_create_parameters(sb, instanceCreation.argumentList);
      sb.append(") {${eol}${A_indent}}");
      sb.append(targetLocation._suffix);
    }
    _insertBuilder(sb);
    if (targetFile == file) {
      _addLinkedPosition("NAME", rangeNode(A_name));
    }
    _addFix(FixKind.CREATE_CONSTRUCTOR, [constructorName], fixFile: targetFile);
  }
  void _addFix_createFunction_forFunctionType() {
    if (node is SimpleIdentifier) {
      SimpleIdentifier nameNode = node as SimpleIdentifier;
      ClassElement targetElement;
      Expression argument;
      {
        Expression A_target = getQualifiedPropertyTarget(node);
        if (A_target != null) {
          DartType targetType = A_target.bestType;
          if (targetType != null && targetType.element is ClassElement) {
            targetElement = targetType.element as ClassElement;
            argument = A_target.parent as Expression;
          } else {
            return;
          }
        } else {
          ClassDeclaration enclosingClass = node.getAncestor((A_node) => A_node is ClassDeclaration);
          targetElement = enclosingClass != null ? enclosingClass.element : null;
          argument = nameNode;
        }
      }
      ParameterElement parameterElement = argument.bestParameterElement;
      if (parameterElement == null) {
        return;
      }
      DartType parameterType = parameterElement.type;
      if (parameterType is! FunctionType) {
        return;
      }
      FunctionType A_functionType = parameterType as FunctionType;
      if (targetElement != null) {
        _addProposal_createFunction_method(targetElement, A_functionType);
      } else {
        _addProposal_createFunction_function(A_functionType);
      }
    }
  }
  void _addFix_createMissingOverrides(List<ExecutableElement> missingOverrides) {
    missingOverrides.sort((A_Element firstElement, A_Element secondElement) {
      return compareStrings(firstElement.displayName, secondElement.displayName);
    });
    ClassDeclaration targetClass = node.parent as ClassDeclaration;
    int insertOffset = targetClass.end - 1;
    SourceBuilder sb = new SourceBuilder(file, insertOffset);
    bool A_isFirst = true;
    for (ExecutableElement missingOverride in missingOverrides) {
      if (!A_isFirst || !targetClass.members.isEmpty) {
        sb.append(eol);
      }
      _addFix_createMissingOverrides_single(sb, targetClass, missingOverride);
      A_isFirst = false;
    }
    exitPosition = new Position(file, insertOffset);
    _insertBuilder(sb);
    _addFix(FixKind.CREATE_MISSING_OVERRIDES, [missingOverrides.length]);
  }
  void _addFix_createMissingOverrides_single(SourceBuilder sb, ClassDeclaration targetClass, ExecutableElement missingOverride) {
    String prefix = utils.getIndent(1);
    String prefix2 = utils.getIndent(2);
    A_ElementKind elementKind = missingOverride.kind;
    bool A_isGetter = elementKind == A_ElementKind.C_GETTER;
    bool A_isSetter = elementKind == A_ElementKind.C_SETTER;
    bool A_isMethod = elementKind == A_ElementKind.E_METHOD;
    bool isOperator = A_isMethod && (missingOverride as MethodElement).isOperator;
    sb.append(prefix);
    if (A_isGetter) {
      sb.append('// TODO: implement ${missingOverride.displayName}');
      sb.append(eol);
      sb.append(prefix);
    }
    {
      sb.append('@override');
      sb.append(eol);
      sb.append(prefix);
    }
    _appendType(sb, missingOverride.type.returnType);
    if (A_isGetter) {
      sb.append('get ');
    } else if (A_isSetter) {
      sb.append('set ');
    } else if (isOperator) {
      sb.append('operator ');
    }
    sb.append(missingOverride.displayName);
    if (A_isGetter) {
      sb.append(' => null;');
    } else {
      List<ParameterElement> A_parameters = missingOverride.parameters;
      _appendParameters(sb, A_parameters, _getDefaultValueMap(A_parameters));
      sb.append(' {');
      sb.append(eol);
      sb.append(prefix2);
      sb.append('// TODO: implement ${missingOverride.displayName}');
      sb.append(eol);
      sb.append(prefix);
      sb.append('}');
    }
    sb.append(eol);
  }
  void _addFix_createNoSuchMethod() {
    ClassDeclaration targetClass = node.parent as ClassDeclaration;
    String prefix = utils.getIndent(1);
    int insertOffset = targetClass.end - 1;
    SourceBuilder sb = new SourceBuilder(file, insertOffset);
    {
      if (!targetClass.members.isEmpty) {
        sb.append(eol);
      }
      sb.append(prefix);
      sb.append("noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);");
      sb.append(eol);
    }
    _insertBuilder(sb);
    exitPosition = new Position(file, insertOffset);
    _addFix(FixKind.CREATE_NO_SUCH_METHOD, []);
  }
  void _addFix_importLibrary(FixKind kind, String importPath) {
    CompilationUnitElement libraryUnitElement = unitLibraryElement.definingCompilationUnit;
    CompilationUnit libraryUnit = libraryUnitElement.node;
    int A_offset = 0;
    String prefix;
    String suffix;
    {
      prefix = "";
      suffix = eol;
      CorrectionUtils libraryUtils = new CorrectionUtils(libraryUnit);
      for (Directive directive in libraryUnit.directives) {
        if (directive is LibraryDirective || directive is ImportDirective) {
          A_offset = directive.end;
          prefix = eol;
          suffix = "";
        }
      }
      if (A_offset == 0) {
        CorrectionUtils_InsertDesc desc = libraryUtils.getInsertDescTop();
        A_offset = desc.offset;
        prefix = desc.prefix;
        suffix = "${desc.suffix}${eol}";
      }
    }
    String importSource = "${prefix}import '${importPath}';${suffix}";
    _addInsertEdit(A_offset, importSource);
    _addFix(kind, [importPath], fixFile: libraryUnitElement.source.fullName);
  }
  void _addFix_importLibrary_withElement(String A_name, A_ElementKind kind) {
    if (A_name.startsWith("_")) {
      return;
    }
    for (ImportElement imp in unitLibraryElement.imports) {
      LibraryElement libraryElement = imp.importedLibrary;
      A_Element A_element = getExportedElement(libraryElement, A_name);
      if (A_element == null) {
        continue;
      }
      if (A_element is PropertyAccessorElement) {
        A_element = (A_element as PropertyAccessorElement).variable;
      }
      if (A_element.kind != kind) {
        continue;
      }
      PrefixElement prefix = imp.prefix;
      if (prefix != null) {
        SourceRange A_range = rangeStartLength(node, 0);
        _addReplaceEdit(A_range, "${prefix.displayName}.");
        _addFix(FixKind.IMPORT_LIBRARY_PREFIX, [libraryElement.displayName, prefix.displayName]);
        continue;
      }
      List<NamespaceCombinator> combinators = imp.combinators;
      if (combinators.length == 1 && combinators[0] is ShowElementCombinator) {
        ShowElementCombinator showCombinator = combinators[0] as ShowElementCombinator;
        Set<String> showNames = new A_p.SplayTreeSet<String>();
        showNames.addAll(showCombinator.shownNames);
        showNames.add(A_name);
        String A_libraryName = libraryElement.definingCompilationUnit.displayName;
        if (libraryElement.isInSdk) {
          A_libraryName = imp.uri;
        }
        String newShowCode = "show ${StringUtils.A_join(showNames, ", ")}";
        _addReplaceEdit(rangeOffsetEnd(showCombinator), newShowCode);
        _addFix(FixKind.IMPORT_LIBRARY_SHOW, [A_libraryName], fixFile: unitLibraryFile);
        return;
      }
    }
    AnalysisContext context = unitLibraryElement.context;
    {
      DartSdk sdk = context.sourceFactory.dartSdk;
      List<SdkLibrary> sdkLibraries = sdk.sdkLibraries;
      for (SdkLibrary sdkLibrary in sdkLibraries) {
        SourceFactory sdkSourceFactory = context.sourceFactory;
        String libraryUri = 'dart:' + sdkLibrary.shortName;
        Source librarySource = sdkSourceFactory.resolveUri(unitSource, libraryUri);
        LibraryElement libraryElement = context.getLibraryElement(librarySource);
        if (libraryElement == null) {
          continue;
        }
        A_Element A_element = getExportedElement(libraryElement, A_name);
        if (A_element == null) {
          continue;
        }
        if (A_element is PropertyAccessorElement) {
          A_element = (A_element as PropertyAccessorElement).variable;
        }
        if (A_element.kind != kind) {
          continue;
        }
        _addFix_importLibrary(FixKind.IMPORT_LIBRARY_SDK, libraryUri);
      }
    }
    {
      List<Source> librarySources = context.librarySources;
      for (Source librarySource in librarySources) {
        if (librarySource.isInSystemLibrary) {
          continue;
        }
        LibraryElement libraryElement = context.getLibraryElement(librarySource);
        if (libraryElement == null) {
          continue;
        }
        A_Element A_element = getExportedElement(libraryElement, A_name);
        if (A_element == null) {
          continue;
        }
        if (A_element is PropertyAccessorElement) {
          A_element = (A_element as PropertyAccessorElement).variable;
        }
        if (A_element.kind != kind) {
          continue;
        }
        String libraryFile = librarySource.fullName;
        {
          String libraryPackageUri = _findPackageUri(context, libraryFile);
          if (libraryPackageUri != null) {
            _addFix_importLibrary(FixKind.IMPORT_LIBRARY_PROJECT, libraryPackageUri);
            continue;
          }
        }
        String relativeFile = relative(libraryFile, from: unitLibraryFolder);
        relativeFile = B_split(relativeFile).join('/');
        _addFix_importLibrary(FixKind.IMPORT_LIBRARY_PROJECT, relativeFile);
      }
    }
  }
  void _addFix_importLibrary_withFunction() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {
      MethodInvocation invocation = node.parent as MethodInvocation;
      if (invocation.realTarget == null && invocation.methodName == node) {
        String A_name = (node as SimpleIdentifier).name;
        _addFix_importLibrary_withElement(A_name, A_ElementKind.C_FUNCTION);
      }
    }
  }
  void _addFix_importLibrary_withTopLevelVariable() {
    if (node is SimpleIdentifier) {
      String A_name = (node as SimpleIdentifier).name;
      _addFix_importLibrary_withElement(A_name, A_ElementKind.C_TOP_LEVEL_VARIABLE);
    }
  }
  void _addFix_importLibrary_withType() {
    if (_mayBeTypeIdentifier(node)) {
      String typeName = (node as SimpleIdentifier).name;
      _addFix_importLibrary_withElement(typeName, A_ElementKind.C_CLASS);
    }
  }
  void _addFix_insertSemicolon() {
    if (error.message.contains("';'")) {
      int insertOffset = error.offset + error.length;
      _addInsertEdit(insertOffset, ";");
      _addFix(FixKind.INSERT_SEMICOLON, []);
    }
  }
  void _addFix_isNotNull() {
    if (coveredNode is IsExpression) {
      IsExpression isExpression = coveredNode as IsExpression;
      _addReplaceEdit(rangeEndEnd(isExpression.expression, isExpression), " != null");
      _addFix(FixKind.USE_NOT_EQ_NULL, []);
    }
  }
  void _addFix_isNull() {
    if (coveredNode is IsExpression) {
      IsExpression isExpression = coveredNode as IsExpression;
      _addReplaceEdit(rangeEndEnd(isExpression.expression, isExpression), " == null");
      _addFix(FixKind.USE_EQ_EQ_NULL, []);
    }
  }
  void _addFix_makeEnclosingClassAbstract() {
    ClassDeclaration enclosingClass = node.getAncestor((A_node) => A_node is ClassDeclaration);
    String className = enclosingClass.name.name;
    _addInsertEdit(enclosingClass.classKeyword.offset, "abstract ");
    _addFix(FixKind.MAKE_CLASS_ABSTRACT, [className]);
  }
  void _addFix_removeParameters_inGetterDeclaration() {
    if (node is SimpleIdentifier && node.parent is MethodDeclaration) {
      MethodDeclaration A_method = node.parent as MethodDeclaration;
      FunctionBody body = A_method.body;
      if (A_method.name == node && body != null) {
        _addReplaceEdit(rangeEndStart(node, body), " ");
        _addFix(FixKind.REMOVE_PARAMETERS_IN_GETTER_DECLARATION, []);
      }
    }
  }
  void _addFix_removeParentheses_inGetterInvocation() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {
      MethodInvocation invocation = node.parent as MethodInvocation;
      if (invocation.methodName == node && invocation.target != null) {
        _addRemoveEdit(rangeEndEnd(node, invocation));
        _addFix(FixKind.REMOVE_PARENTHESIS_IN_GETTER_INVOCATION, []);
      }
    }
  }
  void _addFix_removeUnnecessaryCast() {
    if (coveredNode is! AsExpression) {
      return;
    }
    AsExpression asExpression = coveredNode as AsExpression;
    Expression expression = asExpression.expression;
    int expressionPrecedence = getExpressionPrecedence(expression);
    _addRemoveEdit(rangeEndEnd(expression, asExpression));
    _removeEnclosingParentheses(asExpression, expressionPrecedence);
    _addFix(FixKind.REMOVE_UNNECASSARY_CAST, []);
  }
  void _addFix_removeUnusedImport() {
    ImportDirective importDirective = node.getAncestor((A_node) => A_node is ImportDirective);
    if (importDirective == null) {
      return;
    }
    _addRemoveEdit(utils.getLinesRange(rangeNode(importDirective)));
    _addFix(FixKind.REMOVE_UNUSED_IMPORT, []);
  }
  void _addFix_replaceWithConstInstanceCreation() {
    if (coveredNode is InstanceCreationExpression) {
      var instanceCreation = coveredNode as InstanceCreationExpression;
      _addReplaceEdit(rangeToken(instanceCreation.keyword), "const");
      _addFix(FixKind.USE_CONST, []);
    }
  }
  void _addFix_undefinedClass_useSimilar() {
    if (_mayBeTypeIdentifier(node)) {
      String A_name = (node as SimpleIdentifier).name;
      _ClosestElementFinder finder = new _ClosestElementFinder(A_name, (A_Element A_element) => A_element is ClassElement, MAX_LEVENSHTEIN_DISTANCE);
      {
        for (CompilationUnitElement A_unit in unitLibraryElement.units) {
          finder._updateList(A_unit.types);
        }
        for (ImportElement importElement in unitLibraryElement.imports) {
          if (importElement.prefix == null) {
            Map<String, A_Element> namespace = getImportNamespace(importElement);
            finder._updateList(namespace.values);
          }
        }
      }
      if (finder.A__element != null) {
        String closestName = finder.A__element.name;
        _addReplaceEdit(rangeNode(node), closestName);
        if (closestName != null) {
          _addFix(FixKind.CHANGE_TO, [closestName]);
        }
      }
    }
  }
  void _addFix_undefinedFunction_create() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {} else {
      return;
    }
    String A_name = (node as SimpleIdentifier).name;
    MethodInvocation invocation = node.parent as MethodInvocation;
    Expression A_target = invocation.realTarget;
    if (A_target != null) {
      return;
    }
    int insertOffset;
    String sourcePrefix;
    AstNode enclosingMember = node.getAncestor((A_node) => A_node is CompilationUnitMember);
    insertOffset = enclosingMember.end;
    sourcePrefix = "${eol}${eol}";
    SourceBuilder sb = new SourceBuilder(file, insertOffset);
    {
      sb.append(sourcePrefix);
      {
        DartType A_type = _inferReturnType(invocation);
        _appendType(sb, A_type, 'RETURN_TYPE');
      }
      {
        sb.startPosition("NAME");
        sb.append(A_name);
        sb.endPosition();
      }
      _addFix_undefinedMethod_create_parameters(sb, invocation.argumentList);
      sb.append(") {${eol}}");
    }
    _insertBuilder(sb);
    _addLinkedPosition3('NAME', sb, rangeNode(node));
    _addFix(FixKind.CREATE_FUNCTION, [A_name]);
  }
  void _addFix_undefinedFunction_useSimilar() {
    if (node is SimpleIdentifier) {
      String A_name = (node as SimpleIdentifier).name;
      _ClosestElementFinder finder = new _ClosestElementFinder(A_name, (A_Element A_element) => A_element is FunctionElement, MAX_LEVENSHTEIN_DISTANCE);
      for (CompilationUnitElement A_unit in unitLibraryElement.units) {
        finder._updateList(A_unit.functions);
      }
      for (ImportElement importElement in unitLibraryElement.imports) {
        if (importElement.prefix == null) {
          Map<String, A_Element> namespace = getImportNamespace(importElement);
          finder._updateList(namespace.values);
        }
      }
      if (finder.A__element != null) {
        String closestName = finder.A__element.name;
        _addReplaceEdit(rangeNode(node), closestName);
        _addFix(FixKind.CHANGE_TO, [closestName]);
      }
    }
  }
  void _addFix_undefinedMethod_create() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {
      String A_name = (node as SimpleIdentifier).name;
      MethodInvocation invocation = node.parent as MethodInvocation;
      Source targetSource;
      String prefix;
      int insertOffset;
      String sourcePrefix;
      String sourceSuffix;
      bool staticModifier = false;
      Expression A_target = invocation.realTarget;
      if (A_target == null) {
        targetSource = source;
        ClassMember enclosingMember = node.getAncestor((A_node) => A_node is ClassMember);
        staticModifier = _inStaticContext();
        prefix = utils.getNodePrefix(enclosingMember);
        insertOffset = enclosingMember.end;
        sourcePrefix = "${eol}${eol}";
        sourceSuffix = "";
      } else {
        DartType targetType = A_target.bestType;
        if (targetType is! InterfaceType) {
          return;
        }
        ClassElement targetElement = targetType.element as ClassElement;
        targetSource = targetElement.source;
        if (A_target is Identifier) {
          staticModifier = A_target.bestElement.kind == A_ElementKind.C_CLASS;
        }
        ClassDeclaration targetClass = targetElement.node;
        prefix = "  ";
        insertOffset = targetClass.end - 1;
        if (targetClass.members.isEmpty) {
          sourcePrefix = "";
        } else {
          sourcePrefix = eol;
        }
        sourceSuffix = eol;
      }
      String targetFile = targetSource.fullName;
      SourceBuilder sb = new SourceBuilder(targetFile, insertOffset);
      {
        sb.append(sourcePrefix);
        sb.append(prefix);
        if (staticModifier) {
          sb.append("static ");
        }
        _appendType(sb, _inferReturnType(invocation), 'RETURN_TYPE');
        {
          sb.startPosition("NAME");
          sb.append(A_name);
          sb.endPosition();
        }
        _addFix_undefinedMethod_create_parameters(sb, invocation.argumentList);
        sb.append(") {${eol}${prefix}}");
        sb.append(sourceSuffix);
      }
      _insertBuilder(sb);
      if (targetSource == source) {
        _addLinkedPosition3('NAME', sb, rangeNode(node));
      }
      _addFix(FixKind.CREATE_METHOD, [A_name], fixFile: targetFile);
    }
  }
  void _addFix_undefinedMethod_create_parameters(SourceBuilder sb, ArgumentList argumentList) {
    sb.append("(");
    Set<String> excluded = new Set();
    List<Expression> A_arguments = argumentList.arguments;
    for (int i = 0; i < A_arguments.length; i++) {
      Expression argument = A_arguments[i];
      if (i != 0) {
        sb.append(", ");
      }
      DartType A_type = argument.bestType;
      String typeSource = utils.getTypeSource(A_type);
      {
        sb.startPosition("TYPE${i}");
        sb.append(typeSource);
        _addSuperTypeProposals(sb, new Set(), A_type);
        sb.endPosition();
      }
      sb.append(" ");
      {
        List<String> suggestions = _getArgumentNameSuggestions(excluded, A_type, argument, i);
        String favorite = suggestions[0];
        excluded.add(favorite);
        sb.startPosition("ARG${i}");
        sb.append(favorite);
        sb.addSuggestions(LinkedEditSuggestionKind.D_PARAMETER, suggestions);
        sb.endPosition();
      }
    }
  }
  void _addFix_undefinedMethod_useSimilar() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {
      MethodInvocation invocation = node.parent as MethodInvocation;
      String A_name = (node as SimpleIdentifier).name;
      _ClosestElementFinder finder = new _ClosestElementFinder(A_name, (A_Element A_element) => A_element is MethodElement && !A_element.isOperator, MAX_LEVENSHTEIN_DISTANCE);
      Expression A_target = invocation.realTarget;
      if (A_target == null) {
        ClassDeclaration clazz = invocation.getAncestor((A_node) => A_node is ClassDeclaration);
        if (clazz != null) {
          ClassElement classElement = clazz.element;
          _updateFinderWithClassMembers(finder, classElement);
        }
      } else {
        DartType A_type = A_target.bestType;
        if (A_type is InterfaceType) {
          ClassElement classElement = A_type.element;
          _updateFinderWithClassMembers(finder, classElement);
        }
      }
      if (finder.A__element != null) {
        String closestName = finder.A__element.name;
        _addReplaceEdit(rangeNode(node), closestName);
        _addFix(FixKind.CHANGE_TO, [closestName]);
      }
    }
  }
  void _addFix_useEffectiveIntegerDivision() {
    for (AstNode n = node; n != null; n = n.parent) {
      if (n is MethodInvocation && n.offset == errorOffset && n.length == errorLength) {
        MethodInvocation invocation = n as MethodInvocation;
        Expression A_target = invocation.target;
        while (A_target is ParenthesizedExpression) {
          A_target = (A_target as ParenthesizedExpression).expression;
        }
        BinaryExpression binary = A_target as BinaryExpression;
        _addReplaceEdit(rangeToken(binary.operator), "~/");
        _addRemoveEdit(rangeStartStart(invocation, binary.leftOperand));
        _addRemoveEdit(rangeEndEnd(binary.rightOperand, invocation));
        _addFix(FixKind.USE_EFFECTIVE_INTEGER_DIVISION, []);
        break;
      }
    }
  }
  void _addFix_useStaticAccess_method() {
    if (node is SimpleIdentifier && node.parent is MethodInvocation) {
      MethodInvocation invocation = node.parent as MethodInvocation;
      if (invocation.methodName == node) {
        Expression A_target = invocation.target;
        String targetType = utils.getExpressionTypeSource(A_target);
        SourceRange A_range = rangeNode(A_target);
        _addReplaceEdit(A_range, targetType);
        _addFix(FixKind.CHANGE_TO_STATIC_ACCESS, [targetType]);
      }
    }
  }
  void _addFix_useStaticAccess_property() {
    if (node is SimpleIdentifier) {
      if (node.parent is PrefixedIdentifier) {
        PrefixedIdentifier prefixed = node.parent as PrefixedIdentifier;
        if (prefixed.identifier == node) {
          Expression A_target = prefixed.prefix;
          String targetType = utils.getExpressionTypeSource(A_target);
          SourceRange A_range = rangeNode(A_target);
          _addReplaceEdit(A_range, targetType);
          _addFix(FixKind.CHANGE_TO_STATIC_ACCESS, [targetType]);
        }
      }
    }
  }
  void _addInsertEdit(int A_offset, String text) {
    Edit edit = new Edit(A_offset, 0, text);
    edits.add(edit);
  }
  void _addLinkedPosition(String groupId, SourceRange A_range) {
    Position A_position = new Position(file, A_range.offset);
    LinkedEditGroup A_group = _getLinkedPosition(groupId);
    A_group.addPosition(A_position, A_range.length);
  }
  void _addLinkedPosition3(String groupId, SourceBuilder sb, SourceRange A_range) {
    if (sb.offset < A_range.offset) {
      int delta = sb.length;
      A_range = A_range.getTranslated(delta);
    }
    _addLinkedPosition(groupId, A_range);
  }
  void _addProposal_createFunction(FunctionType A_functionType, String A_name, Source targetSource, int insertOffset, bool A_isStatic, String prefix, String sourcePrefix, String sourceSuffix) {
    String targetFile = targetSource.fullName;
    SourceBuilder sb = new SourceBuilder(targetFile, insertOffset);
    {
      sb.append(sourcePrefix);
      sb.append(prefix);
      if (A_isStatic) {
        sb.append("static ");
      }
      _appendType(sb, A_functionType.returnType, 'RETURN_TYPE');
      {
        sb.startPosition("NAME");
        sb.append(A_name);
        sb.endPosition();
      }
      sb.append("(");
      List<ParameterElement> A_parameters = A_functionType.parameters;
      for (int i = 0; i < A_parameters.length; i++) {
        ParameterElement parameter = A_parameters[i];
        if (i != 0) {
          sb.append(", ");
        }
        DartType A_type = parameter.type;
        if (!A_type.isDynamic) {
          String typeSource = utils.getTypeSource(A_type);
          {
            sb.startPosition("TYPE${i}");
            sb.append(typeSource);
            _addSuperTypeProposals(sb, new Set(), A_type);
            sb.endPosition();
          }
          sb.append(" ");
        }
        {
          sb.startPosition("ARG${i}");
          sb.append(parameter.displayName);
          sb.endPosition();
        }
      }
      sb.append(")");
      sb.append(" {${eol}${prefix}}");
      sb.append(sourceSuffix);
    }
    _insertBuilder(sb);
    if (targetSource == source) {
      _addLinkedPosition3("NAME", sb, rangeNode(node));
    }
  }
  void _addProposal_createFunction_function(FunctionType A_functionType) {
    String A_name = (node as SimpleIdentifier).name;
    int insertOffset = unit.end;
    String prefix = "";
    String sourcePrefix = "${eol}";
    String sourceSuffix = eol;
    _addProposal_createFunction(A_functionType, A_name, source, insertOffset, false, prefix, sourcePrefix, sourceSuffix);
    _addFix(FixKind.CREATE_FUNCTION, [A_name], fixFile: file);
  }
  void _addProposal_createFunction_method(ClassElement targetClassElement, FunctionType A_functionType) {
    String A_name = (node as SimpleIdentifier).name;
    Source targetSource = targetClassElement.source;
    String targetFile = targetSource.fullName;
    ClassDeclaration targetClassNode = targetClassElement.node;
    int insertOffset = targetClassNode.end - 1;
    String prefix = "  ";
    String sourcePrefix;
    if (targetClassNode.members.isEmpty) {
      sourcePrefix = "";
    } else {
      sourcePrefix = eol;
    }
    String sourceSuffix = eol;
    _addProposal_createFunction(A_functionType, A_name, targetSource, insertOffset, _inStaticContext(), prefix, sourcePrefix, sourceSuffix);
    _addFix(FixKind.CREATE_METHOD, [A_name], fixFile: targetFile);
  }
  void _addRemoveEdit(SourceRange A_range) {
    _addReplaceEdit(A_range, '');
  }
  void _addReplaceEdit(SourceRange A_range, String text) {
    Edit edit = new Edit(A_range.offset, A_range.length, text);
    edits.add(edit);
  }
  void _appendParameterSource(SourceBuilder sb, DartType A_type, String A_name) {
    String parameterSource = utils.getParameterSource(A_type, A_name);
    sb.append(parameterSource);
  }
  void _appendParameters(SourceBuilder sb, List<ParameterElement> A_parameters, Map<ParameterElement, String> defaultValueMap) {
    sb.append("(");
    bool firstParameter = true;
    bool sawNamed = false;
    bool sawPositional = false;
    for (ParameterElement parameter in A_parameters) {
      if (!firstParameter) {
        sb.append(", ");
      } else {
        firstParameter = false;
      }
      ParameterKind parameterKind = parameter.parameterKind;
      if (parameterKind == ParameterKind.NAMED) {
        if (!sawNamed) {
          sb.append("{");
          sawNamed = true;
        }
      }
      if (parameterKind == ParameterKind.POSITIONAL) {
        if (!sawPositional) {
          sb.append("[");
          sawPositional = true;
        }
      }
      _appendParameterSource(sb, parameter.type, parameter.name);
      if (defaultValueMap != null) {
        String defaultSource = defaultValueMap[parameter];
        if (defaultSource != null) {
          if (sawPositional) {
            sb.append(" = ");
          } else {
            sb.append(": ");
          }
          sb.append(defaultSource);
        }
      }
    }
    if (sawNamed) {
      sb.append("}");
    }
    if (sawPositional) {
      sb.append("]");
    }
    sb.append(")");
  }
  void _appendType(SourceBuilder sb, DartType A_type, [String groupId]) {
    if (A_type != null && !A_type.isDynamic) {
      String typeSource = utils.getTypeSource(A_type);
      if (groupId != null) {
        sb.startPosition(groupId);
        sb.append(typeSource);
        sb.endPosition();
      } else {
        sb.append(typeSource);
      }
      sb.append(' ');
    }
  }
  String _getConstructorProposalName(ConstructorElement constructor) {
    SourceBuilder proposalNameBuffer = new SourceBuilder.A_buffer();
    proposalNameBuffer.append("super");
    String constructorName = constructor.displayName;
    if (!constructorName.isEmpty) {
      proposalNameBuffer.append(".");
      proposalNameBuffer.append(constructorName);
    }
    _appendParameters(proposalNameBuffer, constructor.parameters, null);
    return proposalNameBuffer.toString();
  }
  DartType _getCoreType(String A_name) {
    List<LibraryElement> libraries = unitLibraryElement.importedLibraries;
    for (LibraryElement library in libraries) {
      if (library.isDartCore) {
        ClassElement classElement = library.getType(A_name);
        if (classElement != null) {
          return classElement.type;
        }
        return null;
      }
    }
    return null;
  }
  Map<ParameterElement, String> _getDefaultValueMap(List<ParameterElement> A_parameters) {
    Map<ParameterElement, String> defaultSourceMap = {};
    Map<Source, String> sourceContentMap = {};
    for (ParameterElement parameter in A_parameters) {
      SourceRange valueRange = parameter.defaultValueRange;
      if (valueRange != null) {
        Source A_source = parameter.source;
        String sourceContent = sourceContentMap[A_source];
        if (sourceContent == null) {
          sourceContent = getSourceContent(parameter.context, A_source);
          sourceContentMap[A_source] = sourceContent;
        }
        String valueSource = sourceContent.substring(valueRange.offset, valueRange.end);
        defaultSourceMap[parameter] = valueSource;
      }
    }
    return defaultSourceMap;
  }
  LinkedEditGroup _getLinkedPosition(String groupId) {
    LinkedEditGroup A_group = linkedPositionGroups[groupId];
    if (A_group == null) {
      A_group = new LinkedEditGroup(groupId);
      linkedPositionGroups[groupId] = A_group;
    }
    return A_group;
  }
  bool _inStaticContext() {
    if (node.getAncestor((A_node) => A_node is ConstructorInitializer) != null) {
      return true;
    }
    if (node.getAncestor((A_node) => A_node is FieldDeclaration) != null) {
      return true;
    }
    MethodDeclaration A_method = node.getAncestor((A_node) {
      return A_node is MethodDeclaration;
    });
    return A_method != null && A_method.isStatic;
  }
  DartType _inferReturnType(MethodInvocation invocation) {
    AstNode A_parent = invocation.parent;
    if (A_parent is ExpressionStatement) {
      return VoidTypeImpl.instance;
    }
    if (A_parent is ReturnStatement) {
      ExecutableElement A_executable = getEnclosingExecutableElement(invocation);
      return A_executable != null ? A_executable.returnType : null;
    }
    if (A_parent is VariableDeclaration) {
      VariableDeclaration variableDeclaration = A_parent;
      if (variableDeclaration.initializer == invocation) {
        VariableElement variableElement = variableDeclaration.element;
        if (variableElement != null) {
          return variableElement.type;
        }
      }
    }
    if (A_parent is AssignmentExpression) {
      AssignmentExpression assignment = A_parent;
      if (assignment.rightHandSide == invocation) {
        if (assignment.operator.type == A_TokenType.A_EQ) {
          Expression lhs = assignment.leftHandSide;
          if (lhs != null) {
            return lhs.bestType;
          }
        } else {
          MethodElement A_method = assignment.bestElement;
          if (A_method != null) {
            List<ParameterElement> A_parameters = A_method.parameters;
            if (A_parameters.length == 1) {
              return A_parameters[0].type;
            }
          }
        }
      }
    }
    if (A_parent is BinaryExpression) {
      BinaryExpression binary = A_parent;
      MethodElement A_method = binary.bestElement;
      if (A_method != null) {
        if (binary.rightOperand == invocation) {
          List<ParameterElement> A_parameters = A_method.parameters;
          return A_parameters.length == 1 ? A_parameters[0].type : null;
        }
      }
    }
    if (A_parent is ArgumentList) {
      ParameterElement parameter = invocation.bestParameterElement;
      return parameter != null ? parameter.type : null;
    }
    {
      if (A_parent is AssertStatement) {
        AssertStatement statement = A_parent;
        if (statement.condition == invocation) {
          return coreTypeBool;
        }
      }
      if (A_parent is IfStatement) {
        IfStatement statement = A_parent;
        if (statement.condition == invocation) {
          return coreTypeBool;
        }
      }
      if (A_parent is WhileStatement) {
        WhileStatement statement = A_parent;
        if (statement.condition == invocation) {
          return coreTypeBool;
        }
      }
      if (A_parent is DoStatement) {
        DoStatement statement = A_parent;
        if (statement.condition == invocation) {
          return coreTypeBool;
        }
      }
      if (A_parent is PrefixExpression) {
        PrefixExpression prefixExpression = A_parent;
        if (prefixExpression.operator.type == A_TokenType.BANG) {
          return coreTypeBool;
        }
      }
      if (A_parent is BinaryExpression) {
        BinaryExpression binaryExpression = A_parent;
        A_TokenType operatorType = binaryExpression.operator.type;
        if (operatorType == A_TokenType.AMPERSAND_AMPERSAND || operatorType == A_TokenType.BAR_BAR) {
          return coreTypeBool;
        }
      }
    }
    return null;
  }
  void _insertBuilder(SourceBuilder A_builder) {
    String text = A_builder.toString();
    _addInsertEdit(A_builder.offset, text);
    A_builder.linkedPositionGroups.forEach((LinkedEditGroup A_group) {
      LinkedEditGroup fixGroup = _getLinkedPosition(A_group.id);
      A_group.positions.forEach((Position A_position) {
        fixGroup.addPosition(A_position, A_group.length);
      });
      A_group.suggestions.forEach((LinkedEditSuggestion suggestion) {
        fixGroup.addSuggestion(suggestion);
      });
    });
  }
  _ConstructorLocation _prepareNewConstructorLocation(ClassDeclaration classDeclaration) {
    List<ClassMember> members = classDeclaration.members;
    ClassMember lastFieldOrConstructor = null;
    for (ClassMember member in members) {
      if (member is FieldDeclaration || member is ConstructorDeclaration) {
        lastFieldOrConstructor = member;
      } else {
        break;
      }
    }
    if (lastFieldOrConstructor != null) {
      return new _ConstructorLocation("${eol}${eol}", lastFieldOrConstructor.end, "");
    }
    String suffix = members.isEmpty ? "" : eol;
    return new _ConstructorLocation(eol, classDeclaration.leftBracket.end, suffix);
  }
  void _removeEnclosingParentheses(Expression expr, int exprPrecedence) {
    while (expr.parent is ParenthesizedExpression) {
      ParenthesizedExpression parenthesized = expr.parent as ParenthesizedExpression;
      if (getExpressionParentPrecedence(parenthesized) > exprPrecedence) {
        break;
      }
      _addRemoveEdit(rangeToken(parenthesized.leftParenthesis));
      _addRemoveEdit(rangeToken(parenthesized.rightParenthesis));
      expr = parenthesized;
    }
  }
  void _updateFinderWithClassMembers(_ClosestElementFinder finder, ClassElement clazz) {
    if (clazz != null) {
      List<A_Element> members = getMembers(clazz);
      finder._updateList(members);
    }
  }
  static void _addSuperTypeProposals(SourceBuilder sb, Set<DartType> alreadyAdded, DartType A_type) {
    if (A_type != null && !alreadyAdded.contains(A_type) && A_type.element is ClassElement) {
      alreadyAdded.add(A_type);
      ClassElement A_element = A_type.element as ClassElement;
      sb.addSuggestion(LinkedEditSuggestionKind.A_TYPE, A_element.name);
      _addSuperTypeProposals(sb, alreadyAdded, A_element.supertype);
      for (InterfaceType interfaceType in A_element.interfaces) {
        _addSuperTypeProposals(sb, alreadyAdded, interfaceType);
      }
    }
  }
  static String _findPackageUri(AnalysisContext context, String A_path) {
    Source fileSource = new NonExistingSource(A_path, UriKind.FILE_URI);
    Uri A_uri = context.sourceFactory.restoreUri(fileSource);
    if (A_uri == null) {
      return null;
    }
    return A_uri.toString();
  }
  static List<String> _getArgumentNameSuggestions(Set<String> excluded, DartType A_type, Expression expression, int A_index) {
    List<String> suggestions = getVariableNameSuggestionsForExpression(A_type, expression, excluded);
    if (suggestions.length != 0) {
      return suggestions;
    }
    return <String>["arg${A_index}"];
  }
  static bool _mayBeTypeIdentifier(AstNode A_node) {
    if (A_node is SimpleIdentifier) {
      AstNode A_parent = A_node.parent;
      if (A_parent is TypeName) {
        return true;
      }
      if (A_parent is MethodInvocation) {
        return A_parent.realTarget == A_node;
      }
      if (A_parent is PrefixedIdentifier) {
        return A_parent.prefix == A_node;
      }
    }
    return false;
  }
}
class _ClosestElementFinder {
  final String _targetName;
  final Predicate<A_Element> _predicate;
  A_Element A__element = null;
  int _distance;
  _ClosestElementFinder(this._targetName, this._predicate, this._distance);
  void _update(A_Element A_element) {
    if (_predicate(A_element)) {
      int memberDistance = levenshtein(A_element.name, _targetName, _distance);
      if (memberDistance < _distance) {
        A__element = A_element;
        _distance = memberDistance;
      }
    }
  }
  void _updateList(Iterable<A_Element> elements) {
    for (A_Element A_element in elements) {
      _update(A_element);
    }
  }
}
class _ConstructorLocation {
  final String _prefix;
  final int A__offset;
  final String _suffix;
  _ConstructorLocation(this._prefix, this.A__offset, this._suffix);
}
const int LEVENSHTEIN_MAX = 1 << 20;
const int _MAX_VALUE = 1 << 10;
int levenshtein(String s, String t, int threshold, {bool caseSensitive: true}) {
  if (s == null || t == null) {
    throw new ArgumentError('Strings must not be null');
  }
  if (threshold < 0) {
    throw new ArgumentError('Threshold must not be negative');
  }
  if (!caseSensitive) {
    s = s.toLowerCase();
    t = t.toLowerCase();
  }
  int s_len = s.length;
  int t_len = t.length;
  if (s_len == 0) {
    return t_len <= threshold ? t_len : LEVENSHTEIN_MAX;
  }
  if (t_len == 0) {
    return s_len <= threshold ? s_len : LEVENSHTEIN_MAX;
  }
  if ((s_len - t_len).abs() > threshold) {
    return LEVENSHTEIN_MAX;
  }
  if (s_len > t_len) {
    String tmp = s;
    s = t;
    t = tmp;
    s_len = t_len;
    t_len = t.length;
  }
  List<int> F_p = new List<int>.filled(s_len + 1, 0);
  List<int> d = new List<int>.filled(s_len + 1, 0);
  List<int> _d;
  int boundary = D_p.min(s_len, threshold) + 1;
  for (int i = 0; i < boundary; i++) {
    F_p[i] = i;
  }
  _setRange(F_p, boundary, F_p.length, _MAX_VALUE);
  _setRange(d, 0, d.length, _MAX_VALUE);
  for (int j = 1; j <= t_len; j++) {
    int t_j = t.codeUnitAt(j - 1);
    d[0] = j;
    int B_min = D_p.max(1, j - threshold);
    int B_max = D_p.min(s_len, j + threshold);
    if (B_min > B_max) {
      return LEVENSHTEIN_MAX;
    }
    if (B_min > 1) {
      d[B_min - 1] = _MAX_VALUE;
    }
    for (int i = B_min; i <= B_max; i++) {
      if (s.codeUnitAt(i - 1) == t_j) {
        d[i] = F_p[i - 1];
      } else {
        d[i] = 1 + D_p.min(D_p.min(d[i - 1], F_p[i]), F_p[i - 1]);
      }
    }
    _d = F_p;
    F_p = d;
    d = _d;
  }
  if (F_p[s_len] <= threshold) {
    return F_p[s_len];
  }
  return LEVENSHTEIN_MAX;
}
void _setRange(List<int> a, int A_start, int A_end, int A_value) {
  for (int i = A_start; i < A_end; i++) {
    a[i] = A_value;
  }
}
List<String> _KNOWN_METHOD_NAME_PREFIXES = ['get', 'is', 'to'];
List<String> getCamelWords(String str) {
  if (str == null || str.isEmpty) {
    return <String>[];
  }
  List<String> parts = <String>[];
  bool wasLowerCase = false;
  bool wasUpperCase = false;
  int wordStart = 0;
  for (int i = 0; i < str.length; i++) {
    int c = str.codeUnitAt(i);
    var newLowerCase = isLowerCase(c);
    var newUpperCase = isUpperCase(c);
    if (wasLowerCase && newUpperCase) {
      parts.add(str.substring(wordStart, i));
      wordStart = i;
    }
    if (wasUpperCase && newUpperCase && i + 1 < str.length && isLowerCase(str.codeUnitAt(i + 1))) {
      parts.add(str.substring(wordStart, i));
      wordStart = i;
    }
    wasLowerCase = newLowerCase;
    wasUpperCase = newUpperCase;
  }
  parts.add(str.substring(wordStart));
  return parts;
}
List<String> getVariableNameSuggestionsForExpression(DartType expectedType, Expression assignedExpression, Set<String> excluded) {
  Set<String> res = new Set();
  if (assignedExpression != null) {
    String nameFromExpression = _getBaseNameFromExpression(assignedExpression);
    if (nameFromExpression != null) {
      nameFromExpression = removeStart(nameFromExpression, '_');
      A__addAll(excluded, res, _getCamelWordCombinations(nameFromExpression));
    }
    String nameFromParent = _getBaseNameFromLocationInParent(assignedExpression);
    if (nameFromParent != null) {
      A__addAll(excluded, res, _getCamelWordCombinations(nameFromParent));
    }
  }
  if (expectedType != null && !expectedType.isDynamic) {
    String typeName = expectedType.name;
    if ('int' == typeName) {
      _addSingleCharacterName(excluded, res, 0x69);
    } else if ('double' == typeName) {
      _addSingleCharacterName(excluded, res, 0x64);
    } else if ('String' == typeName) {
      _addSingleCharacterName(excluded, res, 0x73);
    } else {
      A__addAll(excluded, res, _getCamelWordCombinations(typeName));
    }
    res.remove(typeName);
  }
  return new List.from(res);
}
void A__addAll(Set<String> excluded, Set<String> result, Iterable<String> toAdd) {
  for (String item in toAdd) {
    for (int suffix = 1;; suffix++) {
      String A_name = item;
      if (suffix > 1) {
        A_name += suffix.toString();
      }
      if (!excluded.contains(A_name)) {
        result.add(A_name);
        break;
      }
    }
  }
}
void _addSingleCharacterName(Set<String> excluded, Set<String> result, int c) {
  while (c < 0x7A) {
    String A_name = new String.fromCharCode(c);
    if (!excluded.contains(A_name)) {
      result.add(A_name);
      break;
    }
    c = c + 1;
  }
}
String _getBaseNameFromExpression(Expression expression) {
  String A_name = null;
  if (expression is AsExpression) {
    AsExpression asExpression = expression as AsExpression;
    expression = asExpression.expression;
  }
  if (expression is SimpleIdentifier) {
    SimpleIdentifier node = expression;
    return node.name;
  } else if (expression is PrefixedIdentifier) {
    PrefixedIdentifier node = expression;
    return node.identifier.name;
  } else if (expression is MethodInvocation) {
    A_name = expression.methodName.name;
  } else if (expression is InstanceCreationExpression) {
    InstanceCreationExpression creation = expression;
    ConstructorName constructorName = creation.constructorName;
    TypeName typeName = constructorName.type;
    if (typeName != null) {
      Identifier typeNameIdentifier = typeName.name;
      if (typeNameIdentifier is SimpleIdentifier) {
        return typeNameIdentifier.name;
      }
      if (typeNameIdentifier is PrefixedIdentifier) {
        PrefixedIdentifier prefixed = typeNameIdentifier;
        if (prefixed.prefix.staticElement is PrefixElement) {
          return prefixed.identifier.name;
        }
        return prefixed.prefix.name;
      }
    }
  }
  if (A_name != null) {
    for (int i = 0; i < _KNOWN_METHOD_NAME_PREFIXES.length; i++) {
      String curr = _KNOWN_METHOD_NAME_PREFIXES[i];
      if (A_name.startsWith(curr)) {
        if (A_name == curr) {
          return null;
        } else if (isUpperCase(A_name.codeUnitAt(curr.length))) {
          return A_name.substring(curr.length);
        }
      }
    }
  }
  return A_name;
}
String _getBaseNameFromLocationInParent(Expression expression) {
  if (expression.parent is NamedExpression) {
    NamedExpression namedExpression = expression.parent as NamedExpression;
    if (namedExpression.expression == expression) {
      return namedExpression.name.label.name;
    }
  }
  {
    ParameterElement parameter = expression.propagatedParameterElement;
    if (parameter == null) {
      parameter = expression.staticParameterElement;
    }
    if (parameter != null) {
      return parameter.displayName;
    }
  }
  return null;
}
List<String> _getCamelWordCombinations(String A_name) {
  List<String> result = [];
  List<String> parts = getCamelWords(A_name);
  for (int i = 0; i < parts.length; i++) {
    var s1 = parts[i].toLowerCase();
    var s2 = parts.skip(i + 1).join();
    String suggestion = '${s1}${s2}';
    result.add(suggestion);
  }
  return result;
}
class SourceBuilder {
  final String file;
  final int offset;
  final StringBuffer A__buffer = new StringBuffer();
  final List<LinkedEditGroup> linkedPositionGroups = <LinkedEditGroup>[];
  LinkedEditGroup _currentLinkedPositionGroup;
  int _currentPositionStart;
  int _exitOffset;
  SourceBuilder(this.file, this.offset);
  SourceBuilder.A_buffer() : file = null, offset = 0;
  int get length => A__buffer.length;
  void addSuggestion(LinkedEditSuggestionKind kind, String A_value) {
    var suggestion = new LinkedEditSuggestion(kind, A_value);
    _currentLinkedPositionGroup.addSuggestion(suggestion);
  }
  void addSuggestions(LinkedEditSuggestionKind kind, List<String> C_values) {
    C_values.forEach((A_value) => addSuggestion(kind, A_value));
  }
  SourceBuilder append(String s) {
    A__buffer.write(s);
    return this;
  }
  void endPosition() {
    assert(_currentLinkedPositionGroup != null);
    _addPosition();
    _currentLinkedPositionGroup = null;
  }
  void startPosition(String groupId) {
    assert(_currentLinkedPositionGroup == null);
    for (LinkedEditGroup A_position in linkedPositionGroups) {
      if (A_position.id == groupId) {
        _currentLinkedPositionGroup = A_position;
        break;
      }
    }
    if (_currentLinkedPositionGroup == null) {
      _currentLinkedPositionGroup = new LinkedEditGroup(groupId);
      linkedPositionGroups.add(_currentLinkedPositionGroup);
    }
    _currentPositionStart = A__buffer.length;
  }
  String toString() => A__buffer.toString();
  void _addPosition() {
    int A_start = offset + _currentPositionStart;
    int A_end = offset + A__buffer.length;
    int A_length = A_end - A_start;
    Position A_position = new Position(file, A_start);
    _currentLinkedPositionGroup.addPosition(A_position, A_length);
  }
}
SourceRange rangeEndEnd(a, b) {
  int A_offset = a.end;
  var A_length = b.end - A_offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeEndStart(a, b) {
  int A_offset = a.end;
  var A_length = (b is int ? b : b.offset) - A_offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeError(A_AnalysisError A_error) {
  return new SourceRange(A_error.offset, A_error.length);
}
SourceRange rangeNode(AstNode node) {
  return new SourceRange(node.offset, node.length);
}
SourceRange rangeOffsetEnd(o) {
  int A_offset = o.offset;
  int A_length = o.end - A_offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeStartEnd(a, b) {
  int A_offset = a is int ? a : a.offset;
  int A_end = b is int ? b : b.end;
  var A_length = A_end - A_offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeStartLength(a, int A_length) {
  int A_offset = a is int ? a : a.offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeStartStart(a, b) {
  int A_offset = a is int ? a : a.offset;
  var A_length = (b is int ? b : b.offset) - A_offset;
  return new SourceRange(A_offset, A_length);
}
SourceRange rangeToken(A_Token token) {
  return new SourceRange(token.offset, token.length);
}
bool A_isEmpty(String str) {
  return str == null || str.isEmpty;
}
bool isLowerCase(int c) {
  return c >= 0x61 && c <= 0x7A;
}
bool isSpace(int c) => c == 0x20 || c == 0x09;
bool isUpperCase(int c) {
  return c >= 0x41 && c <= 0x5A;
}
bool isWhitespace(int c) {
  return isSpace(c) || c == 0x0D || c == 0x0A;
}
String removeStart(String str, String A_remove) {
  if (A_isEmpty(str) || A_isEmpty(A_remove)) {
    return str;
  }
  if (str.startsWith(A_remove)) {
    return str.substring(A_remove.length);
  }
  return str;
}
int compareStrings(String a, String b) {
  if (a == b) {
    return 0;
  }
  if (a == null) {
    return 1;
  }
  if (b == null) {
    return -1;
  }
  return a.compareTo(b);
}
String repeat(String s, int n) {
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i < n; i++) {
    sb.write(s);
  }
  return sb.toString();
}
String getDefaultValueCode(DartType A_type) {
  if (A_type != null) {
    String typeName = A_type.displayName;
    if (typeName == "bool") {
      return "false";
    }
    if (typeName == "int") {
      return "0";
    }
    if (typeName == "double") {
      return "0.0";
    }
    if (typeName == "String") {
      return "''";
    }
  }
  return "null";
}
ExecutableElement getEnclosingExecutableElement(AstNode node) {
  while (node != null) {
    if (node is FunctionDeclaration) {
      return node.element;
    }
    if (node is ConstructorDeclaration) {
      return node.element;
    }
    if (node is MethodDeclaration) {
      return node.element;
    }
    node = node.parent;
  }
  return null;
}
Map<String, A_Element> getExportNamespaceForLibrary(LibraryElement library) {
  Namespace namespace = new NamespaceBuilder().createExportNamespaceForLibrary(library);
  return namespace.definedNames;
}
A_Element getExportedElement(LibraryElement library, String A_name) {
  if (library == null) {
    return null;
  }
  return getExportNamespaceForLibrary(library)[A_name];
}
int getExpressionParentPrecedence(AstNode node) {
  AstNode A_parent = node.parent;
  if (A_parent is ParenthesizedExpression) {
    return 0;
  }
  return getExpressionPrecedence(A_parent);
}
int getExpressionPrecedence(AstNode node) {
  if (node is Expression) {
    return node.precedence;
  }
  return -1000;
}
Map<String, A_Element> getImportNamespace(ImportElement imp) {
  NamespaceBuilder A_builder = new NamespaceBuilder();
  Namespace namespace = A_builder.createImportNamespaceForDirective(imp);
  return namespace.definedNames;
}
Expression getQualifiedPropertyTarget(AstNode node) {
  AstNode A_parent = node.parent;
  if (A_parent is PrefixedIdentifier) {
    PrefixedIdentifier prefixed = A_parent;
    if (prefixed.identifier == node) {
      return A_parent.prefix;
    }
  }
  if (A_parent is PropertyAccess) {
    PropertyAccess access = A_parent;
    if (access.propertyName == node) {
      return access.realTarget;
    }
  }
  return null;
}
String getSourceContent(AnalysisContext context, Source A_source) {
  return context.getContents(A_source).data;
}
class CorrectionUtils {
  final CompilationUnit unit;
  LibraryElement _library;
  String B__buffer;
  String _endOfLine;
  CorrectionUtils(this.unit) {
    CompilationUnitElement unitElement = unit.element;
    this._library = unitElement.library;
    this.B__buffer = unitElement.context.getContents(unitElement.source).data;
  }
  String get endOfLine {
    if (_endOfLine == null) {
      if (B__buffer.contains("\r\n")) {
        _endOfLine = "\r\n";
      } else {
        _endOfLine = "\n";
      }
    }
    return _endOfLine;
  }
  String getExpressionTypeSource(Expression expression) {
    if (expression == null) {
      return null;
    }
    DartType A_type = expression.bestType;
    if (A_type.isDynamic) {
      return null;
    }
    return getTypeSource(A_type);
  }
  String getIndent(int A_level) => repeat('  ', A_level);
  CorrectionUtils_InsertDesc getInsertDescTop() {
    int A_offset = 0;
    bool insertEmptyLineBefore = false;
    bool insertEmptyLineAfter = false;
    String A_source = B__buffer;
    if (A_offset < A_source.length - 2) {
      String linePrefix = getText(A_offset, 2);
      if (linePrefix == "#!") {
        insertEmptyLineBefore = true;
        A_offset = getLineNext(A_offset);
        int emptyOffset = A_offset;
        while (emptyOffset < A_source.length - 2) {
          int nextLineOffset = getLineNext(emptyOffset);
          String line = A_source.substring(emptyOffset, nextLineOffset);
          if (line.trim().isEmpty) {
            emptyOffset = nextLineOffset;
            continue;
          } else if (line.startsWith("//")) {
            A_offset = emptyOffset;
            break;
          } else {
            break;
          }
        }
      }
    }
    while (A_offset < A_source.length - 2) {
      String linePrefix = getText(A_offset, 2);
      if (linePrefix == "//") {
        insertEmptyLineBefore = true;
        A_offset = getLineNext(A_offset);
      } else {
        break;
      }
    }
    int nextLineOffset = getLineNext(A_offset);
    String insertLine = A_source.substring(A_offset, nextLineOffset);
    if (!insertLine.trim().isEmpty) {
      insertEmptyLineAfter = true;
    }
    CorrectionUtils_InsertDesc desc = new CorrectionUtils_InsertDesc();
    desc.offset = A_offset;
    if (insertEmptyLineBefore) {
      desc.prefix = endOfLine;
    }
    if (insertEmptyLineAfter) {
      desc.suffix = endOfLine;
    }
    return desc;
  }
  int getLineContentEnd(int A_index) {
    int A_length = B__buffer.length;
    while (A_index < A_length) {
      int c = B__buffer.codeUnitAt(A_index);
      if (!isWhitespace(c) || c == 0x0D || c == 0x0A) {
        break;
      }
      A_index++;
    }
    if (A_index < A_length && B__buffer.codeUnitAt(A_index) == 0x0D) {
      A_index++;
    }
    if (A_index < A_length && B__buffer.codeUnitAt(A_index) == 0x0A) {
      A_index++;
    }
    return A_index;
  }
  int getLineContentStart(int A_index) {
    while (A_index > 0) {
      int c = B__buffer.codeUnitAt(A_index - 1);
      if (!isSpace(c)) {
        break;
      }
      A_index--;
    }
    return A_index;
  }
  int getLineNext(int A_index) {
    int A_length = B__buffer.length;
    while (A_index < A_length) {
      int c = B__buffer.codeUnitAt(A_index);
      if (c == 0xD || c == 0xA) {
        break;
      }
      A_index++;
    }
    if (A_index < A_length && B__buffer.codeUnitAt(A_index) == 0xD) {
      A_index++;
    }
    if (A_index < A_length && B__buffer.codeUnitAt(A_index) == 0xA) {
      A_index++;
    }
    return A_index;
  }
  String getLinePrefix(int A_index) {
    int lineStart = getLineThis(A_index);
    int A_length = B__buffer.length;
    int lineNonWhitespace = lineStart;
    while (lineNonWhitespace < A_length) {
      int c = B__buffer.codeUnitAt(lineNonWhitespace);
      if (c == 0xD || c == 0xA) {
        break;
      }
      if (!isWhitespace(c)) {
        break;
      }
      lineNonWhitespace++;
    }
    return getText(lineStart, lineNonWhitespace - lineStart);
  }
  int getLineThis(int A_index) {
    while (A_index > 0) {
      int c = B__buffer.codeUnitAt(A_index - 1);
      if (c == 0xD || c == 0xA) {
        break;
      }
      A_index--;
    }
    return A_index;
  }
  SourceRange getLinesRange(SourceRange A_range) {
    int startOffset = A_range.offset;
    int startLineOffset = getLineContentStart(startOffset);
    int endOffset = A_range.end;
    int afterEndLineOffset = getLineContentEnd(endOffset);
    return rangeStartEnd(startLineOffset, afterEndLineOffset);
  }
  String getNodePrefix(AstNode node) {
    int A_offset = node.offset;
    if (node is FunctionExpression) {
      return getLinePrefix(A_offset);
    }
    return getPrefix(A_offset);
  }
  String getParameterSource(DartType A_type, String A_name) {
    if (A_type == null || A_type.isDynamic) {
      return A_name;
    }
    if (A_type is FunctionType) {
      FunctionType A_functionType = A_type;
      StringBuffer sb = new StringBuffer();
      DartType A_returnType = A_functionType.returnType;
      if (A_returnType != null && !A_returnType.isDynamic) {
        sb.write(getTypeSource(A_returnType));
        sb.write(' ');
      }
      sb.write(A_name);
      sb.write('(');
      List<ParameterElement> fParameters = A_functionType.parameters;
      for (int i = 0; i < fParameters.length; i++) {
        ParameterElement fParameter = fParameters[i];
        if (i != 0) {
          sb.write(", ");
        }
        sb.write(getParameterSource(fParameter.type, fParameter.name));
      }
      sb.write(')');
      return sb.toString();
    }
    return "${getTypeSource(A_type)} ${A_name}";
  }
  String getPrefix(int endIndex) {
    int startIndex = getLineContentStart(endIndex);
    return B__buffer.substring(startIndex, endIndex);
  }
  String getText(int A_offset, int A_length) {
    return B__buffer.substring(A_offset, A_offset + A_length);
  }
  String getTypeSource(DartType A_type) {
    StringBuffer sb = new StringBuffer();
    if (A_type is FunctionType) {
      return "Function";
    }
    A_Element A_element = A_type.element;
    if (A_element == null) {
      String A_source = A_type.toString();
      A_source = A_source.replaceAll('<dynamic>', '');
      A_source = A_source.replaceAll('<dynamic, dynamic>', '');
      return A_source;
    }
    {
      ImportElement imp = _getImportElement(A_element);
      if (imp != null && imp.prefix != null) {
        sb.write(imp.prefix.displayName);
        sb.write(".");
      }
    }
    String A_name = A_element.displayName;
    sb.write(A_name);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      List<DartType> A_arguments = interfaceType.typeArguments;
      bool hasArguments = false;
      for (DartType argument in A_arguments) {
        if (!argument.isDynamic) {
          hasArguments = true;
          break;
        }
      }
      if (hasArguments) {
        sb.write("<");
        for (int i = 0; i < A_arguments.length; i++) {
          DartType argument = A_arguments[i];
          if (i != 0) {
            sb.write(", ");
          }
          sb.write(getTypeSource(argument));
        }
        sb.write(">");
      }
    }
    return sb.toString();
  }
  ImportElement _getImportElement(A_Element A_element) {
    for (ImportElement imp in _library.imports) {
      Map<String, A_Element> definedNames = getImportNamespace(imp);
      if (definedNames.containsValue(A_element)) {
        return imp;
      }
    }
    return null;
  }
}
class CorrectionUtils_InsertDesc {
  int offset = 0;
  String prefix = "";
  String suffix = "";
}
void indexDartUnit(IndexStore store, AnalysisContext context, CompilationUnit unit) {
  if (unit == null) {
    return;
  }
  CompilationUnitElement unitElement = unit.element;
  if (unitElement == null) {
    return;
  }
  bool mayIndex = store.aboutToIndexDart(context, unitElement);
  if (!mayIndex) {
    return;
  }
  unit.accept(new _IndexContributor(store));
  unit.accept(new _AngularDartIndexContributor(store));
  store.doneIndex();
}
void indexHtmlUnit(IndexStore store, AnalysisContext context, HtmlUnit unit) {
  if (unit == null) {
    return;
  }
  HtmlElement unitElement = unit.element;
  if (unitElement == null) {
    return;
  }
  bool mayIndex = store.aboutToIndexHtml(context, unitElement);
  if (!mayIndex) {
    return;
  }
  unit.accept(new _AngularHtmlIndexContributor(store));
  store.doneIndex();
}
class _AngularDartIndexContributor extends GeneralizingAstVisitor<Object> {
  final IndexStore _store;
  _AngularDartIndexContributor(this._store);
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement classElement = node.element;
    if (classElement != null) {
      List<ToolkitObjectElement> toolkitObjects = classElement.toolkitObjects;
      for (ToolkitObjectElement object in toolkitObjects) {
        if (object is AngularComponentElement) {
          _indexComponent(object);
        }
        if (object is AngularDecoratorElement) {
          AngularDecoratorElement directive = object;
          _indexDirective(directive);
        }
      }
    }
    return null;
  }
  Object visitCompilationUnitMember(CompilationUnitMember node) => null;
  void _indexComponent(AngularComponentElement component) {
    _indexProperties(component.properties);
  }
  void _indexDirective(AngularDecoratorElement directive) {
    _indexProperties(directive.properties);
  }
  void _indexProperties(List<AngularPropertyElement> properties) {
    for (AngularPropertyElement property in properties) {
      FieldElement field = property.field;
      if (field != null) {
        int A_offset = property.fieldNameOffset;
        if (A_offset == -1) {
          continue;
        }
        int A_length = field.name.length;
        A_Location A_location = new A_Location(property, A_offset, A_length);
        if (property.propertyKind.callsGetter()) {
          PropertyAccessorElement getter = field.getter;
          if (getter != null) {
            _store.recordRelationship(getter, IndexConstants.IS_REFERENCED_BY, A_location);
          }
        }
        if (property.propertyKind.callsSetter()) {
          PropertyAccessorElement setter = field.setter;
          if (setter != null) {
            _store.recordRelationship(setter, IndexConstants.IS_REFERENCED_BY, A_location);
          }
        }
      }
    }
  }
}
class _AngularHtmlIndexContributor extends _ExpressionVisitor {
  final IndexStore _store;
  _IndexContributor _indexContributor;
  HtmlElement _htmlUnitElement;
  _AngularHtmlIndexContributor(this._store) {
    _indexContributor = new _AngularHtmlIndexContributor_forEmbeddedDart(_store, this);
  }
  void visitExpression(Expression expression) {
    if (expression is SimpleIdentifier) {
      A_Element A_element = expression.bestElement;
      if (A_element is AngularElement) {
        _store.recordRelationship(A_element, IndexConstants.ANGULAR_REFERENCE, _createLocationForIdentifier(expression));
        return;
      }
    }
    expression.accept(_indexContributor);
  }
  Object visitHtmlUnit(HtmlUnit node) {
    _htmlUnitElement = node.element;
    CompilationUnitElement dartUnitElement = _htmlUnitElement.angularCompilationUnit;
    _indexContributor.enterScope(dartUnitElement);
    return super.visitHtmlUnit(node);
  }
  Object visitXmlAttributeNode(XmlAttributeNode node) {
    A_Element A_element = node.element;
    if (A_element != null) {
      Token nameToken = node.nameToken;
      A_Location A_location = _createLocationForToken(nameToken);
      _store.recordRelationship(A_element, IndexConstants.ANGULAR_REFERENCE, A_location);
    }
    return super.visitXmlAttributeNode(node);
  }
  Object visitXmlTagNode(XmlTagNode node) {
    A_Element A_element = node.element;
    if (A_element != null) {
      {
        Token tagToken = node.tagToken;
        A_Location A_location = _createLocationForToken(tagToken);
        _store.recordRelationship(A_element, IndexConstants.ANGULAR_REFERENCE, A_location);
      }
      Token closingTag = node.closingTag;
      if (closingTag != null) {
        A_Location A_location = _createLocationForToken(closingTag);
        _store.recordRelationship(A_element, IndexConstants.ANGULAR_CLOSING_TAG_REFERENCE, A_location);
      }
    }
    return super.visitXmlTagNode(node);
  }
  A_Location _createLocationForIdentifier(SimpleIdentifier identifier) => new A_Location(_htmlUnitElement, identifier.offset, identifier.length);
  A_Location _createLocationForToken(Token token) => new A_Location(_htmlUnitElement, token.offset, token.length);
}
class _AngularHtmlIndexContributor_forEmbeddedDart extends _IndexContributor {
  final _AngularHtmlIndexContributor angularContributor;
  _AngularHtmlIndexContributor_forEmbeddedDart(IndexStore store, this.angularContributor) : super(store);
  A_Element peekElement() => angularContributor._htmlUnitElement;
  void recordRelationship(A_Element A_element, Relationship relationship, A_Location A_location) {
    AngularElement angularElement = AngularHtmlUnitResolver.getAngularElement(A_element);
    if (angularElement != null) {
      A_element = angularElement;
      relationship = IndexConstants.ANGULAR_REFERENCE;
    }
    super.recordRelationship(A_element, relationship, A_location);
  }
}
abstract class _ExpressionVisitor extends RecursiveXmlVisitor<Object> {
  void visitExpression(Expression expression);
  Object visitXmlAttributeNode(XmlAttributeNode node) {
    _visitExpressions(node.expressions);
    return super.visitXmlAttributeNode(node);
  }
  Object visitXmlTagNode(XmlTagNode node) {
    _visitExpressions(node.expressions);
    return super.visitXmlTagNode(node);
  }
  void _visitExpressions(List<XmlExpression> expressions) {
    for (XmlExpression xmlExpression in expressions) {
      if (xmlExpression is AngularXmlExpression) {
        AngularXmlExpression angularXmlExpression = xmlExpression;
        List<Expression> dartExpressions = angularXmlExpression.expression.expressions;
        for (Expression dartExpression in dartExpressions) {
          visitExpression(dartExpression);
        }
      }
      if (xmlExpression is RawXmlExpression) {
        RawXmlExpression rawXmlExpression = xmlExpression;
        visitExpression(rawXmlExpression.expression);
      }
    }
  }
}
class _ImportElementInfo {
  ImportElement B__element;
  int _periodEnd = 0;
}
class _IndexContributor extends GeneralizingAstVisitor<Object> {
  final IndexStore _store;
  LibraryElement _libraryElement;
  Map<ImportElement, Set<A_Element>> _importElementsMap = {};
  A_p.Queue<A_Element> _elementStack = new A_p.Queue();
  _IndexContributor(this._store);
  void enterScope(A_Element A_element) {
    _elementStack.addFirst(A_element);
  }
  A_Element peekElement() {
    for (A_Element A_element in _elementStack) {
      if (A_element != null) {
        return A_element;
      }
    }
    return null;
  }
  void recordRelationship(A_Element A_element, Relationship relationship, A_Location A_location) {
    if (A_element != null && A_location != null) {
      _store.recordRelationship(A_element, relationship, A_location);
    }
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    _recordOperatorReference(node.operator, node.bestElement);
    return super.visitAssignmentExpression(node);
  }
  Object visitBinaryExpression(BinaryExpression node) {
    _recordOperatorReference(node.operator, node.bestElement);
    return super.visitBinaryExpression(node);
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement A_element = node.element;
    enterScope(A_element);
    try {
      _recordElementDefinition(A_element);
      {
        ExtendsClause extendsClause = node.extendsClause;
        if (extendsClause != null) {
          TypeName superclassNode = extendsClause.superclass;
          _recordSuperType(superclassNode, IndexConstants.IS_EXTENDED_BY);
        } else {
          InterfaceType superType = A_element.supertype;
          if (superType != null) {
            ClassElement objectElement = superType.element;
            recordRelationship(objectElement, IndexConstants.IS_EXTENDED_BY, _createLocationForOffset(node.name.offset, 0));
          }
        }
      }
      {
        WithClause withClause = node.withClause;
        if (withClause != null) {
          for (TypeName mixinNode in withClause.mixinTypes) {
            _recordSuperType(mixinNode, IndexConstants.IS_MIXED_IN_BY);
          }
        }
      }
      {
        ImplementsClause implementsClause = node.implementsClause;
        if (implementsClause != null) {
          for (TypeName interfaceNode in implementsClause.interfaces) {
            _recordSuperType(interfaceNode, IndexConstants.IS_IMPLEMENTED_BY);
          }
        }
      }
      return super.visitClassDeclaration(node);
    } finally {
      _exitScope();
    }
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    ClassElement A_element = node.element;
    enterScope(A_element);
    try {
      _recordElementDefinition(A_element);
      {
        TypeName superclassNode = node.superclass;
        if (superclassNode != null) {
          _recordSuperType(superclassNode, IndexConstants.IS_EXTENDED_BY);
        }
      }
      {
        WithClause withClause = node.withClause;
        if (withClause != null) {
          for (TypeName mixinNode in withClause.mixinTypes) {
            _recordSuperType(mixinNode, IndexConstants.IS_MIXED_IN_BY);
          }
        }
      }
      {
        ImplementsClause implementsClause = node.implementsClause;
        if (implementsClause != null) {
          for (TypeName interfaceNode in implementsClause.interfaces) {
            _recordSuperType(interfaceNode, IndexConstants.IS_IMPLEMENTED_BY);
          }
        }
      }
      return super.visitClassTypeAlias(node);
    } finally {
      _exitScope();
    }
  }
  Object visitCompilationUnit(CompilationUnit node) {
    CompilationUnitElement unitElement = node.element;
    if (unitElement != null) {
      _elementStack.add(unitElement);
      _libraryElement = unitElement.enclosingElement;
      if (_libraryElement != null) {
        return super.visitCompilationUnit(node);
      }
    }
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    ConstructorElement A_element = node.element;
    {
      A_Location A_location;
      if (node.name != null) {
        int A_start = node.period.offset;
        int A_end = node.name.end;
        A_location = _createLocationForOffset(A_start, A_end - A_start);
      } else {
        int A_start = node.returnType.end;
        A_location = _createLocationForOffset(A_start, 0);
      }
      recordRelationship(A_element, IndexConstants.NAME_IS_DEFINED_BY, A_location);
    }
    enterScope(A_element);
    try {
      return super.visitConstructorDeclaration(node);
    } finally {
      _exitScope();
    }
  }
  Object visitConstructorName(ConstructorName node) {
    ConstructorElement A_element = node.staticElement;
    if (A_element != null && A_element.isSynthetic && A_element.redirectedConstructor != null) {
      A_element = A_element.redirectedConstructor;
    }
    A_Location A_location;
    if (node.name != null) {
      int A_start = node.period.offset;
      int A_end = node.name.end;
      A_location = _createLocationForOffset(A_start, A_end - A_start);
    } else {
      int A_start = node.type.end;
      A_location = _createLocationForOffset(A_start, 0);
    }
    recordRelationship(A_element, IndexConstants.IS_REFERENCED_BY, A_location);
    return super.visitConstructorName(node);
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    LocalVariableElement A_element = node.element;
    enterScope(A_element);
    try {
      return super.visitDeclaredIdentifier(node);
    } finally {
      _exitScope();
    }
  }
  Object visitExportDirective(ExportDirective node) {
    ExportElement A_element = node.element;
    if (A_element != null) {
      LibraryElement expLibrary = A_element.exportedLibrary;
      _recordLibraryReference(node, expLibrary);
    }
    return super.visitExportDirective(node);
  }
  Object visitFormalParameter(FormalParameter node) {
    ParameterElement A_element = node.element;
    enterScope(A_element);
    try {
      return super.visitFormalParameter(node);
    } finally {
      _exitScope();
    }
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    A_Element A_element = node.element;
    _recordElementDefinition(A_element);
    enterScope(A_element);
    try {
      return super.visitFunctionDeclaration(node);
    } finally {
      _exitScope();
    }
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    A_Element A_element = node.element;
    _recordElementDefinition(A_element);
    return super.visitFunctionTypeAlias(node);
  }
  Object visitImportDirective(ImportDirective node) {
    ImportElement A_element = node.element;
    if (A_element != null) {
      LibraryElement impLibrary = A_element.importedLibrary;
      _recordLibraryReference(node, impLibrary);
    }
    return super.visitImportDirective(node);
  }
  Object visitIndexExpression(IndexExpression node) {
    MethodElement A_element = node.bestElement;
    if (A_element is MethodElement) {
      A_Token operator = node.leftBracket;
      A_Location A_location = _createLocationForToken(operator, A_element != null);
      recordRelationship(A_element, IndexConstants.IS_INVOKED_BY, A_location);
    }
    return super.visitIndexExpression(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    ExecutableElement A_element = node.element;
    enterScope(A_element);
    try {
      return super.visitMethodDeclaration(node);
    } finally {
      _exitScope();
    }
  }
  Object visitMethodInvocation(MethodInvocation node) {
    SimpleIdentifier A_name = node.methodName;
    A_Location A_location = _createLocationForNode(A_name);
    A_Element A_element = A_name.bestElement;
    if (A_element is MethodElement || A_element is PropertyAccessorElement || A_element is FunctionElement || A_element is VariableElement) {
      recordRelationship(A_element, IndexConstants.IS_INVOKED_BY, A_location);
    }
    {
      A_Element nameElement = new NameElement(A_name.name);
      _store.recordRelationship(nameElement, IndexConstants.IS_INVOKED_BY, A_location);
    }
    _recordImportElementReferenceWithoutPrefix(A_name);
    return super.visitMethodInvocation(node);
  }
  Object visitPartDirective(PartDirective node) {
    A_Element A_element = node.element;
    A_Location A_location = _createLocationForNode(node.uri);
    recordRelationship(A_element, IndexConstants.IS_REFERENCED_BY, A_location);
    return super.visitPartDirective(node);
  }
  Object visitPartOfDirective(PartOfDirective node) {
    A_Location A_location = _createLocationForNode(node.libraryName);
    recordRelationship(node.element, IndexConstants.IS_REFERENCED_BY, A_location);
    return null;
  }
  Object visitPostfixExpression(PostfixExpression node) {
    _recordOperatorReference(node.operator, node.bestElement);
    return super.visitPostfixExpression(node);
  }
  Object visitPrefixExpression(PrefixExpression node) {
    _recordOperatorReference(node.operator, node.bestElement);
    return super.visitPrefixExpression(node);
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    A_Element nameElement = new NameElement(node.name);
    A_Location A_location = _createLocationForNode(node);
    if (node.inDeclarationContext()) {
      recordRelationship(nameElement, IndexConstants.NAME_IS_DEFINED_BY, A_location);
      return null;
    }
    A_Element A_element = node.bestElement;
    if (_isAlreadyHandledName(node)) {
      return null;
    }
    if (A_element != null && A_element.enclosingElement is ClassElement || A_element == null && A_location.isQualified) {
      bool inGetterContext = node.inGetterContext();
      bool inSetterContext = node.inSetterContext();
      if (inGetterContext && inSetterContext) {
        _store.recordRelationship(nameElement, IndexConstants.IS_READ_WRITTEN_BY, A_location);
      } else if (inGetterContext) {
        _store.recordRelationship(nameElement, IndexConstants.IS_READ_BY, A_location);
      } else if (inSetterContext) {
        _store.recordRelationship(nameElement, IndexConstants.IS_WRITTEN_BY, A_location);
      }
    }
    if (A_element is FieldFormalParameterElement) {
      A_element = (A_element as FieldFormalParameterElement).field;
    }
    if (A_element is ClassElement || A_element is FunctionElement || A_element is FunctionTypeAliasElement || A_element is LabelElement || A_element is MethodElement || A_element is PropertyAccessorElement || A_element is PropertyInducingElement || A_element is TypeParameterElement) {
      recordRelationship(A_element, IndexConstants.IS_REFERENCED_BY, A_location);
    } else if (A_element is PrefixElement) {
      _recordImportElementReferenceWithPrefix(node);
    } else if (A_element is ParameterElement || A_element is LocalVariableElement) {
      bool inGetterContext = node.inGetterContext();
      bool inSetterContext = node.inSetterContext();
      if (inGetterContext && inSetterContext) {
        recordRelationship(A_element, IndexConstants.IS_READ_WRITTEN_BY, A_location);
      } else if (inGetterContext) {
        recordRelationship(A_element, IndexConstants.IS_READ_BY, A_location);
      } else if (inSetterContext) {
        recordRelationship(A_element, IndexConstants.IS_WRITTEN_BY, A_location);
      } else {
        recordRelationship(A_element, IndexConstants.IS_REFERENCED_BY, A_location);
      }
    }
    _recordImportElementReferenceWithoutPrefix(node);
    return super.visitSimpleIdentifier(node);
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    ConstructorElement A_element = node.staticElement;
    A_Location A_location;
    if (node.constructorName != null) {
      int A_start = node.period.offset;
      int A_end = node.constructorName.end;
      A_location = _createLocationForOffset(A_start, A_end - A_start);
    } else {
      int A_start = node.keyword.end;
      A_location = _createLocationForOffset(A_start, 0);
    }
    recordRelationship(A_element, IndexConstants.IS_REFERENCED_BY, A_location);
    return super.visitSuperConstructorInvocation(node);
  }
  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    VariableDeclarationList variables = node.variables;
    for (VariableDeclaration variableDeclaration in variables.variables) {
      A_Element A_element = variableDeclaration.element;
      _recordElementDefinition(A_element);
    }
    return super.visitTopLevelVariableDeclaration(node);
  }
  Object visitTypeParameter(TypeParameter node) {
    TypeParameterElement A_element = node.element;
    enterScope(A_element);
    try {
      return super.visitTypeParameter(node);
    } finally {
      _exitScope();
    }
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    VariableElement A_element = node.element;
    {
      SimpleIdentifier A_name = node.name;
      A_Location A_location = _createLocationForNode(A_name);
      A_location = _getLocationWithExpressionType(A_location, node.initializer);
      recordRelationship(A_element, IndexConstants.NAME_IS_DEFINED_BY, A_location);
    }
    enterScope(A_element);
    try {
      return super.visitVariableDeclaration(node);
    } finally {
      _exitScope();
    }
  }
  Object visitVariableDeclarationList(VariableDeclarationList node) {
    NodeList<VariableDeclaration> variables = node.variables;
    if (variables != null) {
      {
        TypeName A_type = node.type;
        if (A_type != null) {
          for (VariableDeclaration variableDeclaration in variables) {
            enterScope(variableDeclaration.element);
            try {
              A_type.accept(this);
            } finally {
              _exitScope();
            }
            break;
          }
        }
      }
      variables.accept(this);
    }
    return null;
  }
  A_Location _createLocationForNode(AstNode node) {
    bool isQualified = _isQualifiedClassMemberAccess(node);
    bool isResolved = true;
    if (node is SimpleIdentifier) {
      isResolved = node.bestElement != null;
    }
    A_Element A_element = peekElement();
    return new A_Location(A_element, node.offset, node.length, isQualified: isQualified, isResolved: isResolved);
  }
  A_Location _createLocationForOffset(int A_offset, int A_length) {
    A_Element A_element = peekElement();
    return new A_Location(A_element, A_offset, A_length);
  }
  A_Location _createLocationForToken(A_Token token, bool isResolved) {
    A_Element A_element = peekElement();
    return new A_Location(A_element, token.offset, token.length, isQualified: true, isResolved: isResolved);
  }
  void _exitScope() {
    _elementStack.removeFirst();
  }
  bool _isAlreadyHandledName(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    if (A_parent is MethodInvocation) {
      return A_parent.methodName == node;
    }
    return false;
  }
  bool _isQualifiedClassMemberAccess(AstNode node) {
    if (node is SimpleIdentifier) {
      AstNode A_parent = node.parent;
      if (A_parent is PrefixedIdentifier && A_parent.identifier == node) {
        return A_parent.prefix.staticElement is! PrefixElement;
      }
      if (A_parent is PropertyAccess && A_parent.propertyName == node) {
        return A_parent.realTarget != null;
      }
      if (A_parent is MethodInvocation && A_parent.methodName == node) {
        Expression A_target = A_parent.realTarget;
        if (A_target is SimpleIdentifier && A_target.staticElement is PrefixElement) {
          return false;
        }
        return A_target != null;
      }
    }
    return false;
  }
  void _recordElementDefinition(A_Element A_element) {
    A_Location A_location = createLocation(A_element);
    Relationship relationship = IndexConstants.DEFINES;
    recordRelationship(_libraryElement, relationship, A_location);
    recordRelationship(UniverseElement.INSTANCE, relationship, A_location);
  }
  void _recordImportElementReferenceWithPrefix(SimpleIdentifier prefixNode) {
    _ImportElementInfo A_info = getImportElementInfo(prefixNode);
    if (A_info != null) {
      int A_offset = prefixNode.offset;
      int A_length = A_info._periodEnd - A_offset;
      A_Location A_location = _createLocationForOffset(A_offset, A_length);
      recordRelationship(A_info.B__element, IndexConstants.IS_REFERENCED_BY, A_location);
    }
  }
  void _recordImportElementReferenceWithoutPrefix(SimpleIdentifier node) {
    if (_isIdentifierInImportCombinator(node)) {
      return;
    }
    if (_isIdentifierInPrefixedIdentifier(node)) {
      return;
    }
    A_Element A_element = node.staticElement;
    ImportElement importElement = _internalGetImportElement(_libraryElement, null, A_element, _importElementsMap);
    if (importElement != null) {
      A_Location A_location = _createLocationForOffset(node.offset, 0);
      recordRelationship(importElement, IndexConstants.IS_REFERENCED_BY, A_location);
    }
  }
  void _recordLibraryReference(UriBasedDirective node, LibraryElement library) {
    if (library != null) {
      A_Location A_location = _createLocationForNode(node.uri);
      recordRelationship(library.definingCompilationUnit, IndexConstants.IS_REFERENCED_BY, A_location);
    }
  }
  void _recordOperatorReference(A_Token operator, A_Element A_element) {
    A_Location A_location = _createLocationForToken(operator, A_element != null);
    {
      String A_name = operator.lexeme;
      if (A_name == "++") {
        A_name = "+";
      }
      if (A_name == "--") {
        A_name = "-";
      }
      if (StringUtilities.endsWithChar(A_name, 0x3D) && A_name != "==") {
        A_name = A_name.substring(0, A_name.length - 1);
      }
      A_Element nameElement = new NameElement(A_name);
      recordRelationship(nameElement, IndexConstants.IS_INVOKED_BY, A_location);
    }
    if (A_element != null) {
      recordRelationship(A_element, IndexConstants.IS_INVOKED_BY, A_location);
    }
  }
  void _recordSuperType(TypeName superNode, Relationship relationship) {
    if (superNode != null) {
      Identifier superName = superNode.name;
      if (superName != null) {
        A_Element superElement = superName.staticElement;
        recordRelationship(superElement, relationship, _createLocationForNode(superNode));
      }
    }
  }
  static A_Location createLocation(A_Element A_element) {
    if (A_element != null) {
      int A_offset = A_element.nameOffset;
      int A_length = A_element.displayName.length;
      return new A_Location(A_element, A_offset, A_length);
    }
    return null;
  }
  static _ImportElementInfo getImportElementInfo(SimpleIdentifier prefixNode) {
    _ImportElementInfo A_info = new _ImportElementInfo();
    AstNode A_parent = prefixNode.parent;
    CompilationUnit unit = prefixNode.getAncestor((node) => node is CompilationUnit);
    LibraryElement libraryElement = unit.element.library;
    A_Element usedElement = null;
    if (A_parent is PrefixedIdentifier) {
      PrefixedIdentifier prefixed = A_parent;
      if (prefixed.prefix == prefixNode) {
        usedElement = prefixed.staticElement;
        A_info._periodEnd = prefixed.period.end;
      }
    }
    if (A_parent is MethodInvocation) {
      MethodInvocation invocation = A_parent;
      if (invocation.target == prefixNode) {
        usedElement = invocation.methodName.staticElement;
        A_info._periodEnd = invocation.period.end;
      }
    }
    if (usedElement == null) {
      return null;
    }
    String prefix = prefixNode.name;
    Map<ImportElement, Set<A_Element>> importElementsMap = {};
    A_info.B__element = _internalGetImportElement(libraryElement, prefix, usedElement, importElementsMap);
    if (A_info.B__element == null) {
      return null;
    }
    return A_info;
  }
  static A_Location _getLocationWithExpressionType(A_Location A_location, Expression expression) {
    if (expression != null) {
      return new LocationWithData<DartType>(A_location, expression.bestType);
    }
    return A_location;
  }
  static ImportElement _internalGetImportElement(LibraryElement libraryElement, String prefix, A_Element usedElement, Map<ImportElement, Set<A_Element>> importElementsMap) {
    if (usedElement == null) {
      return null;
    }
    if (usedElement.enclosingElement is! CompilationUnitElement) {
      return null;
    }
    LibraryElement usedLibrary = usedElement.library;
    List<ImportElement> candidates = null;
    for (ImportElement importElement in libraryElement.imports) {
      if (importElement.importedLibrary != usedLibrary) {
        continue;
      }
      PrefixElement prefixElement = importElement.prefix;
      if (prefix == null) {
        if (prefixElement != null) {
          continue;
        }
      } else {
        if (prefixElement == null) {
          continue;
        }
        if (prefix != prefixElement.name) {
          continue;
        }
      }
      if (importElement.combinators.length == 0) {
        return importElement;
      }
      if (candidates == null) {
        candidates = [];
      }
      candidates.add(importElement);
    }
    if (candidates == null) {
      return null;
    }
    if (candidates.length == 1) {
      return candidates[0];
    }
    for (ImportElement importElement in candidates) {
      if (importElementsMap.containsKey(importElement)) {
        continue;
      }
      Namespace namespace = new NamespaceBuilder().createImportNamespaceForDirective(importElement);
      Set<A_Element> elements = new Set.from(namespace.definedNames.values);
      importElementsMap[importElement] = elements;
    }
    for (MapEntry<ImportElement, Set<A_Element>> A_entry in getMapEntrySet(importElementsMap)) {
      if (A_entry.getValue().contains(usedElement)) {
        return A_entry.getKey();
      }
    }
    return null;
  }
  static bool _isIdentifierInImportCombinator(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    return A_parent is Combinator;
  }
  static bool _isIdentifierInPrefixedIdentifier(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    return A_parent is PrefixedIdentifier && A_parent.identifier == node;
  }
}
class LocalIndex extends Index {
  SplitIndexStore A__store;
  LocalIndex(NodeManager nodeManager) {
    A__store = new SplitIndexStore(nodeManager);
  }
  void clear() {
    A__store.clear();
  }
  p.Future<List<A_Location>> getRelationships(A_Element A_element, Relationship relationship) {
    return A__store.getRelationships(A_element, relationship);
  }
  void A_indexHtmlUnit(AnalysisContext context, HtmlUnit unit) {
    indexHtmlUnit(A__store, context, unit);
  }
  void indexUnit(AnalysisContext context, CompilationUnit unit) {
    indexDartUnit(A__store, context, unit);
  }
  void removeContext(AnalysisContext context) {
    A__store.removeContext(context);
  }
  void removeSource(AnalysisContext context, Source A_source) {
    A__store.removeSource(context, A_source);
  }
  void removeSources(AnalysisContext context, SourceContainer container) {
    A__store.removeSources(context, container);
  }
  void run() {}
  void stop() {}
}
class ContextCodec {
  Map<AnalysisContext, int> _contextToIndex = new A_p.HashMap<AnalysisContext,int>();
  Map<int, AnalysisContext> _indexToContext = new A_p.HashMap<int,AnalysisContext>();
  int _nextId = 0;
  AnalysisContext decode(int A_index) => _indexToContext[A_index];
  int encode(AnalysisContext context) {
    int A_index = _contextToIndex[context];
    if (A_index == null) {
      A_index = _nextId++;
      _contextToIndex[context] = A_index;
      _indexToContext[A_index] = context;
    }
    return A_index;
  }
  void remove(AnalysisContext context) {
    int A_id = _contextToIndex.remove(context);
    if (A_id != null) {
      _indexToContext.remove(A_id);
    }
  }
}
class ElementCodec {
  final StringCodec _stringCodec;
  final IntArrayToIntMap _pathToIndex = new IntArrayToIntMap();
  final List<List<int>> _indexToPath = <List<int>>[];
  ElementCodec(this._stringCodec);
  A_Element decode(AnalysisContext context, int A_index) {
    List<int> A_path = _indexToPath[A_index];
    List<String> components = _getLocationComponents(A_path);
    ElementLocation A_location = new ElementLocationImpl.con3(components);
    A_Element A_element = context.getElement(A_location);
    return A_element;
  }
  int encode(A_Element A_element) {
    List<int> A_path = _getLocationPath(A_element);
    int A_index = _pathToIndex[A_path];
    if (A_index == null) {
      A_index = _indexToPath.length;
      _pathToIndex[A_path] = A_index;
      _indexToPath.add(A_path);
    }
    return A_index;
  }
  int encodeHash(A_Element A_element) {
    List<int> A_path = _getLocationPathLimited(A_element);
    int A_index = _pathToIndex[A_path];
    if (A_index == null) {
      A_index = _indexToPath.length;
      _pathToIndex[A_path] = A_index;
      _indexToPath.add(A_path);
    }
    return A_index;
  }
  List<String> _getLocationComponents(List<int> A_path) {
    int A_length = A_path.length;
    List<String> components = new List<String>();
    for (int i = 0; i < A_length; i++) {
      int componentId = A_path[i];
      String component = _stringCodec.decode(componentId);
      if (i < A_length - 1 && A_path[i + 1] < 0) {
        component += '@${(-A_path[i + 1])}';
        i++;
      }
      components.add(component);
    }
    return components;
  }
  List<int> _getLocationPath(A_Element A_element) {
    List<String> components = A_element.location.components;
    int A_length = components.length;
    if (_hasLocalOffset(components)) {
      List<int> A_path = new List<int>();
      for (String component in components) {
        int atOffset = component.indexOf('@');
        if (atOffset == -1) {
          A_path.add(_stringCodec.encode(component));
        } else {
          String preAtString = component.substring(0, atOffset);
          String atString = component.substring(atOffset + 1);
          A_path.add(_stringCodec.encode(preAtString));
          A_path.add(-1 * int.parse(atString));
        }
      }
      return A_path;
    } else {
      List<int> A_path = new List<int>.filled(A_length, 0);
      for (int i = 0; i < A_length; i++) {
        String component = components[i];
        A_path[i] = _stringCodec.encode(component);
      }
      return A_path;
    }
  }
  List<int> _getLocationPathLimited(A_Element A_element) {
    List<String> components = A_element.location.components;
    int A_length = components.length;
    String firstComponent = components[0];
    String lastComponent = components[A_length - 1];
    lastComponent = _substringBeforeAt(lastComponent);
    int firstId = _stringCodec.encode(firstComponent);
    int lastId = _stringCodec.encode(lastComponent);
    return <int>[firstId, lastId];
  }
  bool _hasLocalOffset(List<String> components) {
    for (String component in components) {
      if (component.indexOf('@') != -1) {
        return true;
      }
    }
    return false;
  }
  String _substringBeforeAt(String str) {
    int atOffset = str.indexOf('@');
    if (atOffset != -1) {
      str = str.substring(0, atOffset);
    }
    return str;
  }
}
class RelationshipCodec {
  final StringCodec _stringCodec;
  RelationshipCodec(this._stringCodec);
  Relationship decode(int idIndex) {
    String A_id = _stringCodec.decode(idIndex);
    return Relationship.getRelationship(A_id);
  }
  int encode(Relationship relationship) {
    String A_id = relationship.identifier;
    return _stringCodec.encode(A_id);
  }
}
class StringCodec {
  final Map<String, int> nameToIndex = new A_p.HashMap<String,int>();
  final List<String> _indexToName = <String>[];
  String decode(int A_index) => _indexToName[A_index];
  int encode(String A_name) {
    int A_index = nameToIndex[A_name];
    if (A_index == null) {
      A_index = _indexToName.length;
      nameToIndex[A_name] = A_index;
      _indexToName.add(A_name);
    }
    return A_index;
  }
}
class IntArrayToIntMap {
  final Map<E_p.Int32List, int> map = new A_p.HashMap<E_p.Int32List,int>(equals: _intArrayEquals, hashCode: _intArrayHashCode);
  int operator[](List<int> A_key) {
    E_p.Int32List typedKey = _getTypedKey(A_key);
    return map[typedKey];
  }
  void operator[]=(List<int> A_key, int A_value) {
    E_p.Int32List typedKey = _getTypedKey(A_key);
    map[typedKey] = A_value;
  }
  static E_p.Int32List _getTypedKey(List<int> A_key) {
    if (A_key is E_p.Int32List) {
      return A_key;
    }
    return new E_p.Int32List.fromList(A_key);
  }
  static bool _intArrayEquals(List<int> a, List<int> b) {
    int A_length = a.length;
    if (A_length != b.length) {
      return false;
    }
    for (int i = 0; i < A_length; i++) {
      if (a[i] != b[i]) {
        return false;
      }
    }
    return true;
  }
  static int _intArrayHashCode(List<int> A_key) {
    return A_key.fold(0, (int result, int item) {
      return 31 * result + item;
    });
  }
}
class IntToIntSetMap {
  final Map<int, E_p.Int32List> A__map = new A_p.HashMap<int,E_p.Int32List>();
  int get length => A__map.length;
  void add(int A_key, int A_value) {
    E_p.Int32List C_values = A__map[A_key];
    if (C_values == null) {
      C_values = new E_p.Int32List(1);
      C_values[0] = A_value;
      A__map[A_key] = C_values;
    }
    if (C_values.indexOf(A_value) == -1) {
      int A_length = C_values.length;
      E_p.Int32List newSet = new E_p.Int32List(A_length + 1);
      newSet.setRange(0, A_length, C_values);
      newSet[A_length] = A_value;
      A__map[A_key] = newSet;
    }
  }
  void clear() {
    A__map.clear();
  }
  List<int> get(int A_key) {
    List<int> C_values = A__map[A_key];
    if (C_values == null) {
      C_values = <int>[];
    }
    return C_values;
  }
}
abstract class FileManager {
  void clear();
  void delete(String A_name);
  p.Future<List<int>> read(String A_name);
  p.Future write(String A_name, List<int> bytes);
}
class FileNodeManager implements NodeManager {
  static int _VERSION = 1;
  final FileManager _fileManager;
  final Logger _logger;
  final ContextCodec contextCodec;
  final ElementCodec elementCodec;
  final StringCodec stringCodec;
  final RelationshipCodec _relationshipCodec;
  int _locationCount = 0;
  Map<String, int> _nodeLocationCounts = new A_p.HashMap<String,int>();
  FileNodeManager(this._fileManager, this._logger, this.stringCodec, this.contextCodec, this.elementCodec, this._relationshipCodec);
  int get locationCount => _locationCount;
  void clear() {
    _fileManager.clear();
  }
  p.Future<IndexNode> getNode(String A_name) {
    return _fileManager.read(A_name).then((List<int> bytes) {
      if (bytes == null) {
        return null;
      }
      _DataInputStream A_stream = new _DataInputStream(bytes);
      return _readNode(A_stream);
    }).catchError((e, A_stackTrace) {
      _logger.logError2('Exception during reading index file ${A_name}', new CaughtException(e, A_stackTrace));
    });
  }
  IndexNode newNode(AnalysisContext context) => new IndexNode(context, elementCodec, _relationshipCodec);
  p.Future putNode(String A_name, IndexNode node) {
    {
      _locationCount -= _getLocationCount(A_name);
      int nodeLocationCount = node.locationCount;
      _nodeLocationCounts[A_name] = nodeLocationCount;
      _locationCount += nodeLocationCount;
    }
    return new p.Future.microtask(() {
      _DataOutputStream A_stream = new _DataOutputStream();
      _writeNode(node, A_stream);
      var bytes = A_stream.getBytes();
      return _fileManager.write(A_name, bytes);
    }).catchError((e, A_stackTrace) {
      _logger.logError2('Exception during reading index file ${A_name}', new CaughtException(e, A_stackTrace));
    });
  }
  void removeNode(String A_name) {
    _locationCount -= _getLocationCount(A_name);
    _nodeLocationCounts.remove(A_name);
    _fileManager.delete(A_name);
  }
  int _getLocationCount(String A_name) {
    int A_locationCount = _nodeLocationCounts[A_name];
    return A_locationCount != null ? A_locationCount : 0;
  }
  RelationKeyData _readElementRelationKey(_DataInputStream A_stream) {
    int elementId = A_stream.readInt();
    int relationshipId = A_stream.readInt();
    return new RelationKeyData.forData(elementId, relationshipId);
  }
  LocationData _readLocationData(_DataInputStream A_stream) {
    int elementId = A_stream.readInt();
    int A_offset = A_stream.readInt();
    int A_length = A_stream.readInt();
    int flags = A_stream.readInt();
    return new LocationData.forData(elementId, A_offset, A_length, flags);
  }
  IndexNode _readNode(_DataInputStream A_stream) {
    {
      int A_version = A_stream.readInt();
      if (A_version != _VERSION) {
        throw new StateError('Version ${_VERSION} expected, but ${A_version} found.');
      }
    }
    int contextId = A_stream.readInt();
    AnalysisContext context = contextCodec.decode(contextId);
    if (context == null) {
      return null;
    }
    Map<RelationKeyData, List<LocationData>> relations = new A_p.HashMap<RelationKeyData,List<LocationData>>();
    int numRelations = A_stream.readInt();
    for (int i = 0; i < numRelations; i++) {
      RelationKeyData A_key = _readElementRelationKey(A_stream);
      int numLocations = A_stream.readInt();
      List<LocationData> locations = new List<LocationData>();
      for (int j = 0; j < numLocations; j++) {
        locations.add(_readLocationData(A_stream));
      }
      relations[A_key] = locations;
    }
    IndexNode node = new IndexNode(context, elementCodec, _relationshipCodec);
    node.relations = relations;
    return node;
  }
  void _writeElementRelationKey(_DataOutputStream A_stream, RelationKeyData A_key) {
    A_stream.writeInt(A_key.elementId);
    A_stream.writeInt(A_key.relationshipId);
  }
  void _writeNode(IndexNode node, _DataOutputStream A_stream) {
    A_stream.writeInt(_VERSION);
    {
      AnalysisContext context = node.context;
      int contextId = contextCodec.encode(context);
      A_stream.writeInt(contextId);
    }
    Map<RelationKeyData, List<LocationData>> relations = node.relations;
    A_stream.writeInt(relations.length);
    relations.forEach((A_key, locations) {
      _writeElementRelationKey(A_stream, A_key);
      A_stream.writeInt(locations.length);
      for (LocationData A_location in locations) {
        A_stream.writeInt(A_location.elementId);
        A_stream.writeInt(A_location.offset);
        A_stream.writeInt(A_location.length);
        A_stream.writeInt(A_location.flags);
      }
    });
  }
}
class IndexNode {
  final AnalysisContext context;
  final ElementCodec _elementCodec;
  final RelationshipCodec _relationshipCodec;
  Map<RelationKeyData, List<LocationData>> _relations = new A_p.HashMap<RelationKeyData,List<LocationData>>();
  IndexNode(this.context, this._elementCodec, this._relationshipCodec);
  int get locationCount {
    int A_locationCount = 0;
    for (List<LocationData> locations in _relations.values) {
      A_locationCount += locations.length;
    }
    return A_locationCount;
  }
  Map<RelationKeyData, List<LocationData>> get relations => _relations;
  void set relations(Map<RelationKeyData, List<LocationData>> A_relations) {
    _relations = A_relations;
  }
  List<A_Location> getRelationships(A_Element A_element, Relationship relationship) {
    RelationKeyData A_key = new RelationKeyData.forObject(_elementCodec, _relationshipCodec, A_element, relationship);
    List<LocationData> locationDatas = _relations[A_key];
    if (locationDatas == null) {
      return A_Location.EMPTY_ARRAY;
    }
    List<A_Location> locations = <A_Location>[];
    for (LocationData locationData in locationDatas) {
      A_Location A_location = locationData.getLocation(context, _elementCodec);
      if (A_location != null) {
        locations.add(A_location);
      }
    }
    return locations;
  }
  void recordRelationship(A_Element A_element, Relationship relationship, A_Location A_location) {
    RelationKeyData A_key = new RelationKeyData.forObject(_elementCodec, _relationshipCodec, A_element, relationship);
    List<LocationData> locationDatas = _relations[A_key];
    if (locationDatas == null) {
      locationDatas = <LocationData>[];
      _relations[A_key] = locationDatas;
    }
    locationDatas.add(new LocationData.forObject(_elementCodec, A_location));
  }
}
class LocationData {
  static const int A__FLAG_QUALIFIED = 1 << 0;
  static const int A__FLAG_RESOLVED = 1 << 1;
  final int elementId;
  final int offset;
  final int length;
  final int flags;
  LocationData.forData(this.elementId, this.offset, this.length, this.flags);
  LocationData.forObject(ElementCodec elementCodec, A_Location A_location) : elementId = elementCodec.encode(A_location.element), offset = A_location.offset, length = A_location.length, flags = (A_location.isQualified ? A__FLAG_QUALIFIED : 0) | (A_location.isResolved ? A__FLAG_RESOLVED : 0);
  int get hashCode {
    return 31 * (31 * elementId + offset) + length;
  }
  bool operator==(Object obj) {
    if (obj is! LocationData) {
      return false;
    }
    LocationData other = obj;
    return other.elementId == elementId && other.offset == offset && other.length == length && other.flags == flags;
  }
  A_Location getLocation(AnalysisContext context, ElementCodec elementCodec) {
    A_Element A_element = elementCodec.decode(context, elementId);
    if (A_element == null) {
      return null;
    }
    bool isQualified = (flags & A__FLAG_QUALIFIED) != 0;
    bool isResovled = (flags & A__FLAG_RESOLVED) != 0;
    return new A_Location(A_element, offset, length, isQualified: isQualified, isResolved: isResovled);
  }
}
abstract class NodeManager {
  ContextCodec get contextCodec;
  ElementCodec get elementCodec;
  int get locationCount;
  StringCodec get stringCodec;
  void clear();
  p.Future<IndexNode> getNode(String A_name);
  IndexNode newNode(AnalysisContext context);
  void putNode(String A_name, IndexNode node);
  void removeNode(String A_name);
}
class RelationKeyData {
  final int elementId;
  final int relationshipId;
  RelationKeyData.forData(this.elementId, this.relationshipId);
  RelationKeyData.forObject(ElementCodec elementCodec, RelationshipCodec relationshipCodec, A_Element A_element, Relationship relationship) : elementId = elementCodec.encode(A_element), relationshipId = relationshipCodec.encode(relationship);
  int get hashCode {
    return 31 * elementId + relationshipId;
  }
  bool operator==(Object obj) {
    if (obj is! RelationKeyData) {
      return false;
    }
    RelationKeyData other = obj;
    return other.elementId == elementId && other.relationshipId == relationshipId;
  }
}
class SplitIndexStore implements IndexStore {
  ContextCodec _contextCodec;
  Map<int, Map<int, Map<Relationship, List<LocationData>>>> _contextNodeRelations = new A_p.HashMap<int,Map<int,Map<Relationship,List<LocationData>>>>();
  Map<AnalysisContext, Map<Source, Set<Source>>> _contextToLibraryToUnits = new A_p.HashMap<AnalysisContext,Map<Source,Set<Source>>>();
  Map<AnalysisContext, Map<Source, Set<Source>>> _contextToUnitToLibraries = new A_p.HashMap<AnalysisContext,Map<Source,Set<Source>>>();
  int _currentContextId = 0;
  IndexNode A__currentNode;
  String _currentNodeName;
  int _currentNodeNameId = 0;
  ElementCodec _elementCodec;
  IntToIntSetMap _nameToNodeNames = new IntToIntSetMap();
  final NodeManager _nodeManager;
  Set<Source> _sources = new A_p.HashSet<Source>();
  StringCodec A__stringCodec;
  SplitIndexStore(this._nodeManager) {
    this._contextCodec = _nodeManager.contextCodec;
    this._elementCodec = _nodeManager.elementCodec;
    this.A__stringCodec = _nodeManager.stringCodec;
  }
  bool aboutToIndexDart(AnalysisContext context, CompilationUnitElement unitElement) {
    context = _unwrapContext(context);
    if (context.isDisposed) {
      return false;
    }
    if (unitElement == null) {
      return false;
    }
    LibraryElement libraryElement = unitElement.library;
    if (libraryElement == null) {
      return false;
    }
    CompilationUnitElement definingUnitElement = libraryElement.definingCompilationUnit;
    if (definingUnitElement == null) {
      return false;
    }
    Source library = definingUnitElement.source;
    Source unit = unitElement.source;
    if (unit == library) {
      A_p.HashSet<Source> newParts = new A_p.HashSet<Source>();
      for (CompilationUnitElement part in libraryElement.parts) {
        newParts.add(part.source);
      }
      Map<Source, Set<Source>> libraryToUnits = _contextToLibraryToUnits[context];
      if (libraryToUnits == null) {
        libraryToUnits = new A_p.HashMap<Source,Set<Source>>();
        _contextToLibraryToUnits[context] = libraryToUnits;
      }
      Set<Source> oldParts = libraryToUnits[library];
      if (oldParts != null) {
        Set<Source> noParts = oldParts.difference(newParts);
        for (Source noPart in noParts) {
          _removeLocations(context, library, noPart);
        }
      }
      libraryToUnits[library] = newParts;
    }
    _recordUnitInLibrary(context, library, unit);
    _recordLibraryWithUnit(context, library, unit);
    _sources.add(library);
    _sources.add(unit);
    String A_libraryName = library.fullName;
    String unitName = unit.fullName;
    int libraryNameIndex = A__stringCodec.encode(A_libraryName);
    int unitNameIndex = A__stringCodec.encode(unitName);
    _currentNodeName = '${libraryNameIndex}_${unitNameIndex}.index';
    _currentNodeNameId = A__stringCodec.encode(_currentNodeName);
    A__currentNode = _nodeManager.newNode(context);
    _currentContextId = _contextCodec.encode(context);
    for (Map<int, dynamic> nodeRelations in _contextNodeRelations.values) {
      nodeRelations.remove(_currentNodeNameId);
    }
    return true;
  }
  bool aboutToIndexHtml(AnalysisContext context, HtmlElement htmlElement) {
    context = _unwrapContext(context);
    if (context.isDisposed) {
      return false;
    }
    Source A_source = htmlElement.source;
    _removeLocations(context, null, A_source);
    _recordUnitInLibrary(context, null, A_source);
    String sourceName = A_source.fullName;
    int sourceNameIndex = A__stringCodec.encode(sourceName);
    _currentNodeName = '${sourceNameIndex}.index';
    _currentNodeNameId = A__stringCodec.encode(_currentNodeName);
    A__currentNode = _nodeManager.newNode(context);
    return true;
  }
  void clear() {
    _contextNodeRelations.clear();
    _nodeManager.clear();
    _nameToNodeNames.clear();
  }
  void doneIndex() {
    if (A__currentNode != null) {
      _nodeManager.putNode(_currentNodeName, A__currentNode);
      _currentNodeName = null;
      _currentNodeNameId = -1;
      A__currentNode = null;
      _currentContextId = -1;
    }
  }
  p.Future<List<A_Location>> getRelationships(A_Element A_element, Relationship relationship) {
    if (identical(A_element, UniverseElement.INSTANCE)) {
      List<A_Location> locations = _getRelationshipsUniverse(relationship);
      return new p.Future.value(locations);
    }
    int nameId = _elementCodec.encodeHash(A_element);
    List<int> nodeNameIds = _nameToNodeNames.get(nameId);
    List<p.Future<List<A_Location>>> nodeFutures = <p.Future<List<A_Location>>>[];
    for (int nodeNameId in nodeNameIds) {
      String nodeName = A__stringCodec.decode(nodeNameId);
      p.Future<IndexNode> nodeFuture = _nodeManager.getNode(nodeName);
      p.Future<List<A_Location>> locationsFuture = nodeFuture.then((node) {
        if (node == null) {
          return A_Location.EMPTY_ARRAY;
        }
        return node.getRelationships(A_element, relationship);
      });
      nodeFutures.add(locationsFuture);
    }
    return p.Future.wait(nodeFutures).then((List<List<A_Location>> locationsList) {
      List<A_Location> allLocations = <A_Location>[];
      for (List<A_Location> locations in locationsList) {
        allLocations.addAll(locations);
      }
      return allLocations;
    });
  }
  void recordRelationship(A_Element A_element, Relationship relationship, A_Location A_location) {
    if (A_element == null || A_location == null) {
      return;
    }
    if (identical(A_element, UniverseElement.INSTANCE)) {
      _recordRelationshipUniverse(relationship, A_location);
      return;
    }
    _recordNodeNameForElement(A_element);
    A__currentNode.recordRelationship(A_element, relationship, A_location);
  }
  void removeContext(AnalysisContext context) {
    context = _unwrapContext(context);
    if (context == null) {
      return;
    }
    removeSources(context, null);
    _contextToLibraryToUnits.remove(context);
    _contextToUnitToLibraries.remove(context);
    _contextNodeRelations.remove(_contextCodec.encode(context));
    _contextCodec.remove(context);
  }
  void removeSource(AnalysisContext context, Source A_source) {
    context = _unwrapContext(context);
    if (context == null) {
      return;
    }
    Map<Source, Set<Source>> unitToLibraries = _contextToUnitToLibraries[context];
    if (unitToLibraries != null) {
      Set<Source> libraries = unitToLibraries.remove(A_source);
      if (libraries != null) {
        for (Source library in libraries) {
          _removeLocations(context, library, A_source);
        }
      }
    }
    Map<Source, Set<Source>> libraryToUnits = _contextToLibraryToUnits[context];
    if (libraryToUnits != null) {
      Set<Source> units = libraryToUnits.remove(A_source);
      if (units != null) {
        for (Source unit in units) {
          _removeLocations(context, A_source, unit);
        }
      }
    }
  }
  void removeSources(AnalysisContext context, SourceContainer container) {
    context = _unwrapContext(context);
    if (context == null) {
      return;
    }
    Map<Source, Set<Source>> unitToLibraries = _contextToUnitToLibraries[context];
    if (unitToLibraries != null) {
      List<Source> units = new List<Source>.from(unitToLibraries.keys);
      for (Source A_source in units) {
        if (container == null || container.contains(A_source)) {
          removeSource(context, A_source);
        }
      }
    }
    Map<Source, Set<Source>> libraryToUnits = _contextToLibraryToUnits[context];
    if (libraryToUnits != null) {
      List<Source> libraries = new List<Source>.from(libraryToUnits.keys);
      for (Source A_source in libraries) {
        if (container == null || container.contains(A_source)) {
          removeSource(context, A_source);
        }
      }
    }
  }
  List<A_Location> _getRelationshipsUniverse(Relationship relationship) {
    List<A_Location> locations = <A_Location>[];
    _contextNodeRelations.forEach((contextId, contextRelations) {
      AnalysisContext context = _contextCodec.decode(contextId);
      if (context != null) {
        for (Map<Relationship, List<LocationData>> nodeRelations in contextRelations.values) {
          List<LocationData> nodeLocations = nodeRelations[relationship];
          if (nodeLocations != null) {
            for (LocationData locationData in nodeLocations) {
              A_Location A_location = locationData.getLocation(context, _elementCodec);
              if (A_location != null) {
                locations.add(A_location);
              }
            }
          }
        }
      }
    });
    return locations;
  }
  void _recordLibraryWithUnit(AnalysisContext context, Source library, Source unit) {
    Map<Source, Set<Source>> libraryToUnits = _contextToLibraryToUnits[context];
    if (libraryToUnits == null) {
      libraryToUnits = new A_p.HashMap<Source,Set<Source>>();
      _contextToLibraryToUnits[context] = libraryToUnits;
    }
    Set<Source> units = libraryToUnits[library];
    if (units == null) {
      units = new A_p.HashSet<Source>();
      libraryToUnits[library] = units;
    }
    units.add(unit);
  }
  void _recordNodeNameForElement(A_Element A_element) {
    int nameId = _elementCodec.encodeHash(A_element);
    _nameToNodeNames.add(nameId, _currentNodeNameId);
  }
  void _recordRelationshipUniverse(Relationship relationship, A_Location A_location) {
    Map<int, Map<Relationship, List<LocationData>>> nodeRelations = _contextNodeRelations[_currentContextId];
    if (nodeRelations == null) {
      nodeRelations = new A_p.HashMap<int,Map<Relationship,List<LocationData>>>();
      _contextNodeRelations[_currentContextId] = nodeRelations;
    }
    Map<Relationship, List<LocationData>> relations = nodeRelations[_currentNodeNameId];
    if (relations == null) {
      relations = new A_p.HashMap<Relationship,List<LocationData>>();
      nodeRelations[_currentNodeNameId] = relations;
    }
    List<LocationData> locations = relations[relationship];
    if (locations == null) {
      locations = <LocationData>[];
      relations[relationship] = locations;
    }
    locations.add(new LocationData.forObject(_elementCodec, A_location));
  }
  void _recordUnitInLibrary(AnalysisContext context, Source library, Source unit) {
    Map<Source, Set<Source>> unitToLibraries = _contextToUnitToLibraries[context];
    if (unitToLibraries == null) {
      unitToLibraries = new A_p.HashMap<Source,Set<Source>>();
      _contextToUnitToLibraries[context] = unitToLibraries;
    }
    Set<Source> libraries = unitToLibraries[unit];
    if (libraries == null) {
      libraries = new A_p.HashSet<Source>();
      unitToLibraries[unit] = libraries;
    }
    libraries.add(library);
  }
  void _removeLocations(AnalysisContext context, Source library, Source unit) {
    String A_libraryName = library != null ? library.fullName : null;
    String unitName = unit.fullName;
    int libraryNameIndex = A__stringCodec.encode(A_libraryName);
    int unitNameIndex = A__stringCodec.encode(unitName);
    String nodeName = '${libraryNameIndex}_${unitNameIndex}.index';
    int nodeNameId = A__stringCodec.encode(nodeName);
    _nodeManager.removeNode(nodeName);
    _sources.remove(library);
    _sources.remove(unit);
    {
      int contextId = _contextCodec.encode(context);
      Map<int, Object> nodeRelations = _contextNodeRelations[contextId];
      if (nodeRelations != null) {
        nodeRelations.remove(nodeNameId);
      }
    }
  }
  AnalysisContext _unwrapContext(AnalysisContext context) {
    if (context is InstrumentedAnalysisContextImpl) {
      context = (context as InstrumentedAnalysisContextImpl).basis;
    }
    return context;
  }
}
class _DataInputStream {
  E_p.ByteData _byteData;
  int _byteOffset = 0;
  _DataInputStream(List<int> bytes) {
    E_p.ByteBuffer A_buffer = new E_p.Uint8List.fromList(bytes).buffer;
    _byteData = new E_p.ByteData.view(A_buffer);
  }
  int readInt() {
    int result = _byteData.getInt32(_byteOffset);
    _byteOffset += 4;
    return result;
  }
}
class _DataOutputStream {
  C_p.BytesBuilder C__buffer = new C_p.BytesBuilder();
  E_p.Uint8List getBytes() {
    return new E_p.Uint8List.fromList(C__buffer.takeBytes());
  }
  void writeInt(int A_value) {
    C__buffer.addByte((A_value & 0xFF000000) >> 24);
    C__buffer.addByte((A_value & 0x00FF0000) >> 16);
    C__buffer.addByte((A_value & 0x0000FF00) >> 8);
    C__buffer.addByte(A_value & 0xFF);
  }
}
class TemporaryFolderFileManager implements FileManager {
  C_p.Directory _directory;
  void clear() {
    if (_directory != null) {
      try {
        _directory.deleteSync(recursive: true);
      }on C_p.FileSystemException   {}
      _directory = null;
    }
  }
  void delete(String A_name) {
    if (_directory == null) {
      return;
    }
    C_p.File A_file = _getFile(A_name);
    try {
      A_file.deleteSync();
    } catch (e) {}
  }
  p.Future<List<int>> read(String A_name) {
    if (_directory == null) {
      return new p.Future.value(null);
    }
    C_p.File A_file = _getFile(A_name);
    return A_file.readAsBytes().catchError((e) {
      return null;
    });
  }
  p.Future write(String A_name, List<int> bytes) {
    _ensureDirectory();
    return _getFile(A_name).writeAsBytes(bytes);
  }
  void _ensureDirectory() {
    if (_directory == null) {
      C_p.Directory temp = C_p.Directory.systemTemp;
      _directory = temp.createTempSync('AnalysisServices_Index');
    }
  }
  C_p.File _getFile(String A_name) {
    String A_path = B_join(_directory.path, A_name);
    return new C_p.File(A_path);
  }
}
class SearchEngineImpl implements SearchEngine {
  final Index A__index;
  SearchEngineImpl(this.A__index);
  p.Future<List<SearchMatch>> searchMemberDeclarations(String A_name) {
    NameElement A_element = new NameElement(A_name);
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(A_element, IndexConstants.NAME_IS_DEFINED_BY, MatchKind.A_DECLARATION);
    return requestor.merge().then((matches) {
      return matches.where((match) {
        return match.element.enclosingElement is ClassElement;
      }).toList();
    });
  }
  p.Future<List<SearchMatch>> searchMemberReferences(String A_name) {
    NameElement A_element = new NameElement(A_name);
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(A_element, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    requestor.add(A_element, IndexConstants.IS_READ_BY, MatchKind.B_READ);
    requestor.add(A_element, IndexConstants.IS_READ_WRITTEN_BY, MatchKind.A_READ_WRITE);
    requestor.add(A_element, IndexConstants.IS_WRITTEN_BY, MatchKind.B_WRITE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> searchReferences(A_Element A_element) {
    if (A_element.kind == A_ElementKind.ANGULAR_COMPONENT || A_element.kind == A_ElementKind.ANGULAR_CONTROLLER || A_element.kind == A_ElementKind.ANGULAR_FORMATTER || A_element.kind == A_ElementKind.ANGULAR_PROPERTY || A_element.kind == A_ElementKind.ANGULAR_SCOPE_PROPERTY || A_element.kind == A_ElementKind.ANGULAR_SELECTOR) {
      return _searchReferences_Angular(A_element as AngularElement);
    } else if (A_element.kind == A_ElementKind.C_CLASS) {
      return _searchReferences_Class(A_element as ClassElement);
    } else if (A_element.kind == A_ElementKind.A_COMPILATION_UNIT) {
      return _searchReferences_CompilationUnit(A_element as CompilationUnitElement);
    } else if (A_element.kind == A_ElementKind.C_CONSTRUCTOR) {
      return _searchReferences_Constructor(A_element as ConstructorElement);
    } else if (A_element.kind == A_ElementKind.C_FIELD || A_element.kind == A_ElementKind.C_TOP_LEVEL_VARIABLE) {
      return _searchReferences_Field(A_element as PropertyInducingElement);
    } else if (A_element.kind == A_ElementKind.C_FUNCTION) {
      return _searchReferences_Function(A_element as FunctionElement);
    } else if (A_element.kind == A_ElementKind.C_GETTER || A_element.kind == A_ElementKind.C_SETTER) {
      return _searchReferences_PropertyAccessor(A_element as PropertyAccessorElement);
    } else if (A_element.kind == A_ElementKind.A_IMPORT) {
      return _searchReferences_Import(A_element as ImportElement);
    } else if (A_element.kind == A_ElementKind.A_LIBRARY) {
      return _searchReferences_Library(A_element as LibraryElement);
    } else if (A_element.kind == A_ElementKind.B_LOCAL_VARIABLE) {
      return _searchReferences_LocalVariable(A_element as LocalVariableElement);
    } else if (A_element.kind == A_ElementKind.E_METHOD) {
      return _searchReferences_Method(A_element as MethodElement);
    } else if (A_element.kind == A_ElementKind.E_PARAMETER) {
      return _searchReferences_Parameter(A_element as ParameterElement);
    } else if (A_element.kind == A_ElementKind.C_FUNCTION_TYPE_ALIAS) {
      return _searchReferences_FunctionTypeAlias(A_element as FunctionTypeAliasElement);
    } else if (A_element.kind == A_ElementKind.B_TYPE_PARAMETER) {
      return _searchReferences_TypeParameter(A_element as TypeParameterElement);
    }
    return new p.Future.value(<SearchMatch>[]);
  }
  p.Future<List<SearchMatch>> searchSubtypes(ClassElement A_type) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(A_type, IndexConstants.IS_EXTENDED_BY, MatchKind.A_REFERENCE);
    requestor.add(A_type, IndexConstants.IS_MIXED_IN_BY, MatchKind.A_REFERENCE);
    requestor.add(A_type, IndexConstants.IS_IMPLEMENTED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> searchTopLevelDeclarations(String A_pattern) {
    UniverseElement universe = UniverseElement.INSTANCE;
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(universe, IndexConstants.DEFINES, MatchKind.A_DECLARATION);
    RegExp regExp = new RegExp(A_pattern);
    return requestor.merge().then((List<SearchMatch> matches) {
      return matches.where((SearchMatch match) {
        String A_name = match.element.displayName;
        return regExp.hasMatch(A_name);
      }).toList();
    });
  }
  p.Future<List<SearchMatch>> _searchReferences_Angular(AngularElement A_element) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(A_element, IndexConstants.ANGULAR_REFERENCE, MatchKind.A_ANGULAR_REFERENCE);
    requestor.add(A_element, IndexConstants.ANGULAR_CLOSING_TAG_REFERENCE, MatchKind.A_ANGULAR_CLOSING_TAG_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Class(ClassElement clazz) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(clazz, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_CompilationUnit(CompilationUnitElement unit) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(unit, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Constructor(ConstructorElement constructor) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(constructor, IndexConstants.NAME_IS_DEFINED_BY, MatchKind.A_DECLARATION);
    requestor.add(constructor, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Field(PropertyInducingElement field) {
    PropertyAccessorElement getter = field.getter;
    PropertyAccessorElement setter = field.setter;
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(field, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    if (getter != null) {
      requestor.add(getter, IndexConstants.IS_REFERENCED_BY, MatchKind.B_READ);
      requestor.add(getter, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    }
    if (setter != null) {
      requestor.add(setter, IndexConstants.IS_REFERENCED_BY, MatchKind.B_WRITE);
    }
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Function(FunctionElement A_function) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(A_function, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    requestor.add(A_function, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_FunctionTypeAlias(FunctionTypeAliasElement alias) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(alias, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Import(ImportElement imp) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(imp, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Library(LibraryElement library) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(library, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_LocalVariable(LocalVariableElement variable) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(variable, IndexConstants.IS_READ_BY, MatchKind.B_READ);
    requestor.add(variable, IndexConstants.IS_READ_WRITTEN_BY, MatchKind.A_READ_WRITE);
    requestor.add(variable, IndexConstants.IS_WRITTEN_BY, MatchKind.B_WRITE);
    requestor.add(variable, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Method(MethodElement A_method) {
    _Requestor requestor = new _Requestor(A__index);
    if (A_method is MethodMember) {
      A_method = (A_method as MethodMember).baseElement;
    }
    requestor.add(A_method, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    requestor.add(A_method, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_Parameter(ParameterElement parameter) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(parameter, IndexConstants.IS_READ_BY, MatchKind.B_READ);
    requestor.add(parameter, IndexConstants.IS_READ_WRITTEN_BY, MatchKind.A_READ_WRITE);
    requestor.add(parameter, IndexConstants.IS_WRITTEN_BY, MatchKind.B_WRITE);
    requestor.add(parameter, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    requestor.add(parameter, IndexConstants.IS_INVOKED_BY, MatchKind.A_INVOCATION);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_PropertyAccessor(PropertyAccessorElement accessor) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(accessor, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
  p.Future<List<SearchMatch>> _searchReferences_TypeParameter(TypeParameterElement typeParameter) {
    _Requestor requestor = new _Requestor(A__index);
    requestor.add(typeParameter, IndexConstants.IS_REFERENCED_BY, MatchKind.A_REFERENCE);
    return requestor.merge();
  }
}
class _Requestor {
  final List<p.Future<List<SearchMatch>>> futures = <p.Future<List<SearchMatch>>>[];
  final Index index;
  _Requestor(this.index);
  void add(A_Element A_element, Relationship relationship, MatchKind kind) {
    p.Future relationsFuture = index.getRelationships(A_element, relationship);
    p.Future matchesFuture = relationsFuture.then((List<A_Location> locations) {
      List<SearchMatch> matches = <SearchMatch>[];
      for (A_Location A_location in locations) {
        matches.add(new SearchMatch(kind, A_location.element, new SourceRange(A_location.offset, A_location.length), A_location.isResolved, A_location.isQualified));
      }
      return matches;
    });
    futures.add(matchesFuture);
  }
  p.Future<List<SearchMatch>> merge() {
    return p.Future.wait(futures).then((List<List<SearchMatch>> matchesList) {
      return matchesList.expand((matches) => matches).toList();
    });
  }
}
abstract class A_File extends Resource {
  Source createSource([Uri A_uri]);
}
abstract class Folder extends Resource {
  p.Stream<WatchEvent> get changes;
  String canonicalizePath(String A_path);
  bool contains(String A_path);
  Resource getChild(String relPath);
  List<Resource> A_getChildren();
}
abstract class Resource {
  bool get exists;
  Folder get parent;
  String get path;
  String get shortName;
}
abstract class ResourceProvider {
  Context get pathContext;
  Resource getResource(String A_path);
}
class ResourceUriResolver extends UriResolver {
  static String _FILE_SCHEME = "file";
  final ResourceProvider _provider;
  ResourceUriResolver(this._provider);
  Source resolveAbsolute(Uri A_uri) {
    if (!_isFileUri(A_uri)) {
      return null;
    }
    Resource resource = _provider.getResource(A_uri.path);
    if (resource is A_File) {
      return resource.createSource(A_uri);
    }
    return null;
  }
  static bool _isFileUri(Uri A_uri) => A_uri.scheme == _FILE_SCHEME;
}
class PhysicalResourceProvider implements ResourceProvider {
  static final PhysicalResourceProvider A_INSTANCE = new PhysicalResourceProvider.C__();
  PhysicalResourceProvider.C__();
  Context get pathContext => C_p.Platform.isWindows ? windows : posix;
  Resource getResource(String A_path) {
    if (C_p.FileSystemEntity.isDirectorySync(A_path)) {
      C_p.Directory directory = new C_p.Directory(A_path);
      return new _PhysicalFolder(directory);
    } else {
      C_p.File A_file = new C_p.File(A_path);
      return new _PhysicalFile(A_file);
    }
  }
}
class _PhysicalFile extends _PhysicalResource implements A_File {
  _PhysicalFile(C_p.File A_file) : super(A_file);
  Source createSource([Uri A_uri]) {
    C_p.File A_file = _entry as C_p.File;
    JavaFile javaFile = new JavaFile(A_file.absolute.path);
    if (A_uri == null) {
      A_uri = javaFile.toURI();
    }
    return new FileBasedSource.I_con2(A_uri, javaFile);
  }
}
class _PhysicalFolder extends _PhysicalResource implements Folder {
  _PhysicalFolder(C_p.Directory directory) : super(directory);
  p.Stream<WatchEvent> get changes => new DirectoryWatcher(_entry.path).events;
  String canonicalizePath(String relPath) {
    return normalize(B_join(_entry.absolute.path, relPath));
  }
  bool contains(String A_path) {
    return isWithin(this.path, A_path);
  }
  Resource getChild(String relPath) {
    String canonicalPath = canonicalizePath(relPath);
    return PhysicalResourceProvider.A_INSTANCE.getResource(canonicalPath);
  }
  List<Resource> A_getChildren() {
    List<Resource> children = <Resource>[];
    C_p.Directory directory = _entry as C_p.Directory;
    List<C_p.FileSystemEntity> entries = directory.listSync(recursive: false);
    int numEntries = entries.length;
    for (int i = 0; i < numEntries; i++) {
      C_p.FileSystemEntity entity = entries[i];
      if (entity is C_p.Directory) {
        children.add(new _PhysicalFolder(entity));
      } else if (entity is C_p.File) {
        children.add(new _PhysicalFile(entity));
      }
    }
    return children;
  }
}
abstract class _PhysicalResource implements Resource {
  final C_p.FileSystemEntity _entry;
  _PhysicalResource(this._entry);
  bool get exists => _entry.existsSync();
  get hashCode => path.hashCode;
  Folder get parent {
    String parentPath = dirname(path);
    if (parentPath == path) {
      return null;
    }
    return new _PhysicalFolder(new C_p.Directory(parentPath));
  }
  String get path => _entry.absolute.path;
  String get shortName => basename(path);
  bool operator==(other) {
    if (runtimeType != other.runtimeType) {
      return false;
    }
    return path == other.path;
  }
  String toString() => path;
}
class PackageMapUriResolver extends UriResolver {
  static const String PACKAGE_SCHEME = "package";
  final Map<String, List<Folder>> packageMap;
  final ResourceProvider resourceProvider;
  PackageMapUriResolver(this.resourceProvider, this.packageMap);
  Source resolveAbsolute(Uri A_uri) {
    if (!isPackageUri(A_uri)) {
      return null;
    }
    String A_path = A_uri.path;
    String pkgName;
    String relPath;
    int A_index = A_path.indexOf('/');
    if (A_index == -1 || A_index == 0) {
      return null;
    } else {
      pkgName = A_path.substring(0, A_index);
      relPath = A_path.substring(A_index + 1);
    }
    List<Folder> packageDirs = packageMap[pkgName];
    if (packageDirs != null) {
      for (Folder packageDir in packageDirs) {
        if (packageDir.exists) {
          Resource result = packageDir.getChild(relPath);
          if (result is A_File && result.exists) {
            return result.createSource(A_uri);
          }
        }
      }
    }
    return new NonExistingSource(A_uri.toString(), UriKind.PACKAGE_URI);
  }
  Uri restoreAbsolute(Source A_source) {
    String sourcePath = A_source.fullName;
    for (String pkgName in packageMap.keys) {
      List<Folder> pkgFolders = packageMap[pkgName];
      for (Folder pkgFolder in pkgFolders) {
        String pkgFolderPath = pkgFolder.path;
        if (sourcePath.startsWith(pkgFolderPath)) {
          String relPath = sourcePath.substring(pkgFolderPath.length);
          return new Uri(path: '${PACKAGE_SCHEME}:${pkgName}${relPath}');
        }
      }
    }
    return null;
  }
  static bool isPackageUri(Uri A_uri) {
    return A_uri.scheme == PACKAGE_SCHEME;
  }
}
class AdjacentStrings extends StringLiteral {
  NodeList<StringLiteral> _strings;
  AdjacentStrings(List<StringLiteral> A_strings) {
    this._strings = new NodeList<StringLiteral>(this);
    this._strings.addAll(A_strings);
  }
  accept(AstVisitor visitor) => visitor.visitAdjacentStrings(this);
  A_Token get beginToken => _strings.beginToken;
  A_Token get endToken => _strings.endToken;
  NodeList<StringLiteral> get strings => _strings;
  void visitChildren(AstVisitor visitor) {
    _strings.accept(visitor);
  }
  void appendStringValue(JavaStringBuilder A_builder) {
    for (StringLiteral stringLiteral in strings) {
      stringLiteral.appendStringValue(A_builder);
    }
  }
}
abstract class AnnotatedNode extends AstNode {
  Comment _comment;
  NodeList<Annotation> _metadata;
  AnnotatedNode(Comment comment, List<Annotation> A_metadata) {
    this._metadata = new NodeList<Annotation>(this);
    this._comment = becomeParentOf(comment);
    this._metadata.addAll(A_metadata);
  }
  A_Token get beginToken {
    if (_comment == null) {
      if (_metadata.isEmpty) {
        return firstTokenAfterCommentAndMetadata;
      } else {
        return _metadata.beginToken;
      }
    } else if (_metadata.isEmpty) {
      return _comment.beginToken;
    }
    A_Token commentToken = _comment.beginToken;
    A_Token metadataToken = _metadata.beginToken;
    if (commentToken.offset < metadataToken.offset) {
      return commentToken;
    }
    return metadataToken;
  }
  Comment get documentationComment => _comment;
  NodeList<Annotation> get metadata => _metadata;
  void set metadata(List<Annotation> A_metadata) {
    this._metadata.clear();
    this._metadata.addAll(A_metadata);
  }
  void visitChildren(AstVisitor visitor) {
    if (_commentIsBeforeAnnotations()) {
      safelyVisitChild(_comment, visitor);
      _metadata.accept(visitor);
    } else {
      for (AstNode child in sortedCommentAndAnnotations) {
        child.accept(visitor);
      }
    }
  }
  A_Token get firstTokenAfterCommentAndMetadata;
  bool _commentIsBeforeAnnotations() {
    if (_comment == null || _metadata.isEmpty) {
      return true;
    }
    Annotation firstAnnotation = _metadata[0];
    return _comment.offset < firstAnnotation.offset;
  }
  List<AstNode> get sortedCommentAndAnnotations {
    List<AstNode> childList = new List<AstNode>();
    childList.add(_comment);
    childList.addAll(_metadata);
    List<AstNode> children = new List.from(childList);
    children.sort(AstNode.LEXICAL_ORDER);
    return children;
  }
}
class Annotation extends AstNode {
  A_Token atSign;
  Identifier A__name;
  A_Token period;
  SimpleIdentifier _constructorName;
  ArgumentList A__arguments;
  A_Element C__element;
  ElementAnnotation elementAnnotation;
  Annotation(this.atSign, Identifier A_name, this.period, SimpleIdentifier A_constructorName, ArgumentList A_arguments) {
    this.A__name = becomeParentOf(A_name);
    this._constructorName = becomeParentOf(A_constructorName);
    this.A__arguments = becomeParentOf(A_arguments);
  }
  accept(AstVisitor visitor) => visitor.visitAnnotation(this);
  ArgumentList get arguments => A__arguments;
  A_Token get beginToken => atSign;
  SimpleIdentifier get constructorName => _constructorName;
  A_Element get element {
    if (C__element != null) {
      return C__element;
    }
    if (A__name != null) {
      return A__name.staticElement;
    }
    return null;
  }
  A_Token get endToken {
    if (A__arguments != null) {
      return A__arguments.endToken;
    } else if (_constructorName != null) {
      return _constructorName.endToken;
    }
    return A__name.endToken;
  }
  Identifier get name => A__name;
  void set element(A_Element A_element) {
    this.C__element = A_element;
  }
  void set name(Identifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_constructorName, visitor);
    safelyVisitChild(A__arguments, visitor);
  }
}
class ArgumentList extends AstNode {
  A_Token _leftParenthesis;
  NodeList<Expression> A__arguments;
  A_Token _rightParenthesis;
  List<ParameterElement> _correspondingStaticParameters;
  List<ParameterElement> _correspondingPropagatedParameters;
  ArgumentList(A_Token A_leftParenthesis, List<Expression> A_arguments, A_Token A_rightParenthesis) {
    this.A__arguments = new NodeList<Expression>(this);
    this._leftParenthesis = A_leftParenthesis;
    this.A__arguments.addAll(A_arguments);
    this._rightParenthesis = A_rightParenthesis;
  }
  accept(AstVisitor visitor) => visitor.visitArgumentList(this);
  NodeList<Expression> get arguments => A__arguments;
  A_Token get beginToken => _leftParenthesis;
  A_Token get endToken => _rightParenthesis;
  A_Token get leftParenthesis => _leftParenthesis;
  A_Token get rightParenthesis => _rightParenthesis;
  void set correspondingPropagatedParameters(List<ParameterElement> A_parameters) {
    if (A_parameters.length != A__arguments.length) {
      throw new IllegalArgumentException("Expected ${A__arguments.length} parameters, not ${A_parameters.length}");
    }
    _correspondingPropagatedParameters = A_parameters;
  }
  void set correspondingStaticParameters(List<ParameterElement> A_parameters) {
    if (A_parameters.length != A__arguments.length) {
      throw new IllegalArgumentException("Expected ${A__arguments.length} parameters, not ${A_parameters.length}");
    }
    _correspondingStaticParameters = A_parameters;
  }
  void visitChildren(AstVisitor visitor) {
    A__arguments.accept(visitor);
  }
  ParameterElement getPropagatedParameterElementFor(Expression expression) {
    if (_correspondingPropagatedParameters == null) {
      return null;
    }
    int A_index = A__arguments.indexOf(expression);
    if (A_index < 0) {
      return null;
    }
    return _correspondingPropagatedParameters[A_index];
  }
  ParameterElement getStaticParameterElementFor(Expression expression) {
    if (_correspondingStaticParameters == null) {
      return null;
    }
    int A_index = A__arguments.indexOf(expression);
    if (A_index < 0) {
      return null;
    }
    return _correspondingStaticParameters[A_index];
  }
}
class AsExpression extends Expression {
  Expression _expression;
  A_Token asOperator;
  TypeName A__type;
  AsExpression(Expression A_expression, A_Token isOperator, TypeName A_type) {
    this._expression = becomeParentOf(A_expression);
    this.asOperator = isOperator;
    this.A__type = becomeParentOf(A_type);
  }
  accept(AstVisitor visitor) => visitor.visitAsExpression(this);
  A_Token get beginToken => _expression.beginToken;
  A_Token get endToken => A__type.endToken;
  Expression get expression => _expression;
  int get precedence => 7;
  TypeName get type => A__type;
  void set type(TypeName A_name) {
    this.A__type = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
    safelyVisitChild(A__type, visitor);
  }
}
class AssertStatement extends Statement {
  A_Token keyword;
  A_Token leftParenthesis;
  Expression _condition;
  A_Token rightParenthesis;
  A_Token semicolon;
  AssertStatement(this.keyword, this.leftParenthesis, Expression A_condition, this.rightParenthesis, this.semicolon) {
    this._condition = becomeParentOf(A_condition);
  }
  accept(AstVisitor visitor) => visitor.visitAssertStatement(this);
  A_Token get beginToken => keyword;
  Expression get condition => _condition;
  A_Token get endToken => semicolon;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_condition, visitor);
  }
}
class AssignmentExpression extends Expression {
  Expression _leftHandSide;
  A_Token operator;
  Expression _rightHandSide;
  MethodElement _staticElement;
  MethodElement _propagatedElement;
  AssignmentExpression(Expression A_leftHandSide, this.operator, Expression A_rightHandSide) {
    if (A_leftHandSide == null || A_rightHandSide == null) {
      String A_message;
      if (A_leftHandSide == null) {
        if (A_rightHandSide == null) {
          A_message = "Both the left-hand and right-hand sides are null";
        } else {
          A_message = "The left-hand size is null";
        }
      } else {
        A_message = "The right-hand size is null";
      }
      AnalysisEngine.A_instance.logger.logError2(A_message, new JavaException(A_message));
    }
    this._leftHandSide = becomeParentOf(A_leftHandSide);
    this._rightHandSide = becomeParentOf(A_rightHandSide);
  }
  accept(AstVisitor visitor) => visitor.visitAssignmentExpression(this);
  A_Token get beginToken => _leftHandSide.beginToken;
  MethodElement get bestElement {
    MethodElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => _rightHandSide.endToken;
  Expression get leftHandSide => _leftHandSide;
  int get precedence => 1;
  MethodElement get propagatedElement => _propagatedElement;
  Expression get rightHandSide => _rightHandSide;
  MethodElement get staticElement => _staticElement;
  void set propagatedElement(MethodElement A_element) {
    _propagatedElement = A_element;
  }
  void set staticElement(MethodElement A_element) {
    _staticElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_leftHandSide, visitor);
    safelyVisitChild(_rightHandSide, visitor);
  }
  ParameterElement get propagatedParameterElementForRightHandSide {
    if (_propagatedElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _propagatedElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
  ParameterElement get staticParameterElementForRightHandSide {
    if (_staticElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _staticElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
}
class AstCloner implements AstVisitor<AstNode> {
  List cloneNodeList(NodeList nodes) {
    int count = nodes.length;
    List clonedNodes = new List();
    for (int i = 0; i < count; i++) {
      clonedNodes.add((nodes[i]).accept(this) as AstNode);
    }
    return clonedNodes;
  }
  AdjacentStrings visitAdjacentStrings(AdjacentStrings node) => new AdjacentStrings(cloneNodeList(node.strings));
  Annotation visitAnnotation(Annotation node) => new Annotation(node.atSign, cloneNode(node.name), node.period, cloneNode(node.constructorName), cloneNode(node.arguments));
  ArgumentList visitArgumentList(ArgumentList node) => new ArgumentList(node.leftParenthesis, cloneNodeList(node.arguments), node.rightParenthesis);
  AsExpression visitAsExpression(AsExpression node) => new AsExpression(cloneNode(node.expression), node.asOperator, cloneNode(node.type));
  AstNode visitAssertStatement(AssertStatement node) => new AssertStatement(node.keyword, node.leftParenthesis, cloneNode(node.condition), node.rightParenthesis, node.semicolon);
  AssignmentExpression visitAssignmentExpression(AssignmentExpression node) => new AssignmentExpression(cloneNode(node.leftHandSide), node.operator, cloneNode(node.rightHandSide));
  AwaitExpression visitAwaitExpression(AwaitExpression node) => new AwaitExpression(node.awaitKeyword, node.expression, node.semicolon);
  BinaryExpression visitBinaryExpression(BinaryExpression node) => new BinaryExpression(cloneNode(node.leftOperand), node.operator, cloneNode(node.rightOperand));
  Block visitBlock(Block node) => new Block(node.leftBracket, cloneNodeList(node.statements), node.rightBracket);
  BlockFunctionBody visitBlockFunctionBody(BlockFunctionBody node) => new BlockFunctionBody(node.keyword, node.star, cloneNode(node.block));
  BooleanLiteral visitBooleanLiteral(BooleanLiteral node) => new BooleanLiteral(node.literal, node.value);
  BreakStatement visitBreakStatement(BreakStatement node) => new BreakStatement(node.keyword, cloneNode(node.label), node.semicolon);
  CascadeExpression visitCascadeExpression(CascadeExpression node) => new CascadeExpression(cloneNode(node.target), cloneNodeList(node.cascadeSections));
  CatchClause visitCatchClause(CatchClause node) => new CatchClause(node.onKeyword, cloneNode(node.exceptionType), node.catchKeyword, node.leftParenthesis, cloneNode(node.exceptionParameter), node.comma, cloneNode(node.stackTraceParameter), node.rightParenthesis, cloneNode(node.body));
  ClassDeclaration visitClassDeclaration(ClassDeclaration node) {
    ClassDeclaration A_copy = new ClassDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.abstractKeyword, node.classKeyword, cloneNode(node.name), cloneNode(node.typeParameters), cloneNode(node.extendsClause), cloneNode(node.withClause), cloneNode(node.implementsClause), node.leftBracket, cloneNodeList(node.members), node.rightBracket);
    A_copy.nativeClause = cloneNode(node.nativeClause);
    return A_copy;
  }
  ClassTypeAlias visitClassTypeAlias(ClassTypeAlias node) => new ClassTypeAlias(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.name), cloneNode(node.typeParameters), node.A_equals, node.abstractKeyword, cloneNode(node.superclass), cloneNode(node.withClause), cloneNode(node.implementsClause), node.semicolon);
  Comment visitComment(Comment node) {
    if (node.isDocumentation) {
      return Comment.createDocumentationCommentWithReferences(node.tokens, cloneNodeList(node.references));
    } else if (node.isBlock) {
      return Comment.createBlockComment(node.tokens);
    }
    return Comment.createEndOfLineComment(node.tokens);
  }
  CommentReference visitCommentReference(CommentReference node) => new CommentReference(node.newKeyword, cloneNode(node.identifier));
  CompilationUnit visitCompilationUnit(CompilationUnit node) {
    CompilationUnit clone = new CompilationUnit(node.beginToken, cloneNode(node.scriptTag), cloneNodeList(node.directives), cloneNodeList(node.declarations), node.endToken);
    clone.lineInfo = node.lineInfo;
    return clone;
  }
  ConditionalExpression visitConditionalExpression(ConditionalExpression node) => new ConditionalExpression(cloneNode(node.condition), node.question, cloneNode(node.thenExpression), node.colon, cloneNode(node.elseExpression));
  ConstructorDeclaration visitConstructorDeclaration(ConstructorDeclaration node) => new ConstructorDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.externalKeyword, node.constKeyword, node.factoryKeyword, cloneNode(node.returnType), node.period, cloneNode(node.name), cloneNode(node.parameters), node.A_separator, cloneNodeList(node.initializers), cloneNode(node.redirectedConstructor), cloneNode(node.body));
  ConstructorFieldInitializer visitConstructorFieldInitializer(ConstructorFieldInitializer node) => new ConstructorFieldInitializer(node.keyword, node.period, cloneNode(node.fieldName), node.A_equals, cloneNode(node.expression));
  ConstructorName visitConstructorName(ConstructorName node) => new ConstructorName(cloneNode(node.type), node.period, cloneNode(node.name));
  ContinueStatement visitContinueStatement(ContinueStatement node) => new ContinueStatement(node.keyword, cloneNode(node.label), node.semicolon);
  DeclaredIdentifier visitDeclaredIdentifier(DeclaredIdentifier node) => new DeclaredIdentifier(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.type), cloneNode(node.identifier));
  DefaultFormalParameter visitDefaultFormalParameter(DefaultFormalParameter node) => new DefaultFormalParameter(cloneNode(node.parameter), node.kind, node.A_separator, cloneNode(node.defaultValue));
  DoStatement visitDoStatement(DoStatement node) => new DoStatement(node.doKeyword, cloneNode(node.body), node.whileKeyword, node.leftParenthesis, cloneNode(node.condition), node.rightParenthesis, node.semicolon);
  DoubleLiteral visitDoubleLiteral(DoubleLiteral node) => new DoubleLiteral(node.literal, node.value);
  EmptyFunctionBody visitEmptyFunctionBody(EmptyFunctionBody node) => new EmptyFunctionBody(node.semicolon);
  EmptyStatement visitEmptyStatement(EmptyStatement node) => new EmptyStatement(node.semicolon);
  AstNode visitEnumConstantDeclaration(EnumConstantDeclaration node) => new EnumConstantDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), cloneNode(node.name));
  EnumDeclaration visitEnumDeclaration(EnumDeclaration node) => new EnumDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.name), node.leftBracket, cloneNodeList(node.constants), node.rightBracket);
  ExportDirective visitExportDirective(ExportDirective node) {
    ExportDirective directive = new ExportDirective(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.uri), cloneNodeList(node.combinators), node.semicolon);
    directive.source = node.source;
    directive.uriContent = node.uriContent;
    return directive;
  }
  ExpressionFunctionBody visitExpressionFunctionBody(ExpressionFunctionBody node) => new ExpressionFunctionBody(node.keyword, node.functionDefinition, cloneNode(node.expression), node.semicolon);
  ExpressionStatement visitExpressionStatement(ExpressionStatement node) => new ExpressionStatement(cloneNode(node.expression), node.semicolon);
  ExtendsClause visitExtendsClause(ExtendsClause node) => new ExtendsClause(node.keyword, cloneNode(node.superclass));
  FieldDeclaration visitFieldDeclaration(FieldDeclaration node) => new FieldDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.staticKeyword, cloneNode(node.fields), node.semicolon);
  FieldFormalParameter visitFieldFormalParameter(FieldFormalParameter node) => new FieldFormalParameter(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.type), node.thisToken, node.period, cloneNode(node.identifier), cloneNode(node.parameters));
  ForEachStatement visitForEachStatement(ForEachStatement node) {
    DeclaredIdentifier loopVariable = node.loopVariable;
    if (loopVariable == null) {
      return new ForEachStatement.con2(node.awaitKeyword, node.forKeyword, node.leftParenthesis, cloneNode(node.identifier), node.inKeyword, cloneNode(node.iterator), node.rightParenthesis, cloneNode(node.body));
    }
    return new ForEachStatement.con1(node.awaitKeyword, node.forKeyword, node.leftParenthesis, cloneNode(loopVariable), node.inKeyword, cloneNode(node.iterator), node.rightParenthesis, cloneNode(node.body));
  }
  FormalParameterList visitFormalParameterList(FormalParameterList node) => new FormalParameterList(node.leftParenthesis, cloneNodeList(node.parameters), node.leftDelimiter, node.rightDelimiter, node.rightParenthesis);
  ForStatement visitForStatement(ForStatement node) => new ForStatement(node.forKeyword, node.leftParenthesis, cloneNode(node.variables), cloneNode(node.initialization), node.leftSeparator, cloneNode(node.condition), node.rightSeparator, cloneNodeList(node.updaters), node.rightParenthesis, cloneNode(node.body));
  FunctionDeclaration visitFunctionDeclaration(FunctionDeclaration node) => new FunctionDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.externalKeyword, cloneNode(node.returnType), node.propertyKeyword, cloneNode(node.name), cloneNode(node.functionExpression));
  FunctionDeclarationStatement visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => new FunctionDeclarationStatement(cloneNode(node.functionDeclaration));
  FunctionExpression visitFunctionExpression(FunctionExpression node) => new FunctionExpression(cloneNode(node.parameters), cloneNode(node.body));
  FunctionExpressionInvocation visitFunctionExpressionInvocation(FunctionExpressionInvocation node) => new FunctionExpressionInvocation(cloneNode(node.function), cloneNode(node.argumentList));
  FunctionTypeAlias visitFunctionTypeAlias(FunctionTypeAlias node) => new FunctionTypeAlias(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.returnType), cloneNode(node.name), cloneNode(node.typeParameters), cloneNode(node.parameters), node.semicolon);
  FunctionTypedFormalParameter visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) => new FunctionTypedFormalParameter(cloneNode(node.documentationComment), cloneNodeList(node.metadata), cloneNode(node.returnType), cloneNode(node.identifier), cloneNode(node.parameters));
  HideCombinator visitHideCombinator(HideCombinator node) => new HideCombinator(node.keyword, cloneNodeList(node.hiddenNames));
  IfStatement visitIfStatement(IfStatement node) => new IfStatement(node.ifKeyword, node.leftParenthesis, cloneNode(node.condition), node.rightParenthesis, cloneNode(node.thenStatement), node.elseKeyword, cloneNode(node.elseStatement));
  ImplementsClause visitImplementsClause(ImplementsClause node) => new ImplementsClause(node.keyword, cloneNodeList(node.interfaces));
  ImportDirective visitImportDirective(ImportDirective node) {
    ImportDirective directive = new ImportDirective(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.uri), node.deferredToken, node.asToken, cloneNode(node.prefix), cloneNodeList(node.combinators), node.semicolon);
    directive.source = node.source;
    directive.uriContent = node.uriContent;
    return directive;
  }
  IndexExpression visitIndexExpression(IndexExpression node) {
    A_Token period = node.period;
    if (period == null) {
      return new IndexExpression.forTarget(cloneNode(node.target), node.leftBracket, cloneNode(node.index), node.rightBracket);
    } else {
      return new IndexExpression.forCascade(period, node.leftBracket, cloneNode(node.index), node.rightBracket);
    }
  }
  InstanceCreationExpression visitInstanceCreationExpression(InstanceCreationExpression node) => new InstanceCreationExpression(node.keyword, cloneNode(node.constructorName), cloneNode(node.argumentList));
  IntegerLiteral visitIntegerLiteral(IntegerLiteral node) => new IntegerLiteral(node.literal, node.value);
  InterpolationExpression visitInterpolationExpression(InterpolationExpression node) => new InterpolationExpression(node.leftBracket, cloneNode(node.expression), node.rightBracket);
  InterpolationString visitInterpolationString(InterpolationString node) => new InterpolationString(node.contents, node.value);
  IsExpression visitIsExpression(IsExpression node) => new IsExpression(cloneNode(node.expression), node.isOperator, node.notOperator, cloneNode(node.type));
  Label visitLabel(Label node) => new Label(cloneNode(node.label), node.colon);
  LabeledStatement visitLabeledStatement(LabeledStatement node) => new LabeledStatement(cloneNodeList(node.labels), cloneNode(node.statement));
  LibraryDirective visitLibraryDirective(LibraryDirective node) => new LibraryDirective(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.libraryToken, cloneNode(node.name), node.semicolon);
  LibraryIdentifier visitLibraryIdentifier(LibraryIdentifier node) => new LibraryIdentifier(cloneNodeList(node.components));
  ListLiteral visitListLiteral(ListLiteral node) => new ListLiteral(node.constKeyword, cloneNode(node.typeArguments), node.leftBracket, cloneNodeList(node.elements), node.rightBracket);
  MapLiteral visitMapLiteral(MapLiteral node) => new MapLiteral(node.constKeyword, cloneNode(node.typeArguments), node.leftBracket, cloneNodeList(node.entries), node.rightBracket);
  MapLiteralEntry visitMapLiteralEntry(MapLiteralEntry node) => new MapLiteralEntry(cloneNode(node.key), node.A_separator, cloneNode(node.value));
  MethodDeclaration visitMethodDeclaration(MethodDeclaration node) => new MethodDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.externalKeyword, node.modifierKeyword, cloneNode(node.returnType), node.propertyKeyword, node.operatorKeyword, cloneNode(node.name), cloneNode(node.parameters), cloneNode(node.body));
  MethodInvocation visitMethodInvocation(MethodInvocation node) => new MethodInvocation(cloneNode(node.target), node.period, cloneNode(node.methodName), cloneNode(node.argumentList));
  NamedExpression visitNamedExpression(NamedExpression node) => new NamedExpression(cloneNode(node.name), cloneNode(node.expression));
  AstNode visitNativeClause(NativeClause node) => new NativeClause(node.keyword, cloneNode(node.name));
  NativeFunctionBody visitNativeFunctionBody(NativeFunctionBody node) => new NativeFunctionBody(node.nativeToken, cloneNode(node.stringLiteral), node.semicolon);
  NullLiteral visitNullLiteral(NullLiteral node) => new NullLiteral(node.literal);
  ParenthesizedExpression visitParenthesizedExpression(ParenthesizedExpression node) => new ParenthesizedExpression(node.leftParenthesis, cloneNode(node.expression), node.rightParenthesis);
  PartDirective visitPartDirective(PartDirective node) {
    PartDirective directive = new PartDirective(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.partToken, cloneNode(node.uri), node.semicolon);
    directive.source = node.source;
    directive.uriContent = node.uriContent;
    return directive;
  }
  PartOfDirective visitPartOfDirective(PartOfDirective node) => new PartOfDirective(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.partToken, node.ofToken, cloneNode(node.libraryName), node.semicolon);
  PostfixExpression visitPostfixExpression(PostfixExpression node) => new PostfixExpression(cloneNode(node.operand), node.operator);
  PrefixedIdentifier visitPrefixedIdentifier(PrefixedIdentifier node) => new PrefixedIdentifier(cloneNode(node.prefix), node.period, cloneNode(node.identifier));
  PrefixExpression visitPrefixExpression(PrefixExpression node) => new PrefixExpression(node.operator, cloneNode(node.operand));
  PropertyAccess visitPropertyAccess(PropertyAccess node) => new PropertyAccess(cloneNode(node.target), node.operator, cloneNode(node.propertyName));
  RedirectingConstructorInvocation visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) => new RedirectingConstructorInvocation(node.keyword, node.period, cloneNode(node.constructorName), cloneNode(node.argumentList));
  RethrowExpression visitRethrowExpression(RethrowExpression node) => new RethrowExpression(node.keyword);
  ReturnStatement visitReturnStatement(ReturnStatement node) => new ReturnStatement(node.keyword, cloneNode(node.expression), node.semicolon);
  ScriptTag visitScriptTag(ScriptTag node) => new ScriptTag(node.scriptTag);
  ShowCombinator visitShowCombinator(ShowCombinator node) => new ShowCombinator(node.keyword, cloneNodeList(node.shownNames));
  SimpleFormalParameter visitSimpleFormalParameter(SimpleFormalParameter node) => new SimpleFormalParameter(cloneNode(node.documentationComment), cloneNodeList(node.metadata), node.keyword, cloneNode(node.type), cloneNode(node.identifier));
  SimpleIdentifier visitSimpleIdentifier(SimpleIdentifier node) => new SimpleIdentifier(node.token);
  SimpleStringLiteral visitSimpleStringLiteral(SimpleStringLiteral node) => new SimpleStringLiteral(node.literal, node.value);
  StringInterpolation visitStringInterpolation(StringInterpolation node) => new StringInterpolation(cloneNodeList(node.elements));
  SuperConstructorInvocation visitSuperConstructorInvocation(SuperConstructorInvocation node) => new SuperConstructorInvocation(node.keyword, node.period, cloneNode(node.constructorName), cloneNode(node.argumentList));
  SuperExpression visitSuperExpression(SuperExpression node) => new SuperExpression(node.keyword);
  SwitchCase visitSwitchCase(SwitchCase node) => new SwitchCase(cloneNodeList(node.labels), node.keyword, cloneNode(node.expression), node.colon, cloneNodeList(node.statements));
  SwitchDefault visitSwitchDefault(SwitchDefault node) => new SwitchDefault(cloneNodeList(node.labels), node.keyword, node.colon, cloneNodeList(node.statements));
  SwitchStatement visitSwitchStatement(SwitchStatement node) => new SwitchStatement(node.keyword, node.leftParenthesis, cloneNode(node.expression), node.rightParenthesis, node.leftBracket, cloneNodeList(node.members), node.rightBracket);
  SymbolLiteral visitSymbolLiteral(SymbolLiteral node) => new SymbolLiteral(node.poundSign, node.components);
  ThisExpression visitThisExpression(ThisExpression node) => new ThisExpression(node.keyword);
  ThrowExpression visitThrowExpression(ThrowExpression node) => new ThrowExpression(node.keyword, cloneNode(node.expression));
  TopLevelVariableDeclaration visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) => new TopLevelVariableDeclaration(cloneNode(node.documentationComment), cloneNodeList(node.metadata), cloneNode(node.variables), node.semicolon);
  TryStatement visitTryStatement(TryStatement node) => new TryStatement(node.tryKeyword, cloneNode(node.body), cloneNodeList(node.catchClauses), node.finallyKeyword, cloneNode(node.finallyBlock));
  TypeArgumentList visitTypeArgumentList(TypeArgumentList node) => new TypeArgumentList(node.leftBracket, cloneNodeList(node.arguments), node.rightBracket);
  TypeName visitTypeName(TypeName node) => new TypeName(cloneNode(node.name), cloneNode(node.typeArguments));
  TypeParameter visitTypeParameter(TypeParameter node) => new TypeParameter(cloneNode(node.documentationComment), cloneNodeList(node.metadata), cloneNode(node.name), node.keyword, cloneNode(node.bound));
  TypeParameterList visitTypeParameterList(TypeParameterList node) => new TypeParameterList(node.leftBracket, cloneNodeList(node.typeParameters), node.rightBracket);
  VariableDeclaration visitVariableDeclaration(VariableDeclaration node) => new VariableDeclaration(null, cloneNodeList(node.metadata), cloneNode(node.name), node.A_equals, cloneNode(node.initializer));
  VariableDeclarationList visitVariableDeclarationList(VariableDeclarationList node) => new VariableDeclarationList(null, cloneNodeList(node.metadata), node.keyword, cloneNode(node.type), cloneNodeList(node.variables));
  VariableDeclarationStatement visitVariableDeclarationStatement(VariableDeclarationStatement node) => new VariableDeclarationStatement(cloneNode(node.variables), node.semicolon);
  WhileStatement visitWhileStatement(WhileStatement node) => new WhileStatement(node.keyword, node.leftParenthesis, cloneNode(node.condition), node.rightParenthesis, cloneNode(node.body));
  WithClause visitWithClause(WithClause node) => new WithClause(node.withKeyword, cloneNodeList(node.mixinTypes));
  YieldStatement visitYieldStatement(YieldStatement node) => new YieldStatement(node.yieldKeyword, node.star, node.expression, node.semicolon);
  AstNode cloneNode(AstNode node) {
    if (node == null) {
      return null;
    }
    return node.accept(this) as AstNode;
  }
}
class AstComparator implements AstVisitor<bool> {
  static bool equalNodes(AstNode A_first, AstNode A_second) {
    AstComparator comparator = new AstComparator();
    return comparator._isEqualNodes(A_first, A_second);
  }
  AstNode _other;
  bool visitAdjacentStrings(AdjacentStrings node) {
    AdjacentStrings other = this._other as AdjacentStrings;
    return _isEqualNodeLists(node.strings, other.strings);
  }
  bool visitAnnotation(Annotation node) {
    Annotation other = this._other as Annotation;
    return _isEqualTokens(node.atSign, other.atSign) && _isEqualNodes(node.name, other.name) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.constructorName, other.constructorName) && _isEqualNodes(node.arguments, other.arguments);
  }
  bool visitArgumentList(ArgumentList node) {
    ArgumentList other = this._other as ArgumentList;
    return _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodeLists(node.arguments, other.arguments) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis);
  }
  bool visitAsExpression(AsExpression node) {
    AsExpression other = this._other as AsExpression;
    return _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.asOperator, other.asOperator) && _isEqualNodes(node.type, other.type);
  }
  bool visitAssertStatement(AssertStatement node) {
    AssertStatement other = this._other as AssertStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitAssignmentExpression(AssignmentExpression node) {
    AssignmentExpression other = this._other as AssignmentExpression;
    return _isEqualNodes(node.leftHandSide, other.leftHandSide) && _isEqualTokens(node.operator, other.operator) && _isEqualNodes(node.rightHandSide, other.rightHandSide);
  }
  bool visitAwaitExpression(AwaitExpression node) {
    AwaitExpression other = this._other as AwaitExpression;
    return _isEqualTokens(node.awaitKeyword, other.awaitKeyword) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitBinaryExpression(BinaryExpression node) {
    BinaryExpression other = this._other as BinaryExpression;
    return _isEqualNodes(node.leftOperand, other.leftOperand) && _isEqualTokens(node.operator, other.operator) && _isEqualNodes(node.rightOperand, other.rightOperand);
  }
  bool visitBlock(Block node) {
    Block other = this._other as Block;
    return _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.statements, other.statements) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitBlockFunctionBody(BlockFunctionBody node) {
    BlockFunctionBody other = this._other as BlockFunctionBody;
    return _isEqualNodes(node.block, other.block);
  }
  bool visitBooleanLiteral(BooleanLiteral node) {
    BooleanLiteral other = this._other as BooleanLiteral;
    return _isEqualTokens(node.literal, other.literal) && node.value == other.value;
  }
  bool visitBreakStatement(BreakStatement node) {
    BreakStatement other = this._other as BreakStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.label, other.label) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitCascadeExpression(CascadeExpression node) {
    CascadeExpression other = this._other as CascadeExpression;
    return _isEqualNodes(node.target, other.target) && _isEqualNodeLists(node.cascadeSections, other.cascadeSections);
  }
  bool visitCatchClause(CatchClause node) {
    CatchClause other = this._other as CatchClause;
    return _isEqualTokens(node.onKeyword, other.onKeyword) && _isEqualNodes(node.exceptionType, other.exceptionType) && _isEqualTokens(node.catchKeyword, other.catchKeyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.exceptionParameter, other.exceptionParameter) && _isEqualTokens(node.comma, other.comma) && _isEqualNodes(node.stackTraceParameter, other.stackTraceParameter) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualNodes(node.body, other.body);
  }
  bool visitClassDeclaration(ClassDeclaration node) {
    ClassDeclaration other = this._other as ClassDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.abstractKeyword, other.abstractKeyword) && _isEqualTokens(node.classKeyword, other.classKeyword) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.typeParameters, other.typeParameters) && _isEqualNodes(node.extendsClause, other.extendsClause) && _isEqualNodes(node.withClause, other.withClause) && _isEqualNodes(node.implementsClause, other.implementsClause) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.members, other.members) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitClassTypeAlias(ClassTypeAlias node) {
    ClassTypeAlias other = this._other as ClassTypeAlias;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.typeParameters, other.typeParameters) && _isEqualTokens(node.A_equals, other.A_equals) && _isEqualTokens(node.abstractKeyword, other.abstractKeyword) && _isEqualNodes(node.superclass, other.superclass) && _isEqualNodes(node.withClause, other.withClause) && _isEqualNodes(node.implementsClause, other.implementsClause) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitComment(Comment node) {
    Comment other = this._other as Comment;
    return _isEqualNodeLists(node.references, other.references);
  }
  bool visitCommentReference(CommentReference node) {
    CommentReference other = this._other as CommentReference;
    return _isEqualTokens(node.newKeyword, other.newKeyword) && _isEqualNodes(node.identifier, other.identifier);
  }
  bool visitCompilationUnit(CompilationUnit node) {
    CompilationUnit other = this._other as CompilationUnit;
    return _isEqualTokens(node.beginToken, other.beginToken) && _isEqualNodes(node.scriptTag, other.scriptTag) && _isEqualNodeLists(node.directives, other.directives) && _isEqualNodeLists(node.declarations, other.declarations) && _isEqualTokens(node.endToken, other.endToken);
  }
  bool visitConditionalExpression(ConditionalExpression node) {
    ConditionalExpression other = this._other as ConditionalExpression;
    return _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.question, other.question) && _isEqualNodes(node.thenExpression, other.thenExpression) && _isEqualTokens(node.colon, other.colon) && _isEqualNodes(node.elseExpression, other.elseExpression);
  }
  bool visitConstructorDeclaration(ConstructorDeclaration node) {
    ConstructorDeclaration other = this._other as ConstructorDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.externalKeyword, other.externalKeyword) && _isEqualTokens(node.constKeyword, other.constKeyword) && _isEqualTokens(node.factoryKeyword, other.factoryKeyword) && _isEqualNodes(node.returnType, other.returnType) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.parameters, other.parameters) && _isEqualTokens(node.A_separator, other.A_separator) && _isEqualNodeLists(node.initializers, other.initializers) && _isEqualNodes(node.redirectedConstructor, other.redirectedConstructor) && _isEqualNodes(node.body, other.body);
  }
  bool visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    ConstructorFieldInitializer other = this._other as ConstructorFieldInitializer;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.fieldName, other.fieldName) && _isEqualTokens(node.A_equals, other.A_equals) && _isEqualNodes(node.expression, other.expression);
  }
  bool visitConstructorName(ConstructorName node) {
    ConstructorName other = this._other as ConstructorName;
    return _isEqualNodes(node.type, other.type) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.name, other.name);
  }
  bool visitContinueStatement(ContinueStatement node) {
    ContinueStatement other = this._other as ContinueStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.label, other.label) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitDeclaredIdentifier(DeclaredIdentifier node) {
    DeclaredIdentifier other = this._other as DeclaredIdentifier;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.type, other.type) && _isEqualNodes(node.identifier, other.identifier);
  }
  bool visitDefaultFormalParameter(DefaultFormalParameter node) {
    DefaultFormalParameter other = this._other as DefaultFormalParameter;
    return _isEqualNodes(node.parameter, other.parameter) && node.kind == other.kind && _isEqualTokens(node.A_separator, other.A_separator) && _isEqualNodes(node.defaultValue, other.defaultValue);
  }
  bool visitDoStatement(DoStatement node) {
    DoStatement other = this._other as DoStatement;
    return _isEqualTokens(node.doKeyword, other.doKeyword) && _isEqualNodes(node.body, other.body) && _isEqualTokens(node.whileKeyword, other.whileKeyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitDoubleLiteral(DoubleLiteral node) {
    DoubleLiteral other = this._other as DoubleLiteral;
    return _isEqualTokens(node.literal, other.literal) && node.value == other.value;
  }
  bool visitEmptyFunctionBody(EmptyFunctionBody node) {
    EmptyFunctionBody other = this._other as EmptyFunctionBody;
    return _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitEmptyStatement(EmptyStatement node) {
    EmptyStatement other = this._other as EmptyStatement;
    return _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    EnumConstantDeclaration other = this._other as EnumConstantDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualNodes(node.name, other.name);
  }
  bool visitEnumDeclaration(EnumDeclaration node) {
    EnumDeclaration other = this._other as EnumDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.name, other.name) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.constants, other.constants) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitExportDirective(ExportDirective node) {
    ExportDirective other = this._other as ExportDirective;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.uri, other.uri) && _isEqualNodeLists(node.combinators, other.combinators) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitExpressionFunctionBody(ExpressionFunctionBody node) {
    ExpressionFunctionBody other = this._other as ExpressionFunctionBody;
    return _isEqualTokens(node.functionDefinition, other.functionDefinition) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitExpressionStatement(ExpressionStatement node) {
    ExpressionStatement other = this._other as ExpressionStatement;
    return _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitExtendsClause(ExtendsClause node) {
    ExtendsClause other = this._other as ExtendsClause;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.superclass, other.superclass);
  }
  bool visitFieldDeclaration(FieldDeclaration node) {
    FieldDeclaration other = this._other as FieldDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.staticKeyword, other.staticKeyword) && _isEqualNodes(node.fields, other.fields) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitFieldFormalParameter(FieldFormalParameter node) {
    FieldFormalParameter other = this._other as FieldFormalParameter;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.type, other.type) && _isEqualTokens(node.thisToken, other.thisToken) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.identifier, other.identifier);
  }
  bool visitForEachStatement(ForEachStatement node) {
    ForEachStatement other = this._other as ForEachStatement;
    return _isEqualTokens(node.forKeyword, other.forKeyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.loopVariable, other.loopVariable) && _isEqualTokens(node.inKeyword, other.inKeyword) && _isEqualNodes(node.iterator, other.iterator) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualNodes(node.body, other.body);
  }
  bool visitFormalParameterList(FormalParameterList node) {
    FormalParameterList other = this._other as FormalParameterList;
    return _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodeLists(node.parameters, other.parameters) && _isEqualTokens(node.leftDelimiter, other.leftDelimiter) && _isEqualTokens(node.rightDelimiter, other.rightDelimiter) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis);
  }
  bool visitForStatement(ForStatement node) {
    ForStatement other = this._other as ForStatement;
    return _isEqualTokens(node.forKeyword, other.forKeyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.variables, other.variables) && _isEqualNodes(node.initialization, other.initialization) && _isEqualTokens(node.leftSeparator, other.leftSeparator) && _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.rightSeparator, other.rightSeparator) && _isEqualNodeLists(node.updaters, other.updaters) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualNodes(node.body, other.body);
  }
  bool visitFunctionDeclaration(FunctionDeclaration node) {
    FunctionDeclaration other = this._other as FunctionDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.externalKeyword, other.externalKeyword) && _isEqualNodes(node.returnType, other.returnType) && _isEqualTokens(node.propertyKeyword, other.propertyKeyword) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.functionExpression, other.functionExpression);
  }
  bool visitFunctionDeclarationStatement(FunctionDeclarationStatement node) {
    FunctionDeclarationStatement other = this._other as FunctionDeclarationStatement;
    return _isEqualNodes(node.functionDeclaration, other.functionDeclaration);
  }
  bool visitFunctionExpression(FunctionExpression node) {
    FunctionExpression other = this._other as FunctionExpression;
    return _isEqualNodes(node.parameters, other.parameters) && _isEqualNodes(node.body, other.body);
  }
  bool visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    FunctionExpressionInvocation other = this._other as FunctionExpressionInvocation;
    return _isEqualNodes(node.function, other.function) && _isEqualNodes(node.argumentList, other.argumentList);
  }
  bool visitFunctionTypeAlias(FunctionTypeAlias node) {
    FunctionTypeAlias other = this._other as FunctionTypeAlias;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.returnType, other.returnType) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.typeParameters, other.typeParameters) && _isEqualNodes(node.parameters, other.parameters) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    FunctionTypedFormalParameter other = this._other as FunctionTypedFormalParameter;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualNodes(node.returnType, other.returnType) && _isEqualNodes(node.identifier, other.identifier) && _isEqualNodes(node.parameters, other.parameters);
  }
  bool visitHideCombinator(HideCombinator node) {
    HideCombinator other = this._other as HideCombinator;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodeLists(node.hiddenNames, other.hiddenNames);
  }
  bool visitIfStatement(IfStatement node) {
    IfStatement other = this._other as IfStatement;
    return _isEqualTokens(node.ifKeyword, other.ifKeyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualNodes(node.thenStatement, other.thenStatement) && _isEqualTokens(node.elseKeyword, other.elseKeyword) && _isEqualNodes(node.elseStatement, other.elseStatement);
  }
  bool visitImplementsClause(ImplementsClause node) {
    ImplementsClause other = this._other as ImplementsClause;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodeLists(node.interfaces, other.interfaces);
  }
  bool visitImportDirective(ImportDirective node) {
    ImportDirective other = this._other as ImportDirective;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.uri, other.uri) && _isEqualTokens(node.asToken, other.asToken) && _isEqualNodes(node.prefix, other.prefix) && _isEqualNodeLists(node.combinators, other.combinators) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitIndexExpression(IndexExpression node) {
    IndexExpression other = this._other as IndexExpression;
    return _isEqualNodes(node.target, other.target) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodes(node.index, other.index) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitInstanceCreationExpression(InstanceCreationExpression node) {
    InstanceCreationExpression other = this._other as InstanceCreationExpression;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.constructorName, other.constructorName) && _isEqualNodes(node.argumentList, other.argumentList);
  }
  bool visitIntegerLiteral(IntegerLiteral node) {
    IntegerLiteral other = this._other as IntegerLiteral;
    return _isEqualTokens(node.literal, other.literal) && (node.value == other.value);
  }
  bool visitInterpolationExpression(InterpolationExpression node) {
    InterpolationExpression other = this._other as InterpolationExpression;
    return _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitInterpolationString(InterpolationString node) {
    InterpolationString other = this._other as InterpolationString;
    return _isEqualTokens(node.contents, other.contents) && node.value == other.value;
  }
  bool visitIsExpression(IsExpression node) {
    IsExpression other = this._other as IsExpression;
    return _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.isOperator, other.isOperator) && _isEqualTokens(node.notOperator, other.notOperator) && _isEqualNodes(node.type, other.type);
  }
  bool visitLabel(Label node) {
    Label other = this._other as Label;
    return _isEqualNodes(node.label, other.label) && _isEqualTokens(node.colon, other.colon);
  }
  bool visitLabeledStatement(LabeledStatement node) {
    LabeledStatement other = this._other as LabeledStatement;
    return _isEqualNodeLists(node.labels, other.labels) && _isEqualNodes(node.statement, other.statement);
  }
  bool visitLibraryDirective(LibraryDirective node) {
    LibraryDirective other = this._other as LibraryDirective;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.libraryToken, other.libraryToken) && _isEqualNodes(node.name, other.name) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitLibraryIdentifier(LibraryIdentifier node) {
    LibraryIdentifier other = this._other as LibraryIdentifier;
    return _isEqualNodeLists(node.components, other.components);
  }
  bool visitListLiteral(ListLiteral node) {
    ListLiteral other = this._other as ListLiteral;
    return _isEqualTokens(node.constKeyword, other.constKeyword) && _isEqualNodes(node.typeArguments, other.typeArguments) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.elements, other.elements) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitMapLiteral(MapLiteral node) {
    MapLiteral other = this._other as MapLiteral;
    return _isEqualTokens(node.constKeyword, other.constKeyword) && _isEqualNodes(node.typeArguments, other.typeArguments) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.entries, other.entries) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitMapLiteralEntry(MapLiteralEntry node) {
    MapLiteralEntry other = this._other as MapLiteralEntry;
    return _isEqualNodes(node.key, other.key) && _isEqualTokens(node.A_separator, other.A_separator) && _isEqualNodes(node.value, other.value);
  }
  bool visitMethodDeclaration(MethodDeclaration node) {
    MethodDeclaration other = this._other as MethodDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.externalKeyword, other.externalKeyword) && _isEqualTokens(node.modifierKeyword, other.modifierKeyword) && _isEqualNodes(node.returnType, other.returnType) && _isEqualTokens(node.propertyKeyword, other.propertyKeyword) && _isEqualTokens(node.propertyKeyword, other.propertyKeyword) && _isEqualNodes(node.name, other.name) && _isEqualNodes(node.parameters, other.parameters) && _isEqualNodes(node.body, other.body);
  }
  bool visitMethodInvocation(MethodInvocation node) {
    MethodInvocation other = this._other as MethodInvocation;
    return _isEqualNodes(node.target, other.target) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.methodName, other.methodName) && _isEqualNodes(node.argumentList, other.argumentList);
  }
  bool visitNamedExpression(NamedExpression node) {
    NamedExpression other = this._other as NamedExpression;
    return _isEqualNodes(node.name, other.name) && _isEqualNodes(node.expression, other.expression);
  }
  bool visitNativeClause(NativeClause node) {
    NativeClause other = this._other as NativeClause;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.name, other.name);
  }
  bool visitNativeFunctionBody(NativeFunctionBody node) {
    NativeFunctionBody other = this._other as NativeFunctionBody;
    return _isEqualTokens(node.nativeToken, other.nativeToken) && _isEqualNodes(node.stringLiteral, other.stringLiteral) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitNullLiteral(NullLiteral node) {
    NullLiteral other = this._other as NullLiteral;
    return _isEqualTokens(node.literal, other.literal);
  }
  bool visitParenthesizedExpression(ParenthesizedExpression node) {
    ParenthesizedExpression other = this._other as ParenthesizedExpression;
    return _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis);
  }
  bool visitPartDirective(PartDirective node) {
    PartDirective other = this._other as PartDirective;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.partToken, other.partToken) && _isEqualNodes(node.uri, other.uri) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitPartOfDirective(PartOfDirective node) {
    PartOfDirective other = this._other as PartOfDirective;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.partToken, other.partToken) && _isEqualTokens(node.ofToken, other.ofToken) && _isEqualNodes(node.libraryName, other.libraryName) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitPostfixExpression(PostfixExpression node) {
    PostfixExpression other = this._other as PostfixExpression;
    return _isEqualNodes(node.operand, other.operand) && _isEqualTokens(node.operator, other.operator);
  }
  bool visitPrefixedIdentifier(PrefixedIdentifier node) {
    PrefixedIdentifier other = this._other as PrefixedIdentifier;
    return _isEqualNodes(node.prefix, other.prefix) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.identifier, other.identifier);
  }
  bool visitPrefixExpression(PrefixExpression node) {
    PrefixExpression other = this._other as PrefixExpression;
    return _isEqualTokens(node.operator, other.operator) && _isEqualNodes(node.operand, other.operand);
  }
  bool visitPropertyAccess(PropertyAccess node) {
    PropertyAccess other = this._other as PropertyAccess;
    return _isEqualNodes(node.target, other.target) && _isEqualTokens(node.operator, other.operator) && _isEqualNodes(node.propertyName, other.propertyName);
  }
  bool visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    RedirectingConstructorInvocation other = this._other as RedirectingConstructorInvocation;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.constructorName, other.constructorName) && _isEqualNodes(node.argumentList, other.argumentList);
  }
  bool visitRethrowExpression(RethrowExpression node) {
    RethrowExpression other = this._other as RethrowExpression;
    return _isEqualTokens(node.keyword, other.keyword);
  }
  bool visitReturnStatement(ReturnStatement node) {
    ReturnStatement other = this._other as ReturnStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitScriptTag(ScriptTag node) {
    ScriptTag other = this._other as ScriptTag;
    return _isEqualTokens(node.scriptTag, other.scriptTag);
  }
  bool visitShowCombinator(ShowCombinator node) {
    ShowCombinator other = this._other as ShowCombinator;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodeLists(node.shownNames, other.shownNames);
  }
  bool visitSimpleFormalParameter(SimpleFormalParameter node) {
    SimpleFormalParameter other = this._other as SimpleFormalParameter;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.type, other.type) && _isEqualNodes(node.identifier, other.identifier);
  }
  bool visitSimpleIdentifier(SimpleIdentifier node) {
    SimpleIdentifier other = this._other as SimpleIdentifier;
    return _isEqualTokens(node.token, other.token);
  }
  bool visitSimpleStringLiteral(SimpleStringLiteral node) {
    SimpleStringLiteral other = this._other as SimpleStringLiteral;
    return _isEqualTokens(node.literal, other.literal) && (node.value == other.value);
  }
  bool visitStringInterpolation(StringInterpolation node) {
    StringInterpolation other = this._other as StringInterpolation;
    return _isEqualNodeLists(node.elements, other.elements);
  }
  bool visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    SuperConstructorInvocation other = this._other as SuperConstructorInvocation;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.period, other.period) && _isEqualNodes(node.constructorName, other.constructorName) && _isEqualNodes(node.argumentList, other.argumentList);
  }
  bool visitSuperExpression(SuperExpression node) {
    SuperExpression other = this._other as SuperExpression;
    return _isEqualTokens(node.keyword, other.keyword);
  }
  bool visitSwitchCase(SwitchCase node) {
    SwitchCase other = this._other as SwitchCase;
    return _isEqualNodeLists(node.labels, other.labels) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.colon, other.colon) && _isEqualNodeLists(node.statements, other.statements);
  }
  bool visitSwitchDefault(SwitchDefault node) {
    SwitchDefault other = this._other as SwitchDefault;
    return _isEqualNodeLists(node.labels, other.labels) && _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.colon, other.colon) && _isEqualNodeLists(node.statements, other.statements);
  }
  bool visitSwitchStatement(SwitchStatement node) {
    SwitchStatement other = this._other as SwitchStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.members, other.members) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitSymbolLiteral(SymbolLiteral node) {
    SymbolLiteral other = this._other as SymbolLiteral;
    return _isEqualTokens(node.poundSign, other.poundSign) && _isEqualTokenLists(node.components, other.components);
  }
  bool visitThisExpression(ThisExpression node) {
    ThisExpression other = this._other as ThisExpression;
    return _isEqualTokens(node.keyword, other.keyword);
  }
  bool visitThrowExpression(ThrowExpression node) {
    ThrowExpression other = this._other as ThrowExpression;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.expression, other.expression);
  }
  bool visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    TopLevelVariableDeclaration other = this._other as TopLevelVariableDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualNodes(node.variables, other.variables) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitTryStatement(TryStatement node) {
    TryStatement other = this._other as TryStatement;
    return _isEqualTokens(node.tryKeyword, other.tryKeyword) && _isEqualNodes(node.body, other.body) && _isEqualNodeLists(node.catchClauses, other.catchClauses) && _isEqualTokens(node.finallyKeyword, other.finallyKeyword) && _isEqualNodes(node.finallyBlock, other.finallyBlock);
  }
  bool visitTypeArgumentList(TypeArgumentList node) {
    TypeArgumentList other = this._other as TypeArgumentList;
    return _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.arguments, other.arguments) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitTypeName(TypeName node) {
    TypeName other = this._other as TypeName;
    return _isEqualNodes(node.name, other.name) && _isEqualNodes(node.typeArguments, other.typeArguments);
  }
  bool visitTypeParameter(TypeParameter node) {
    TypeParameter other = this._other as TypeParameter;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualNodes(node.name, other.name) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.bound, other.bound);
  }
  bool visitTypeParameterList(TypeParameterList node) {
    TypeParameterList other = this._other as TypeParameterList;
    return _isEqualTokens(node.leftBracket, other.leftBracket) && _isEqualNodeLists(node.typeParameters, other.typeParameters) && _isEqualTokens(node.rightBracket, other.rightBracket);
  }
  bool visitVariableDeclaration(VariableDeclaration node) {
    VariableDeclaration other = this._other as VariableDeclaration;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualNodes(node.name, other.name) && _isEqualTokens(node.A_equals, other.A_equals) && _isEqualNodes(node.initializer, other.initializer);
  }
  bool visitVariableDeclarationList(VariableDeclarationList node) {
    VariableDeclarationList other = this._other as VariableDeclarationList;
    return _isEqualNodes(node.documentationComment, other.documentationComment) && _isEqualNodeLists(node.metadata, other.metadata) && _isEqualTokens(node.keyword, other.keyword) && _isEqualNodes(node.type, other.type) && _isEqualNodeLists(node.variables, other.variables);
  }
  bool visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    VariableDeclarationStatement other = this._other as VariableDeclarationStatement;
    return _isEqualNodes(node.variables, other.variables) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool visitWhileStatement(WhileStatement node) {
    WhileStatement other = this._other as WhileStatement;
    return _isEqualTokens(node.keyword, other.keyword) && _isEqualTokens(node.leftParenthesis, other.leftParenthesis) && _isEqualNodes(node.condition, other.condition) && _isEqualTokens(node.rightParenthesis, other.rightParenthesis) && _isEqualNodes(node.body, other.body);
  }
  bool visitWithClause(WithClause node) {
    WithClause other = this._other as WithClause;
    return _isEqualTokens(node.withKeyword, other.withKeyword) && _isEqualNodeLists(node.mixinTypes, other.mixinTypes);
  }
  bool visitYieldStatement(YieldStatement node) {
    YieldStatement other = this._other as YieldStatement;
    return _isEqualTokens(node.yieldKeyword, other.yieldKeyword) && _isEqualNodes(node.expression, other.expression) && _isEqualTokens(node.semicolon, other.semicolon);
  }
  bool _isEqualNodeLists(NodeList A_first, NodeList A_second) {
    if (A_first == null) {
      return A_second == null;
    } else if (A_second == null) {
      return false;
    }
    int A_size = A_first.length;
    if (A_second.length != A_size) {
      return false;
    }
    for (int i = 0; i < A_size; i++) {
      if (!_isEqualNodes(A_first[i], A_second[i])) {
        return false;
      }
    }
    return true;
  }
  bool _isEqualNodes(AstNode A_first, AstNode A_second) {
    if (A_first == null) {
      return A_second == null;
    } else if (A_second == null) {
      return false;
    } else if (A_first.runtimeType != A_second.runtimeType) {
      return false;
    }
    _other = A_second;
    return A_first.accept(this);
  }
  bool _isEqualTokenLists(List<A_Token> A_first, List<A_Token> A_second) {
    int A_length = A_first.length;
    if (A_second.length != A_length) {
      return false;
    }
    for (int i = 0; i < A_length; i++) {
      if (!_isEqualTokens(A_first[i], A_second[i])) {
        return false;
      }
    }
    return true;
  }
  bool _isEqualTokens(A_Token A_first, A_Token A_second) {
    if (A_first == null) {
      return A_second == null;
    } else if (A_second == null) {
      return false;
    } else if (identical(A_first, A_second)) {
      return true;
    }
    return A_first.offset == A_second.offset && A_first.length == A_second.length && A_first.lexeme == A_second.lexeme;
  }
}
abstract class AstNode {
  static List<AstNode> A_EMPTY_ARRAY = new List<AstNode>(0);
  AstNode A__parent;
  Map<String, Object> _propertyMap;
  static Comparator<AstNode> LEXICAL_ORDER = (AstNode A_first, AstNode A_second) => A_second.offset - A_first.offset;
  accept(AstVisitor visitor);
  AstNode getAncestor(A_Predicate<AstNode> predicate) {
    AstNode node = this;
    while (node != null && !predicate(node)) {
      node = node.parent;
    }
    return node;
  }
  A_Token get beginToken;
  int get end => offset + length;
  A_Token get endToken;
  int get length {
    A_Token A_beginToken = this.beginToken;
    A_Token A_endToken = this.endToken;
    if (A_beginToken == null || A_endToken == null) {
      return -1;
    }
    return A_endToken.offset + A_endToken.length - A_beginToken.offset;
  }
  int get offset {
    A_Token A_beginToken = this.beginToken;
    if (A_beginToken == null) {
      return -1;
    }
    return A_beginToken.offset;
  }
  AstNode get parent => A__parent;
  Object getProperty(String propertyName) {
    if (_propertyMap == null) {
      return null;
    }
    return _propertyMap[propertyName];
  }
  AstNode get A_root {
    AstNode A_root = this;
    AstNode A_parent = this.parent;
    while (A_parent != null) {
      A_root = A_parent;
      A_parent = A_root.parent;
    }
    return A_root;
  }
  bool get isSynthetic => false;
  void setProperty(String propertyName, Object propertyValue) {
    if (propertyValue == null) {
      if (_propertyMap != null) {
        _propertyMap.remove(propertyName);
        if (_propertyMap.isEmpty) {
          _propertyMap = null;
        }
      }
    } else {
      if (_propertyMap == null) {
        _propertyMap = new A_p.HashMap<String,Object>();
      }
      _propertyMap[propertyName] = propertyValue;
    }
  }
  String toSource() {
    PrintStringWriter writer = new PrintStringWriter();
    accept(new ToSourceVisitor(writer));
    return writer.toString();
  }
  String toString() => toSource();
  void visitChildren(AstVisitor visitor);
  AstNode becomeParentOf(AstNode child) {
    if (child != null) {
      AstNode node = child;
      node.parent = this;
    }
    return child;
  }
  void safelyVisitChild(AstNode child, AstVisitor visitor) {
    if (child != null) {
      child.accept(visitor);
    }
  }
  void set parent(AstNode newParent) {
    A__parent = newParent;
  }
}
abstract class AstVisitor<R> {
  R visitAdjacentStrings(AdjacentStrings node);
  R visitAnnotation(Annotation node);
  R visitArgumentList(ArgumentList node);
  R visitAsExpression(AsExpression node);
  R visitAssertStatement(AssertStatement assertStatement);
  R visitAssignmentExpression(AssignmentExpression node);
  R visitAwaitExpression(AwaitExpression node);
  R visitBinaryExpression(BinaryExpression node);
  R visitBlock(Block node);
  R visitBlockFunctionBody(BlockFunctionBody node);
  R visitBooleanLiteral(BooleanLiteral node);
  R visitBreakStatement(BreakStatement node);
  R visitCascadeExpression(CascadeExpression node);
  R visitCatchClause(CatchClause node);
  R visitClassDeclaration(ClassDeclaration node);
  R visitClassTypeAlias(ClassTypeAlias node);
  R visitComment(Comment node);
  R visitCommentReference(CommentReference node);
  R visitCompilationUnit(CompilationUnit node);
  R visitConditionalExpression(ConditionalExpression node);
  R visitConstructorDeclaration(ConstructorDeclaration node);
  R visitConstructorFieldInitializer(ConstructorFieldInitializer node);
  R visitConstructorName(ConstructorName node);
  R visitContinueStatement(ContinueStatement node);
  R visitDeclaredIdentifier(DeclaredIdentifier node);
  R visitDefaultFormalParameter(DefaultFormalParameter node);
  R visitDoStatement(DoStatement node);
  R visitDoubleLiteral(DoubleLiteral node);
  R visitEmptyFunctionBody(EmptyFunctionBody node);
  R visitEmptyStatement(EmptyStatement node);
  R visitEnumConstantDeclaration(EnumConstantDeclaration node);
  R visitEnumDeclaration(EnumDeclaration node);
  R visitExportDirective(ExportDirective node);
  R visitExpressionFunctionBody(ExpressionFunctionBody node);
  R visitExpressionStatement(ExpressionStatement node);
  R visitExtendsClause(ExtendsClause node);
  R visitFieldDeclaration(FieldDeclaration node);
  R visitFieldFormalParameter(FieldFormalParameter node);
  R visitForEachStatement(ForEachStatement node);
  R visitFormalParameterList(FormalParameterList node);
  R visitForStatement(ForStatement node);
  R visitFunctionDeclaration(FunctionDeclaration node);
  R visitFunctionDeclarationStatement(FunctionDeclarationStatement node);
  R visitFunctionExpression(FunctionExpression node);
  R visitFunctionExpressionInvocation(FunctionExpressionInvocation node);
  R visitFunctionTypeAlias(FunctionTypeAlias functionTypeAlias);
  R visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node);
  R visitHideCombinator(HideCombinator node);
  R visitIfStatement(IfStatement node);
  R visitImplementsClause(ImplementsClause node);
  R visitImportDirective(ImportDirective node);
  R visitIndexExpression(IndexExpression node);
  R visitInstanceCreationExpression(InstanceCreationExpression node);
  R visitIntegerLiteral(IntegerLiteral node);
  R visitInterpolationExpression(InterpolationExpression node);
  R visitInterpolationString(InterpolationString node);
  R visitIsExpression(IsExpression node);
  R visitLabel(Label node);
  R visitLabeledStatement(LabeledStatement node);
  R visitLibraryDirective(LibraryDirective node);
  R visitLibraryIdentifier(LibraryIdentifier node);
  R visitListLiteral(ListLiteral node);
  R visitMapLiteral(MapLiteral node);
  R visitMapLiteralEntry(MapLiteralEntry node);
  R visitMethodDeclaration(MethodDeclaration node);
  R visitMethodInvocation(MethodInvocation node);
  R visitNamedExpression(NamedExpression node);
  R visitNativeClause(NativeClause node);
  R visitNativeFunctionBody(NativeFunctionBody node);
  R visitNullLiteral(NullLiteral node);
  R visitParenthesizedExpression(ParenthesizedExpression node);
  R visitPartDirective(PartDirective node);
  R visitPartOfDirective(PartOfDirective node);
  R visitPostfixExpression(PostfixExpression node);
  R visitPrefixedIdentifier(PrefixedIdentifier node);
  R visitPrefixExpression(PrefixExpression node);
  R visitPropertyAccess(PropertyAccess node);
  R visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node);
  R visitRethrowExpression(RethrowExpression node);
  R visitReturnStatement(ReturnStatement node);
  R visitScriptTag(ScriptTag node);
  R visitShowCombinator(ShowCombinator node);
  R visitSimpleFormalParameter(SimpleFormalParameter node);
  R visitSimpleIdentifier(SimpleIdentifier node);
  R visitSimpleStringLiteral(SimpleStringLiteral node);
  R visitStringInterpolation(StringInterpolation node);
  R visitSuperConstructorInvocation(SuperConstructorInvocation node);
  R visitSuperExpression(SuperExpression node);
  R visitSwitchCase(SwitchCase node);
  R visitSwitchDefault(SwitchDefault node);
  R visitSwitchStatement(SwitchStatement node);
  R visitSymbolLiteral(SymbolLiteral node);
  R visitThisExpression(ThisExpression node);
  R visitThrowExpression(ThrowExpression node);
  R visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node);
  R visitTryStatement(TryStatement node);
  R visitTypeArgumentList(TypeArgumentList node);
  R visitTypeName(TypeName node);
  R visitTypeParameter(TypeParameter node);
  R visitTypeParameterList(TypeParameterList node);
  R visitVariableDeclaration(VariableDeclaration node);
  R visitVariableDeclarationList(VariableDeclarationList node);
  R visitVariableDeclarationStatement(VariableDeclarationStatement node);
  R visitWhileStatement(WhileStatement node);
  R visitWithClause(WithClause node);
  R visitYieldStatement(YieldStatement node);
}
class AwaitExpression extends Expression {
  A_Token awaitKeyword;
  Expression _expression;
  A_Token semicolon;
  AwaitExpression(this.awaitKeyword, Expression A_expression, this.semicolon) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitAwaitExpression(this);
  A_Token get beginToken {
    if (awaitKeyword != null) {
      return awaitKeyword;
    }
    return _expression.beginToken;
  }
  A_Token get endToken {
    if (semicolon != null) {
      return semicolon;
    }
    return _expression.endToken;
  }
  Expression get expression => _expression;
  int get precedence => 0;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class BinaryExpression extends Expression {
  Expression _leftOperand;
  A_Token operator;
  Expression _rightOperand;
  MethodElement _staticElement;
  MethodElement _propagatedElement;
  BinaryExpression(Expression A_leftOperand, this.operator, Expression A_rightOperand) {
    this._leftOperand = becomeParentOf(A_leftOperand);
    this._rightOperand = becomeParentOf(A_rightOperand);
  }
  accept(AstVisitor visitor) => visitor.visitBinaryExpression(this);
  A_Token get beginToken => _leftOperand.beginToken;
  MethodElement get bestElement {
    MethodElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => _rightOperand.endToken;
  Expression get leftOperand => _leftOperand;
  int get precedence => operator.type.precedence;
  MethodElement get propagatedElement => _propagatedElement;
  Expression get rightOperand => _rightOperand;
  MethodElement get staticElement => _staticElement;
  void set propagatedElement(MethodElement A_element) {
    _propagatedElement = A_element;
  }
  void set staticElement(MethodElement A_element) {
    _staticElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_leftOperand, visitor);
    safelyVisitChild(_rightOperand, visitor);
  }
  ParameterElement get propagatedParameterElementForRightOperand {
    if (_propagatedElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _propagatedElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
  ParameterElement get staticParameterElementForRightOperand {
    if (_staticElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _staticElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
}
class Block extends Statement {
  A_Token leftBracket;
  NodeList<Statement> _statements;
  A_Token rightBracket;
  Block(this.leftBracket, List<Statement> A_statements, this.rightBracket) {
    this._statements = new NodeList<Statement>(this);
    this._statements.addAll(A_statements);
  }
  accept(AstVisitor visitor) => visitor.visitBlock(this);
  A_Token get beginToken => leftBracket;
  A_Token get endToken => rightBracket;
  NodeList<Statement> get statements => _statements;
  void visitChildren(AstVisitor visitor) {
    _statements.accept(visitor);
  }
}
class BlockFunctionBody extends FunctionBody {
  A_Token keyword;
  A_Token star;
  Block _block;
  BlockFunctionBody(this.keyword, this.star, Block A_block) {
    this._block = becomeParentOf(A_block);
  }
  accept(AstVisitor visitor) => visitor.visitBlockFunctionBody(this);
  A_Token get beginToken => _block.beginToken;
  Block get block => _block;
  A_Token get endToken => _block.endToken;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_block, visitor);
  }
}
class BooleanLiteral extends Literal {
  A_Token literal;
  bool value = false;
  BooleanLiteral(this.literal, this.value);
  accept(AstVisitor visitor) => visitor.visitBooleanLiteral(this);
  A_Token get beginToken => literal;
  A_Token get endToken => literal;
  bool get isSynthetic => literal.isSynthetic;
  void visitChildren(AstVisitor visitor) {}
}
class BreakStatement extends Statement {
  A_Token keyword;
  SimpleIdentifier _label;
  A_Token semicolon;
  BreakStatement(this.keyword, SimpleIdentifier A_label, this.semicolon) {
    this._label = becomeParentOf(A_label);
  }
  accept(AstVisitor visitor) => visitor.visitBreakStatement(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => semicolon;
  SimpleIdentifier get label => _label;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_label, visitor);
  }
}
class CascadeExpression extends Expression {
  Expression A__target;
  NodeList<Expression> _cascadeSections;
  CascadeExpression(Expression A_target, List<Expression> A_cascadeSections) {
    this._cascadeSections = new NodeList<Expression>(this);
    this.A__target = becomeParentOf(A_target);
    this._cascadeSections.addAll(A_cascadeSections);
  }
  accept(AstVisitor visitor) => visitor.visitCascadeExpression(this);
  A_Token get beginToken => A__target.beginToken;
  NodeList<Expression> get cascadeSections => _cascadeSections;
  A_Token get endToken => _cascadeSections.endToken;
  int get precedence => 2;
  Expression get target => A__target;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__target, visitor);
    _cascadeSections.accept(visitor);
  }
}
class CatchClause extends AstNode {
  A_Token onKeyword;
  TypeName _exceptionType;
  A_Token catchKeyword;
  A_Token _leftParenthesis;
  SimpleIdentifier _exceptionParameter;
  A_Token comma;
  SimpleIdentifier _stackTraceParameter;
  A_Token _rightParenthesis;
  Block _body;
  CatchClause(this.onKeyword, TypeName A_exceptionType, this.catchKeyword, A_Token A_leftParenthesis, SimpleIdentifier A_exceptionParameter, this.comma, SimpleIdentifier A_stackTraceParameter, A_Token A_rightParenthesis, Block A_body) {
    this._exceptionType = becomeParentOf(A_exceptionType);
    this._leftParenthesis = A_leftParenthesis;
    this._exceptionParameter = becomeParentOf(A_exceptionParameter);
    this._stackTraceParameter = becomeParentOf(A_stackTraceParameter);
    this._rightParenthesis = A_rightParenthesis;
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitCatchClause(this);
  A_Token get beginToken {
    if (onKeyword != null) {
      return onKeyword;
    }
    return catchKeyword;
  }
  Block get body => _body;
  A_Token get endToken => _body.endToken;
  SimpleIdentifier get exceptionParameter => _exceptionParameter;
  TypeName get exceptionType => _exceptionType;
  A_Token get leftParenthesis => _leftParenthesis;
  A_Token get rightParenthesis => _rightParenthesis;
  SimpleIdentifier get stackTraceParameter => _stackTraceParameter;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_exceptionType, visitor);
    safelyVisitChild(_exceptionParameter, visitor);
    safelyVisitChild(_stackTraceParameter, visitor);
    safelyVisitChild(_body, visitor);
  }
}
class ClassDeclaration extends CompilationUnitMember {
  A_Token abstractKeyword;
  A_Token classKeyword;
  SimpleIdentifier A__name;
  TypeParameterList _typeParameters;
  ExtendsClause _extendsClause;
  WithClause _withClause;
  ImplementsClause _implementsClause;
  NativeClause _nativeClause;
  A_Token leftBracket;
  NodeList<ClassMember> _members;
  A_Token rightBracket;
  ClassDeclaration(Comment comment, List<Annotation> metadata, this.abstractKeyword, this.classKeyword, SimpleIdentifier A_name, TypeParameterList A_typeParameters, ExtendsClause A_extendsClause, WithClause A_withClause, ImplementsClause A_implementsClause, this.leftBracket, List<ClassMember> A_members, this.rightBracket) : super(comment, metadata) {
    this._members = new NodeList<ClassMember>(this);
    this.A__name = becomeParentOf(A_name);
    this._typeParameters = becomeParentOf(A_typeParameters);
    this._extendsClause = becomeParentOf(A_extendsClause);
    this._withClause = becomeParentOf(A_withClause);
    this._implementsClause = becomeParentOf(A_implementsClause);
    this._members.addAll(A_members);
  }
  accept(AstVisitor visitor) => visitor.visitClassDeclaration(this);
  ClassElement get element => A__name != null ? (A__name.staticElement as ClassElement) : null;
  A_Token get endToken => rightBracket;
  ExtendsClause get extendsClause => _extendsClause;
  VariableDeclaration getField(String A_name) {
    for (ClassMember classMember in _members) {
      if (classMember is FieldDeclaration) {
        FieldDeclaration fieldDeclaration = classMember;
        NodeList<VariableDeclaration> fields = fieldDeclaration.fields.variables;
        for (VariableDeclaration field in fields) {
          SimpleIdentifier fieldName = field.name;
          if (fieldName != null && A_name == fieldName.name) {
            return field;
          }
        }
      }
    }
    return null;
  }
  ImplementsClause get implementsClause => _implementsClause;
  NodeList<ClassMember> get members => _members;
  MethodDeclaration getMethod(String A_name) {
    for (ClassMember classMember in _members) {
      if (classMember is MethodDeclaration) {
        MethodDeclaration A_method = classMember;
        SimpleIdentifier methodName = A_method.name;
        if (methodName != null && A_name == methodName.name) {
          return A_method;
        }
      }
    }
    return null;
  }
  SimpleIdentifier get name => A__name;
  NativeClause get nativeClause => _nativeClause;
  TypeParameterList get typeParameters => _typeParameters;
  WithClause get withClause => _withClause;
  bool get isAbstract => abstractKeyword != null;
  void set name(SimpleIdentifier identifier) {
    A__name = becomeParentOf(identifier);
  }
  void set nativeClause(NativeClause A_nativeClause) {
    this._nativeClause = becomeParentOf(A_nativeClause);
  }
  void set typeParameters(TypeParameterList A_typeParameters) {
    this._typeParameters = becomeParentOf(A_typeParameters);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_typeParameters, visitor);
    safelyVisitChild(_extendsClause, visitor);
    safelyVisitChild(_withClause, visitor);
    safelyVisitChild(_implementsClause, visitor);
    safelyVisitChild(_nativeClause, visitor);
    members.accept(visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (abstractKeyword != null) {
      return abstractKeyword;
    }
    return classKeyword;
  }
}
abstract class ClassMember extends Declaration {
  ClassMember(Comment comment, List<Annotation> metadata) : super(comment, metadata);
}
class ClassTypeAlias extends TypeAlias {
  SimpleIdentifier A__name;
  TypeParameterList _typeParameters;
  A_Token A_equals;
  A_Token abstractKeyword;
  TypeName _superclass;
  WithClause _withClause;
  ImplementsClause _implementsClause;
  ClassTypeAlias(Comment comment, List<Annotation> metadata, A_Token keyword, SimpleIdentifier A_name, TypeParameterList A_typeParameters, this.A_equals, this.abstractKeyword, TypeName A_superclass, WithClause A_withClause, ImplementsClause A_implementsClause, A_Token semicolon) : super(comment, metadata, keyword, semicolon) {
    this.A__name = becomeParentOf(A_name);
    this._typeParameters = becomeParentOf(A_typeParameters);
    this._superclass = becomeParentOf(A_superclass);
    this._withClause = becomeParentOf(A_withClause);
    this._implementsClause = becomeParentOf(A_implementsClause);
  }
  accept(AstVisitor visitor) => visitor.visitClassTypeAlias(this);
  ClassElement get element => A__name != null ? (A__name.staticElement as ClassElement) : null;
  ImplementsClause get implementsClause => _implementsClause;
  SimpleIdentifier get name => A__name;
  TypeName get superclass => _superclass;
  TypeParameterList get typeParameters => _typeParameters;
  WithClause get withClause => _withClause;
  bool get isAbstract => abstractKeyword != null;
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void set superclass(TypeName A_superclass) {
    this._superclass = becomeParentOf(A_superclass);
  }
  void set typeParameters(TypeParameterList A_typeParameters) {
    this._typeParameters = becomeParentOf(A_typeParameters);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_typeParameters, visitor);
    safelyVisitChild(_superclass, visitor);
    safelyVisitChild(_withClause, visitor);
    safelyVisitChild(_implementsClause, visitor);
  }
}
abstract class Combinator extends AstNode {
  A_Token keyword;
  Combinator(this.keyword);
  A_Token get beginToken => keyword;
}
class Comment extends AstNode {
  static Comment createBlockComment(List<A_Token> A_tokens) => new Comment(A_tokens, CommentType.BLOCK, null);
  static Comment createDocumentationCommentWithReferences(List<A_Token> A_tokens, List<CommentReference> A_references) => new Comment(A_tokens, CommentType.DOCUMENTATION, A_references);
  static Comment createEndOfLineComment(List<A_Token> A_tokens) => new Comment(A_tokens, CommentType.END_OF_LINE, null);
  final List<A_Token> tokens;
  final CommentType A__type;
  NodeList<CommentReference> _references;
  Comment(this.tokens, this.A__type, List<CommentReference> A_references) {
    this._references = new NodeList<CommentReference>(this);
    this._references.addAll(A_references);
  }
  accept(AstVisitor visitor) => visitor.visitComment(this);
  A_Token get beginToken => tokens[0];
  A_Token get endToken => tokens[tokens.length - 1];
  NodeList<CommentReference> get references => _references;
  bool get isBlock => A__type == CommentType.BLOCK;
  bool get isDocumentation => A__type == CommentType.DOCUMENTATION;
  void visitChildren(AstVisitor visitor) {
    _references.accept(visitor);
  }
}
class CommentReference extends AstNode {
  A_Token newKeyword;
  Identifier _identifier;
  CommentReference(this.newKeyword, Identifier A_identifier) {
    this._identifier = becomeParentOf(A_identifier);
  }
  accept(AstVisitor visitor) => visitor.visitCommentReference(this);
  A_Token get beginToken => _identifier.beginToken;
  A_Token get endToken => _identifier.endToken;
  Identifier get identifier => _identifier;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_identifier, visitor);
  }
}
class CommentType extends Enum<CommentType> {
  static const CommentType END_OF_LINE = const CommentType('END_OF_LINE', 0);
  static const CommentType BLOCK = const CommentType('BLOCK', 1);
  static const CommentType DOCUMENTATION = const CommentType('DOCUMENTATION', 2);
  const CommentType(String A_name, int ordinal) : super(A_name, ordinal);
}
class CompilationUnit extends AstNode {
  final A_Token beginToken;
  ScriptTag _scriptTag;
  NodeList<Directive> _directives;
  NodeList<CompilationUnitMember> _declarations;
  final A_Token endToken;
  CompilationUnitElement element;
  LineInfo lineInfo;
  CompilationUnit(this.beginToken, ScriptTag A_scriptTag, List<Directive> A_directives, List<CompilationUnitMember> A_declarations, this.endToken) {
    this._directives = new NodeList<Directive>(this);
    this._declarations = new NodeList<CompilationUnitMember>(this);
    this._scriptTag = becomeParentOf(A_scriptTag);
    this._directives.addAll(A_directives);
    this._declarations.addAll(A_declarations);
  }
  accept(AstVisitor visitor) => visitor.visitCompilationUnit(this);
  NodeList<CompilationUnitMember> get declarations => _declarations;
  NodeList<Directive> get directives => _directives;
  int get length {
    A_Token A_endToken = this.endToken;
    if (A_endToken == null) {
      return 0;
    }
    return A_endToken.offset + A_endToken.length;
  }
  int get offset => 0;
  ScriptTag get scriptTag => _scriptTag;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_scriptTag, visitor);
    if (_directivesAreBeforeDeclarations()) {
      _directives.accept(visitor);
      _declarations.accept(visitor);
    } else {
      for (AstNode child in sortedDirectivesAndDeclarations) {
        child.accept(visitor);
      }
    }
  }
  bool _directivesAreBeforeDeclarations() {
    if (_directives.isEmpty || _declarations.isEmpty) {
      return true;
    }
    Directive lastDirective = _directives[_directives.length - 1];
    CompilationUnitMember firstDeclaration = _declarations[0];
    return lastDirective.offset < firstDeclaration.offset;
  }
  List<AstNode> get sortedDirectivesAndDeclarations {
    List<AstNode> childList = new List<AstNode>();
    childList.addAll(_directives);
    childList.addAll(_declarations);
    List<AstNode> children = new List.from(childList);
    children.sort(AstNode.LEXICAL_ORDER);
    return children;
  }
}
abstract class CompilationUnitMember extends Declaration {
  CompilationUnitMember(Comment comment, List<Annotation> metadata) : super(comment, metadata);
}
class ConditionalExpression extends Expression {
  Expression _condition;
  A_Token question;
  Expression _thenExpression;
  A_Token colon;
  Expression _elseExpression;
  ConditionalExpression(Expression A_condition, this.question, Expression A_thenExpression, this.colon, Expression A_elseExpression) {
    this._condition = becomeParentOf(A_condition);
    this._thenExpression = becomeParentOf(A_thenExpression);
    this._elseExpression = becomeParentOf(A_elseExpression);
  }
  accept(AstVisitor visitor) => visitor.visitConditionalExpression(this);
  A_Token get beginToken => _condition.beginToken;
  Expression get condition => _condition;
  Expression get elseExpression => _elseExpression;
  A_Token get endToken => _elseExpression.endToken;
  int get precedence => 3;
  Expression get thenExpression => _thenExpression;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_condition, visitor);
    safelyVisitChild(_thenExpression, visitor);
    safelyVisitChild(_elseExpression, visitor);
  }
}
class ConstructorDeclaration extends ClassMember {
  A_Token externalKeyword;
  A_Token constKeyword;
  A_Token factoryKeyword;
  Identifier A__returnType;
  A_Token period;
  SimpleIdentifier A__name;
  FormalParameterList A__parameters;
  A_Token A_separator;
  NodeList<ConstructorInitializer> _initializers;
  ConstructorName _redirectedConstructor;
  FunctionBody _body;
  ConstructorElement element;
  ConstructorDeclaration(Comment comment, List<Annotation> metadata, this.externalKeyword, this.constKeyword, this.factoryKeyword, Identifier A_returnType, this.period, SimpleIdentifier A_name, FormalParameterList A_parameters, this.A_separator, List<ConstructorInitializer> A_initializers, ConstructorName A_redirectedConstructor, FunctionBody A_body) : super(comment, metadata) {
    this._initializers = new NodeList<ConstructorInitializer>(this);
    this.A__returnType = becomeParentOf(A_returnType);
    this.A__name = becomeParentOf(A_name);
    this.A__parameters = becomeParentOf(A_parameters);
    this._initializers.addAll(A_initializers);
    this._redirectedConstructor = becomeParentOf(A_redirectedConstructor);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitConstructorDeclaration(this);
  FunctionBody get body => _body;
  A_Token get endToken {
    if (_body != null) {
      return _body.endToken;
    } else if (!_initializers.isEmpty) {
      return _initializers.endToken;
    }
    return A__parameters.endToken;
  }
  NodeList<ConstructorInitializer> get initializers => _initializers;
  SimpleIdentifier get name => A__name;
  FormalParameterList get parameters => A__parameters;
  ConstructorName get redirectedConstructor => _redirectedConstructor;
  Identifier get returnType => A__returnType;
  void set name(SimpleIdentifier identifier) {
    A__name = becomeParentOf(identifier);
  }
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void set redirectedConstructor(ConstructorName A_redirectedConstructor) {
    this._redirectedConstructor = becomeParentOf(A_redirectedConstructor);
  }
  void set returnType(Identifier typeName) {
    A__returnType = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__returnType, visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(A__parameters, visitor);
    _initializers.accept(visitor);
    safelyVisitChild(_redirectedConstructor, visitor);
    safelyVisitChild(_body, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    A_Token leftMost = _leftMost([externalKeyword, constKeyword, factoryKeyword]);
    if (leftMost != null) {
      return leftMost;
    }
    return A__returnType.beginToken;
  }
  A_Token _leftMost(List<A_Token> tokens) {
    A_Token leftMost = null;
    int A_offset = 2147483647;
    for (A_Token token in tokens) {
      if (token != null && token.offset < A_offset) {
        leftMost = token;
      }
    }
    return leftMost;
  }
}
class ConstructorFieldInitializer extends ConstructorInitializer {
  A_Token keyword;
  A_Token period;
  SimpleIdentifier _fieldName;
  A_Token A_equals;
  Expression _expression;
  ConstructorFieldInitializer(this.keyword, this.period, SimpleIdentifier A_fieldName, this.A_equals, Expression A_expression) {
    this._fieldName = becomeParentOf(A_fieldName);
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitConstructorFieldInitializer(this);
  A_Token get beginToken {
    if (keyword != null) {
      return keyword;
    }
    return _fieldName.beginToken;
  }
  A_Token get endToken => _expression.endToken;
  Expression get expression => _expression;
  SimpleIdentifier get fieldName => _fieldName;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_fieldName, visitor);
    safelyVisitChild(_expression, visitor);
  }
}
abstract class ConstructorInitializer extends AstNode {}
class ConstructorName extends AstNode {
  TypeName A__type;
  A_Token period;
  SimpleIdentifier A__name;
  ConstructorElement _staticElement;
  ConstructorName(TypeName A_type, this.period, SimpleIdentifier A_name) {
    this.A__type = becomeParentOf(A_type);
    this.A__name = becomeParentOf(A_name);
  }
  accept(AstVisitor visitor) => visitor.visitConstructorName(this);
  A_Token get beginToken => A__type.beginToken;
  A_Token get endToken {
    if (A__name != null) {
      return A__name.endToken;
    }
    return A__type.endToken;
  }
  SimpleIdentifier get name => A__name;
  ConstructorElement get staticElement => _staticElement;
  TypeName get type => A__type;
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void set staticElement(ConstructorElement A_element) {
    _staticElement = A_element;
  }
  void set type(TypeName A_type) {
    this.A__type = becomeParentOf(A_type);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__type, visitor);
    safelyVisitChild(A__name, visitor);
  }
}
class ContinueStatement extends Statement {
  A_Token keyword;
  SimpleIdentifier _label;
  A_Token semicolon;
  ContinueStatement(this.keyword, SimpleIdentifier A_label, this.semicolon) {
    this._label = becomeParentOf(A_label);
  }
  accept(AstVisitor visitor) => visitor.visitContinueStatement(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => semicolon;
  SimpleIdentifier get label => _label;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_label, visitor);
  }
}
abstract class Declaration extends AnnotatedNode {
  Declaration(Comment comment, List<Annotation> metadata) : super(comment, metadata);
  A_Element get element;
}
class DeclaredIdentifier extends Declaration {
  A_Token keyword;
  TypeName A__type;
  SimpleIdentifier _identifier;
  DeclaredIdentifier(Comment comment, List<Annotation> metadata, this.keyword, TypeName A_type, SimpleIdentifier A_identifier) : super(comment, metadata) {
    this.A__type = becomeParentOf(A_type);
    this._identifier = becomeParentOf(A_identifier);
  }
  accept(AstVisitor visitor) => visitor.visitDeclaredIdentifier(this);
  LocalVariableElement get element {
    SimpleIdentifier A_identifier = this.identifier;
    if (A_identifier == null) {
      return null;
    }
    return A_identifier.staticElement as LocalVariableElement;
  }
  A_Token get endToken => _identifier.endToken;
  SimpleIdentifier get identifier => _identifier;
  TypeName get type => A__type;
  bool get isConst => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.B_CONST;
  bool get isFinal => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.A_FINAL;
  void set type(TypeName typeName) {
    A__type = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__type, visitor);
    safelyVisitChild(_identifier, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (keyword != null) {
      return keyword;
    } else if (A__type != null) {
      return A__type.beginToken;
    }
    return _identifier.beginToken;
  }
}
class DefaultFormalParameter extends FormalParameter {
  NormalFormalParameter _parameter;
  ParameterKind kind;
  A_Token A_separator;
  Expression _defaultValue;
  DefaultFormalParameter(NormalFormalParameter A_parameter, this.kind, this.A_separator, Expression A_defaultValue) {
    this._parameter = becomeParentOf(A_parameter);
    this._defaultValue = becomeParentOf(A_defaultValue);
  }
  accept(AstVisitor visitor) => visitor.visitDefaultFormalParameter(this);
  A_Token get beginToken => _parameter.beginToken;
  Expression get defaultValue => _defaultValue;
  A_Token get endToken {
    if (_defaultValue != null) {
      return _defaultValue.endToken;
    }
    return _parameter.endToken;
  }
  SimpleIdentifier get identifier => _parameter.identifier;
  NormalFormalParameter get parameter => _parameter;
  bool get isConst => _parameter != null && _parameter.isConst;
  bool get isFinal => _parameter != null && _parameter.isFinal;
  void set parameter(NormalFormalParameter formalParameter) {
    _parameter = becomeParentOf(formalParameter);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_parameter, visitor);
    safelyVisitChild(_defaultValue, visitor);
  }
}
class DeferredLibraryReferenceDetector extends RecursiveAstVisitor<Object> {
  bool _result = false;
  bool get result => _result;
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    if (!_result) {
      if (node.isDeferred) {
        _result = true;
      }
    }
    return null;
  }
}
abstract class Directive extends AnnotatedNode {
  A_Element C__element;
  Directive(Comment comment, List<Annotation> metadata) : super(comment, metadata);
  A_Element get element => C__element;
  A_Token get keyword;
  void set element(A_Element A_element) {
    this.C__element = A_element;
  }
}
class DoStatement extends Statement {
  A_Token doKeyword;
  Statement _body;
  A_Token whileKeyword;
  A_Token _leftParenthesis;
  Expression _condition;
  A_Token _rightParenthesis;
  A_Token semicolon;
  DoStatement(this.doKeyword, Statement A_body, this.whileKeyword, A_Token A_leftParenthesis, Expression A_condition, A_Token A_rightParenthesis, this.semicolon) {
    this._body = becomeParentOf(A_body);
    this._leftParenthesis = A_leftParenthesis;
    this._condition = becomeParentOf(A_condition);
    this._rightParenthesis = A_rightParenthesis;
  }
  accept(AstVisitor visitor) => visitor.visitDoStatement(this);
  A_Token get beginToken => doKeyword;
  Statement get body => _body;
  Expression get condition => _condition;
  A_Token get endToken => semicolon;
  A_Token get leftParenthesis => _leftParenthesis;
  A_Token get rightParenthesis => _rightParenthesis;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_body, visitor);
    safelyVisitChild(_condition, visitor);
  }
}
class DoubleLiteral extends Literal {
  A_Token literal;
  double value = 0.0;
  DoubleLiteral(this.literal, this.value);
  accept(AstVisitor visitor) => visitor.visitDoubleLiteral(this);
  A_Token get beginToken => literal;
  A_Token get endToken => literal;
  void visitChildren(AstVisitor visitor) {}
}
class ElementLocator {
  static A_Element locate(AstNode node) {
    ElementLocator_ElementMapper mapper = new ElementLocator_ElementMapper();
    return node.accept(mapper);
  }
  static A_Element locateWithOffset(AstNode node, int A_offset) {
    if (node == null) {
      return null;
    }
    {
      A_Element nodeElement = locate(node);
      if (nodeElement != null) {
        return nodeElement;
      }
    }
    {
      A_Element A_element = null;
      if (A_element != null) {
        return A_element;
      }
    }
    {
      A_Element A_element = null;
      if (A_element != null) {
        return A_element;
      }
    }
    return null;
  }
}
class ElementLocator_ElementMapper extends GeneralizingAstVisitor<A_Element> {
  A_Element visitAnnotation(Annotation node) => node.element;
  A_Element visitAssignmentExpression(AssignmentExpression node) => node.bestElement;
  A_Element visitBinaryExpression(BinaryExpression node) => node.bestElement;
  A_Element visitClassDeclaration(ClassDeclaration node) => node.element;
  A_Element visitCompilationUnit(CompilationUnit node) => node.element;
  A_Element visitConstructorDeclaration(ConstructorDeclaration node) => node.element;
  A_Element visitFunctionDeclaration(FunctionDeclaration node) => node.element;
  A_Element visitIdentifier(Identifier node) {
    AstNode A_parent = node.parent;
    if (A_parent is Annotation) {
      Annotation annotation = A_parent;
      if (identical(annotation.name, node) && annotation.constructorName == null) {
        return annotation.element;
      }
    }
    {
      AstNode typeNameCandidate = A_parent;
      if (typeNameCandidate is PrefixedIdentifier) {
        PrefixedIdentifier prefixedIdentifier = typeNameCandidate as PrefixedIdentifier;
        if (identical(prefixedIdentifier.identifier, node)) {
          typeNameCandidate = prefixedIdentifier.parent;
        }
      }
      if (typeNameCandidate is TypeName) {
        TypeName typeName = typeNameCandidate as TypeName;
        if (typeName.parent is ConstructorName) {
          ConstructorName constructorName = typeName.parent as ConstructorName;
          return constructorName.staticElement;
        }
      }
    }
    if (A_parent is ConstructorDeclaration) {
      ConstructorDeclaration decl = A_parent;
      Identifier A_returnType = decl.returnType;
      if (identical(A_returnType, node)) {
        SimpleIdentifier A_name = decl.name;
        if (A_name != null) {
          return A_name.bestElement;
        }
        A_Element A_element = node.bestElement;
        if (A_element is ClassElement) {
          return A_element.unnamedConstructor;
        }
      }
    }
    if (A_parent is LibraryIdentifier) {
      AstNode grandParent = A_parent.parent;
      if (grandParent is PartOfDirective) {
        A_Element A_element = grandParent.element;
        if (A_element is LibraryElement) {
          return A_element.definingCompilationUnit;
        }
      }
    }
    return node.bestElement;
  }
  A_Element visitImportDirective(ImportDirective node) => node.element;
  A_Element visitIndexExpression(IndexExpression node) => node.bestElement;
  A_Element visitInstanceCreationExpression(InstanceCreationExpression node) => node.staticElement;
  A_Element visitLibraryDirective(LibraryDirective node) => node.element;
  A_Element visitMethodDeclaration(MethodDeclaration node) => node.element;
  A_Element visitMethodInvocation(MethodInvocation node) => node.methodName.bestElement;
  A_Element visitPostfixExpression(PostfixExpression node) => node.bestElement;
  A_Element visitPrefixedIdentifier(PrefixedIdentifier node) => node.bestElement;
  A_Element visitPrefixExpression(PrefixExpression node) => node.bestElement;
  A_Element visitStringLiteral(StringLiteral node) {
    AstNode A_parent = node.parent;
    if (A_parent is UriBasedDirective) {
      return A_parent.uriElement;
    }
    return null;
  }
  A_Element visitVariableDeclaration(VariableDeclaration node) => node.element;
}
class EmptyFunctionBody extends FunctionBody {
  A_Token semicolon;
  EmptyFunctionBody(this.semicolon);
  accept(AstVisitor visitor) => visitor.visitEmptyFunctionBody(this);
  A_Token get beginToken => semicolon;
  A_Token get endToken => semicolon;
  void visitChildren(AstVisitor visitor) {}
}
class EmptyStatement extends Statement {
  A_Token semicolon;
  EmptyStatement(this.semicolon);
  accept(AstVisitor visitor) => visitor.visitEmptyStatement(this);
  A_Token get beginToken => semicolon;
  A_Token get endToken => semicolon;
  void visitChildren(AstVisitor visitor) {}
}
class EnumConstantDeclaration extends Declaration {
  SimpleIdentifier A__name;
  EnumConstantDeclaration(Comment comment, List<Annotation> metadata, SimpleIdentifier A_name) : super(comment, metadata) {
    this.A__name = becomeParentOf(A_name);
  }
  accept(AstVisitor visitor) => visitor.visitEnumConstantDeclaration(this);
  FieldElement get element => A__name == null ? null : (A__name.staticElement as FieldElement);
  A_Token get endToken => A__name.endToken;
  SimpleIdentifier get name => A__name;
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  A_Token get firstTokenAfterCommentAndMetadata => A__name.beginToken;
}
class EnumDeclaration extends CompilationUnitMember {
  A_Token keyword;
  SimpleIdentifier A__name;
  A_Token leftBracket;
  NodeList<EnumConstantDeclaration> _constants;
  A_Token rightBracket;
  EnumDeclaration(Comment comment, List<Annotation> metadata, this.keyword, SimpleIdentifier A_name, this.leftBracket, List<EnumConstantDeclaration> A_constants, this.rightBracket) : super(comment, metadata) {
    this._constants = new NodeList<EnumConstantDeclaration>(this);
    this.A__name = becomeParentOf(A_name);
    this._constants.addAll(A_constants);
  }
  accept(AstVisitor visitor) => visitor.visitEnumDeclaration(this);
  NodeList<EnumConstantDeclaration> get constants => _constants;
  ClassElement get element => A__name != null ? (A__name.staticElement as ClassElement) : null;
  A_Token get endToken => rightBracket;
  SimpleIdentifier get name => A__name;
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  A_Token get firstTokenAfterCommentAndMetadata => keyword;
}
class ExportDirective extends NamespaceDirective {
  ExportDirective(Comment comment, List<Annotation> metadata, A_Token keyword, StringLiteral libraryUri, List<Combinator> combinators, A_Token semicolon) : super(comment, metadata, keyword, libraryUri, combinators, semicolon);
  accept(AstVisitor visitor) => visitor.visitExportDirective(this);
  ExportElement get element => super.element as ExportElement;
  LibraryElement get uriElement {
    ExportElement exportElement = element;
    if (exportElement != null) {
      return exportElement.exportedLibrary;
    }
    return null;
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    combinators.accept(visitor);
  }
}
abstract class Expression extends AstNode {
  static List<Expression> A_EMPTY_ARRAY = new List<Expression>(0);
  DartType staticType;
  DartType propagatedType;
  ParameterElement get bestParameterElement {
    ParameterElement propagatedElement = propagatedParameterElement;
    if (propagatedElement != null) {
      return propagatedElement;
    }
    return staticParameterElement;
  }
  DartType get bestType {
    if (propagatedType != null) {
      return propagatedType;
    } else if (staticType != null) {
      return staticType;
    }
    return DynamicTypeImpl.instance;
  }
  int get precedence;
  ParameterElement get propagatedParameterElement {
    AstNode A_parent = this.parent;
    if (A_parent is ArgumentList) {
      return A_parent.getPropagatedParameterElementFor(this);
    } else if (A_parent is IndexExpression) {
      IndexExpression indexExpression = A_parent;
      if (identical(indexExpression.index, this)) {
        return indexExpression.propagatedParameterElementForIndex;
      }
    } else if (A_parent is BinaryExpression) {
      BinaryExpression binaryExpression = A_parent;
      if (identical(binaryExpression.rightOperand, this)) {
        return binaryExpression.propagatedParameterElementForRightOperand;
      }
    } else if (A_parent is AssignmentExpression) {
      AssignmentExpression assignmentExpression = A_parent;
      if (identical(assignmentExpression.rightHandSide, this)) {
        return assignmentExpression.propagatedParameterElementForRightHandSide;
      }
    } else if (A_parent is PrefixExpression) {
      return A_parent.propagatedParameterElementForOperand;
    } else if (A_parent is PostfixExpression) {
      return A_parent.propagatedParameterElementForOperand;
    }
    return null;
  }
  ParameterElement get staticParameterElement {
    AstNode A_parent = this.parent;
    if (A_parent is ArgumentList) {
      return A_parent.getStaticParameterElementFor(this);
    } else if (A_parent is IndexExpression) {
      IndexExpression indexExpression = A_parent;
      if (identical(indexExpression.index, this)) {
        return indexExpression.staticParameterElementForIndex;
      }
    } else if (A_parent is BinaryExpression) {
      BinaryExpression binaryExpression = A_parent;
      if (identical(binaryExpression.rightOperand, this)) {
        return binaryExpression.staticParameterElementForRightOperand;
      }
    } else if (A_parent is AssignmentExpression) {
      AssignmentExpression assignmentExpression = A_parent;
      if (identical(assignmentExpression.rightHandSide, this)) {
        return assignmentExpression.staticParameterElementForRightHandSide;
      }
    } else if (A_parent is PrefixExpression) {
      return A_parent.staticParameterElementForOperand;
    } else if (A_parent is PostfixExpression) {
      return A_parent.staticParameterElementForOperand;
    }
    return null;
  }
  bool get isAssignable => false;
}
class ExpressionFunctionBody extends FunctionBody {
  A_Token keyword;
  A_Token functionDefinition;
  Expression _expression;
  A_Token semicolon;
  ExpressionFunctionBody(this.keyword, this.functionDefinition, Expression A_expression, this.semicolon) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitExpressionFunctionBody(this);
  A_Token get beginToken => functionDefinition;
  A_Token get endToken {
    if (semicolon != null) {
      return semicolon;
    }
    return _expression.endToken;
  }
  Expression get expression => _expression;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class ExpressionStatement extends Statement {
  Expression _expression;
  A_Token semicolon;
  ExpressionStatement(Expression A_expression, this.semicolon) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitExpressionStatement(this);
  A_Token get beginToken => _expression.beginToken;
  A_Token get endToken {
    if (semicolon != null) {
      return semicolon;
    }
    return _expression.endToken;
  }
  Expression get expression => _expression;
  bool get isSynthetic => _expression.isSynthetic && semicolon.isSynthetic;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class ExtendsClause extends AstNode {
  A_Token keyword;
  TypeName _superclass;
  ExtendsClause(this.keyword, TypeName A_superclass) {
    this._superclass = becomeParentOf(A_superclass);
  }
  accept(AstVisitor visitor) => visitor.visitExtendsClause(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => _superclass.endToken;
  TypeName get superclass => _superclass;
  void set superclass(TypeName A_name) {
    _superclass = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_superclass, visitor);
  }
}
class FieldDeclaration extends ClassMember {
  A_Token staticKeyword;
  VariableDeclarationList _fieldList;
  A_Token semicolon;
  FieldDeclaration(Comment comment, List<Annotation> metadata, this.staticKeyword, VariableDeclarationList fieldList, this.semicolon) : super(comment, metadata) {
    this._fieldList = becomeParentOf(fieldList);
  }
  accept(AstVisitor visitor) => visitor.visitFieldDeclaration(this);
  A_Element get element => null;
  A_Token get endToken => semicolon;
  VariableDeclarationList get fields => _fieldList;
  bool get isStatic => staticKeyword != null;
  void set fields(VariableDeclarationList fieldList) {
    this._fieldList = becomeParentOf(fieldList);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(_fieldList, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (staticKeyword != null) {
      return staticKeyword;
    }
    return _fieldList.beginToken;
  }
}
class FieldFormalParameter extends NormalFormalParameter {
  A_Token keyword;
  TypeName A__type;
  A_Token thisToken;
  A_Token period;
  FormalParameterList A__parameters;
  FieldFormalParameter(Comment comment, List<Annotation> metadata, this.keyword, TypeName A_type, this.thisToken, this.period, SimpleIdentifier identifier, FormalParameterList A_parameters) : super(comment, metadata, identifier) {
    this.A__type = becomeParentOf(A_type);
    this.A__parameters = becomeParentOf(A_parameters);
  }
  accept(AstVisitor visitor) => visitor.visitFieldFormalParameter(this);
  A_Token get beginToken {
    if (keyword != null) {
      return keyword;
    } else if (A__type != null) {
      return A__type.beginToken;
    }
    return thisToken;
  }
  A_Token get endToken => identifier.endToken;
  FormalParameterList get parameters => A__parameters;
  TypeName get type => A__type;
  bool get isConst => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.B_CONST;
  bool get isFinal => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.A_FINAL;
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void set type(TypeName typeName) {
    A__type = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__type, visitor);
    safelyVisitChild(identifier, visitor);
    safelyVisitChild(A__parameters, visitor);
  }
}
class ForEachStatement extends Statement {
  A_Token awaitKeyword;
  A_Token forKeyword;
  A_Token leftParenthesis;
  DeclaredIdentifier _loopVariable;
  SimpleIdentifier _identifier;
  A_Token inKeyword;
  Expression A__iterator;
  A_Token rightParenthesis;
  Statement _body;
  ForEachStatement.con1(this.awaitKeyword, this.forKeyword, this.leftParenthesis, DeclaredIdentifier A_loopVariable, this.inKeyword, Expression A_iterator, this.rightParenthesis, Statement A_body) {
    this._loopVariable = becomeParentOf(A_loopVariable);
    this.A__iterator = becomeParentOf(A_iterator);
    this._body = becomeParentOf(A_body);
  }
  ForEachStatement.con2(this.awaitKeyword, this.forKeyword, this.leftParenthesis, SimpleIdentifier A_identifier, this.inKeyword, Expression A_iterator, this.rightParenthesis, Statement A_body) {
    this._identifier = becomeParentOf(A_identifier);
    this.A__iterator = becomeParentOf(A_iterator);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitForEachStatement(this);
  A_Token get beginToken => forKeyword;
  Statement get body => _body;
  A_Token get endToken => _body.endToken;
  SimpleIdentifier get identifier => _identifier;
  Expression get iterator => A__iterator;
  DeclaredIdentifier get loopVariable => _loopVariable;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_loopVariable, visitor);
    safelyVisitChild(_identifier, visitor);
    safelyVisitChild(A__iterator, visitor);
    safelyVisitChild(_body, visitor);
  }
}
class ForStatement extends Statement {
  A_Token forKeyword;
  A_Token leftParenthesis;
  VariableDeclarationList _variableList;
  Expression _initialization;
  A_Token leftSeparator;
  Expression _condition;
  A_Token rightSeparator;
  NodeList<Expression> _updaters;
  A_Token rightParenthesis;
  Statement _body;
  ForStatement(this.forKeyword, this.leftParenthesis, VariableDeclarationList variableList, Expression A_initialization, this.leftSeparator, Expression A_condition, this.rightSeparator, List<Expression> A_updaters, this.rightParenthesis, Statement A_body) {
    this._updaters = new NodeList<Expression>(this);
    this._variableList = becomeParentOf(variableList);
    this._initialization = becomeParentOf(A_initialization);
    this._condition = becomeParentOf(A_condition);
    this._updaters.addAll(A_updaters);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitForStatement(this);
  A_Token get beginToken => forKeyword;
  Statement get body => _body;
  Expression get condition => _condition;
  A_Token get endToken => _body.endToken;
  Expression get initialization => _initialization;
  NodeList<Expression> get updaters => _updaters;
  VariableDeclarationList get variables => _variableList;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_variableList, visitor);
    safelyVisitChild(_initialization, visitor);
    safelyVisitChild(_condition, visitor);
    _updaters.accept(visitor);
    safelyVisitChild(_body, visitor);
  }
}
abstract class FormalParameter extends AstNode {
  ParameterElement get element {
    SimpleIdentifier A_identifier = this.identifier;
    if (A_identifier == null) {
      return null;
    }
    return A_identifier.staticElement as ParameterElement;
  }
  SimpleIdentifier get identifier;
  ParameterKind get kind;
  bool get isConst;
  bool get isFinal;
}
class FormalParameterList extends AstNode {
  A_Token _leftParenthesis;
  NodeList<FormalParameter> A__parameters;
  A_Token _leftDelimiter;
  A_Token _rightDelimiter;
  A_Token _rightParenthesis;
  FormalParameterList(A_Token A_leftParenthesis, List<FormalParameter> A_parameters, A_Token A_leftDelimiter, A_Token A_rightDelimiter, A_Token A_rightParenthesis) {
    this.A__parameters = new NodeList<FormalParameter>(this);
    this._leftParenthesis = A_leftParenthesis;
    this.A__parameters.addAll(A_parameters);
    this._leftDelimiter = A_leftDelimiter;
    this._rightDelimiter = A_rightDelimiter;
    this._rightParenthesis = A_rightParenthesis;
  }
  accept(AstVisitor visitor) => visitor.visitFormalParameterList(this);
  A_Token get beginToken => _leftParenthesis;
  A_Token get endToken => _rightParenthesis;
  A_Token get leftDelimiter => _leftDelimiter;
  A_Token get leftParenthesis => _leftParenthesis;
  List<ParameterElement> get parameterElements {
    int count = A__parameters.length;
    List<ParameterElement> A_types = new List<ParameterElement>(count);
    for (int i = 0; i < count; i++) {
      A_types[i] = A__parameters[i].element;
    }
    return A_types;
  }
  NodeList<FormalParameter> get parameters => A__parameters;
  A_Token get rightDelimiter => _rightDelimiter;
  A_Token get rightParenthesis => _rightParenthesis;
  void visitChildren(AstVisitor visitor) {
    A__parameters.accept(visitor);
  }
}
abstract class FunctionBody extends AstNode {}
class FunctionDeclaration extends CompilationUnitMember {
  A_Token externalKeyword;
  TypeName A__returnType;
  A_Token propertyKeyword;
  SimpleIdentifier A__name;
  FunctionExpression _functionExpression;
  FunctionDeclaration(Comment comment, List<Annotation> metadata, this.externalKeyword, TypeName A_returnType, this.propertyKeyword, SimpleIdentifier A_name, FunctionExpression A_functionExpression) : super(comment, metadata) {
    this.A__returnType = becomeParentOf(A_returnType);
    this.A__name = becomeParentOf(A_name);
    this._functionExpression = becomeParentOf(A_functionExpression);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionDeclaration(this);
  ExecutableElement get element => A__name != null ? (A__name.staticElement as ExecutableElement) : null;
  A_Token get endToken => _functionExpression.endToken;
  FunctionExpression get functionExpression => _functionExpression;
  SimpleIdentifier get name => A__name;
  TypeName get returnType => A__returnType;
  bool get isGetter => propertyKeyword != null && (propertyKeyword as KeywordToken).keyword == Keyword.GET;
  bool get isSetter => propertyKeyword != null && (propertyKeyword as KeywordToken).keyword == Keyword.SET;
  void set name(SimpleIdentifier identifier) {
    this.A__name = becomeParentOf(identifier);
  }
  void set returnType(TypeName A_returnType) {
    this.A__returnType = becomeParentOf(A_returnType);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__returnType, visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_functionExpression, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (externalKeyword != null) {
      return externalKeyword;
    }
    if (A__returnType != null) {
      return A__returnType.beginToken;
    } else if (propertyKeyword != null) {
      return propertyKeyword;
    } else if (A__name != null) {
      return A__name.beginToken;
    }
    return _functionExpression.beginToken;
  }
}
class FunctionDeclarationStatement extends Statement {
  FunctionDeclaration _functionDeclaration;
  FunctionDeclarationStatement(FunctionDeclaration A_functionDeclaration) {
    this._functionDeclaration = becomeParentOf(A_functionDeclaration);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionDeclarationStatement(this);
  A_Token get beginToken => _functionDeclaration.beginToken;
  A_Token get endToken => _functionDeclaration.endToken;
  FunctionDeclaration get functionDeclaration => _functionDeclaration;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_functionDeclaration, visitor);
  }
}
class FunctionExpression extends Expression {
  FormalParameterList A__parameters;
  FunctionBody _body;
  ExecutableElement element;
  FunctionExpression(FormalParameterList A_parameters, FunctionBody A_body) {
    this.A__parameters = becomeParentOf(A_parameters);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionExpression(this);
  A_Token get beginToken {
    if (A__parameters != null) {
      return A__parameters.beginToken;
    } else if (_body != null) {
      return _body.beginToken;
    }
    throw new IllegalStateException("Non-external functions must have a body");
  }
  FunctionBody get body => _body;
  A_Token get endToken {
    if (_body != null) {
      return _body.endToken;
    } else if (A__parameters != null) {
      return A__parameters.endToken;
    }
    throw new IllegalStateException("Non-external functions must have a body");
  }
  FormalParameterList get parameters => A__parameters;
  int get precedence => 16;
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__parameters, visitor);
    safelyVisitChild(_body, visitor);
  }
}
class FunctionExpressionInvocation extends Expression {
  Expression _function;
  ArgumentList _argumentList;
  ExecutableElement staticElement;
  ExecutableElement _propagatedElement;
  FunctionExpressionInvocation(Expression A_function, ArgumentList A_argumentList) {
    this._function = becomeParentOf(A_function);
    this._argumentList = becomeParentOf(A_argumentList);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionExpressionInvocation(this);
  ArgumentList get argumentList => _argumentList;
  A_Token get beginToken => _function.beginToken;
  ExecutableElement get bestElement {
    ExecutableElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => _argumentList.endToken;
  Expression get function => _function;
  int get precedence => 15;
  ExecutableElement get propagatedElement => _propagatedElement;
  void set propagatedElement(ExecutableElement A_element) {
    _propagatedElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_function, visitor);
    safelyVisitChild(_argumentList, visitor);
  }
}
class FunctionTypeAlias extends TypeAlias {
  TypeName A__returnType;
  SimpleIdentifier A__name;
  TypeParameterList _typeParameters;
  FormalParameterList A__parameters;
  FunctionTypeAlias(Comment comment, List<Annotation> metadata, A_Token keyword, TypeName A_returnType, SimpleIdentifier A_name, TypeParameterList A_typeParameters, FormalParameterList A_parameters, A_Token semicolon) : super(comment, metadata, keyword, semicolon) {
    this.A__returnType = becomeParentOf(A_returnType);
    this.A__name = becomeParentOf(A_name);
    this._typeParameters = becomeParentOf(A_typeParameters);
    this.A__parameters = becomeParentOf(A_parameters);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionTypeAlias(this);
  FunctionTypeAliasElement get element => A__name != null ? (A__name.staticElement as FunctionTypeAliasElement) : null;
  SimpleIdentifier get name => A__name;
  FormalParameterList get parameters => A__parameters;
  TypeName get returnType => A__returnType;
  TypeParameterList get typeParameters => _typeParameters;
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void set returnType(TypeName typeName) {
    A__returnType = becomeParentOf(typeName);
  }
  void set typeParameters(TypeParameterList A_typeParameters) {
    this._typeParameters = becomeParentOf(A_typeParameters);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__returnType, visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_typeParameters, visitor);
    safelyVisitChild(A__parameters, visitor);
  }
}
class FunctionTypedFormalParameter extends NormalFormalParameter {
  TypeName A__returnType;
  FormalParameterList A__parameters;
  FunctionTypedFormalParameter(Comment comment, List<Annotation> metadata, TypeName A_returnType, SimpleIdentifier identifier, FormalParameterList A_parameters) : super(comment, metadata, identifier) {
    this.A__returnType = becomeParentOf(A_returnType);
    this.A__parameters = becomeParentOf(A_parameters);
  }
  accept(AstVisitor visitor) => visitor.visitFunctionTypedFormalParameter(this);
  A_Token get beginToken {
    if (A__returnType != null) {
      return A__returnType.beginToken;
    }
    return identifier.beginToken;
  }
  A_Token get endToken => A__parameters.endToken;
  FormalParameterList get parameters => A__parameters;
  TypeName get returnType => A__returnType;
  bool get isConst => false;
  bool get isFinal => false;
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void set returnType(TypeName A_returnType) {
    this.A__returnType = becomeParentOf(A_returnType);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__returnType, visitor);
    safelyVisitChild(identifier, visitor);
    safelyVisitChild(A__parameters, visitor);
  }
}
class GeneralizingAstVisitor<R> implements AstVisitor<R> {
  R visitAdjacentStrings(AdjacentStrings node) => visitStringLiteral(node);
  R visitAnnotatedNode(AnnotatedNode node) => visitNode(node);
  R visitAnnotation(Annotation node) => visitNode(node);
  R visitArgumentList(ArgumentList node) => visitNode(node);
  R visitAsExpression(AsExpression node) => visitExpression(node);
  R visitAssertStatement(AssertStatement node) => visitStatement(node);
  R visitAssignmentExpression(AssignmentExpression node) => visitExpression(node);
  R visitAwaitExpression(AwaitExpression node) => visitExpression(node);
  R visitBinaryExpression(BinaryExpression node) => visitExpression(node);
  R visitBlock(Block node) => visitStatement(node);
  R visitBlockFunctionBody(BlockFunctionBody node) => visitFunctionBody(node);
  R visitBooleanLiteral(BooleanLiteral node) => visitLiteral(node);
  R visitBreakStatement(BreakStatement node) => visitStatement(node);
  R visitCascadeExpression(CascadeExpression node) => visitExpression(node);
  R visitCatchClause(CatchClause node) => visitNode(node);
  R visitClassDeclaration(ClassDeclaration node) => visitCompilationUnitMember(node);
  R visitClassMember(ClassMember node) => visitDeclaration(node);
  R visitClassTypeAlias(ClassTypeAlias node) => visitTypeAlias(node);
  R visitCombinator(Combinator node) => visitNode(node);
  R visitComment(Comment node) => visitNode(node);
  R visitCommentReference(CommentReference node) => visitNode(node);
  R visitCompilationUnit(CompilationUnit node) => visitNode(node);
  R visitCompilationUnitMember(CompilationUnitMember node) => visitDeclaration(node);
  R visitConditionalExpression(ConditionalExpression node) => visitExpression(node);
  R visitConstructorDeclaration(ConstructorDeclaration node) => visitClassMember(node);
  R visitConstructorFieldInitializer(ConstructorFieldInitializer node) => visitConstructorInitializer(node);
  R visitConstructorInitializer(ConstructorInitializer node) => visitNode(node);
  R visitConstructorName(ConstructorName node) => visitNode(node);
  R visitContinueStatement(ContinueStatement node) => visitStatement(node);
  R visitDeclaration(Declaration node) => visitAnnotatedNode(node);
  R visitDeclaredIdentifier(DeclaredIdentifier node) => visitDeclaration(node);
  R visitDefaultFormalParameter(DefaultFormalParameter node) => visitFormalParameter(node);
  R visitDirective(Directive node) => visitAnnotatedNode(node);
  R visitDoStatement(DoStatement node) => visitStatement(node);
  R visitDoubleLiteral(DoubleLiteral node) => visitLiteral(node);
  R visitEmptyFunctionBody(EmptyFunctionBody node) => visitFunctionBody(node);
  R visitEmptyStatement(EmptyStatement node) => visitStatement(node);
  R visitEnumConstantDeclaration(EnumConstantDeclaration node) => visitDeclaration(node);
  R visitEnumDeclaration(EnumDeclaration node) => visitCompilationUnitMember(node);
  R visitExportDirective(ExportDirective node) => visitNamespaceDirective(node);
  R visitExpression(Expression node) => visitNode(node);
  R visitExpressionFunctionBody(ExpressionFunctionBody node) => visitFunctionBody(node);
  R visitExpressionStatement(ExpressionStatement node) => visitStatement(node);
  R visitExtendsClause(ExtendsClause node) => visitNode(node);
  R visitFieldDeclaration(FieldDeclaration node) => visitClassMember(node);
  R visitFieldFormalParameter(FieldFormalParameter node) => visitNormalFormalParameter(node);
  R visitForEachStatement(ForEachStatement node) => visitStatement(node);
  R visitFormalParameter(FormalParameter node) => visitNode(node);
  R visitFormalParameterList(FormalParameterList node) => visitNode(node);
  R visitForStatement(ForStatement node) => visitStatement(node);
  R visitFunctionBody(FunctionBody node) => visitNode(node);
  R visitFunctionDeclaration(FunctionDeclaration node) => visitCompilationUnitMember(node);
  R visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => visitStatement(node);
  R visitFunctionExpression(FunctionExpression node) => visitExpression(node);
  R visitFunctionExpressionInvocation(FunctionExpressionInvocation node) => visitExpression(node);
  R visitFunctionTypeAlias(FunctionTypeAlias node) => visitTypeAlias(node);
  R visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) => visitNormalFormalParameter(node);
  R visitHideCombinator(HideCombinator node) => visitCombinator(node);
  R visitIdentifier(Identifier node) => visitExpression(node);
  R visitIfStatement(IfStatement node) => visitStatement(node);
  R visitImplementsClause(ImplementsClause node) => visitNode(node);
  R visitImportDirective(ImportDirective node) => visitNamespaceDirective(node);
  R visitIndexExpression(IndexExpression node) => visitExpression(node);
  R visitInstanceCreationExpression(InstanceCreationExpression node) => visitExpression(node);
  R visitIntegerLiteral(IntegerLiteral node) => visitLiteral(node);
  R visitInterpolationElement(InterpolationElement node) => visitNode(node);
  R visitInterpolationExpression(InterpolationExpression node) => visitInterpolationElement(node);
  R visitInterpolationString(InterpolationString node) => visitInterpolationElement(node);
  R visitIsExpression(IsExpression node) => visitExpression(node);
  R visitLabel(Label node) => visitNode(node);
  R visitLabeledStatement(LabeledStatement node) => visitStatement(node);
  R visitLibraryDirective(LibraryDirective node) => visitDirective(node);
  R visitLibraryIdentifier(LibraryIdentifier node) => visitIdentifier(node);
  R visitListLiteral(ListLiteral node) => visitTypedLiteral(node);
  R visitLiteral(Literal node) => visitExpression(node);
  R visitMapLiteral(MapLiteral node) => visitTypedLiteral(node);
  R visitMapLiteralEntry(MapLiteralEntry node) => visitNode(node);
  R visitMethodDeclaration(MethodDeclaration node) => visitClassMember(node);
  R visitMethodInvocation(MethodInvocation node) => visitExpression(node);
  R visitNamedExpression(NamedExpression node) => visitExpression(node);
  R visitNamespaceDirective(NamespaceDirective node) => visitUriBasedDirective(node);
  R visitNativeClause(NativeClause node) => visitNode(node);
  R visitNativeFunctionBody(NativeFunctionBody node) => visitFunctionBody(node);
  R visitNode(AstNode node) {
    node.visitChildren(this);
    return null;
  }
  R visitNormalFormalParameter(NormalFormalParameter node) => visitFormalParameter(node);
  R visitNullLiteral(NullLiteral node) => visitLiteral(node);
  R visitParenthesizedExpression(ParenthesizedExpression node) => visitExpression(node);
  R visitPartDirective(PartDirective node) => visitUriBasedDirective(node);
  R visitPartOfDirective(PartOfDirective node) => visitDirective(node);
  R visitPostfixExpression(PostfixExpression node) => visitExpression(node);
  R visitPrefixedIdentifier(PrefixedIdentifier node) => visitIdentifier(node);
  R visitPrefixExpression(PrefixExpression node) => visitExpression(node);
  R visitPropertyAccess(PropertyAccess node) => visitExpression(node);
  R visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) => visitConstructorInitializer(node);
  R visitRethrowExpression(RethrowExpression node) => visitExpression(node);
  R visitReturnStatement(ReturnStatement node) => visitStatement(node);
  R visitScriptTag(ScriptTag scriptTag) => visitNode(scriptTag);
  R visitShowCombinator(ShowCombinator node) => visitCombinator(node);
  R visitSimpleFormalParameter(SimpleFormalParameter node) => visitNormalFormalParameter(node);
  R visitSimpleIdentifier(SimpleIdentifier node) => visitIdentifier(node);
  R visitSimpleStringLiteral(SimpleStringLiteral node) => visitStringLiteral(node);
  R visitStatement(Statement node) => visitNode(node);
  R visitStringInterpolation(StringInterpolation node) => visitStringLiteral(node);
  R visitStringLiteral(StringLiteral node) => visitLiteral(node);
  R visitSuperConstructorInvocation(SuperConstructorInvocation node) => visitConstructorInitializer(node);
  R visitSuperExpression(SuperExpression node) => visitExpression(node);
  R visitSwitchCase(SwitchCase node) => visitSwitchMember(node);
  R visitSwitchDefault(SwitchDefault node) => visitSwitchMember(node);
  R visitSwitchMember(SwitchMember node) => visitNode(node);
  R visitSwitchStatement(SwitchStatement node) => visitStatement(node);
  R visitSymbolLiteral(SymbolLiteral node) => visitLiteral(node);
  R visitThisExpression(ThisExpression node) => visitExpression(node);
  R visitThrowExpression(ThrowExpression node) => visitExpression(node);
  R visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) => visitCompilationUnitMember(node);
  R visitTryStatement(TryStatement node) => visitStatement(node);
  R visitTypeAlias(TypeAlias node) => visitCompilationUnitMember(node);
  R visitTypeArgumentList(TypeArgumentList node) => visitNode(node);
  R visitTypedLiteral(TypedLiteral node) => visitLiteral(node);
  R visitTypeName(TypeName node) => visitNode(node);
  R visitTypeParameter(TypeParameter node) => visitNode(node);
  R visitTypeParameterList(TypeParameterList node) => visitNode(node);
  R visitUriBasedDirective(UriBasedDirective node) => visitDirective(node);
  R visitVariableDeclaration(VariableDeclaration node) => visitDeclaration(node);
  R visitVariableDeclarationList(VariableDeclarationList node) => visitNode(node);
  R visitVariableDeclarationStatement(VariableDeclarationStatement node) => visitStatement(node);
  R visitWhileStatement(WhileStatement node) => visitStatement(node);
  R visitWithClause(WithClause node) => visitNode(node);
  R visitYieldStatement(YieldStatement node) => visitStatement(node);
}
class HideCombinator extends Combinator {
  NodeList<SimpleIdentifier> _hiddenNames;
  HideCombinator(A_Token keyword, List<SimpleIdentifier> A_hiddenNames) : super(keyword) {
    this._hiddenNames = new NodeList<SimpleIdentifier>(this);
    this._hiddenNames.addAll(A_hiddenNames);
  }
  accept(AstVisitor visitor) => visitor.visitHideCombinator(this);
  A_Token get endToken => _hiddenNames.endToken;
  NodeList<SimpleIdentifier> get hiddenNames => _hiddenNames;
  void visitChildren(AstVisitor visitor) {
    _hiddenNames.accept(visitor);
  }
}
abstract class Identifier extends Expression {
  static bool isPrivateName(String A_name) => StringUtilities.startsWithChar(A_name, 0x5F);
  A_Element get bestElement;
  String get name;
  A_Element get propagatedElement;
  A_Element get staticElement;
  bool get isAssignable => true;
}
class IfStatement extends Statement {
  A_Token ifKeyword;
  A_Token leftParenthesis;
  Expression _condition;
  A_Token rightParenthesis;
  Statement _thenStatement;
  A_Token elseKeyword;
  Statement _elseStatement;
  IfStatement(this.ifKeyword, this.leftParenthesis, Expression A_condition, this.rightParenthesis, Statement A_thenStatement, this.elseKeyword, Statement A_elseStatement) {
    this._condition = becomeParentOf(A_condition);
    this._thenStatement = becomeParentOf(A_thenStatement);
    this._elseStatement = becomeParentOf(A_elseStatement);
  }
  accept(AstVisitor visitor) => visitor.visitIfStatement(this);
  A_Token get beginToken => ifKeyword;
  Expression get condition => _condition;
  Statement get elseStatement => _elseStatement;
  A_Token get endToken {
    if (_elseStatement != null) {
      return _elseStatement.endToken;
    }
    return _thenStatement.endToken;
  }
  Statement get thenStatement => _thenStatement;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_condition, visitor);
    safelyVisitChild(_thenStatement, visitor);
    safelyVisitChild(_elseStatement, visitor);
  }
}
class ImplementsClause extends AstNode {
  A_Token keyword;
  NodeList<TypeName> _interfaces;
  ImplementsClause(this.keyword, List<TypeName> A_interfaces) {
    this._interfaces = new NodeList<TypeName>(this);
    this._interfaces.addAll(A_interfaces);
  }
  accept(AstVisitor visitor) => visitor.visitImplementsClause(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => _interfaces.endToken;
  NodeList<TypeName> get interfaces => _interfaces;
  void visitChildren(AstVisitor visitor) {
    _interfaces.accept(visitor);
  }
}
class ImportDirective extends NamespaceDirective {
  static Comparator<ImportDirective> COMPARATOR = (ImportDirective import1, ImportDirective import2) {
    StringLiteral uri1 = import1.uri;
    StringLiteral uri2 = import2.uri;
    String uriStr1 = uri1.stringValue;
    String uriStr2 = uri2.stringValue;
    if (uriStr1 != null || uriStr2 != null) {
      if (uriStr1 == null) {
        return -1;
      } else if (uriStr2 == null) {
        return 1;
      } else {
        int A_compare = uriStr1.compareTo(uriStr2);
        if (A_compare != 0) {
          return A_compare;
        }
      }
    }
    SimpleIdentifier prefix1 = import1.prefix;
    SimpleIdentifier prefix2 = import2.prefix;
    String prefixStr1 = prefix1 != null ? prefix1.name : null;
    String prefixStr2 = prefix2 != null ? prefix2.name : null;
    if (prefixStr1 != null || prefixStr2 != null) {
      if (prefixStr1 == null) {
        return -1;
      } else if (prefixStr2 == null) {
        return 1;
      } else {
        int A_compare = prefixStr1.compareTo(prefixStr2);
        if (A_compare != 0) {
          return A_compare;
        }
      }
    }
    NodeList<Combinator> combinators1 = import1.combinators;
    List<String> allHides1 = new List<String>();
    List<String> allShows1 = new List<String>();
    for (Combinator combinator in combinators1) {
      if (combinator is HideCombinator) {
        NodeList<SimpleIdentifier> hides = combinator.hiddenNames;
        for (SimpleIdentifier simpleIdentifier in hides) {
          allHides1.add(simpleIdentifier.name);
        }
      } else {
        NodeList<SimpleIdentifier> shows = (combinator as ShowCombinator).shownNames;
        for (SimpleIdentifier simpleIdentifier in shows) {
          allShows1.add(simpleIdentifier.name);
        }
      }
    }
    NodeList<Combinator> combinators2 = import2.combinators;
    List<String> allHides2 = new List<String>();
    List<String> allShows2 = new List<String>();
    for (Combinator combinator in combinators2) {
      if (combinator is HideCombinator) {
        NodeList<SimpleIdentifier> hides = combinator.hiddenNames;
        for (SimpleIdentifier simpleIdentifier in hides) {
          allHides2.add(simpleIdentifier.name);
        }
      } else {
        NodeList<SimpleIdentifier> shows = (combinator as ShowCombinator).shownNames;
        for (SimpleIdentifier simpleIdentifier in shows) {
          allShows2.add(simpleIdentifier.name);
        }
      }
    }
    if (allHides1.length != allHides2.length) {
      return allHides1.length - allHides2.length;
    }
    if (allShows1.length != allShows2.length) {
      return allShows1.length - allShows2.length;
    }
    if (!javaCollectionContainsAll(allHides1, allHides2)) {
      return -1;
    }
    if (!javaCollectionContainsAll(allShows1, allShows2)) {
      return -1;
    }
    return 0;
  };
  A_Token deferredToken;
  A_Token asToken;
  SimpleIdentifier A__prefix;
  ImportDirective(Comment comment, List<Annotation> metadata, A_Token keyword, StringLiteral libraryUri, this.deferredToken, this.asToken, SimpleIdentifier A_prefix, List<Combinator> combinators, A_Token semicolon) : super(comment, metadata, keyword, libraryUri, combinators, semicolon) {
    this.A__prefix = becomeParentOf(A_prefix);
  }
  accept(AstVisitor visitor) => visitor.visitImportDirective(this);
  ImportElement get element => super.element as ImportElement;
  SimpleIdentifier get prefix => A__prefix;
  LibraryElement get uriElement {
    ImportElement A_element = this.element;
    if (A_element == null) {
      return null;
    }
    return A_element.importedLibrary;
  }
  void set prefix(SimpleIdentifier A_prefix) {
    this.A__prefix = becomeParentOf(A_prefix);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__prefix, visitor);
    combinators.accept(visitor);
  }
}
class IncrementalAstCloner implements AstVisitor<AstNode> {
  final AstNode _oldNode;
  final AstNode _newNode;
  final TokenMap _tokenMap;
  IncrementalAstCloner(this._oldNode, this._newNode, this._tokenMap);
  AdjacentStrings visitAdjacentStrings(AdjacentStrings node) => new AdjacentStrings(_cloneNodeList(node.strings));
  Annotation visitAnnotation(Annotation node) {
    Annotation A_copy = new Annotation(_mapToken(node.atSign), A__cloneNode(node.name), _mapToken(node.period), A__cloneNode(node.constructorName), A__cloneNode(node.arguments));
    A_copy.element = node.element;
    return A_copy;
  }
  ArgumentList visitArgumentList(ArgumentList node) => new ArgumentList(_mapToken(node.leftParenthesis), _cloneNodeList(node.arguments), _mapToken(node.rightParenthesis));
  AsExpression visitAsExpression(AsExpression node) {
    AsExpression A_copy = new AsExpression(A__cloneNode(node.expression), _mapToken(node.asOperator), A__cloneNode(node.type));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  AstNode visitAssertStatement(AssertStatement node) => new AssertStatement(_mapToken(node.keyword), _mapToken(node.leftParenthesis), A__cloneNode(node.condition), _mapToken(node.rightParenthesis), _mapToken(node.semicolon));
  AssignmentExpression visitAssignmentExpression(AssignmentExpression node) {
    AssignmentExpression A_copy = new AssignmentExpression(A__cloneNode(node.leftHandSide), _mapToken(node.operator), A__cloneNode(node.rightHandSide));
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  AwaitExpression visitAwaitExpression(AwaitExpression node) => new AwaitExpression(_mapToken(node.awaitKeyword), A__cloneNode(node.expression), _mapToken(node.semicolon));
  BinaryExpression visitBinaryExpression(BinaryExpression node) {
    BinaryExpression A_copy = new BinaryExpression(A__cloneNode(node.leftOperand), _mapToken(node.operator), A__cloneNode(node.rightOperand));
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  Block visitBlock(Block node) => new Block(_mapToken(node.leftBracket), _cloneNodeList(node.statements), _mapToken(node.rightBracket));
  BlockFunctionBody visitBlockFunctionBody(BlockFunctionBody node) => new BlockFunctionBody(_mapToken(node.keyword), _mapToken(node.star), A__cloneNode(node.block));
  BooleanLiteral visitBooleanLiteral(BooleanLiteral node) {
    BooleanLiteral A_copy = new BooleanLiteral(_mapToken(node.literal), node.value);
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  BreakStatement visitBreakStatement(BreakStatement node) => new BreakStatement(_mapToken(node.keyword), A__cloneNode(node.label), _mapToken(node.semicolon));
  CascadeExpression visitCascadeExpression(CascadeExpression node) {
    CascadeExpression A_copy = new CascadeExpression(A__cloneNode(node.target), _cloneNodeList(node.cascadeSections));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  CatchClause visitCatchClause(CatchClause node) => new CatchClause(_mapToken(node.onKeyword), A__cloneNode(node.exceptionType), _mapToken(node.catchKeyword), _mapToken(node.leftParenthesis), A__cloneNode(node.exceptionParameter), _mapToken(node.comma), A__cloneNode(node.stackTraceParameter), _mapToken(node.rightParenthesis), A__cloneNode(node.body));
  ClassDeclaration visitClassDeclaration(ClassDeclaration node) {
    ClassDeclaration A_copy = new ClassDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.abstractKeyword), _mapToken(node.classKeyword), A__cloneNode(node.name), A__cloneNode(node.typeParameters), A__cloneNode(node.extendsClause), A__cloneNode(node.withClause), A__cloneNode(node.implementsClause), _mapToken(node.leftBracket), _cloneNodeList(node.members), _mapToken(node.rightBracket));
    A_copy.nativeClause = A__cloneNode(node.nativeClause);
    return A_copy;
  }
  ClassTypeAlias visitClassTypeAlias(ClassTypeAlias node) => new ClassTypeAlias(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.name), A__cloneNode(node.typeParameters), _mapToken(node.A_equals), _mapToken(node.abstractKeyword), A__cloneNode(node.superclass), A__cloneNode(node.withClause), A__cloneNode(node.implementsClause), _mapToken(node.semicolon));
  Comment visitComment(Comment node) {
    if (node.isDocumentation) {
      return Comment.createDocumentationCommentWithReferences(_mapTokens(node.tokens), _cloneNodeList(node.references));
    } else if (node.isBlock) {
      return Comment.createBlockComment(_mapTokens(node.tokens));
    }
    return Comment.createEndOfLineComment(_mapTokens(node.tokens));
  }
  CommentReference visitCommentReference(CommentReference node) => new CommentReference(_mapToken(node.newKeyword), A__cloneNode(node.identifier));
  CompilationUnit visitCompilationUnit(CompilationUnit node) {
    CompilationUnit A_copy = new CompilationUnit(_mapToken(node.beginToken), A__cloneNode(node.scriptTag), _cloneNodeList(node.directives), _cloneNodeList(node.declarations), _mapToken(node.endToken));
    A_copy.lineInfo = node.lineInfo;
    A_copy.element = node.element;
    return A_copy;
  }
  ConditionalExpression visitConditionalExpression(ConditionalExpression node) {
    ConditionalExpression A_copy = new ConditionalExpression(A__cloneNode(node.condition), _mapToken(node.question), A__cloneNode(node.thenExpression), _mapToken(node.colon), A__cloneNode(node.elseExpression));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ConstructorDeclaration visitConstructorDeclaration(ConstructorDeclaration node) {
    ConstructorDeclaration A_copy = new ConstructorDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.externalKeyword), _mapToken(node.constKeyword), _mapToken(node.factoryKeyword), A__cloneNode(node.returnType), _mapToken(node.period), A__cloneNode(node.name), A__cloneNode(node.parameters), _mapToken(node.A_separator), _cloneNodeList(node.initializers), A__cloneNode(node.redirectedConstructor), A__cloneNode(node.body));
    A_copy.element = node.element;
    return A_copy;
  }
  ConstructorFieldInitializer visitConstructorFieldInitializer(ConstructorFieldInitializer node) => new ConstructorFieldInitializer(_mapToken(node.keyword), _mapToken(node.period), A__cloneNode(node.fieldName), _mapToken(node.A_equals), A__cloneNode(node.expression));
  ConstructorName visitConstructorName(ConstructorName node) {
    ConstructorName A_copy = new ConstructorName(A__cloneNode(node.type), _mapToken(node.period), A__cloneNode(node.name));
    A_copy.staticElement = node.staticElement;
    return A_copy;
  }
  ContinueStatement visitContinueStatement(ContinueStatement node) => new ContinueStatement(_mapToken(node.keyword), A__cloneNode(node.label), _mapToken(node.semicolon));
  DeclaredIdentifier visitDeclaredIdentifier(DeclaredIdentifier node) => new DeclaredIdentifier(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.type), A__cloneNode(node.identifier));
  DefaultFormalParameter visitDefaultFormalParameter(DefaultFormalParameter node) => new DefaultFormalParameter(A__cloneNode(node.parameter), node.kind, _mapToken(node.A_separator), A__cloneNode(node.defaultValue));
  DoStatement visitDoStatement(DoStatement node) => new DoStatement(_mapToken(node.doKeyword), A__cloneNode(node.body), _mapToken(node.whileKeyword), _mapToken(node.leftParenthesis), A__cloneNode(node.condition), _mapToken(node.rightParenthesis), _mapToken(node.semicolon));
  DoubleLiteral visitDoubleLiteral(DoubleLiteral node) {
    DoubleLiteral A_copy = new DoubleLiteral(_mapToken(node.literal), node.value);
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  EmptyFunctionBody visitEmptyFunctionBody(EmptyFunctionBody node) => new EmptyFunctionBody(_mapToken(node.semicolon));
  EmptyStatement visitEmptyStatement(EmptyStatement node) => new EmptyStatement(_mapToken(node.semicolon));
  AstNode visitEnumConstantDeclaration(EnumConstantDeclaration node) => new EnumConstantDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), A__cloneNode(node.name));
  AstNode visitEnumDeclaration(EnumDeclaration node) => new EnumDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.name), _mapToken(node.leftBracket), _cloneNodeList(node.constants), _mapToken(node.rightBracket));
  ExportDirective visitExportDirective(ExportDirective node) {
    ExportDirective A_copy = new ExportDirective(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.uri), _cloneNodeList(node.combinators), _mapToken(node.semicolon));
    A_copy.element = node.element;
    return A_copy;
  }
  ExpressionFunctionBody visitExpressionFunctionBody(ExpressionFunctionBody node) => new ExpressionFunctionBody(_mapToken(node.keyword), _mapToken(node.functionDefinition), A__cloneNode(node.expression), _mapToken(node.semicolon));
  ExpressionStatement visitExpressionStatement(ExpressionStatement node) => new ExpressionStatement(A__cloneNode(node.expression), _mapToken(node.semicolon));
  ExtendsClause visitExtendsClause(ExtendsClause node) => new ExtendsClause(_mapToken(node.keyword), A__cloneNode(node.superclass));
  FieldDeclaration visitFieldDeclaration(FieldDeclaration node) => new FieldDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.staticKeyword), A__cloneNode(node.fields), _mapToken(node.semicolon));
  FieldFormalParameter visitFieldFormalParameter(FieldFormalParameter node) => new FieldFormalParameter(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.type), _mapToken(node.thisToken), _mapToken(node.period), A__cloneNode(node.identifier), A__cloneNode(node.parameters));
  ForEachStatement visitForEachStatement(ForEachStatement node) {
    DeclaredIdentifier loopVariable = node.loopVariable;
    if (loopVariable == null) {
      return new ForEachStatement.con2(_mapToken(node.awaitKeyword), _mapToken(node.forKeyword), _mapToken(node.leftParenthesis), A__cloneNode(node.identifier), _mapToken(node.inKeyword), A__cloneNode(node.iterator), _mapToken(node.rightParenthesis), A__cloneNode(node.body));
    }
    return new ForEachStatement.con1(_mapToken(node.awaitKeyword), _mapToken(node.forKeyword), _mapToken(node.leftParenthesis), A__cloneNode(loopVariable), _mapToken(node.inKeyword), A__cloneNode(node.iterator), _mapToken(node.rightParenthesis), A__cloneNode(node.body));
  }
  FormalParameterList visitFormalParameterList(FormalParameterList node) => new FormalParameterList(_mapToken(node.leftParenthesis), _cloneNodeList(node.parameters), _mapToken(node.leftDelimiter), _mapToken(node.rightDelimiter), _mapToken(node.rightParenthesis));
  ForStatement visitForStatement(ForStatement node) => new ForStatement(_mapToken(node.forKeyword), _mapToken(node.leftParenthesis), A__cloneNode(node.variables), A__cloneNode(node.initialization), _mapToken(node.leftSeparator), A__cloneNode(node.condition), _mapToken(node.rightSeparator), _cloneNodeList(node.updaters), _mapToken(node.rightParenthesis), A__cloneNode(node.body));
  FunctionDeclaration visitFunctionDeclaration(FunctionDeclaration node) => new FunctionDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.externalKeyword), A__cloneNode(node.returnType), _mapToken(node.propertyKeyword), A__cloneNode(node.name), A__cloneNode(node.functionExpression));
  FunctionDeclarationStatement visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => new FunctionDeclarationStatement(A__cloneNode(node.functionDeclaration));
  FunctionExpression visitFunctionExpression(FunctionExpression node) {
    FunctionExpression A_copy = new FunctionExpression(A__cloneNode(node.parameters), A__cloneNode(node.body));
    A_copy.element = node.element;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  FunctionExpressionInvocation visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    FunctionExpressionInvocation A_copy = new FunctionExpressionInvocation(A__cloneNode(node.function), A__cloneNode(node.argumentList));
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  FunctionTypeAlias visitFunctionTypeAlias(FunctionTypeAlias node) => new FunctionTypeAlias(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.returnType), A__cloneNode(node.name), A__cloneNode(node.typeParameters), A__cloneNode(node.parameters), _mapToken(node.semicolon));
  FunctionTypedFormalParameter visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) => new FunctionTypedFormalParameter(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), A__cloneNode(node.returnType), A__cloneNode(node.identifier), A__cloneNode(node.parameters));
  HideCombinator visitHideCombinator(HideCombinator node) => new HideCombinator(_mapToken(node.keyword), _cloneNodeList(node.hiddenNames));
  IfStatement visitIfStatement(IfStatement node) => new IfStatement(_mapToken(node.ifKeyword), _mapToken(node.leftParenthesis), A__cloneNode(node.condition), _mapToken(node.rightParenthesis), A__cloneNode(node.thenStatement), _mapToken(node.elseKeyword), A__cloneNode(node.elseStatement));
  ImplementsClause visitImplementsClause(ImplementsClause node) => new ImplementsClause(_mapToken(node.keyword), _cloneNodeList(node.interfaces));
  ImportDirective visitImportDirective(ImportDirective node) => new ImportDirective(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.uri), _mapToken(node.deferredToken), _mapToken(node.asToken), A__cloneNode(node.prefix), _cloneNodeList(node.combinators), _mapToken(node.semicolon));
  IndexExpression visitIndexExpression(IndexExpression node) {
    A_Token period = _mapToken(node.period);
    IndexExpression A_copy;
    if (period == null) {
      A_copy = new IndexExpression.forTarget(A__cloneNode(node.target), _mapToken(node.leftBracket), A__cloneNode(node.index), _mapToken(node.rightBracket));
    } else {
      A_copy = new IndexExpression.forCascade(period, _mapToken(node.leftBracket), A__cloneNode(node.index), _mapToken(node.rightBracket));
    }
    A_copy.auxiliaryElements = node.auxiliaryElements;
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  InstanceCreationExpression visitInstanceCreationExpression(InstanceCreationExpression node) {
    InstanceCreationExpression A_copy = new InstanceCreationExpression(_mapToken(node.keyword), A__cloneNode(node.constructorName), A__cloneNode(node.argumentList));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  IntegerLiteral visitIntegerLiteral(IntegerLiteral node) {
    IntegerLiteral A_copy = new IntegerLiteral(_mapToken(node.literal), node.value);
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  InterpolationExpression visitInterpolationExpression(InterpolationExpression node) => new InterpolationExpression(_mapToken(node.leftBracket), A__cloneNode(node.expression), _mapToken(node.rightBracket));
  InterpolationString visitInterpolationString(InterpolationString node) => new InterpolationString(_mapToken(node.contents), node.value);
  IsExpression visitIsExpression(IsExpression node) {
    IsExpression A_copy = new IsExpression(A__cloneNode(node.expression), _mapToken(node.isOperator), _mapToken(node.notOperator), A__cloneNode(node.type));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  Label visitLabel(Label node) => new Label(A__cloneNode(node.label), _mapToken(node.colon));
  LabeledStatement visitLabeledStatement(LabeledStatement node) => new LabeledStatement(_cloneNodeList(node.labels), A__cloneNode(node.statement));
  LibraryDirective visitLibraryDirective(LibraryDirective node) => new LibraryDirective(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.libraryToken), A__cloneNode(node.name), _mapToken(node.semicolon));
  LibraryIdentifier visitLibraryIdentifier(LibraryIdentifier node) {
    LibraryIdentifier A_copy = new LibraryIdentifier(_cloneNodeList(node.components));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ListLiteral visitListLiteral(ListLiteral node) {
    ListLiteral A_copy = new ListLiteral(_mapToken(node.constKeyword), A__cloneNode(node.typeArguments), _mapToken(node.leftBracket), _cloneNodeList(node.elements), _mapToken(node.rightBracket));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  MapLiteral visitMapLiteral(MapLiteral node) {
    MapLiteral A_copy = new MapLiteral(_mapToken(node.constKeyword), A__cloneNode(node.typeArguments), _mapToken(node.leftBracket), _cloneNodeList(node.entries), _mapToken(node.rightBracket));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  MapLiteralEntry visitMapLiteralEntry(MapLiteralEntry node) => new MapLiteralEntry(A__cloneNode(node.key), _mapToken(node.A_separator), A__cloneNode(node.value));
  MethodDeclaration visitMethodDeclaration(MethodDeclaration node) => new MethodDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.externalKeyword), _mapToken(node.modifierKeyword), A__cloneNode(node.returnType), _mapToken(node.propertyKeyword), _mapToken(node.operatorKeyword), A__cloneNode(node.name), A__cloneNode(node.parameters), A__cloneNode(node.body));
  MethodInvocation visitMethodInvocation(MethodInvocation node) {
    MethodInvocation A_copy = new MethodInvocation(A__cloneNode(node.target), _mapToken(node.period), A__cloneNode(node.methodName), A__cloneNode(node.argumentList));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  NamedExpression visitNamedExpression(NamedExpression node) {
    NamedExpression A_copy = new NamedExpression(A__cloneNode(node.name), A__cloneNode(node.expression));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  AstNode visitNativeClause(NativeClause node) => new NativeClause(_mapToken(node.keyword), A__cloneNode(node.name));
  NativeFunctionBody visitNativeFunctionBody(NativeFunctionBody node) => new NativeFunctionBody(_mapToken(node.nativeToken), A__cloneNode(node.stringLiteral), _mapToken(node.semicolon));
  NullLiteral visitNullLiteral(NullLiteral node) {
    NullLiteral A_copy = new NullLiteral(_mapToken(node.literal));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ParenthesizedExpression visitParenthesizedExpression(ParenthesizedExpression node) {
    ParenthesizedExpression A_copy = new ParenthesizedExpression(_mapToken(node.leftParenthesis), A__cloneNode(node.expression), _mapToken(node.rightParenthesis));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  PartDirective visitPartDirective(PartDirective node) {
    PartDirective A_copy = new PartDirective(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.partToken), A__cloneNode(node.uri), _mapToken(node.semicolon));
    A_copy.element = node.element;
    return A_copy;
  }
  PartOfDirective visitPartOfDirective(PartOfDirective node) {
    PartOfDirective A_copy = new PartOfDirective(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.partToken), _mapToken(node.ofToken), A__cloneNode(node.libraryName), _mapToken(node.semicolon));
    A_copy.element = node.element;
    return A_copy;
  }
  PostfixExpression visitPostfixExpression(PostfixExpression node) {
    PostfixExpression A_copy = new PostfixExpression(A__cloneNode(node.operand), _mapToken(node.operator));
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  PrefixedIdentifier visitPrefixedIdentifier(PrefixedIdentifier node) {
    PrefixedIdentifier A_copy = new PrefixedIdentifier(A__cloneNode(node.prefix), _mapToken(node.period), A__cloneNode(node.identifier));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  PrefixExpression visitPrefixExpression(PrefixExpression node) {
    PrefixExpression A_copy = new PrefixExpression(_mapToken(node.operator), A__cloneNode(node.operand));
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  PropertyAccess visitPropertyAccess(PropertyAccess node) {
    PropertyAccess A_copy = new PropertyAccess(A__cloneNode(node.target), _mapToken(node.operator), A__cloneNode(node.propertyName));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  RedirectingConstructorInvocation visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    RedirectingConstructorInvocation A_copy = new RedirectingConstructorInvocation(_mapToken(node.keyword), _mapToken(node.period), A__cloneNode(node.constructorName), A__cloneNode(node.argumentList));
    A_copy.staticElement = node.staticElement;
    return A_copy;
  }
  RethrowExpression visitRethrowExpression(RethrowExpression node) {
    RethrowExpression A_copy = new RethrowExpression(_mapToken(node.keyword));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ReturnStatement visitReturnStatement(ReturnStatement node) => new ReturnStatement(_mapToken(node.keyword), A__cloneNode(node.expression), _mapToken(node.semicolon));
  ScriptTag visitScriptTag(ScriptTag node) => new ScriptTag(_mapToken(node.scriptTag));
  ShowCombinator visitShowCombinator(ShowCombinator node) => new ShowCombinator(_mapToken(node.keyword), _cloneNodeList(node.shownNames));
  SimpleFormalParameter visitSimpleFormalParameter(SimpleFormalParameter node) => new SimpleFormalParameter(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.type), A__cloneNode(node.identifier));
  SimpleIdentifier visitSimpleIdentifier(SimpleIdentifier node) {
    A_Token mappedToken = _mapToken(node.token);
    if (mappedToken == null) {
      mappedToken = node.token;
    }
    SimpleIdentifier A_copy = new SimpleIdentifier(mappedToken);
    A_copy.auxiliaryElements = node.auxiliaryElements;
    A_copy.propagatedElement = node.propagatedElement;
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticElement = node.staticElement;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  SimpleStringLiteral visitSimpleStringLiteral(SimpleStringLiteral node) {
    SimpleStringLiteral A_copy = new SimpleStringLiteral(_mapToken(node.literal), node.value);
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  StringInterpolation visitStringInterpolation(StringInterpolation node) {
    StringInterpolation A_copy = new StringInterpolation(_cloneNodeList(node.elements));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  SuperConstructorInvocation visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    SuperConstructorInvocation A_copy = new SuperConstructorInvocation(_mapToken(node.keyword), _mapToken(node.period), A__cloneNode(node.constructorName), A__cloneNode(node.argumentList));
    A_copy.staticElement = node.staticElement;
    return A_copy;
  }
  SuperExpression visitSuperExpression(SuperExpression node) {
    SuperExpression A_copy = new SuperExpression(_mapToken(node.keyword));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  SwitchCase visitSwitchCase(SwitchCase node) => new SwitchCase(_cloneNodeList(node.labels), _mapToken(node.keyword), A__cloneNode(node.expression), _mapToken(node.colon), _cloneNodeList(node.statements));
  SwitchDefault visitSwitchDefault(SwitchDefault node) => new SwitchDefault(_cloneNodeList(node.labels), _mapToken(node.keyword), _mapToken(node.colon), _cloneNodeList(node.statements));
  SwitchStatement visitSwitchStatement(SwitchStatement node) => new SwitchStatement(_mapToken(node.keyword), _mapToken(node.leftParenthesis), A__cloneNode(node.expression), _mapToken(node.rightParenthesis), _mapToken(node.leftBracket), _cloneNodeList(node.members), _mapToken(node.rightBracket));
  AstNode visitSymbolLiteral(SymbolLiteral node) {
    SymbolLiteral A_copy = new SymbolLiteral(_mapToken(node.poundSign), _mapTokens(node.components));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ThisExpression visitThisExpression(ThisExpression node) {
    ThisExpression A_copy = new ThisExpression(_mapToken(node.keyword));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  ThrowExpression visitThrowExpression(ThrowExpression node) {
    ThrowExpression A_copy = new ThrowExpression(_mapToken(node.keyword), A__cloneNode(node.expression));
    A_copy.propagatedType = node.propagatedType;
    A_copy.staticType = node.staticType;
    return A_copy;
  }
  TopLevelVariableDeclaration visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) => new TopLevelVariableDeclaration(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), A__cloneNode(node.variables), _mapToken(node.semicolon));
  TryStatement visitTryStatement(TryStatement node) => new TryStatement(_mapToken(node.tryKeyword), A__cloneNode(node.body), _cloneNodeList(node.catchClauses), _mapToken(node.finallyKeyword), A__cloneNode(node.finallyBlock));
  TypeArgumentList visitTypeArgumentList(TypeArgumentList node) => new TypeArgumentList(_mapToken(node.leftBracket), _cloneNodeList(node.arguments), _mapToken(node.rightBracket));
  TypeName visitTypeName(TypeName node) {
    TypeName A_copy = new TypeName(A__cloneNode(node.name), A__cloneNode(node.typeArguments));
    A_copy.type = node.type;
    return A_copy;
  }
  TypeParameter visitTypeParameter(TypeParameter node) => new TypeParameter(A__cloneNode(node.documentationComment), _cloneNodeList(node.metadata), A__cloneNode(node.name), _mapToken(node.keyword), A__cloneNode(node.bound));
  TypeParameterList visitTypeParameterList(TypeParameterList node) => new TypeParameterList(_mapToken(node.leftBracket), _cloneNodeList(node.typeParameters), _mapToken(node.rightBracket));
  VariableDeclaration visitVariableDeclaration(VariableDeclaration node) => new VariableDeclaration(null, _cloneNodeList(node.metadata), A__cloneNode(node.name), _mapToken(node.A_equals), A__cloneNode(node.initializer));
  VariableDeclarationList visitVariableDeclarationList(VariableDeclarationList node) => new VariableDeclarationList(null, _cloneNodeList(node.metadata), _mapToken(node.keyword), A__cloneNode(node.type), _cloneNodeList(node.variables));
  VariableDeclarationStatement visitVariableDeclarationStatement(VariableDeclarationStatement node) => new VariableDeclarationStatement(A__cloneNode(node.variables), _mapToken(node.semicolon));
  WhileStatement visitWhileStatement(WhileStatement node) => new WhileStatement(_mapToken(node.keyword), _mapToken(node.leftParenthesis), A__cloneNode(node.condition), _mapToken(node.rightParenthesis), A__cloneNode(node.body));
  WithClause visitWithClause(WithClause node) => new WithClause(_mapToken(node.withKeyword), _cloneNodeList(node.mixinTypes));
  YieldStatement visitYieldStatement(YieldStatement node) => new YieldStatement(_mapToken(node.yieldKeyword), _mapToken(node.star), A__cloneNode(node.expression), _mapToken(node.semicolon));
  AstNode A__cloneNode(AstNode node) {
    if (node == null) {
      return null;
    }
    if (identical(node, _oldNode)) {
      return _newNode;
    }
    return node.accept(this) as AstNode;
  }
  List _cloneNodeList(NodeList nodes) {
    List clonedNodes = new List();
    for (AstNode node in nodes) {
      clonedNodes.add(A__cloneNode(node));
    }
    return clonedNodes;
  }
  A_Token _mapToken(A_Token oldToken) {
    if (oldToken == null) {
      return null;
    }
    return _tokenMap.get(oldToken);
  }
  List<A_Token> _mapTokens(List<A_Token> oldTokens) {
    List<A_Token> newTokens = new List<A_Token>(oldTokens.length);
    for (int A_index = 0; A_index < newTokens.length; A_index++) {
      newTokens[A_index] = _mapToken(oldTokens[A_index]);
    }
    return newTokens;
  }
}
class IndexExpression extends Expression {
  Expression A__target;
  A_Token period;
  A_Token _leftBracket;
  Expression B__index;
  A_Token _rightBracket;
  MethodElement _staticElement;
  MethodElement _propagatedElement;
  AuxiliaryElements auxiliaryElements = null;
  IndexExpression.forTarget(Expression A_target, A_Token A_leftBracket, Expression A_index, A_Token A_rightBracket) {
    this.A__target = becomeParentOf(A_target);
    this._leftBracket = A_leftBracket;
    this.B__index = becomeParentOf(A_index);
    this._rightBracket = A_rightBracket;
  }
  IndexExpression.forCascade(this.period, A_Token A_leftBracket, Expression A_index, A_Token A_rightBracket) {
    this._leftBracket = A_leftBracket;
    this.B__index = becomeParentOf(A_index);
    this._rightBracket = A_rightBracket;
  }
  accept(AstVisitor visitor) => visitor.visitIndexExpression(this);
  A_Token get beginToken {
    if (A__target != null) {
      return A__target.beginToken;
    }
    return period;
  }
  MethodElement get bestElement {
    MethodElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => _rightBracket;
  Expression get index => B__index;
  A_Token get leftBracket => _leftBracket;
  int get precedence => 15;
  MethodElement get propagatedElement => _propagatedElement;
  Expression get realTarget {
    if (isCascaded) {
      AstNode ancestor = parent;
      while (ancestor is! CascadeExpression) {
        if (ancestor == null) {
          return A__target;
        }
        ancestor = ancestor.parent;
      }
      return (ancestor as CascadeExpression).target;
    }
    return A__target;
  }
  A_Token get rightBracket => _rightBracket;
  MethodElement get staticElement => _staticElement;
  Expression get target => A__target;
  bool inGetterContext() {
    AstNode A_parent = this.parent;
    if (A_parent is AssignmentExpression) {
      AssignmentExpression assignment = A_parent;
      if (identical(assignment.leftHandSide, this) && assignment.operator.type == A_TokenType.A_EQ) {
        return false;
      }
    }
    return true;
  }
  bool inSetterContext() {
    AstNode A_parent = this.parent;
    if (A_parent is PrefixExpression) {
      return A_parent.operator.type.isIncrementOperator;
    } else if (A_parent is PostfixExpression) {
      return true;
    } else if (A_parent is AssignmentExpression) {
      return identical(A_parent.leftHandSide, this);
    }
    return false;
  }
  bool get isAssignable => true;
  bool get isCascaded => period != null;
  void set index(Expression expression) {
    B__index = becomeParentOf(expression);
  }
  void set propagatedElement(MethodElement A_element) {
    _propagatedElement = A_element;
  }
  void set staticElement(MethodElement A_element) {
    _staticElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__target, visitor);
    safelyVisitChild(B__index, visitor);
  }
  ParameterElement get propagatedParameterElementForIndex {
    if (_propagatedElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _propagatedElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
  ParameterElement get staticParameterElementForIndex {
    if (_staticElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _staticElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
}
class InstanceCreationExpression extends Expression {
  A_Token keyword;
  ConstructorName _constructorName;
  ArgumentList _argumentList;
  ConstructorElement staticElement;
  EvaluationResultImpl _result;
  InstanceCreationExpression(this.keyword, ConstructorName A_constructorName, ArgumentList A_argumentList) {
    this._constructorName = becomeParentOf(A_constructorName);
    this._argumentList = becomeParentOf(A_argumentList);
  }
  accept(AstVisitor visitor) => visitor.visitInstanceCreationExpression(this);
  ArgumentList get argumentList => _argumentList;
  A_Token get beginToken => keyword;
  ConstructorName get constructorName => _constructorName;
  A_Token get endToken => _argumentList.endToken;
  EvaluationResultImpl get evaluationResult => _result;
  int get precedence => 15;
  bool get isConst => keyword is KeywordToken && (keyword as KeywordToken).keyword == Keyword.B_CONST;
  void set evaluationResult(EvaluationResultImpl result) {
    this._result = result;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_constructorName, visitor);
    safelyVisitChild(_argumentList, visitor);
  }
}
class IntegerLiteral extends Literal {
  A_Token literal;
  int value = 0;
  IntegerLiteral(this.literal, this.value);
  accept(AstVisitor visitor) => visitor.visitIntegerLiteral(this);
  A_Token get beginToken => literal;
  A_Token get endToken => literal;
  void visitChildren(AstVisitor visitor) {}
}
abstract class InterpolationElement extends AstNode {}
class InterpolationExpression extends InterpolationElement {
  A_Token leftBracket;
  Expression _expression;
  A_Token rightBracket;
  InterpolationExpression(this.leftBracket, Expression A_expression, this.rightBracket) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitInterpolationExpression(this);
  A_Token get beginToken => leftBracket;
  A_Token get endToken {
    if (rightBracket != null) {
      return rightBracket;
    }
    return _expression.endToken;
  }
  Expression get expression => _expression;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class InterpolationString extends InterpolationElement {
  A_Token _contents;
  String A__value;
  InterpolationString(A_Token A_contents, String A_value) {
    this._contents = A_contents;
    this.A__value = A_value;
  }
  accept(AstVisitor visitor) => visitor.visitInterpolationString(this);
  A_Token get beginToken => _contents;
  A_Token get contents => _contents;
  A_Token get endToken => _contents;
  String get value => A__value;
  void set value(String A_string) {
    A__value = A_string;
  }
  void visitChildren(AstVisitor visitor) {}
}
class IsExpression extends Expression {
  Expression _expression;
  A_Token isOperator;
  A_Token notOperator;
  TypeName A__type;
  IsExpression(Expression A_expression, this.isOperator, this.notOperator, TypeName A_type) {
    this._expression = becomeParentOf(A_expression);
    this.A__type = becomeParentOf(A_type);
  }
  accept(AstVisitor visitor) => visitor.visitIsExpression(this);
  A_Token get beginToken => _expression.beginToken;
  A_Token get endToken => A__type.endToken;
  Expression get expression => _expression;
  int get precedence => 7;
  TypeName get type => A__type;
  void set type(TypeName A_name) {
    this.A__type = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
    safelyVisitChild(A__type, visitor);
  }
}
class Label extends AstNode {
  SimpleIdentifier _label;
  A_Token colon;
  Label(SimpleIdentifier A_label, this.colon) {
    this._label = becomeParentOf(A_label);
  }
  accept(AstVisitor visitor) => visitor.visitLabel(this);
  A_Token get beginToken => _label.beginToken;
  A_Token get endToken => colon;
  SimpleIdentifier get label => _label;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_label, visitor);
  }
}
class LabeledStatement extends Statement {
  NodeList<Label> _labels;
  Statement _statement;
  LabeledStatement(List<Label> A_labels, Statement A_statement) {
    this._labels = new NodeList<Label>(this);
    this._labels.addAll(A_labels);
    this._statement = becomeParentOf(A_statement);
  }
  accept(AstVisitor visitor) => visitor.visitLabeledStatement(this);
  A_Token get beginToken {
    if (!_labels.isEmpty) {
      return _labels.beginToken;
    }
    return _statement.beginToken;
  }
  A_Token get endToken => _statement.endToken;
  NodeList<Label> get labels => _labels;
  Statement get statement => _statement;
  void visitChildren(AstVisitor visitor) {
    _labels.accept(visitor);
    safelyVisitChild(_statement, visitor);
  }
}
class LibraryDirective extends Directive {
  A_Token libraryToken;
  LibraryIdentifier A__name;
  A_Token semicolon;
  LibraryDirective(Comment comment, List<Annotation> metadata, this.libraryToken, LibraryIdentifier A_name, this.semicolon) : super(comment, metadata) {
    this.A__name = becomeParentOf(A_name);
  }
  accept(AstVisitor visitor) => visitor.visitLibraryDirective(this);
  A_Token get endToken => semicolon;
  A_Token get keyword => libraryToken;
  LibraryIdentifier get name => A__name;
  void set name(LibraryIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__name, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata => libraryToken;
}
class LibraryIdentifier extends Identifier {
  NodeList<SimpleIdentifier> _components;
  LibraryIdentifier(List<SimpleIdentifier> A_components) {
    this._components = new NodeList<SimpleIdentifier>(this);
    this._components.addAll(A_components);
  }
  accept(AstVisitor visitor) => visitor.visitLibraryIdentifier(this);
  A_Token get beginToken => _components.beginToken;
  A_Element get bestElement => staticElement;
  NodeList<SimpleIdentifier> get components => _components;
  A_Token get endToken => _components.endToken;
  String get name {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    bool needsPeriod = false;
    for (SimpleIdentifier identifier in _components) {
      if (needsPeriod) {
        A_builder.append(".");
      } else {
        needsPeriod = true;
      }
      A_builder.append(identifier.name);
    }
    return A_builder.toString();
  }
  int get precedence => 15;
  A_Element get propagatedElement => null;
  A_Element get staticElement => null;
  void visitChildren(AstVisitor visitor) {
    _components.accept(visitor);
  }
}
class ListLiteral extends TypedLiteral {
  A_Token _leftBracket;
  NodeList<Expression> _elements;
  A_Token _rightBracket;
  ListLiteral(A_Token constKeyword, TypeArgumentList typeArguments, A_Token A_leftBracket, List<Expression> A_elements, A_Token A_rightBracket) : super(constKeyword, typeArguments) {
    this._elements = new NodeList<Expression>(this);
    this._leftBracket = A_leftBracket;
    this._elements.addAll(A_elements);
    this._rightBracket = A_rightBracket;
  }
  accept(AstVisitor visitor) => visitor.visitListLiteral(this);
  A_Token get beginToken {
    A_Token token = constKeyword;
    if (token != null) {
      return token;
    }
    TypeArgumentList typeArguments = this.typeArguments;
    if (typeArguments != null) {
      return typeArguments.beginToken;
    }
    return _leftBracket;
  }
  NodeList<Expression> get elements => _elements;
  A_Token get endToken => _rightBracket;
  A_Token get leftBracket => _leftBracket;
  A_Token get rightBracket => _rightBracket;
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    _elements.accept(visitor);
  }
}
abstract class Literal extends Expression {
  int get precedence => 16;
}
class MapLiteral extends TypedLiteral {
  A_Token _leftBracket;
  NodeList<MapLiteralEntry> _entries;
  A_Token _rightBracket;
  MapLiteral(A_Token constKeyword, TypeArgumentList typeArguments, A_Token A_leftBracket, List<MapLiteralEntry> A_entries, A_Token A_rightBracket) : super(constKeyword, typeArguments) {
    this._entries = new NodeList<MapLiteralEntry>(this);
    this._leftBracket = A_leftBracket;
    this._entries.addAll(A_entries);
    this._rightBracket = A_rightBracket;
  }
  accept(AstVisitor visitor) => visitor.visitMapLiteral(this);
  A_Token get beginToken {
    A_Token token = constKeyword;
    if (token != null) {
      return token;
    }
    TypeArgumentList typeArguments = this.typeArguments;
    if (typeArguments != null) {
      return typeArguments.beginToken;
    }
    return _leftBracket;
  }
  A_Token get endToken => _rightBracket;
  NodeList<MapLiteralEntry> get entries => _entries;
  A_Token get leftBracket => _leftBracket;
  A_Token get rightBracket => _rightBracket;
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    _entries.accept(visitor);
  }
}
class MapLiteralEntry extends AstNode {
  Expression _key;
  A_Token A_separator;
  Expression A__value;
  MapLiteralEntry(Expression A_key, this.A_separator, Expression A_value) {
    this._key = becomeParentOf(A_key);
    this.A__value = becomeParentOf(A_value);
  }
  accept(AstVisitor visitor) => visitor.visitMapLiteralEntry(this);
  A_Token get beginToken => _key.beginToken;
  A_Token get endToken => A__value.endToken;
  Expression get key => _key;
  Expression get value => A__value;
  void set value(Expression expression) {
    A__value = becomeParentOf(expression);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_key, visitor);
    safelyVisitChild(A__value, visitor);
  }
}
class MethodDeclaration extends ClassMember {
  A_Token externalKeyword;
  A_Token modifierKeyword;
  TypeName A__returnType;
  A_Token propertyKeyword;
  A_Token operatorKeyword;
  SimpleIdentifier A__name;
  FormalParameterList A__parameters;
  FunctionBody _body;
  MethodDeclaration(Comment comment, List<Annotation> metadata, this.externalKeyword, this.modifierKeyword, TypeName A_returnType, this.propertyKeyword, this.operatorKeyword, SimpleIdentifier A_name, FormalParameterList A_parameters, FunctionBody A_body) : super(comment, metadata) {
    this.A__returnType = becomeParentOf(A_returnType);
    this.A__name = becomeParentOf(A_name);
    this.A__parameters = becomeParentOf(A_parameters);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitMethodDeclaration(this);
  FunctionBody get body => _body;
  ExecutableElement get element => A__name != null ? (A__name.staticElement as ExecutableElement) : null;
  A_Token get endToken => _body.endToken;
  SimpleIdentifier get name => A__name;
  FormalParameterList get parameters => A__parameters;
  TypeName get returnType => A__returnType;
  bool get isAbstract => externalKeyword == null && (_body is EmptyFunctionBody);
  bool get isGetter => propertyKeyword != null && (propertyKeyword as KeywordToken).keyword == Keyword.GET;
  bool get isOperator => operatorKeyword != null;
  bool get isSetter => propertyKeyword != null && (propertyKeyword as KeywordToken).keyword == Keyword.SET;
  bool get isStatic => modifierKeyword != null && (modifierKeyword as KeywordToken).keyword == Keyword.A_STATIC;
  void set name(SimpleIdentifier identifier) {
    A__name = becomeParentOf(identifier);
  }
  void set parameters(FormalParameterList A_parameters) {
    this.A__parameters = becomeParentOf(A_parameters);
  }
  void set returnType(TypeName typeName) {
    A__returnType = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__returnType, visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(A__parameters, visitor);
    safelyVisitChild(_body, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (modifierKeyword != null) {
      return modifierKeyword;
    } else if (A__returnType != null) {
      return A__returnType.beginToken;
    } else if (propertyKeyword != null) {
      return propertyKeyword;
    } else if (operatorKeyword != null) {
      return operatorKeyword;
    }
    return A__name.beginToken;
  }
}
class MethodInvocation extends Expression {
  Expression A__target;
  A_Token period;
  SimpleIdentifier _methodName;
  ArgumentList _argumentList;
  MethodInvocation(Expression A_target, this.period, SimpleIdentifier A_methodName, ArgumentList A_argumentList) {
    this.A__target = becomeParentOf(A_target);
    this._methodName = becomeParentOf(A_methodName);
    this._argumentList = becomeParentOf(A_argumentList);
  }
  accept(AstVisitor visitor) => visitor.visitMethodInvocation(this);
  ArgumentList get argumentList => _argumentList;
  A_Token get beginToken {
    if (A__target != null) {
      return A__target.beginToken;
    } else if (period != null) {
      return period;
    }
    return _methodName.beginToken;
  }
  A_Token get endToken => _argumentList.endToken;
  SimpleIdentifier get methodName => _methodName;
  int get precedence => 15;
  Expression get realTarget {
    if (isCascaded) {
      AstNode ancestor = parent;
      while (ancestor is! CascadeExpression) {
        if (ancestor == null) {
          return A__target;
        }
        ancestor = ancestor.parent;
      }
      return (ancestor as CascadeExpression).target;
    }
    return A__target;
  }
  Expression get target => A__target;
  bool get isCascaded => period != null && period.type == A_TokenType.PERIOD_PERIOD;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__target, visitor);
    safelyVisitChild(_methodName, visitor);
    safelyVisitChild(_argumentList, visitor);
  }
}
class NamedExpression extends Expression {
  Label A__name;
  Expression _expression;
  NamedExpression(Label A_name, Expression A_expression) {
    this.A__name = becomeParentOf(A_name);
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitNamedExpression(this);
  A_Token get beginToken => A__name.beginToken;
  ParameterElement get element {
    A_Element A_element = A__name.label.staticElement;
    if (A_element is ParameterElement) {
      return A_element;
    }
    return null;
  }
  A_Token get endToken => _expression.endToken;
  Expression get expression => _expression;
  Label get name => A__name;
  int get precedence => 0;
  void set name(Label identifier) {
    A__name = becomeParentOf(identifier);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_expression, visitor);
  }
}
abstract class NamespaceDirective extends UriBasedDirective {
  A_Token keyword;
  NodeList<Combinator> _combinators;
  A_Token semicolon;
  NamespaceDirective(Comment comment, List<Annotation> metadata, this.keyword, StringLiteral libraryUri, List<Combinator> A_combinators, this.semicolon) : super(comment, metadata, libraryUri) {
    this._combinators = new NodeList<Combinator>(this);
    this._combinators.addAll(A_combinators);
  }
  NodeList<Combinator> get combinators => _combinators;
  A_Token get endToken => semicolon;
  LibraryElement get uriElement;
  A_Token get firstTokenAfterCommentAndMetadata => keyword;
}
class NativeClause extends AstNode {
  A_Token keyword;
  StringLiteral A__name;
  NativeClause(this.keyword, StringLiteral A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  accept(AstVisitor visitor) => visitor.visitNativeClause(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => A__name.endToken;
  StringLiteral get name => A__name;
  void set name(StringLiteral A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__name, visitor);
  }
}
class NativeFunctionBody extends FunctionBody {
  final A_Token nativeToken;
  StringLiteral _stringLiteral;
  final A_Token semicolon;
  NativeFunctionBody(this.nativeToken, StringLiteral A_stringLiteral, this.semicolon) {
    this._stringLiteral = becomeParentOf(A_stringLiteral);
  }
  accept(AstVisitor visitor) => visitor.visitNativeFunctionBody(this);
  A_Token get beginToken => nativeToken;
  A_Token get endToken => semicolon;
  StringLiteral get stringLiteral => _stringLiteral;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_stringLiteral, visitor);
  }
}
class NodeLocator extends UnifyingAstVisitor<Object> {
  int _startOffset = 0;
  int _endOffset = 0;
  AstNode _foundNode;
  NodeLocator.con1(int A_offset) : this.con2(A_offset, A_offset);
  NodeLocator.con2(int A_start, int A_end) {
    this._startOffset = A_start;
    this._endOffset = A_end;
  }
  AstNode searchWithin(AstNode node) {
    if (node == null) {
      return null;
    }
    try {
      node.accept(this);
    }on NodeLocator_NodeFoundException  catch (exception) {}  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Unable to locate element at offset (${_startOffset} - ${_endOffset})", exception);
      return null;
    }
    return _foundNode;
  }
  Object visitNode(AstNode node) {
    int A_start = node.offset;
    int A_end = A_start + node.length;
    if (A_end < _startOffset) {
      return null;
    }
    if (A_start > _endOffset) {
      return null;
    }
    try {
      node.visitChildren(this);
    }on NodeLocator_NodeFoundException  catch (exception) {
      throw exception;
    }  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Exception caught while traversing an AST structure.", exception);
    }
    if (A_start <= _startOffset && _endOffset <= A_end) {
      _foundNode = node;
      throw new NodeLocator_NodeFoundException();
    }
    return null;
  }
}
class NodeLocator_NodeFoundException extends RuntimeException {}
abstract class NormalFormalParameter extends FormalParameter {
  Comment _comment;
  NodeList<Annotation> _metadata;
  SimpleIdentifier _identifier;
  NormalFormalParameter(Comment comment, List<Annotation> A_metadata, SimpleIdentifier A_identifier) {
    this._metadata = new NodeList<Annotation>(this);
    this._comment = becomeParentOf(comment);
    this._metadata.addAll(A_metadata);
    this._identifier = becomeParentOf(A_identifier);
  }
  Comment get documentationComment => _comment;
  SimpleIdentifier get identifier => _identifier;
  ParameterKind get kind {
    AstNode A_parent = this.parent;
    if (A_parent is DefaultFormalParameter) {
      return A_parent.kind;
    }
    return ParameterKind.REQUIRED;
  }
  NodeList<Annotation> get metadata => _metadata;
  void set metadata(List<Annotation> A_metadata) {
    this._metadata.clear();
    this._metadata.addAll(A_metadata);
  }
  void visitChildren(AstVisitor visitor) {
    if (_commentIsBeforeAnnotations()) {
      safelyVisitChild(_comment, visitor);
      _metadata.accept(visitor);
    } else {
      for (AstNode child in sortedCommentAndAnnotations) {
        child.accept(visitor);
      }
    }
  }
  bool _commentIsBeforeAnnotations() {
    if (_comment == null || _metadata.isEmpty) {
      return true;
    }
    Annotation firstAnnotation = _metadata[0];
    return _comment.offset < firstAnnotation.offset;
  }
  List<AstNode> get sortedCommentAndAnnotations {
    List<AstNode> childList = new List<AstNode>();
    childList.add(_comment);
    childList.addAll(_metadata);
    List<AstNode> children = new List.from(childList);
    children.sort(AstNode.LEXICAL_ORDER);
    return children;
  }
}
class NullLiteral extends Literal {
  A_Token literal;
  NullLiteral(A_Token token) {
    this.literal = token;
  }
  accept(AstVisitor visitor) => visitor.visitNullLiteral(this);
  A_Token get beginToken => literal;
  A_Token get endToken => literal;
  void visitChildren(AstVisitor visitor) {}
}
class ParenthesizedExpression extends Expression {
  A_Token _leftParenthesis;
  Expression _expression;
  A_Token _rightParenthesis;
  ParenthesizedExpression(A_Token A_leftParenthesis, Expression A_expression, A_Token A_rightParenthesis) {
    this._leftParenthesis = A_leftParenthesis;
    this._expression = becomeParentOf(A_expression);
    this._rightParenthesis = A_rightParenthesis;
  }
  accept(AstVisitor visitor) => visitor.visitParenthesizedExpression(this);
  A_Token get beginToken => _leftParenthesis;
  A_Token get endToken => _rightParenthesis;
  Expression get expression => _expression;
  A_Token get leftParenthesis => _leftParenthesis;
  int get precedence => 15;
  A_Token get rightParenthesis => _rightParenthesis;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class PartDirective extends UriBasedDirective {
  A_Token partToken;
  A_Token semicolon;
  PartDirective(Comment comment, List<Annotation> metadata, this.partToken, StringLiteral partUri, this.semicolon) : super(comment, metadata, partUri);
  accept(AstVisitor visitor) => visitor.visitPartDirective(this);
  A_Token get endToken => semicolon;
  A_Token get keyword => partToken;
  CompilationUnitElement get uriElement => element as CompilationUnitElement;
  A_Token get firstTokenAfterCommentAndMetadata => partToken;
}
class PartOfDirective extends Directive {
  A_Token partToken;
  A_Token ofToken;
  LibraryIdentifier _libraryName;
  A_Token semicolon;
  PartOfDirective(Comment comment, List<Annotation> metadata, this.partToken, this.ofToken, LibraryIdentifier A_libraryName, this.semicolon) : super(comment, metadata) {
    this._libraryName = becomeParentOf(A_libraryName);
  }
  accept(AstVisitor visitor) => visitor.visitPartOfDirective(this);
  A_Token get endToken => semicolon;
  A_Token get keyword => partToken;
  LibraryIdentifier get libraryName => _libraryName;
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(_libraryName, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata => partToken;
}
class PostfixExpression extends Expression {
  Expression _operand;
  A_Token operator;
  MethodElement _propagatedElement;
  MethodElement _staticElement;
  PostfixExpression(Expression A_operand, this.operator) {
    this._operand = becomeParentOf(A_operand);
  }
  accept(AstVisitor visitor) => visitor.visitPostfixExpression(this);
  A_Token get beginToken => _operand.beginToken;
  MethodElement get bestElement {
    MethodElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => operator;
  Expression get operand => _operand;
  int get precedence => 15;
  MethodElement get propagatedElement => _propagatedElement;
  MethodElement get staticElement => _staticElement;
  void set propagatedElement(MethodElement A_element) {
    _propagatedElement = A_element;
  }
  void set staticElement(MethodElement A_element) {
    _staticElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_operand, visitor);
  }
  ParameterElement get propagatedParameterElementForOperand {
    if (_propagatedElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _propagatedElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
  ParameterElement get staticParameterElementForOperand {
    if (_staticElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _staticElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
}
class PrefixExpression extends Expression {
  A_Token operator;
  Expression _operand;
  MethodElement _staticElement;
  MethodElement _propagatedElement;
  PrefixExpression(this.operator, Expression A_operand) {
    this._operand = becomeParentOf(A_operand);
  }
  accept(AstVisitor visitor) => visitor.visitPrefixExpression(this);
  A_Token get beginToken => operator;
  MethodElement get bestElement {
    MethodElement A_element = propagatedElement;
    if (A_element == null) {
      A_element = staticElement;
    }
    return A_element;
  }
  A_Token get endToken => _operand.endToken;
  Expression get operand => _operand;
  int get precedence => 14;
  MethodElement get propagatedElement => _propagatedElement;
  MethodElement get staticElement => _staticElement;
  void set propagatedElement(MethodElement A_element) {
    _propagatedElement = A_element;
  }
  void set staticElement(MethodElement A_element) {
    _staticElement = A_element;
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_operand, visitor);
  }
  ParameterElement get propagatedParameterElementForOperand {
    if (_propagatedElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _propagatedElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
  ParameterElement get staticParameterElementForOperand {
    if (_staticElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = _staticElement.parameters;
    if (A_parameters.length < 1) {
      return null;
    }
    return A_parameters[0];
  }
}
class PrefixedIdentifier extends Identifier {
  SimpleIdentifier A__prefix;
  A_Token period;
  SimpleIdentifier _identifier;
  PrefixedIdentifier(SimpleIdentifier A_prefix, this.period, SimpleIdentifier A_identifier) {
    this.A__prefix = becomeParentOf(A_prefix);
    this._identifier = becomeParentOf(A_identifier);
  }
  accept(AstVisitor visitor) => visitor.visitPrefixedIdentifier(this);
  A_Token get beginToken => A__prefix.beginToken;
  A_Element get bestElement {
    if (_identifier == null) {
      return null;
    }
    return _identifier.bestElement;
  }
  A_Token get endToken => _identifier.endToken;
  SimpleIdentifier get identifier => _identifier;
  String get name => "${A__prefix.name}.${_identifier.name}";
  int get precedence => 15;
  SimpleIdentifier get prefix => A__prefix;
  A_Element get propagatedElement {
    if (_identifier == null) {
      return null;
    }
    return _identifier.propagatedElement;
  }
  A_Element get staticElement {
    if (_identifier == null) {
      return null;
    }
    return _identifier.staticElement;
  }
  bool get isDeferred {
    A_Element A_element = A__prefix.staticElement;
    if (A_element is! PrefixElement) {
      return false;
    }
    PrefixElement prefixElement = A_element as PrefixElement;
    List<ImportElement> imports = prefixElement.enclosingElement.getImportsWithPrefix(prefixElement);
    if (imports.length != 1) {
      return false;
    }
    return imports[0].isDeferred;
  }
  void set prefix(SimpleIdentifier A_identifier) {
    A__prefix = becomeParentOf(A_identifier);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__prefix, visitor);
    safelyVisitChild(_identifier, visitor);
  }
}
class PropertyAccess extends Expression {
  Expression A__target;
  A_Token operator;
  SimpleIdentifier _propertyName;
  PropertyAccess(Expression A_target, this.operator, SimpleIdentifier A_propertyName) {
    this.A__target = becomeParentOf(A_target);
    this._propertyName = becomeParentOf(A_propertyName);
  }
  accept(AstVisitor visitor) => visitor.visitPropertyAccess(this);
  A_Token get beginToken {
    if (A__target != null) {
      return A__target.beginToken;
    }
    return operator;
  }
  A_Token get endToken => _propertyName.endToken;
  int get precedence => 15;
  SimpleIdentifier get propertyName => _propertyName;
  Expression get realTarget {
    if (isCascaded) {
      AstNode ancestor = parent;
      while (ancestor is! CascadeExpression) {
        if (ancestor == null) {
          return A__target;
        }
        ancestor = ancestor.parent;
      }
      return (ancestor as CascadeExpression).target;
    }
    return A__target;
  }
  Expression get target => A__target;
  bool get isAssignable => true;
  bool get isCascaded => operator != null && operator.type == A_TokenType.PERIOD_PERIOD;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__target, visitor);
    safelyVisitChild(_propertyName, visitor);
  }
}
class RecursiveAstVisitor<R> implements AstVisitor<R> {
  R visitAdjacentStrings(AdjacentStrings node) {
    node.visitChildren(this);
    return null;
  }
  R visitAnnotation(Annotation node) {
    node.visitChildren(this);
    return null;
  }
  R visitArgumentList(ArgumentList node) {
    node.visitChildren(this);
    return null;
  }
  R visitAsExpression(AsExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitAssertStatement(AssertStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitAssignmentExpression(AssignmentExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitAwaitExpression(AwaitExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitBinaryExpression(BinaryExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitBlock(Block node) {
    node.visitChildren(this);
    return null;
  }
  R visitBlockFunctionBody(BlockFunctionBody node) {
    node.visitChildren(this);
    return null;
  }
  R visitBooleanLiteral(BooleanLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitBreakStatement(BreakStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitCascadeExpression(CascadeExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitCatchClause(CatchClause node) {
    node.visitChildren(this);
    return null;
  }
  R visitClassDeclaration(ClassDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitClassTypeAlias(ClassTypeAlias node) {
    node.visitChildren(this);
    return null;
  }
  R visitComment(Comment node) {
    node.visitChildren(this);
    return null;
  }
  R visitCommentReference(CommentReference node) {
    node.visitChildren(this);
    return null;
  }
  R visitCompilationUnit(CompilationUnit node) {
    node.visitChildren(this);
    return null;
  }
  R visitConditionalExpression(ConditionalExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitConstructorDeclaration(ConstructorDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    node.visitChildren(this);
    return null;
  }
  R visitConstructorName(ConstructorName node) {
    node.visitChildren(this);
    return null;
  }
  R visitContinueStatement(ContinueStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitDeclaredIdentifier(DeclaredIdentifier node) {
    node.visitChildren(this);
    return null;
  }
  R visitDefaultFormalParameter(DefaultFormalParameter node) {
    node.visitChildren(this);
    return null;
  }
  R visitDoStatement(DoStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitDoubleLiteral(DoubleLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitEmptyFunctionBody(EmptyFunctionBody node) {
    node.visitChildren(this);
    return null;
  }
  R visitEmptyStatement(EmptyStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitEnumDeclaration(EnumDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitExportDirective(ExportDirective node) {
    node.visitChildren(this);
    return null;
  }
  R visitExpressionFunctionBody(ExpressionFunctionBody node) {
    node.visitChildren(this);
    return null;
  }
  R visitExpressionStatement(ExpressionStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitExtendsClause(ExtendsClause node) {
    node.visitChildren(this);
    return null;
  }
  R visitFieldDeclaration(FieldDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitFieldFormalParameter(FieldFormalParameter node) {
    node.visitChildren(this);
    return null;
  }
  R visitForEachStatement(ForEachStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitFormalParameterList(FormalParameterList node) {
    node.visitChildren(this);
    return null;
  }
  R visitForStatement(ForStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionDeclaration(FunctionDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionDeclarationStatement(FunctionDeclarationStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionExpression(FunctionExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionTypeAlias(FunctionTypeAlias node) {
    node.visitChildren(this);
    return null;
  }
  R visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    node.visitChildren(this);
    return null;
  }
  R visitHideCombinator(HideCombinator node) {
    node.visitChildren(this);
    return null;
  }
  R visitIfStatement(IfStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitImplementsClause(ImplementsClause node) {
    node.visitChildren(this);
    return null;
  }
  R visitImportDirective(ImportDirective node) {
    node.visitChildren(this);
    return null;
  }
  R visitIndexExpression(IndexExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitInstanceCreationExpression(InstanceCreationExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitIntegerLiteral(IntegerLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitInterpolationExpression(InterpolationExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitInterpolationString(InterpolationString node) {
    node.visitChildren(this);
    return null;
  }
  R visitIsExpression(IsExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitLabel(Label node) {
    node.visitChildren(this);
    return null;
  }
  R visitLabeledStatement(LabeledStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitLibraryDirective(LibraryDirective node) {
    node.visitChildren(this);
    return null;
  }
  R visitLibraryIdentifier(LibraryIdentifier node) {
    node.visitChildren(this);
    return null;
  }
  R visitListLiteral(ListLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitMapLiteral(MapLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitMapLiteralEntry(MapLiteralEntry node) {
    node.visitChildren(this);
    return null;
  }
  R visitMethodDeclaration(MethodDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitMethodInvocation(MethodInvocation node) {
    node.visitChildren(this);
    return null;
  }
  R visitNamedExpression(NamedExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitNativeClause(NativeClause node) {
    node.visitChildren(this);
    return null;
  }
  R visitNativeFunctionBody(NativeFunctionBody node) {
    node.visitChildren(this);
    return null;
  }
  R visitNullLiteral(NullLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitParenthesizedExpression(ParenthesizedExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitPartDirective(PartDirective node) {
    node.visitChildren(this);
    return null;
  }
  R visitPartOfDirective(PartOfDirective node) {
    node.visitChildren(this);
    return null;
  }
  R visitPostfixExpression(PostfixExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitPrefixedIdentifier(PrefixedIdentifier node) {
    node.visitChildren(this);
    return null;
  }
  R visitPrefixExpression(PrefixExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitPropertyAccess(PropertyAccess node) {
    node.visitChildren(this);
    return null;
  }
  R visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    node.visitChildren(this);
    return null;
  }
  R visitRethrowExpression(RethrowExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitReturnStatement(ReturnStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitScriptTag(ScriptTag node) {
    node.visitChildren(this);
    return null;
  }
  R visitShowCombinator(ShowCombinator node) {
    node.visitChildren(this);
    return null;
  }
  R visitSimpleFormalParameter(SimpleFormalParameter node) {
    node.visitChildren(this);
    return null;
  }
  R visitSimpleIdentifier(SimpleIdentifier node) {
    node.visitChildren(this);
    return null;
  }
  R visitSimpleStringLiteral(SimpleStringLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitStringInterpolation(StringInterpolation node) {
    node.visitChildren(this);
    return null;
  }
  R visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    node.visitChildren(this);
    return null;
  }
  R visitSuperExpression(SuperExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitSwitchCase(SwitchCase node) {
    node.visitChildren(this);
    return null;
  }
  R visitSwitchDefault(SwitchDefault node) {
    node.visitChildren(this);
    return null;
  }
  R visitSwitchStatement(SwitchStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitSymbolLiteral(SymbolLiteral node) {
    node.visitChildren(this);
    return null;
  }
  R visitThisExpression(ThisExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitThrowExpression(ThrowExpression node) {
    node.visitChildren(this);
    return null;
  }
  R visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitTryStatement(TryStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitTypeArgumentList(TypeArgumentList node) {
    node.visitChildren(this);
    return null;
  }
  R visitTypeName(TypeName node) {
    node.visitChildren(this);
    return null;
  }
  R visitTypeParameter(TypeParameter node) {
    node.visitChildren(this);
    return null;
  }
  R visitTypeParameterList(TypeParameterList node) {
    node.visitChildren(this);
    return null;
  }
  R visitVariableDeclaration(VariableDeclaration node) {
    node.visitChildren(this);
    return null;
  }
  R visitVariableDeclarationList(VariableDeclarationList node) {
    node.visitChildren(this);
    return null;
  }
  R visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitWhileStatement(WhileStatement node) {
    node.visitChildren(this);
    return null;
  }
  R visitWithClause(WithClause node) {
    node.visitChildren(this);
    return null;
  }
  R visitYieldStatement(YieldStatement node) {
    node.visitChildren(this);
    return null;
  }
}
class RedirectingConstructorInvocation extends ConstructorInitializer {
  A_Token keyword;
  A_Token period;
  SimpleIdentifier _constructorName;
  ArgumentList _argumentList;
  ConstructorElement staticElement;
  RedirectingConstructorInvocation(this.keyword, this.period, SimpleIdentifier A_constructorName, ArgumentList A_argumentList) {
    this._constructorName = becomeParentOf(A_constructorName);
    this._argumentList = becomeParentOf(A_argumentList);
  }
  accept(AstVisitor visitor) => visitor.visitRedirectingConstructorInvocation(this);
  ArgumentList get argumentList => _argumentList;
  A_Token get beginToken => keyword;
  SimpleIdentifier get constructorName => _constructorName;
  A_Token get endToken => _argumentList.endToken;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_constructorName, visitor);
    safelyVisitChild(_argumentList, visitor);
  }
}
class RethrowExpression extends Expression {
  A_Token keyword;
  RethrowExpression(this.keyword);
  accept(AstVisitor visitor) => visitor.visitRethrowExpression(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => keyword;
  int get precedence => 0;
  void visitChildren(AstVisitor visitor) {}
}
class ReturnStatement extends Statement {
  A_Token keyword;
  Expression _expression;
  A_Token semicolon;
  ReturnStatement(this.keyword, Expression A_expression, this.semicolon) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitReturnStatement(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => semicolon;
  Expression get expression => _expression;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class ScriptTag extends AstNode {
  A_Token scriptTag;
  ScriptTag(this.scriptTag);
  accept(AstVisitor visitor) => visitor.visitScriptTag(this);
  A_Token get beginToken => scriptTag;
  A_Token get endToken => scriptTag;
  void visitChildren(AstVisitor visitor) {}
}
class ShowCombinator extends Combinator {
  NodeList<SimpleIdentifier> _shownNames;
  ShowCombinator(A_Token keyword, List<SimpleIdentifier> A_shownNames) : super(keyword) {
    this._shownNames = new NodeList<SimpleIdentifier>(this);
    this._shownNames.addAll(A_shownNames);
  }
  accept(AstVisitor visitor) => visitor.visitShowCombinator(this);
  A_Token get endToken => _shownNames.endToken;
  NodeList<SimpleIdentifier> get shownNames => _shownNames;
  void visitChildren(AstVisitor visitor) {
    _shownNames.accept(visitor);
  }
}
class SimpleAstVisitor<R> implements AstVisitor<R> {
  R visitAdjacentStrings(AdjacentStrings node) => null;
  R visitAnnotation(Annotation node) => null;
  R visitArgumentList(ArgumentList node) => null;
  R visitAsExpression(AsExpression node) => null;
  R visitAssertStatement(AssertStatement node) => null;
  R visitAssignmentExpression(AssignmentExpression node) => null;
  R visitAwaitExpression(AwaitExpression node) => null;
  R visitBinaryExpression(BinaryExpression node) => null;
  R visitBlock(Block node) => null;
  R visitBlockFunctionBody(BlockFunctionBody node) => null;
  R visitBooleanLiteral(BooleanLiteral node) => null;
  R visitBreakStatement(BreakStatement node) => null;
  R visitCascadeExpression(CascadeExpression node) => null;
  R visitCatchClause(CatchClause node) => null;
  R visitClassDeclaration(ClassDeclaration node) => null;
  R visitClassTypeAlias(ClassTypeAlias node) => null;
  R visitComment(Comment node) => null;
  R visitCommentReference(CommentReference node) => null;
  R visitCompilationUnit(CompilationUnit node) => null;
  R visitConditionalExpression(ConditionalExpression node) => null;
  R visitConstructorDeclaration(ConstructorDeclaration node) => null;
  R visitConstructorFieldInitializer(ConstructorFieldInitializer node) => null;
  R visitConstructorName(ConstructorName node) => null;
  R visitContinueStatement(ContinueStatement node) => null;
  R visitDeclaredIdentifier(DeclaredIdentifier node) => null;
  R visitDefaultFormalParameter(DefaultFormalParameter node) => null;
  R visitDoStatement(DoStatement node) => null;
  R visitDoubleLiteral(DoubleLiteral node) => null;
  R visitEmptyFunctionBody(EmptyFunctionBody node) => null;
  R visitEmptyStatement(EmptyStatement node) => null;
  R visitEnumConstantDeclaration(EnumConstantDeclaration node) => null;
  R visitEnumDeclaration(EnumDeclaration node) => null;
  R visitExportDirective(ExportDirective node) => null;
  R visitExpressionFunctionBody(ExpressionFunctionBody node) => null;
  R visitExpressionStatement(ExpressionStatement node) => null;
  R visitExtendsClause(ExtendsClause node) => null;
  R visitFieldDeclaration(FieldDeclaration node) => null;
  R visitFieldFormalParameter(FieldFormalParameter node) => null;
  R visitForEachStatement(ForEachStatement node) => null;
  R visitFormalParameterList(FormalParameterList node) => null;
  R visitForStatement(ForStatement node) => null;
  R visitFunctionDeclaration(FunctionDeclaration node) => null;
  R visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => null;
  R visitFunctionExpression(FunctionExpression node) => null;
  R visitFunctionExpressionInvocation(FunctionExpressionInvocation node) => null;
  R visitFunctionTypeAlias(FunctionTypeAlias node) => null;
  R visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) => null;
  R visitHideCombinator(HideCombinator node) => null;
  R visitIfStatement(IfStatement node) => null;
  R visitImplementsClause(ImplementsClause node) => null;
  R visitImportDirective(ImportDirective node) => null;
  R visitIndexExpression(IndexExpression node) => null;
  R visitInstanceCreationExpression(InstanceCreationExpression node) => null;
  R visitIntegerLiteral(IntegerLiteral node) => null;
  R visitInterpolationExpression(InterpolationExpression node) => null;
  R visitInterpolationString(InterpolationString node) => null;
  R visitIsExpression(IsExpression node) => null;
  R visitLabel(Label node) => null;
  R visitLabeledStatement(LabeledStatement node) => null;
  R visitLibraryDirective(LibraryDirective node) => null;
  R visitLibraryIdentifier(LibraryIdentifier node) => null;
  R visitListLiteral(ListLiteral node) => null;
  R visitMapLiteral(MapLiteral node) => null;
  R visitMapLiteralEntry(MapLiteralEntry node) => null;
  R visitMethodDeclaration(MethodDeclaration node) => null;
  R visitMethodInvocation(MethodInvocation node) => null;
  R visitNamedExpression(NamedExpression node) => null;
  R visitNativeClause(NativeClause node) => null;
  R visitNativeFunctionBody(NativeFunctionBody node) => null;
  R visitNullLiteral(NullLiteral node) => null;
  R visitParenthesizedExpression(ParenthesizedExpression node) => null;
  R visitPartDirective(PartDirective node) => null;
  R visitPartOfDirective(PartOfDirective node) => null;
  R visitPostfixExpression(PostfixExpression node) => null;
  R visitPrefixedIdentifier(PrefixedIdentifier node) => null;
  R visitPrefixExpression(PrefixExpression node) => null;
  R visitPropertyAccess(PropertyAccess node) => null;
  R visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) => null;
  R visitRethrowExpression(RethrowExpression node) => null;
  R visitReturnStatement(ReturnStatement node) => null;
  R visitScriptTag(ScriptTag node) => null;
  R visitShowCombinator(ShowCombinator node) => null;
  R visitSimpleFormalParameter(SimpleFormalParameter node) => null;
  R visitSimpleIdentifier(SimpleIdentifier node) => null;
  R visitSimpleStringLiteral(SimpleStringLiteral node) => null;
  R visitStringInterpolation(StringInterpolation node) => null;
  R visitSuperConstructorInvocation(SuperConstructorInvocation node) => null;
  R visitSuperExpression(SuperExpression node) => null;
  R visitSwitchCase(SwitchCase node) => null;
  R visitSwitchDefault(SwitchDefault node) => null;
  R visitSwitchStatement(SwitchStatement node) => null;
  R visitSymbolLiteral(SymbolLiteral node) => null;
  R visitThisExpression(ThisExpression node) => null;
  R visitThrowExpression(ThrowExpression node) => null;
  R visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) => null;
  R visitTryStatement(TryStatement node) => null;
  R visitTypeArgumentList(TypeArgumentList node) => null;
  R visitTypeName(TypeName node) => null;
  R visitTypeParameter(TypeParameter node) => null;
  R visitTypeParameterList(TypeParameterList node) => null;
  R visitVariableDeclaration(VariableDeclaration node) => null;
  R visitVariableDeclarationList(VariableDeclarationList node) => null;
  R visitVariableDeclarationStatement(VariableDeclarationStatement node) => null;
  R visitWhileStatement(WhileStatement node) => null;
  R visitWithClause(WithClause node) => null;
  R visitYieldStatement(YieldStatement node) => null;
}
class SimpleFormalParameter extends NormalFormalParameter {
  A_Token keyword;
  TypeName A__type;
  SimpleFormalParameter(Comment comment, List<Annotation> metadata, this.keyword, TypeName A_type, SimpleIdentifier identifier) : super(comment, metadata, identifier) {
    this.A__type = becomeParentOf(A_type);
  }
  accept(AstVisitor visitor) => visitor.visitSimpleFormalParameter(this);
  A_Token get beginToken {
    NodeList<Annotation> metadata = this.metadata;
    if (!metadata.isEmpty) {
      return metadata.beginToken;
    } else if (keyword != null) {
      return keyword;
    } else if (A__type != null) {
      return A__type.beginToken;
    }
    return identifier.beginToken;
  }
  A_Token get endToken => identifier.endToken;
  TypeName get type => A__type;
  bool get isConst => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.B_CONST;
  bool get isFinal => (keyword is KeywordToken) && (keyword as KeywordToken).keyword == Keyword.A_FINAL;
  void set type(TypeName typeName) {
    A__type = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__type, visitor);
    safelyVisitChild(identifier, visitor);
  }
}
class SimpleIdentifier extends Identifier {
  A_Token token;
  A_Element _staticElement;
  A_Element _propagatedElement;
  AuxiliaryElements auxiliaryElements = null;
  SimpleIdentifier(this.token);
  accept(AstVisitor visitor) => visitor.visitSimpleIdentifier(this);
  A_Token get beginToken => token;
  A_Element get bestElement {
    if (_propagatedElement == null) {
      return _staticElement;
    }
    return _propagatedElement;
  }
  A_Token get endToken => token;
  String get name => token.lexeme;
  int get precedence => 16;
  A_Element get propagatedElement => _propagatedElement;
  A_Element get staticElement => _staticElement;
  bool inDeclarationContext() {
    AstNode A_parent = this.parent;
    if (A_parent is CatchClause) {
      CatchClause clause = A_parent;
      return identical(this, clause.exceptionParameter) || identical(this, clause.stackTraceParameter);
    } else if (A_parent is ClassDeclaration) {
      return identical(this, A_parent.name);
    } else if (A_parent is ClassTypeAlias) {
      return identical(this, A_parent.name);
    } else if (A_parent is ConstructorDeclaration) {
      return identical(this, A_parent.name);
    } else if (A_parent is DeclaredIdentifier) {
      return identical(this, A_parent.identifier);
    } else if (A_parent is FunctionDeclaration) {
      return identical(this, A_parent.name);
    } else if (A_parent is FunctionTypeAlias) {
      return identical(this, A_parent.name);
    } else if (A_parent is Label) {
      return identical(this, A_parent.label) && (A_parent.parent is LabeledStatement);
    } else if (A_parent is MethodDeclaration) {
      return identical(this, A_parent.name);
    } else if (A_parent is FunctionTypedFormalParameter || A_parent is SimpleFormalParameter) {
      return identical(this, (A_parent as NormalFormalParameter).identifier);
    } else if (A_parent is TypeParameter) {
      return identical(this, A_parent.name);
    } else if (A_parent is VariableDeclaration) {
      return identical(this, A_parent.name);
    }
    return false;
  }
  bool inGetterContext() {
    AstNode A_parent = this.parent;
    AstNode A_target = this;
    if (A_parent is PrefixedIdentifier) {
      PrefixedIdentifier prefixed = A_parent as PrefixedIdentifier;
      if (identical(prefixed.prefix, this)) {
        return true;
      }
      A_parent = prefixed.parent;
      A_target = prefixed;
    } else if (A_parent is PropertyAccess) {
      PropertyAccess access = A_parent as PropertyAccess;
      if (identical(access.target, this)) {
        return true;
      }
      A_parent = access.parent;
      A_target = access;
    }
    if (A_parent is Label) {
      return false;
    }
    if (A_parent is AssignmentExpression) {
      AssignmentExpression expr = A_parent as AssignmentExpression;
      if (identical(expr.leftHandSide, A_target) && expr.operator.type == A_TokenType.A_EQ) {
        return false;
      }
    }
    return true;
  }
  bool inSetterContext() {
    AstNode A_parent = this.parent;
    AstNode A_target = this;
    if (A_parent is PrefixedIdentifier) {
      PrefixedIdentifier prefixed = A_parent as PrefixedIdentifier;
      if (identical(prefixed.prefix, this)) {
        return false;
      }
      A_parent = prefixed.parent;
      A_target = prefixed;
    } else if (A_parent is PropertyAccess) {
      PropertyAccess access = A_parent as PropertyAccess;
      if (identical(access.target, this)) {
        return false;
      }
      A_parent = access.parent;
      A_target = access;
    }
    if (A_parent is PrefixExpression) {
      return (A_parent as PrefixExpression).operator.type.isIncrementOperator;
    } else if (A_parent is PostfixExpression) {
      return true;
    } else if (A_parent is AssignmentExpression) {
      return identical((A_parent as AssignmentExpression).leftHandSide, A_target);
    }
    return false;
  }
  bool get isQualified {
    AstNode A_parent = this.parent;
    if (A_parent is PrefixedIdentifier) {
      return identical(A_parent.identifier, this);
    }
    if (A_parent is PropertyAccess) {
      return identical(A_parent.propertyName, this);
    }
    if (A_parent is MethodInvocation) {
      MethodInvocation invocation = A_parent;
      return identical(invocation.methodName, this) && invocation.realTarget != null;
    }
    return false;
  }
  bool get isSynthetic => token.isSynthetic;
  void set propagatedElement(A_Element A_element) {
    _propagatedElement = _validateElement(A_element);
  }
  void set staticElement(A_Element A_element) {
    _staticElement = _validateElement(A_element);
  }
  void visitChildren(AstVisitor visitor) {}
  A_Element _returnOrReportElement(AstNode A_parent, bool isValid, A_Element A_element) {
    if (!isValid) {
      AnalysisEngine.A_instance.logger.logInformation2("Internal error: attempting to set the name of a ${A_parent.runtimeType.toString()} to a ${A_element.runtimeType.toString()}", new JavaException());
      return null;
    }
    return A_element;
  }
  A_Element _validateElement(A_Element A_element) {
    if (A_element == null) {
      return null;
    }
    AstNode A_parent = this.parent;
    if (A_parent is ClassDeclaration && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is ClassElement, A_element);
    } else if (A_parent is ClassTypeAlias && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is ClassElement, A_element);
    } else if (A_parent is DeclaredIdentifier && identical(A_parent.identifier, this)) {
      return _returnOrReportElement(A_parent, A_element is LocalVariableElement, A_element);
    } else if (A_parent is FormalParameter && identical(A_parent.identifier, this)) {
      return _returnOrReportElement(A_parent, A_element is ParameterElement, A_element);
    } else if (A_parent is FunctionDeclaration && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is ExecutableElement, A_element);
    } else if (A_parent is FunctionTypeAlias && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is FunctionTypeAliasElement, A_element);
    } else if (A_parent is MethodDeclaration && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is ExecutableElement, A_element);
    } else if (A_parent is TypeParameter && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is TypeParameterElement, A_element);
    } else if (A_parent is VariableDeclaration && identical(A_parent.name, this)) {
      return _returnOrReportElement(A_parent, A_element is VariableElement, A_element);
    }
    return A_element;
  }
}
class SimpleStringLiteral extends StringLiteral {
  A_Token literal;
  String A__value;
  A_Element _toolkitElement;
  SimpleStringLiteral(this.literal, String A_value) {
    this.A__value = StringUtilities.intern(A_value);
  }
  accept(AstVisitor visitor) => visitor.visitSimpleStringLiteral(this);
  A_Token get beginToken => literal;
  A_Token get endToken => literal;
  String get value => A__value;
  int get valueOffset {
    int A_valueOffset = 0;
    if (isRaw) {
      A_valueOffset += 1;
    }
    if (isMultiline) {
      A_valueOffset += 3;
    } else {
      A_valueOffset += 1;
    }
    return offset + A_valueOffset;
  }
  bool get isMultiline {
    String lexeme = literal.lexeme;
    if (lexeme.length < 6) {
      return false;
    }
    return StringUtilities.endsWith3(lexeme, 0x22, 0x22, 0x22) || StringUtilities.endsWith3(lexeme, 0x27, 0x27, 0x27);
  }
  bool get isRaw => literal.lexeme.codeUnitAt(0) == 0x72;
  bool get isSynthetic => literal.isSynthetic;
  void set toolkitElement(A_Element A_element) {
    _toolkitElement = A_element;
  }
  void set value(String A_string) {
    A__value = StringUtilities.intern(A__value);
  }
  void visitChildren(AstVisitor visitor) {}
  void appendStringValue(JavaStringBuilder A_builder) {
    A_builder.append(value);
  }
}
abstract class Statement extends AstNode {}
class StringInterpolation extends StringLiteral {
  NodeList<InterpolationElement> _elements;
  StringInterpolation(List<InterpolationElement> A_elements) {
    this._elements = new NodeList<InterpolationElement>(this);
    this._elements.addAll(A_elements);
  }
  accept(AstVisitor visitor) => visitor.visitStringInterpolation(this);
  A_Token get beginToken => _elements.beginToken;
  NodeList<InterpolationElement> get elements => _elements;
  A_Token get endToken => _elements.endToken;
  void visitChildren(AstVisitor visitor) {
    _elements.accept(visitor);
  }
  void appendStringValue(JavaStringBuilder A_builder) {
    throw new IllegalArgumentException();
  }
}
abstract class StringLiteral extends Literal {
  String get stringValue {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    try {
      appendStringValue(A_builder);
    }on IllegalArgumentException  catch (exception) {
      return null;
    }
    return A_builder.toString();
  }
  void appendStringValue(JavaStringBuilder A_builder);
}
class SuperConstructorInvocation extends ConstructorInitializer {
  A_Token keyword;
  A_Token period;
  SimpleIdentifier _constructorName;
  ArgumentList _argumentList;
  ConstructorElement staticElement;
  SuperConstructorInvocation(this.keyword, this.period, SimpleIdentifier A_constructorName, ArgumentList A_argumentList) {
    this._constructorName = becomeParentOf(A_constructorName);
    this._argumentList = becomeParentOf(A_argumentList);
  }
  accept(AstVisitor visitor) => visitor.visitSuperConstructorInvocation(this);
  ArgumentList get argumentList => _argumentList;
  A_Token get beginToken => keyword;
  SimpleIdentifier get constructorName => _constructorName;
  A_Token get endToken => _argumentList.endToken;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_constructorName, visitor);
    safelyVisitChild(_argumentList, visitor);
  }
}
class SuperExpression extends Expression {
  A_Token keyword;
  SuperExpression(this.keyword);
  accept(AstVisitor visitor) => visitor.visitSuperExpression(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => keyword;
  int get precedence => 16;
  void visitChildren(AstVisitor visitor) {}
}
class SwitchCase extends SwitchMember {
  Expression _expression;
  SwitchCase(List<Label> labels, A_Token keyword, Expression A_expression, A_Token colon, List<Statement> statements) : super(labels, keyword, colon, statements) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitSwitchCase(this);
  Expression get expression => _expression;
  void visitChildren(AstVisitor visitor) {
    labels.accept(visitor);
    safelyVisitChild(_expression, visitor);
    statements.accept(visitor);
  }
}
class SwitchDefault extends SwitchMember {
  SwitchDefault(List<Label> labels, A_Token keyword, A_Token colon, List<Statement> statements) : super(labels, keyword, colon, statements);
  accept(AstVisitor visitor) => visitor.visitSwitchDefault(this);
  void visitChildren(AstVisitor visitor) {
    labels.accept(visitor);
    statements.accept(visitor);
  }
}
abstract class SwitchMember extends AstNode {
  NodeList<Label> _labels;
  A_Token keyword;
  A_Token colon;
  NodeList<Statement> _statements;
  SwitchMember(List<Label> A_labels, this.keyword, this.colon, List<Statement> A_statements) {
    this._labels = new NodeList<Label>(this);
    this._statements = new NodeList<Statement>(this);
    this._labels.addAll(A_labels);
    this._statements.addAll(A_statements);
  }
  A_Token get beginToken {
    if (!_labels.isEmpty) {
      return _labels.beginToken;
    }
    return keyword;
  }
  A_Token get endToken {
    if (!_statements.isEmpty) {
      return _statements.endToken;
    }
    return colon;
  }
  NodeList<Label> get labels => _labels;
  NodeList<Statement> get statements => _statements;
}
class SwitchStatement extends Statement {
  A_Token keyword;
  A_Token leftParenthesis;
  Expression _expression;
  A_Token rightParenthesis;
  A_Token leftBracket;
  NodeList<SwitchMember> _members;
  A_Token rightBracket;
  SwitchStatement(this.keyword, this.leftParenthesis, Expression A_expression, this.rightParenthesis, this.leftBracket, List<SwitchMember> A_members, this.rightBracket) {
    this._members = new NodeList<SwitchMember>(this);
    this._expression = becomeParentOf(A_expression);
    this._members.addAll(A_members);
  }
  accept(AstVisitor visitor) => visitor.visitSwitchStatement(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => rightBracket;
  Expression get expression => _expression;
  NodeList<SwitchMember> get members => _members;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
    _members.accept(visitor);
  }
}
class SymbolLiteral extends Literal {
  A_Token poundSign;
  final List<A_Token> components;
  SymbolLiteral(this.poundSign, this.components);
  accept(AstVisitor visitor) => visitor.visitSymbolLiteral(this);
  A_Token get beginToken => poundSign;
  A_Token get endToken => components[components.length - 1];
  void visitChildren(AstVisitor visitor) {}
}
class ThisExpression extends Expression {
  A_Token keyword;
  ThisExpression(this.keyword);
  accept(AstVisitor visitor) => visitor.visitThisExpression(this);
  A_Token get beginToken => keyword;
  A_Token get endToken => keyword;
  int get precedence => 16;
  void visitChildren(AstVisitor visitor) {}
}
class ThrowExpression extends Expression {
  A_Token keyword;
  Expression _expression;
  ThrowExpression(this.keyword, Expression A_expression) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitThrowExpression(this);
  A_Token get beginToken => keyword;
  A_Token get endToken {
    if (_expression != null) {
      return _expression.endToken;
    }
    return keyword;
  }
  Expression get expression => _expression;
  int get precedence => 0;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class ToSourceVisitor implements AstVisitor<Object> {
  final PrintWriter _writer;
  ToSourceVisitor(this._writer);
  Object visitAdjacentStrings(AdjacentStrings node) {
    _visitNodeListWithSeparator(node.strings, " ");
    return null;
  }
  Object visitAnnotation(Annotation node) {
    _writer.print('@');
    _visitNode(node.name);
    _visitNodeWithPrefix(".", node.constructorName);
    _visitNode(node.arguments);
    return null;
  }
  Object visitArgumentList(ArgumentList node) {
    _writer.print('(');
    _visitNodeListWithSeparator(node.arguments, ", ");
    _writer.print(')');
    return null;
  }
  Object visitAsExpression(AsExpression node) {
    _visitNode(node.expression);
    _writer.print(" as ");
    _visitNode(node.type);
    return null;
  }
  Object visitAssertStatement(AssertStatement node) {
    _writer.print("assert (");
    _visitNode(node.condition);
    _writer.print(");");
    return null;
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    _visitNode(node.leftHandSide);
    _writer.print(' ');
    _writer.print(node.operator.lexeme);
    _writer.print(' ');
    _visitNode(node.rightHandSide);
    return null;
  }
  Object visitAwaitExpression(AwaitExpression node) {
    _writer.print("await ");
    _visitNode(node.expression);
    _writer.print(";");
    return null;
  }
  Object visitBinaryExpression(BinaryExpression node) {
    _visitNode(node.leftOperand);
    _writer.print(' ');
    _writer.print(node.operator.lexeme);
    _writer.print(' ');
    _visitNode(node.rightOperand);
    return null;
  }
  Object visitBlock(Block node) {
    _writer.print('{');
    _visitNodeListWithSeparator(node.statements, " ");
    _writer.print('}');
    return null;
  }
  Object visitBlockFunctionBody(BlockFunctionBody node) {
    A_Token keyword = node.keyword;
    if (keyword != null) {
      _writer.print(keyword.lexeme);
      if (node.star != null) {
        _writer.print('*');
      }
      _writer.print(' ');
    }
    _visitNode(node.block);
    return null;
  }
  Object visitBooleanLiteral(BooleanLiteral node) {
    _writer.print(node.literal.lexeme);
    return null;
  }
  Object visitBreakStatement(BreakStatement node) {
    _writer.print("break");
    _visitNodeWithPrefix(" ", node.label);
    _writer.print(";");
    return null;
  }
  Object visitCascadeExpression(CascadeExpression node) {
    _visitNode(node.target);
    _visitNodeList(node.cascadeSections);
    return null;
  }
  Object visitCatchClause(CatchClause node) {
    _visitNodeWithPrefix("on ", node.exceptionType);
    if (node.catchKeyword != null) {
      if (node.exceptionType != null) {
        _writer.print(' ');
      }
      _writer.print("catch (");
      _visitNode(node.exceptionParameter);
      _visitNodeWithPrefix(", ", node.stackTraceParameter);
      _writer.print(") ");
    } else {
      _writer.print(" ");
    }
    _visitNode(node.body);
    return null;
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.abstractKeyword, " ");
    _writer.print("class ");
    _visitNode(node.name);
    _visitNode(node.typeParameters);
    _visitNodeWithPrefix(" ", node.extendsClause);
    _visitNodeWithPrefix(" ", node.withClause);
    _visitNodeWithPrefix(" ", node.implementsClause);
    _writer.print(" {");
    _visitNodeListWithSeparator(node.members, " ");
    _writer.print("}");
    return null;
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    if (node.abstractKeyword != null) {
      _writer.print("abstract ");
    }
    _writer.print("class ");
    _visitNode(node.name);
    _visitNode(node.typeParameters);
    _writer.print(" = ");
    _visitNode(node.superclass);
    _visitNodeWithPrefix(" ", node.withClause);
    _visitNodeWithPrefix(" ", node.implementsClause);
    _writer.print(";");
    return null;
  }
  Object visitComment(Comment node) => null;
  Object visitCommentReference(CommentReference node) => null;
  Object visitCompilationUnit(CompilationUnit node) {
    ScriptTag scriptTag = node.scriptTag;
    NodeList<Directive> directives = node.directives;
    _visitNode(scriptTag);
    String prefix = scriptTag == null ? "" : " ";
    _visitNodeListWithSeparatorAndPrefix(prefix, directives, " ");
    prefix = scriptTag == null && directives.isEmpty ? "" : " ";
    _visitNodeListWithSeparatorAndPrefix(prefix, node.declarations, " ");
    return null;
  }
  Object visitConditionalExpression(ConditionalExpression node) {
    _visitNode(node.condition);
    _writer.print(" ? ");
    _visitNode(node.thenExpression);
    _writer.print(" : ");
    _visitNode(node.elseExpression);
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.externalKeyword, " ");
    _visitTokenWithSuffix(node.constKeyword, " ");
    _visitTokenWithSuffix(node.factoryKeyword, " ");
    _visitNode(node.returnType);
    _visitNodeWithPrefix(".", node.name);
    _visitNode(node.parameters);
    _visitNodeListWithSeparatorAndPrefix(" : ", node.initializers, ", ");
    _visitNodeWithPrefix(" = ", node.redirectedConstructor);
    _visitFunctionWithPrefix(" ", node.body);
    return null;
  }
  Object visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    _visitTokenWithSuffix(node.keyword, ".");
    _visitNode(node.fieldName);
    _writer.print(" = ");
    _visitNode(node.expression);
    return null;
  }
  Object visitConstructorName(ConstructorName node) {
    _visitNode(node.type);
    _visitNodeWithPrefix(".", node.name);
    return null;
  }
  Object visitContinueStatement(ContinueStatement node) {
    _writer.print("continue");
    _visitNodeWithPrefix(" ", node.label);
    _writer.print(";");
    return null;
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.keyword, " ");
    _visitNodeWithSuffix(node.type, " ");
    _visitNode(node.identifier);
    return null;
  }
  Object visitDefaultFormalParameter(DefaultFormalParameter node) {
    _visitNode(node.parameter);
    if (node.A_separator != null) {
      _writer.print(" ");
      _writer.print(node.A_separator.lexeme);
      _visitNodeWithPrefix(" ", node.defaultValue);
    }
    return null;
  }
  Object visitDoStatement(DoStatement node) {
    _writer.print("do ");
    _visitNode(node.body);
    _writer.print(" while (");
    _visitNode(node.condition);
    _writer.print(");");
    return null;
  }
  Object visitDoubleLiteral(DoubleLiteral node) {
    _writer.print(node.literal.lexeme);
    return null;
  }
  Object visitEmptyFunctionBody(EmptyFunctionBody node) {
    _writer.print(';');
    return null;
  }
  Object visitEmptyStatement(EmptyStatement node) {
    _writer.print(';');
    return null;
  }
  Object visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitNode(node.name);
    return null;
  }
  Object visitEnumDeclaration(EnumDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("enum ");
    _visitNode(node.name);
    _writer.print(" {");
    _visitNodeListWithSeparator(node.constants, ", ");
    _writer.print("}");
    return null;
  }
  Object visitExportDirective(ExportDirective node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("export ");
    _visitNode(node.uri);
    _visitNodeListWithSeparatorAndPrefix(" ", node.combinators, " ");
    _writer.print(';');
    return null;
  }
  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {
    A_Token keyword = node.keyword;
    if (keyword != null) {
      _writer.print(keyword.lexeme);
      _writer.print(' ');
    }
    _writer.print("=> ");
    _visitNode(node.expression);
    if (node.semicolon != null) {
      _writer.print(';');
    }
    return null;
  }
  Object visitExpressionStatement(ExpressionStatement node) {
    _visitNode(node.expression);
    _writer.print(';');
    return null;
  }
  Object visitExtendsClause(ExtendsClause node) {
    _writer.print("extends ");
    _visitNode(node.superclass);
    return null;
  }
  Object visitFieldDeclaration(FieldDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.staticKeyword, " ");
    _visitNode(node.fields);
    _writer.print(";");
    return null;
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    _visitTokenWithSuffix(node.keyword, " ");
    _visitNodeWithSuffix(node.type, " ");
    _writer.print("this.");
    _visitNode(node.identifier);
    _visitNode(node.parameters);
    return null;
  }
  Object visitForEachStatement(ForEachStatement node) {
    DeclaredIdentifier loopVariable = node.loopVariable;
    if (node.awaitKeyword != null) {
      _writer.print("await ");
    }
    _writer.print("for (");
    if (loopVariable == null) {
      _visitNode(node.identifier);
    } else {
      _visitNode(loopVariable);
    }
    _writer.print(" in ");
    _visitNode(node.iterator);
    _writer.print(") ");
    _visitNode(node.body);
    return null;
  }
  Object visitFormalParameterList(FormalParameterList node) {
    String groupEnd = null;
    _writer.print('(');
    NodeList<FormalParameter> A_parameters = node.parameters;
    int A_size = A_parameters.length;
    for (int i = 0; i < A_size; i++) {
      FormalParameter parameter = A_parameters[i];
      if (i > 0) {
        _writer.print(", ");
      }
      if (groupEnd == null && parameter is DefaultFormalParameter) {
        if (parameter.kind == ParameterKind.NAMED) {
          groupEnd = "}";
          _writer.print('{');
        } else {
          groupEnd = "]";
          _writer.print('[');
        }
      }
      parameter.accept(this);
    }
    if (groupEnd != null) {
      _writer.print(groupEnd);
    }
    _writer.print(')');
    return null;
  }
  Object visitForStatement(ForStatement node) {
    Expression initialization = node.initialization;
    _writer.print("for (");
    if (initialization != null) {
      _visitNode(initialization);
    } else {
      _visitNode(node.variables);
    }
    _writer.print(";");
    _visitNodeWithPrefix(" ", node.condition);
    _writer.print(";");
    _visitNodeListWithSeparatorAndPrefix(" ", node.updaters, ", ");
    _writer.print(") ");
    _visitNode(node.body);
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitNodeWithSuffix(node.returnType, " ");
    _visitTokenWithSuffix(node.propertyKeyword, " ");
    _visitNode(node.name);
    _visitNode(node.functionExpression);
    return null;
  }
  Object visitFunctionDeclarationStatement(FunctionDeclarationStatement node) {
    _visitNode(node.functionDeclaration);
    _writer.print(';');
    return null;
  }
  Object visitFunctionExpression(FunctionExpression node) {
    _visitNode(node.parameters);
    _writer.print(' ');
    _visitNode(node.body);
    return null;
  }
  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    _visitNode(node.function);
    _visitNode(node.argumentList);
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("typedef ");
    _visitNodeWithSuffix(node.returnType, " ");
    _visitNode(node.name);
    _visitNode(node.typeParameters);
    _visitNode(node.parameters);
    _writer.print(";");
    return null;
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    _visitNodeWithSuffix(node.returnType, " ");
    _visitNode(node.identifier);
    _visitNode(node.parameters);
    return null;
  }
  Object visitHideCombinator(HideCombinator node) {
    _writer.print("hide ");
    _visitNodeListWithSeparator(node.hiddenNames, ", ");
    return null;
  }
  Object visitIfStatement(IfStatement node) {
    _writer.print("if (");
    _visitNode(node.condition);
    _writer.print(") ");
    _visitNode(node.thenStatement);
    _visitNodeWithPrefix(" else ", node.elseStatement);
    return null;
  }
  Object visitImplementsClause(ImplementsClause node) {
    _writer.print("implements ");
    _visitNodeListWithSeparator(node.interfaces, ", ");
    return null;
  }
  Object visitImportDirective(ImportDirective node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("import ");
    _visitNode(node.uri);
    if (node.deferredToken != null) {
      _writer.print(" deferred");
    }
    _visitNodeWithPrefix(" as ", node.prefix);
    _visitNodeListWithSeparatorAndPrefix(" ", node.combinators, " ");
    _writer.print(';');
    return null;
  }
  Object visitIndexExpression(IndexExpression node) {
    if (node.isCascaded) {
      _writer.print("..");
    } else {
      _visitNode(node.target);
    }
    _writer.print('[');
    _visitNode(node.index);
    _writer.print(']');
    return null;
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    _visitTokenWithSuffix(node.keyword, " ");
    _visitNode(node.constructorName);
    _visitNode(node.argumentList);
    return null;
  }
  Object visitIntegerLiteral(IntegerLiteral node) {
    _writer.print(node.literal.lexeme);
    return null;
  }
  Object visitInterpolationExpression(InterpolationExpression node) {
    if (node.rightBracket != null) {
      _writer.print("\${");
      _visitNode(node.expression);
      _writer.print("}");
    } else {
      _writer.print("\$");
      _visitNode(node.expression);
    }
    return null;
  }
  Object visitInterpolationString(InterpolationString node) {
    _writer.print(node.contents.lexeme);
    return null;
  }
  Object visitIsExpression(IsExpression node) {
    _visitNode(node.expression);
    if (node.notOperator == null) {
      _writer.print(" is ");
    } else {
      _writer.print(" is! ");
    }
    _visitNode(node.type);
    return null;
  }
  Object visitLabel(Label node) {
    _visitNode(node.label);
    _writer.print(":");
    return null;
  }
  Object visitLabeledStatement(LabeledStatement node) {
    _visitNodeListWithSeparatorAndSuffix(node.labels, " ", " ");
    _visitNode(node.statement);
    return null;
  }
  Object visitLibraryDirective(LibraryDirective node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("library ");
    _visitNode(node.name);
    _writer.print(';');
    return null;
  }
  Object visitLibraryIdentifier(LibraryIdentifier node) {
    _writer.print(node.name);
    return null;
  }
  Object visitListLiteral(ListLiteral node) {
    if (node.constKeyword != null) {
      _writer.print(node.constKeyword.lexeme);
      _writer.print(' ');
    }
    _visitNodeWithSuffix(node.typeArguments, " ");
    _writer.print("[");
    _visitNodeListWithSeparator(node.elements, ", ");
    _writer.print("]");
    return null;
  }
  Object visitMapLiteral(MapLiteral node) {
    if (node.constKeyword != null) {
      _writer.print(node.constKeyword.lexeme);
      _writer.print(' ');
    }
    _visitNodeWithSuffix(node.typeArguments, " ");
    _writer.print("{");
    _visitNodeListWithSeparator(node.entries, ", ");
    _writer.print("}");
    return null;
  }
  Object visitMapLiteralEntry(MapLiteralEntry node) {
    _visitNode(node.key);
    _writer.print(" : ");
    _visitNode(node.value);
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.externalKeyword, " ");
    _visitTokenWithSuffix(node.modifierKeyword, " ");
    _visitNodeWithSuffix(node.returnType, " ");
    _visitTokenWithSuffix(node.propertyKeyword, " ");
    _visitTokenWithSuffix(node.operatorKeyword, " ");
    _visitNode(node.name);
    if (!node.isGetter) {
      _visitNode(node.parameters);
    }
    _visitFunctionWithPrefix(" ", node.body);
    return null;
  }
  Object visitMethodInvocation(MethodInvocation node) {
    if (node.isCascaded) {
      _writer.print("..");
    } else {
      _visitNodeWithSuffix(node.target, ".");
    }
    _visitNode(node.methodName);
    _visitNode(node.argumentList);
    return null;
  }
  Object visitNamedExpression(NamedExpression node) {
    _visitNode(node.name);
    _visitNodeWithPrefix(" ", node.expression);
    return null;
  }
  Object visitNativeClause(NativeClause node) {
    _writer.print("native ");
    _visitNode(node.name);
    return null;
  }
  Object visitNativeFunctionBody(NativeFunctionBody node) {
    _writer.print("native ");
    _visitNode(node.stringLiteral);
    _writer.print(';');
    return null;
  }
  Object visitNullLiteral(NullLiteral node) {
    _writer.print("null");
    return null;
  }
  Object visitParenthesizedExpression(ParenthesizedExpression node) {
    _writer.print('(');
    _visitNode(node.expression);
    _writer.print(')');
    return null;
  }
  Object visitPartDirective(PartDirective node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("part ");
    _visitNode(node.uri);
    _writer.print(';');
    return null;
  }
  Object visitPartOfDirective(PartOfDirective node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _writer.print("part of ");
    _visitNode(node.libraryName);
    _writer.print(';');
    return null;
  }
  Object visitPostfixExpression(PostfixExpression node) {
    _visitNode(node.operand);
    _writer.print(node.operator.lexeme);
    return null;
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    _visitNode(node.prefix);
    _writer.print('.');
    _visitNode(node.identifier);
    return null;
  }
  Object visitPrefixExpression(PrefixExpression node) {
    _writer.print(node.operator.lexeme);
    _visitNode(node.operand);
    return null;
  }
  Object visitPropertyAccess(PropertyAccess node) {
    if (node.isCascaded) {
      _writer.print("..");
    } else {
      _visitNode(node.target);
      _writer.print('.');
    }
    _visitNode(node.propertyName);
    return null;
  }
  Object visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    _writer.print("this");
    _visitNodeWithPrefix(".", node.constructorName);
    _visitNode(node.argumentList);
    return null;
  }
  Object visitRethrowExpression(RethrowExpression node) {
    _writer.print("rethrow");
    return null;
  }
  Object visitReturnStatement(ReturnStatement node) {
    Expression expression = node.expression;
    if (expression == null) {
      _writer.print("return;");
    } else {
      _writer.print("return ");
      expression.accept(this);
      _writer.print(";");
    }
    return null;
  }
  Object visitScriptTag(ScriptTag node) {
    _writer.print(node.scriptTag.lexeme);
    return null;
  }
  Object visitShowCombinator(ShowCombinator node) {
    _writer.print("show ");
    _visitNodeListWithSeparator(node.shownNames, ", ");
    return null;
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    _visitTokenWithSuffix(node.keyword, " ");
    _visitNodeWithSuffix(node.type, " ");
    _visitNode(node.identifier);
    return null;
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    _writer.print(node.token.lexeme);
    return null;
  }
  Object visitSimpleStringLiteral(SimpleStringLiteral node) {
    _writer.print(node.literal.lexeme);
    return null;
  }
  Object visitStringInterpolation(StringInterpolation node) {
    _visitNodeList(node.elements);
    return null;
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    _writer.print("super");
    _visitNodeWithPrefix(".", node.constructorName);
    _visitNode(node.argumentList);
    return null;
  }
  Object visitSuperExpression(SuperExpression node) {
    _writer.print("super");
    return null;
  }
  Object visitSwitchCase(SwitchCase node) {
    _visitNodeListWithSeparatorAndSuffix(node.labels, " ", " ");
    _writer.print("case ");
    _visitNode(node.expression);
    _writer.print(": ");
    _visitNodeListWithSeparator(node.statements, " ");
    return null;
  }
  Object visitSwitchDefault(SwitchDefault node) {
    _visitNodeListWithSeparatorAndSuffix(node.labels, " ", " ");
    _writer.print("default: ");
    _visitNodeListWithSeparator(node.statements, " ");
    return null;
  }
  Object visitSwitchStatement(SwitchStatement node) {
    _writer.print("switch (");
    _visitNode(node.expression);
    _writer.print(") {");
    _visitNodeListWithSeparator(node.members, " ");
    _writer.print("}");
    return null;
  }
  Object visitSymbolLiteral(SymbolLiteral node) {
    _writer.print("#");
    List<A_Token> components = node.components;
    for (int i = 0; i < components.length; i++) {
      if (i > 0) {
        _writer.print(".");
      }
      _writer.print(components[i].lexeme);
    }
    return null;
  }
  Object visitThisExpression(ThisExpression node) {
    _writer.print("this");
    return null;
  }
  Object visitThrowExpression(ThrowExpression node) {
    _writer.print("throw ");
    _visitNode(node.expression);
    return null;
  }
  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    _visitNodeWithSuffix(node.variables, ";");
    return null;
  }
  Object visitTryStatement(TryStatement node) {
    _writer.print("try ");
    _visitNode(node.body);
    _visitNodeListWithSeparatorAndPrefix(" ", node.catchClauses, " ");
    _visitNodeWithPrefix(" finally ", node.finallyBlock);
    return null;
  }
  Object visitTypeArgumentList(TypeArgumentList node) {
    _writer.print('<');
    _visitNodeListWithSeparator(node.arguments, ", ");
    _writer.print('>');
    return null;
  }
  Object visitTypeName(TypeName node) {
    _visitNode(node.name);
    _visitNode(node.typeArguments);
    return null;
  }
  Object visitTypeParameter(TypeParameter node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitNode(node.name);
    _visitNodeWithPrefix(" extends ", node.bound);
    return null;
  }
  Object visitTypeParameterList(TypeParameterList node) {
    _writer.print('<');
    _visitNodeListWithSeparator(node.typeParameters, ", ");
    _writer.print('>');
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitNode(node.name);
    _visitNodeWithPrefix(" = ", node.initializer);
    return null;
  }
  Object visitVariableDeclarationList(VariableDeclarationList node) {
    _visitNodeListWithSeparatorAndSuffix(node.metadata, " ", " ");
    _visitTokenWithSuffix(node.keyword, " ");
    _visitNodeWithSuffix(node.type, " ");
    _visitNodeListWithSeparator(node.variables, ", ");
    return null;
  }
  Object visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    _visitNode(node.variables);
    _writer.print(";");
    return null;
  }
  Object visitWhileStatement(WhileStatement node) {
    _writer.print("while (");
    _visitNode(node.condition);
    _writer.print(") ");
    _visitNode(node.body);
    return null;
  }
  Object visitWithClause(WithClause node) {
    _writer.print("with ");
    _visitNodeListWithSeparator(node.mixinTypes, ", ");
    return null;
  }
  Object visitYieldStatement(YieldStatement node) {
    if (node.star != null) {
      _writer.print("yield* ");
    } else {
      _writer.print("yield ");
    }
    _visitNode(node.expression);
    _writer.print(";");
    return null;
  }
  void _visitFunctionWithPrefix(String prefix, FunctionBody body) {
    if (body is! EmptyFunctionBody) {
      _writer.print(prefix);
    }
    _visitNode(body);
  }
  void _visitNode(AstNode node) {
    if (node != null) {
      node.accept(this);
    }
  }
  void _visitNodeList(NodeList<AstNode> nodes) {
    _visitNodeListWithSeparator(nodes, "");
  }
  void _visitNodeListWithSeparator(NodeList<AstNode> nodes, String A_separator) {
    if (nodes != null) {
      int A_size = nodes.length;
      for (int i = 0; i < A_size; i++) {
        if (i > 0) {
          _writer.print(A_separator);
        }
        nodes[i].accept(this);
      }
    }
  }
  void _visitNodeListWithSeparatorAndPrefix(String prefix, NodeList<AstNode> nodes, String A_separator) {
    if (nodes != null) {
      int A_size = nodes.length;
      if (A_size > 0) {
        _writer.print(prefix);
        for (int i = 0; i < A_size; i++) {
          if (i > 0) {
            _writer.print(A_separator);
          }
          nodes[i].accept(this);
        }
      }
    }
  }
  void _visitNodeListWithSeparatorAndSuffix(NodeList<AstNode> nodes, String A_separator, String suffix) {
    if (nodes != null) {
      int A_size = nodes.length;
      if (A_size > 0) {
        for (int i = 0; i < A_size; i++) {
          if (i > 0) {
            _writer.print(A_separator);
          }
          nodes[i].accept(this);
        }
        _writer.print(suffix);
      }
    }
  }
  void _visitNodeWithPrefix(String prefix, AstNode node) {
    if (node != null) {
      _writer.print(prefix);
      node.accept(this);
    }
  }
  void _visitNodeWithSuffix(AstNode node, String suffix) {
    if (node != null) {
      node.accept(this);
      _writer.print(suffix);
    }
  }
  void _visitTokenWithSuffix(A_Token token, String suffix) {
    if (token != null) {
      _writer.print(token.lexeme);
      _writer.print(suffix);
    }
  }
}
class TopLevelVariableDeclaration extends CompilationUnitMember {
  VariableDeclarationList _variableList;
  A_Token semicolon;
  TopLevelVariableDeclaration(Comment comment, List<Annotation> metadata, VariableDeclarationList variableList, this.semicolon) : super(comment, metadata) {
    this._variableList = becomeParentOf(variableList);
  }
  accept(AstVisitor visitor) => visitor.visitTopLevelVariableDeclaration(this);
  A_Element get element => null;
  A_Token get endToken => semicolon;
  VariableDeclarationList get variables => _variableList;
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(_variableList, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata => _variableList.beginToken;
}
class TryStatement extends Statement {
  A_Token tryKeyword;
  Block _body;
  NodeList<CatchClause> _catchClauses;
  A_Token finallyKeyword;
  Block _finallyBlock;
  TryStatement(this.tryKeyword, Block A_body, List<CatchClause> A_catchClauses, this.finallyKeyword, Block A_finallyBlock) {
    this._catchClauses = new NodeList<CatchClause>(this);
    this._body = becomeParentOf(A_body);
    this._catchClauses.addAll(A_catchClauses);
    this._finallyBlock = becomeParentOf(A_finallyBlock);
  }
  accept(AstVisitor visitor) => visitor.visitTryStatement(this);
  A_Token get beginToken => tryKeyword;
  Block get body => _body;
  NodeList<CatchClause> get catchClauses => _catchClauses;
  A_Token get endToken {
    if (_finallyBlock != null) {
      return _finallyBlock.endToken;
    } else if (finallyKeyword != null) {
      return finallyKeyword;
    } else if (!_catchClauses.isEmpty) {
      return _catchClauses.endToken;
    }
    return _body.endToken;
  }
  Block get finallyBlock => _finallyBlock;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_body, visitor);
    _catchClauses.accept(visitor);
    safelyVisitChild(_finallyBlock, visitor);
  }
}
abstract class TypeAlias extends CompilationUnitMember {
  A_Token keyword;
  A_Token semicolon;
  TypeAlias(Comment comment, List<Annotation> metadata, this.keyword, this.semicolon) : super(comment, metadata);
  A_Token get endToken => semicolon;
  A_Token get firstTokenAfterCommentAndMetadata => keyword;
}
class TypeArgumentList extends AstNode {
  A_Token leftBracket;
  NodeList<TypeName> A__arguments;
  A_Token rightBracket;
  TypeArgumentList(this.leftBracket, List<TypeName> A_arguments, this.rightBracket) {
    this.A__arguments = new NodeList<TypeName>(this);
    this.A__arguments.addAll(A_arguments);
  }
  accept(AstVisitor visitor) => visitor.visitTypeArgumentList(this);
  NodeList<TypeName> get arguments => A__arguments;
  A_Token get beginToken => leftBracket;
  A_Token get endToken => rightBracket;
  void visitChildren(AstVisitor visitor) {
    A__arguments.accept(visitor);
  }
}
class TypeName extends AstNode {
  Identifier A__name;
  TypeArgumentList _typeArguments;
  DartType type;
  TypeName(Identifier A_name, TypeArgumentList A_typeArguments) {
    this.A__name = becomeParentOf(A_name);
    this._typeArguments = becomeParentOf(A_typeArguments);
  }
  accept(AstVisitor visitor) => visitor.visitTypeName(this);
  A_Token get beginToken => A__name.beginToken;
  A_Token get endToken {
    if (_typeArguments != null) {
      return _typeArguments.endToken;
    }
    return A__name.endToken;
  }
  Identifier get name => A__name;
  TypeArgumentList get typeArguments => _typeArguments;
  bool get isDeferred {
    Identifier identifier = name;
    if (identifier is! PrefixedIdentifier) {
      return false;
    }
    return (identifier as PrefixedIdentifier).isDeferred;
  }
  bool get isSynthetic => A__name.isSynthetic && _typeArguments == null;
  void set name(Identifier identifier) {
    A__name = becomeParentOf(identifier);
  }
  void set typeArguments(TypeArgumentList A_typeArguments) {
    this._typeArguments = becomeParentOf(A_typeArguments);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_typeArguments, visitor);
  }
}
class TypeParameter extends Declaration {
  SimpleIdentifier A__name;
  A_Token keyword;
  TypeName _bound;
  TypeParameter(Comment comment, List<Annotation> metadata, SimpleIdentifier A_name, this.keyword, TypeName A_bound) : super(comment, metadata) {
    this.A__name = becomeParentOf(A_name);
    this._bound = becomeParentOf(A_bound);
  }
  accept(AstVisitor visitor) => visitor.visitTypeParameter(this);
  TypeName get bound => _bound;
  TypeParameterElement get element => A__name != null ? (A__name.staticElement as TypeParameterElement) : null;
  A_Token get endToken {
    if (_bound == null) {
      return A__name.endToken;
    }
    return _bound.endToken;
  }
  SimpleIdentifier get name => A__name;
  void set bound(TypeName typeName) {
    _bound = becomeParentOf(typeName);
  }
  void set name(SimpleIdentifier identifier) {
    A__name = becomeParentOf(identifier);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_bound, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata => A__name.beginToken;
}
class TypeParameterList extends AstNode {
  final A_Token leftBracket;
  NodeList<TypeParameter> _typeParameters;
  final A_Token rightBracket;
  TypeParameterList(this.leftBracket, List<TypeParameter> A_typeParameters, this.rightBracket) {
    this._typeParameters = new NodeList<TypeParameter>(this);
    this._typeParameters.addAll(A_typeParameters);
  }
  accept(AstVisitor visitor) => visitor.visitTypeParameterList(this);
  A_Token get beginToken => leftBracket;
  A_Token get endToken => rightBracket;
  NodeList<TypeParameter> get typeParameters => _typeParameters;
  void visitChildren(AstVisitor visitor) {
    _typeParameters.accept(visitor);
  }
}
abstract class TypedLiteral extends Literal {
  A_Token constKeyword;
  TypeArgumentList _typeArguments;
  TypedLiteral(this.constKeyword, TypeArgumentList A_typeArguments) {
    this._typeArguments = becomeParentOf(A_typeArguments);
  }
  TypeArgumentList get typeArguments => _typeArguments;
  void set typeArguments(TypeArgumentList A_typeArguments) {
    this._typeArguments = becomeParentOf(A_typeArguments);
  }
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_typeArguments, visitor);
  }
}
class UnifyingAstVisitor<R> implements AstVisitor<R> {
  R visitAdjacentStrings(AdjacentStrings node) => visitNode(node);
  R visitAnnotation(Annotation node) => visitNode(node);
  R visitArgumentList(ArgumentList node) => visitNode(node);
  R visitAsExpression(AsExpression node) => visitNode(node);
  R visitAssertStatement(AssertStatement node) => visitNode(node);
  R visitAssignmentExpression(AssignmentExpression node) => visitNode(node);
  R visitAwaitExpression(AwaitExpression node) => visitNode(node);
  R visitBinaryExpression(BinaryExpression node) => visitNode(node);
  R visitBlock(Block node) => visitNode(node);
  R visitBlockFunctionBody(BlockFunctionBody node) => visitNode(node);
  R visitBooleanLiteral(BooleanLiteral node) => visitNode(node);
  R visitBreakStatement(BreakStatement node) => visitNode(node);
  R visitCascadeExpression(CascadeExpression node) => visitNode(node);
  R visitCatchClause(CatchClause node) => visitNode(node);
  R visitClassDeclaration(ClassDeclaration node) => visitNode(node);
  R visitClassTypeAlias(ClassTypeAlias node) => visitNode(node);
  R visitComment(Comment node) => visitNode(node);
  R visitCommentReference(CommentReference node) => visitNode(node);
  R visitCompilationUnit(CompilationUnit node) => visitNode(node);
  R visitConditionalExpression(ConditionalExpression node) => visitNode(node);
  R visitConstructorDeclaration(ConstructorDeclaration node) => visitNode(node);
  R visitConstructorFieldInitializer(ConstructorFieldInitializer node) => visitNode(node);
  R visitConstructorName(ConstructorName node) => visitNode(node);
  R visitContinueStatement(ContinueStatement node) => visitNode(node);
  R visitDeclaredIdentifier(DeclaredIdentifier node) => visitNode(node);
  R visitDefaultFormalParameter(DefaultFormalParameter node) => visitNode(node);
  R visitDoStatement(DoStatement node) => visitNode(node);
  R visitDoubleLiteral(DoubleLiteral node) => visitNode(node);
  R visitEmptyFunctionBody(EmptyFunctionBody node) => visitNode(node);
  R visitEmptyStatement(EmptyStatement node) => visitNode(node);
  R visitEnumConstantDeclaration(EnumConstantDeclaration node) => visitNode(node);
  R visitEnumDeclaration(EnumDeclaration node) => visitNode(node);
  R visitExportDirective(ExportDirective node) => visitNode(node);
  R visitExpressionFunctionBody(ExpressionFunctionBody node) => visitNode(node);
  R visitExpressionStatement(ExpressionStatement node) => visitNode(node);
  R visitExtendsClause(ExtendsClause node) => visitNode(node);
  R visitFieldDeclaration(FieldDeclaration node) => visitNode(node);
  R visitFieldFormalParameter(FieldFormalParameter node) => visitNode(node);
  R visitForEachStatement(ForEachStatement node) => visitNode(node);
  R visitFormalParameterList(FormalParameterList node) => visitNode(node);
  R visitForStatement(ForStatement node) => visitNode(node);
  R visitFunctionDeclaration(FunctionDeclaration node) => visitNode(node);
  R visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => visitNode(node);
  R visitFunctionExpression(FunctionExpression node) => visitNode(node);
  R visitFunctionExpressionInvocation(FunctionExpressionInvocation node) => visitNode(node);
  R visitFunctionTypeAlias(FunctionTypeAlias node) => visitNode(node);
  R visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) => visitNode(node);
  R visitHideCombinator(HideCombinator node) => visitNode(node);
  R visitIfStatement(IfStatement node) => visitNode(node);
  R visitImplementsClause(ImplementsClause node) => visitNode(node);
  R visitImportDirective(ImportDirective node) => visitNode(node);
  R visitIndexExpression(IndexExpression node) => visitNode(node);
  R visitInstanceCreationExpression(InstanceCreationExpression node) => visitNode(node);
  R visitIntegerLiteral(IntegerLiteral node) => visitNode(node);
  R visitInterpolationExpression(InterpolationExpression node) => visitNode(node);
  R visitInterpolationString(InterpolationString node) => visitNode(node);
  R visitIsExpression(IsExpression node) => visitNode(node);
  R visitLabel(Label node) => visitNode(node);
  R visitLabeledStatement(LabeledStatement node) => visitNode(node);
  R visitLibraryDirective(LibraryDirective node) => visitNode(node);
  R visitLibraryIdentifier(LibraryIdentifier node) => visitNode(node);
  R visitListLiteral(ListLiteral node) => visitNode(node);
  R visitMapLiteral(MapLiteral node) => visitNode(node);
  R visitMapLiteralEntry(MapLiteralEntry node) => visitNode(node);
  R visitMethodDeclaration(MethodDeclaration node) => visitNode(node);
  R visitMethodInvocation(MethodInvocation node) => visitNode(node);
  R visitNamedExpression(NamedExpression node) => visitNode(node);
  R visitNativeClause(NativeClause node) => visitNode(node);
  R visitNativeFunctionBody(NativeFunctionBody node) => visitNode(node);
  R visitNode(AstNode node) {
    node.visitChildren(this);
    return null;
  }
  R visitNullLiteral(NullLiteral node) => visitNode(node);
  R visitParenthesizedExpression(ParenthesizedExpression node) => visitNode(node);
  R visitPartDirective(PartDirective node) => visitNode(node);
  R visitPartOfDirective(PartOfDirective node) => visitNode(node);
  R visitPostfixExpression(PostfixExpression node) => visitNode(node);
  R visitPrefixedIdentifier(PrefixedIdentifier node) => visitNode(node);
  R visitPrefixExpression(PrefixExpression node) => visitNode(node);
  R visitPropertyAccess(PropertyAccess node) => visitNode(node);
  R visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) => visitNode(node);
  R visitRethrowExpression(RethrowExpression node) => visitNode(node);
  R visitReturnStatement(ReturnStatement node) => visitNode(node);
  R visitScriptTag(ScriptTag scriptTag) => visitNode(scriptTag);
  R visitShowCombinator(ShowCombinator node) => visitNode(node);
  R visitSimpleFormalParameter(SimpleFormalParameter node) => visitNode(node);
  R visitSimpleIdentifier(SimpleIdentifier node) => visitNode(node);
  R visitSimpleStringLiteral(SimpleStringLiteral node) => visitNode(node);
  R visitStringInterpolation(StringInterpolation node) => visitNode(node);
  R visitSuperConstructorInvocation(SuperConstructorInvocation node) => visitNode(node);
  R visitSuperExpression(SuperExpression node) => visitNode(node);
  R visitSwitchCase(SwitchCase node) => visitNode(node);
  R visitSwitchDefault(SwitchDefault node) => visitNode(node);
  R visitSwitchStatement(SwitchStatement node) => visitNode(node);
  R visitSymbolLiteral(SymbolLiteral node) => visitNode(node);
  R visitThisExpression(ThisExpression node) => visitNode(node);
  R visitThrowExpression(ThrowExpression node) => visitNode(node);
  R visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) => visitNode(node);
  R visitTryStatement(TryStatement node) => visitNode(node);
  R visitTypeArgumentList(TypeArgumentList node) => visitNode(node);
  R visitTypeName(TypeName node) => visitNode(node);
  R visitTypeParameter(TypeParameter node) => visitNode(node);
  R visitTypeParameterList(TypeParameterList node) => visitNode(node);
  R visitVariableDeclaration(VariableDeclaration node) => visitNode(node);
  R visitVariableDeclarationList(VariableDeclarationList node) => visitNode(node);
  R visitVariableDeclarationStatement(VariableDeclarationStatement node) => visitNode(node);
  R visitWhileStatement(WhileStatement node) => visitNode(node);
  R visitWithClause(WithClause node) => visitNode(node);
  R visitYieldStatement(YieldStatement node) => visitNode(node);
}
abstract class UriBasedDirective extends Directive {
  StringLiteral A__uri;
  static String _DART_EXT_SCHEME = "dart-ext:";
  String uriContent;
  Source source;
  UriBasedDirective(Comment comment, List<Annotation> metadata, StringLiteral A_uri) : super(comment, metadata) {
    this.A__uri = becomeParentOf(A_uri);
  }
  StringLiteral get uri => A__uri;
  A_Element get uriElement;
  void set uri(StringLiteral A_uri) {
    this.A__uri = becomeParentOf(A_uri);
  }
  UriValidationCode validate() {
    StringLiteral uriLiteral = uri;
    if (uriLiteral is StringInterpolation) {
      return UriValidationCode.URI_WITH_INTERPOLATION;
    }
    String A_uriContent = this.uriContent;
    if (A_uriContent == null) {
      return UriValidationCode.INVALID_URI;
    }
    if (this is ImportDirective && A_uriContent.startsWith(_DART_EXT_SCHEME)) {
      return UriValidationCode.URI_WITH_DART_EXT_SCHEME;
    }
    try {
      parseUriWithException(Uri.encodeFull(A_uriContent));
    }on URISyntaxException  catch (exception) {
      return UriValidationCode.INVALID_URI;
    }
    return null;
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__uri, visitor);
  }
}
class UriValidationCode extends Enum<UriValidationCode> {
  static const UriValidationCode INVALID_URI = const UriValidationCode('INVALID_URI', 0);
  static const UriValidationCode URI_WITH_INTERPOLATION = const UriValidationCode('URI_WITH_INTERPOLATION', 1);
  static const UriValidationCode URI_WITH_DART_EXT_SCHEME = const UriValidationCode('URI_WITH_DART_EXT_SCHEME', 2);
  const UriValidationCode(String A_name, int ordinal) : super(A_name, ordinal);
}
class VariableDeclaration extends Declaration {
  SimpleIdentifier A__name;
  A_Token A_equals;
  Expression _initializer;
  VariableDeclaration(Comment comment, List<Annotation> metadata, SimpleIdentifier A_name, this.A_equals, Expression A_initializer) : super(comment, metadata) {
    this.A__name = becomeParentOf(A_name);
    this._initializer = becomeParentOf(A_initializer);
  }
  accept(AstVisitor visitor) => visitor.visitVariableDeclaration(this);
  Comment get documentationComment {
    Comment comment = super.documentationComment;
    if (comment == null) {
      if (parent != null && parent.parent != null) {
        AstNode node = parent.parent;
        if (node is AnnotatedNode) {
          return node.documentationComment;
        }
      }
    }
    return comment;
  }
  VariableElement get element => A__name != null ? (A__name.staticElement as VariableElement) : null;
  A_Token get endToken {
    if (_initializer != null) {
      return _initializer.endToken;
    }
    return A__name.endToken;
  }
  Expression get initializer => _initializer;
  SimpleIdentifier get name => A__name;
  bool get isConst {
    AstNode A_parent = this.parent;
    return A_parent is VariableDeclarationList && A_parent.isConst;
  }
  bool get isFinal {
    AstNode A_parent = this.parent;
    return A_parent is VariableDeclarationList && A_parent.isFinal;
  }
  void set initializer(Expression A_initializer) {
    this._initializer = becomeParentOf(A_initializer);
  }
  void set name(SimpleIdentifier A_name) {
    this.A__name = becomeParentOf(A_name);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__name, visitor);
    safelyVisitChild(_initializer, visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata => A__name.beginToken;
}
class VariableDeclarationList extends AnnotatedNode {
  A_Token keyword;
  TypeName A__type;
  NodeList<VariableDeclaration> _variables;
  VariableDeclarationList(Comment comment, List<Annotation> metadata, this.keyword, TypeName A_type, List<VariableDeclaration> A_variables) : super(comment, metadata) {
    this._variables = new NodeList<VariableDeclaration>(this);
    this.A__type = becomeParentOf(A_type);
    this._variables.addAll(A_variables);
  }
  accept(AstVisitor visitor) => visitor.visitVariableDeclarationList(this);
  A_Token get endToken => _variables.endToken;
  TypeName get type => A__type;
  NodeList<VariableDeclaration> get variables => _variables;
  bool get isConst => keyword is KeywordToken && (keyword as KeywordToken).keyword == Keyword.B_CONST;
  bool get isFinal => keyword is KeywordToken && (keyword as KeywordToken).keyword == Keyword.A_FINAL;
  void set type(TypeName typeName) {
    A__type = becomeParentOf(typeName);
  }
  void visitChildren(AstVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__type, visitor);
    _variables.accept(visitor);
  }
  A_Token get firstTokenAfterCommentAndMetadata {
    if (keyword != null) {
      return keyword;
    } else if (A__type != null) {
      return A__type.beginToken;
    }
    return _variables.beginToken;
  }
}
class VariableDeclarationStatement extends Statement {
  VariableDeclarationList _variableList;
  A_Token semicolon;
  VariableDeclarationStatement(VariableDeclarationList variableList, this.semicolon) {
    this._variableList = becomeParentOf(variableList);
  }
  accept(AstVisitor visitor) => visitor.visitVariableDeclarationStatement(this);
  A_Token get beginToken => _variableList.beginToken;
  A_Token get endToken => semicolon;
  VariableDeclarationList get variables => _variableList;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_variableList, visitor);
  }
}
class WhileStatement extends Statement {
  A_Token keyword;
  A_Token leftParenthesis;
  Expression _condition;
  A_Token rightParenthesis;
  Statement _body;
  WhileStatement(this.keyword, this.leftParenthesis, Expression A_condition, this.rightParenthesis, Statement A_body) {
    this._condition = becomeParentOf(A_condition);
    this._body = becomeParentOf(A_body);
  }
  accept(AstVisitor visitor) => visitor.visitWhileStatement(this);
  A_Token get beginToken => keyword;
  Statement get body => _body;
  Expression get condition => _condition;
  A_Token get endToken => _body.endToken;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_condition, visitor);
    safelyVisitChild(_body, visitor);
  }
}
class WithClause extends AstNode {
  A_Token _withKeyword;
  NodeList<TypeName> _mixinTypes;
  WithClause(A_Token A_withKeyword, List<TypeName> A_mixinTypes) {
    this._mixinTypes = new NodeList<TypeName>(this);
    this._withKeyword = A_withKeyword;
    this._mixinTypes.addAll(A_mixinTypes);
  }
  accept(AstVisitor visitor) => visitor.visitWithClause(this);
  A_Token get beginToken => _withKeyword;
  A_Token get endToken => _mixinTypes.endToken;
  NodeList<TypeName> get mixinTypes => _mixinTypes;
  A_Token get withKeyword => _withKeyword;
  void visitChildren(AstVisitor visitor) {
    _mixinTypes.accept(visitor);
  }
}
class YieldStatement extends Statement {
  A_Token yieldKeyword;
  A_Token star;
  Expression _expression;
  A_Token semicolon;
  YieldStatement(this.yieldKeyword, this.star, Expression A_expression, this.semicolon) {
    this._expression = becomeParentOf(A_expression);
  }
  accept(AstVisitor visitor) => visitor.visitYieldStatement(this);
  A_Token get beginToken {
    if (yieldKeyword != null) {
      return yieldKeyword;
    }
    return _expression.beginToken;
  }
  A_Token get endToken {
    if (semicolon != null) {
      return semicolon;
    }
    return _expression.endToken;
  }
  Expression get expression => _expression;
  void visitChildren(AstVisitor visitor) {
    safelyVisitChild(_expression, visitor);
  }
}
class NodeList<D_E extends AstNode> extends Object with A_p.ListMixin<D_E> {
  AstNode owner;
  List<D_E> _elements = <D_E>[];
  NodeList(this.owner);
  accept(AstVisitor visitor) {
    var A_length = _elements.length;
    for (var i = 0; i < A_length; i++) {
      _elements[i].accept(visitor);
    }
  }
  void add(D_E node) {
    insert(length, node);
  }
  void insert(int A_index, D_E node) {
    int A_length = _elements.length;
    if (A_index < 0 || A_index > A_length) {
      throw new RangeError("Index: ${A_index}, Size: ${_elements.length}");
    }
    owner.becomeParentOf(node);
    if (A_length == 0) {
      _elements = <D_E>[node];
    } else {
      _elements.insert(A_index, node);
    }
  }
  bool addAll(Iterable<D_E> nodes) {
    if (nodes != null && !nodes.isEmpty) {
      _elements.addAll(nodes);
      for (D_E node in nodes) {
        owner.becomeParentOf(node);
      }
      return true;
    }
    return false;
  }
  D_E operator[](int A_index) {
    if (A_index < 0 || A_index >= _elements.length) {
      throw new RangeError("Index: ${A_index}, Size: ${_elements.length}");
    }
    return _elements[A_index] as D_E;
  }
  A_Token get beginToken {
    if (_elements.length == 0) {
      return null;
    }
    return _elements[0].beginToken;
  }
  A_Token get endToken {
    if (_elements.length == 0) {
      return null;
    }
    return _elements[_elements.length - 1].endToken;
  }
  D_E removeAt(int A_index) {
    if (A_index < 0 || A_index >= _elements.length) {
      throw new RangeError("Index: ${A_index}, Size: ${_elements.length}");
    }
    D_E removedNode = _elements[A_index] as D_E;
    int A_length = _elements.length;
    if (A_length == 1) {
      _elements = AstNode.A_EMPTY_ARRAY;
      return removedNode;
    }
    _elements.removeAt(A_index);
    return removedNode;
  }
  void operator[]=(int A_index, D_E node) {
    if (A_index < 0 || A_index >= _elements.length) {
      throw new RangeError("Index: ${A_index}, Size: ${_elements.length}");
    }
    owner.becomeParentOf(node);
    _elements[A_index] = node;
  }
  void clear() {
    _elements = <D_E>[];
  }
  int get length => _elements.length;
  void set length(int A_value) {
    throw new UnsupportedError("Cannot resize NodeList.");
  }
}
class BoolState extends InstanceState {
  final bool value;
  static BoolState FALSE_STATE = new BoolState(false);
  static BoolState TRUE_STATE = new BoolState(true);
  static BoolState UNKNOWN_VALUE = new BoolState(null);
  static BoolState A_from(bool A_value) => A_value ? BoolState.TRUE_STATE : BoolState.FALSE_STATE;
  BoolState(this.value);
  BoolState convertToBool() => this;
  StringState convertToString() {
    if (value == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(value ? "true" : "false");
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is BoolState) {
      bool rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return BoolState.A_from(identical(value, rightValue));
    } else if (rightOperand is DynamicState) {
      return UNKNOWN_VALUE;
    }
    return FALSE_STATE;
  }
  bool operator==(Object object) => object is BoolState && identical(value, object.value);
  bool get hasExactValue => true;
  int get hashCode => value == null ? 0 : (value ? 2 : 3);
  bool get isBool => true;
  bool get isBoolNumStringOrNull => true;
  bool get isUnknown => value == null;
  BoolState logicalAnd(InstanceState rightOperand) {
    assertBool(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return value ? rightOperand.convertToBool() : FALSE_STATE;
  }
  BoolState logicalNot() {
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return value ? FALSE_STATE : TRUE_STATE;
  }
  BoolState logicalOr(InstanceState rightOperand) {
    assertBool(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return value ? TRUE_STATE : rightOperand.convertToBool();
  }
  String toString() => value == null ? "-unknown-" : (value ? "true" : "false");
}
class ConstantFinder extends RecursiveAstVisitor<Object> {
  final A_p.HashMap<VariableElement, VariableDeclaration> variableMap = new A_p.HashMap<VariableElement,VariableDeclaration>();
  final A_p.HashMap<ConstructorElement, ConstructorDeclaration> constructorMap = new A_p.HashMap<ConstructorElement,ConstructorDeclaration>();
  final List<InstanceCreationExpression> constructorInvocations = new List<InstanceCreationExpression>();
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    super.visitConstructorDeclaration(node);
    if (node.constKeyword != null) {
      ConstructorElement A_element = node.element;
      if (A_element != null) {
        constructorMap[A_element] = node;
      }
    }
    return null;
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    super.visitInstanceCreationExpression(node);
    if (node.isConst) {
      constructorInvocations.add(node);
    }
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    super.visitVariableDeclaration(node);
    Expression initializer = node.initializer;
    if (initializer != null && node.isConst) {
      VariableElement A_element = node.element;
      if (A_element != null) {
        variableMap[A_element] = node;
      }
    }
    return null;
  }
}
class ConstantValueComputer {
  static String _DEFAULT_VALUE_PARAM = "defaultValue";
  static String _OPERATOR_RE = "(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)";
  static String _PUBLIC_IDENTIFIER_RE = "(?!${ConstantValueComputer._RESERVED_WORD_RE}\\b(?!\\\$))[a-zA-Z\$][\\w\$]*";
  static String _RESERVED_WORD_RE = "(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))";
  static RegExp _PUBLIC_SYMBOL_PATTERN = new RegExp("^(?:${ConstantValueComputer._OPERATOR_RE}\$|${_PUBLIC_IDENTIFIER_RE}(?:=?\$|[.](?!\$)))+?\$");
  static bool isValidPublicSymbol(String A_name) => A_name.isEmpty || A_name == "void" || new JavaPatternMatcher(_PUBLIC_SYMBOL_PATTERN, A_name).matches();
  TypeProvider typeProvider;
  ConstantFinder _constantFinder = new ConstantFinder();
  DirectedGraph<AstNode> referenceGraph = new DirectedGraph<AstNode>();
  A_p.HashMap<VariableElement, VariableDeclaration> _variableDeclarationMap;
  A_p.HashMap<ConstructorElement, ConstructorDeclaration> constructorDeclarationMap;
  List<InstanceCreationExpression> _constructorInvocations;
  final DeclaredVariables _declaredVariables;
  ConstantValueComputer(TypeProvider A_typeProvider, this._declaredVariables) {
    this.typeProvider = A_typeProvider;
  }
  void add(CompilationUnit unit) {
    unit.accept(_constantFinder);
  }
  void computeValues() {
    _variableDeclarationMap = _constantFinder.variableMap;
    constructorDeclarationMap = _constantFinder.constructorMap;
    _constructorInvocations = _constantFinder.constructorInvocations;
    for (MapEntry<VariableElement, VariableDeclaration> A_entry in getMapEntrySet(_variableDeclarationMap)) {
      VariableDeclaration declaration = A_entry.getValue();
      ReferenceFinder referenceFinder = new ReferenceFinder(declaration, referenceGraph, _variableDeclarationMap, constructorDeclarationMap);
      referenceGraph.addNode(declaration);
      declaration.initializer.accept(referenceFinder);
    }
    for (MapEntry<ConstructorElement, ConstructorDeclaration> A_entry in getMapEntrySet(constructorDeclarationMap)) {
      ConstructorDeclaration declaration = A_entry.getValue();
      ReferenceFinder referenceFinder = new ReferenceFinder(declaration, referenceGraph, _variableDeclarationMap, constructorDeclarationMap);
      referenceGraph.addNode(declaration);
      bool superInvocationFound = false;
      NodeList<ConstructorInitializer> initializers = declaration.initializers;
      for (ConstructorInitializer initializer in initializers) {
        if (initializer is SuperConstructorInvocation) {
          superInvocationFound = true;
        }
        initializer.accept(referenceFinder);
      }
      if (!superInvocationFound) {
        InterfaceType superclass = (A_entry.getKey().returnType as InterfaceType).superclass;
        if (superclass != null && !superclass.isObject) {
          ConstructorElement unnamedConstructor = superclass.element.unnamedConstructor;
          ConstructorDeclaration superConstructorDeclaration = findConstructorDeclaration(unnamedConstructor);
          if (superConstructorDeclaration != null) {
            referenceGraph.addEdge(declaration, superConstructorDeclaration);
          }
        }
      }
      for (FormalParameter parameter in declaration.parameters.parameters) {
        referenceGraph.addNode(parameter);
        referenceGraph.addEdge(declaration, parameter);
        if (parameter is DefaultFormalParameter) {
          Expression A_defaultValue = parameter.defaultValue;
          if (A_defaultValue != null) {
            ReferenceFinder parameterReferenceFinder = new ReferenceFinder(parameter, referenceGraph, _variableDeclarationMap, constructorDeclarationMap);
            A_defaultValue.accept(parameterReferenceFinder);
          }
        }
      }
    }
    for (InstanceCreationExpression expression in _constructorInvocations) {
      referenceGraph.addNode(expression);
      ConstructorElement constructor = expression.staticElement;
      if (constructor == null) {
        break;
      }
      constructor = _followConstantRedirectionChain(constructor);
      ConstructorDeclaration declaration = findConstructorDeclaration(constructor);
      ReferenceFinder referenceFinder = new ReferenceFinder(expression, referenceGraph, _variableDeclarationMap, constructorDeclarationMap);
      if (declaration != null) {
        referenceGraph.addEdge(expression, declaration);
      }
      expression.argumentList.accept(referenceFinder);
    }
    List<List<AstNode>> topologicalSort = referenceGraph.computeTopologicalSort();
    for (List<AstNode> constantsInCycle in topologicalSort) {
      if (constantsInCycle.length == 1) {
        _computeValueFor(constantsInCycle[0]);
      } else {
        for (AstNode constant in constantsInCycle) {
          _generateCycleError(constantsInCycle, constant);
        }
      }
    }
  }
  void beforeComputeValue(AstNode constNode) {}
  void beforeGetConstantInitializers(ConstructorElement constructor) {}
  void beforeGetParameterDefault(ParameterElement parameter) {}
  ConstantVisitor createConstantVisitor() => new ConstantVisitor.A_con1(typeProvider);
  ConstructorDeclaration findConstructorDeclaration(ConstructorElement constructor) => constructorDeclarationMap[_getConstructorBase(constructor)];
  bool _checkFromEnvironmentArguments(NodeList<Expression> A_arguments, List<DartObjectImpl> argumentValues, A_p.HashMap<String, DartObjectImpl> namedArgumentValues, InterfaceType expectedDefaultValueType) {
    int argumentCount = A_arguments.length;
    if (argumentCount < 1 || argumentCount > 2) {
      return false;
    }
    if (A_arguments[0] is NamedExpression) {
      return false;
    }
    if (!identical(argumentValues[0].type, typeProvider.stringType)) {
      return false;
    }
    if (argumentCount == 2) {
      if (A_arguments[1] is! NamedExpression) {
        return false;
      }
      if (!((A_arguments[1] as NamedExpression).name.label.name == _DEFAULT_VALUE_PARAM)) {
        return false;
      }
      InterfaceType defaultValueType = namedArgumentValues[_DEFAULT_VALUE_PARAM].type;
      if (!(identical(defaultValueType, expectedDefaultValueType) || identical(defaultValueType, typeProvider.nullType))) {
        return false;
      }
    }
    return true;
  }
  bool _checkSymbolArguments(NodeList<Expression> A_arguments, List<DartObjectImpl> argumentValues, A_p.HashMap<String, DartObjectImpl> namedArgumentValues) {
    if (A_arguments.length != 1) {
      return false;
    }
    if (A_arguments[0] is NamedExpression) {
      return false;
    }
    if (!identical(argumentValues[0].type, typeProvider.stringType)) {
      return false;
    }
    String A_name = argumentValues[0].stringValue;
    return isValidPublicSymbol(A_name);
  }
  void _computeValueFor(AstNode constNode) {
    beforeComputeValue(constNode);
    if (constNode is VariableDeclaration) {
      VariableDeclaration declaration = constNode;
      A_Element A_element = declaration.element;
      EvaluationResultImpl result = declaration.initializer.accept(createConstantVisitor());
      (A_element as VariableElementImpl).evaluationResult = result;
    } else if (constNode is InstanceCreationExpression) {
      InstanceCreationExpression expression = constNode;
      ConstructorElement constructor = expression.staticElement;
      if (constructor == null) {
        return;
      }
      ConstantVisitor constantVisitor = createConstantVisitor();
      EvaluationResultImpl result = _evaluateConstructorCall(constNode, expression.argumentList.arguments, constructor, constantVisitor);
      expression.evaluationResult = result;
    } else if (constNode is ConstructorDeclaration) {
      ConstructorDeclaration declaration = constNode;
      NodeList<ConstructorInitializer> initializers = declaration.initializers;
      ConstructorElementImpl constructor = declaration.element as ConstructorElementImpl;
      constructor.constantInitializers = new ConstantValueComputer_InitializerCloner().cloneNodeList(initializers);
    } else if (constNode is FormalParameter) {
      if (constNode is DefaultFormalParameter) {
        DefaultFormalParameter parameter = constNode;
        ParameterElement A_element = parameter.element;
        Expression A_defaultValue = parameter.defaultValue;
        if (A_defaultValue != null) {
          EvaluationResultImpl result = A_defaultValue.accept(createConstantVisitor());
          (A_element as ParameterElementImpl).evaluationResult = result;
        }
      }
    } else {
      AnalysisEngine.A_instance.logger.logError("Constant value computer trying to compute the value of a node which is not a VariableDeclaration, InstanceCreationExpression, FormalParameter, or ConstructorDeclaration");
      return;
    }
  }
  ValidResult _computeValueFromEnvironment(DartObject environmentValue, DartObjectImpl builtInDefaultValue, A_p.HashMap<String, DartObjectImpl> namedArgumentValues) {
    DartObjectImpl A_value = environmentValue as DartObjectImpl;
    if (A_value.isUnknown || A_value.isNull) {
      if (namedArgumentValues.containsKey(_DEFAULT_VALUE_PARAM)) {
        A_value = namedArgumentValues[_DEFAULT_VALUE_PARAM];
      } else if (A_value.isNull) {
        A_value = builtInDefaultValue;
      } else {}
    }
    return new ValidResult(A_value);
  }
  EvaluationResultImpl _evaluateConstructorCall(AstNode node, NodeList<Expression> A_arguments, ConstructorElement constructor, ConstantVisitor constantVisitor) {
    int argumentCount = A_arguments.length;
    List<DartObjectImpl> argumentValues = new List<DartObjectImpl>(argumentCount);
    A_p.HashMap<String, DartObjectImpl> namedArgumentValues = new A_p.HashMap<String,DartObjectImpl>();
    for (int i = 0; i < argumentCount; i++) {
      Expression argument = A_arguments[i];
      if (argument is NamedExpression) {
        NamedExpression namedExpression = argument;
        String A_name = namedExpression.name.label.name;
        namedArgumentValues[A_name] = constantVisitor._valueOf(namedExpression.expression);
        argumentValues[i] = constantVisitor.null2;
      } else {
        argumentValues[i] = constantVisitor._valueOf(argument);
      }
    }
    constructor = _followConstantRedirectionChain(constructor);
    InterfaceType definingClass = constructor.returnType as InterfaceType;
    if (constructor.isFactory) {
      if (constructor.name == "fromEnvironment") {
        if (!_checkFromEnvironmentArguments(A_arguments, argumentValues, namedArgumentValues, definingClass)) {
          return new ErrorResult.A_con1(node, CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
        }
        String A_variableName = argumentCount < 1 ? null : argumentValues[0].stringValue;
        if (identical(definingClass, typeProvider.boolType)) {
          DartObject valueFromEnvironment;
          valueFromEnvironment = _declaredVariables.getBool(typeProvider, A_variableName);
          return _computeValueFromEnvironment(valueFromEnvironment, new DartObjectImpl(typeProvider.boolType, BoolState.FALSE_STATE), namedArgumentValues);
        } else if (identical(definingClass, typeProvider.intType)) {
          DartObject valueFromEnvironment;
          valueFromEnvironment = _declaredVariables.getInt(typeProvider, A_variableName);
          return _computeValueFromEnvironment(valueFromEnvironment, new DartObjectImpl(typeProvider.nullType, NullState.NULL_STATE), namedArgumentValues);
        } else if (identical(definingClass, typeProvider.stringType)) {
          DartObject valueFromEnvironment;
          valueFromEnvironment = _declaredVariables.getString(typeProvider, A_variableName);
          return _computeValueFromEnvironment(valueFromEnvironment, new DartObjectImpl(typeProvider.nullType, NullState.NULL_STATE), namedArgumentValues);
        }
      } else if (constructor.name == "" && identical(definingClass, typeProvider.symbolType) && argumentCount == 1) {
        if (!_checkSymbolArguments(A_arguments, argumentValues, namedArgumentValues)) {
          return new ErrorResult.A_con1(node, CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
        }
        String argumentValue = argumentValues[0].stringValue;
        return constantVisitor._valid(definingClass, new SymbolState(argumentValue));
      }
      return constantVisitor._validWithUnknownValue(definingClass);
    }
    beforeGetConstantInitializers(constructor);
    ConstructorElementImpl constructorBase = _getConstructorBase(constructor) as ConstructorElementImpl;
    List<ConstructorInitializer> initializers = constructorBase.constantInitializers;
    if (initializers == null) {
      return constantVisitor._validWithUnknownValue(definingClass);
    }
    A_p.HashMap<String, DartObjectImpl> fieldMap = new A_p.HashMap<String,DartObjectImpl>();
    A_p.HashMap<String, DartObjectImpl> parameterMap = new A_p.HashMap<String,DartObjectImpl>();
    List<ParameterElement> A_parameters = constructorBase.parameters;
    int parameterCount = A_parameters.length;
    for (int i = 0; i < parameterCount; i++) {
      ParameterElement parameter = A_parameters[i];
      while (parameter is ParameterMember) {
        parameter = (parameter as ParameterMember).baseElement;
      }
      DartObjectImpl argumentValue = null;
      if (parameter.parameterKind == ParameterKind.NAMED) {
        argumentValue = namedArgumentValues[parameter.name];
      } else if (i < argumentCount) {
        argumentValue = argumentValues[i];
      }
      if (argumentValue == null && parameter is ParameterElementImpl) {
        beforeGetParameterDefault(parameter);
        EvaluationResultImpl evaluationResult = (parameter as ParameterElementImpl).evaluationResult;
        if (evaluationResult is ValidResult) {
          argumentValue = evaluationResult.value;
        } else if (evaluationResult == null) {
          argumentValue = constantVisitor.null2;
        }
      }
      if (argumentValue != null) {
        if (parameter.isInitializingFormal) {
          FieldElement field = (parameter as FieldFormalParameterElement).field;
          if (field != null) {
            String fieldName = field.name;
            fieldMap[fieldName] = argumentValue;
          }
        } else {
          String A_name = parameter.name;
          parameterMap[A_name] = argumentValue;
        }
      }
    }
    ConstantVisitor initializerVisitor = new ConstantVisitor.A_con2(typeProvider, parameterMap);
    String superName = null;
    NodeList<Expression> superArguments = null;
    for (ConstructorInitializer initializer in initializers) {
      if (initializer is ConstructorFieldInitializer) {
        ConstructorFieldInitializer constructorFieldInitializer = initializer;
        Expression initializerExpression = constructorFieldInitializer.expression;
        EvaluationResultImpl evaluationResult = initializerExpression.accept(initializerVisitor);
        if (evaluationResult is ValidResult) {
          DartObjectImpl A_value = evaluationResult.value;
          String fieldName = constructorFieldInitializer.fieldName.name;
          fieldMap[fieldName] = A_value;
        }
      } else if (initializer is SuperConstructorInvocation) {
        SuperConstructorInvocation superConstructorInvocation = initializer;
        SimpleIdentifier A_name = superConstructorInvocation.constructorName;
        if (A_name != null) {
          superName = A_name.name;
        }
        superArguments = superConstructorInvocation.argumentList.arguments;
      }
    }
    InterfaceType superclass = definingClass.superclass;
    if (superclass != null && !superclass.isObject) {
      ConstructorElement superConstructor = superclass.lookUpConstructor(superName, constructor.library);
      if (superConstructor != null) {
        if (superArguments == null) {
          superArguments = new NodeList<Expression>(null);
        }
        _evaluateSuperConstructorCall(node, fieldMap, superConstructor, superArguments, initializerVisitor);
      }
    }
    return constantVisitor._valid(definingClass, new GenericState(fieldMap));
  }
  void _evaluateSuperConstructorCall(AstNode node, A_p.HashMap<String, DartObjectImpl> fieldMap, ConstructorElement superConstructor, NodeList<Expression> superArguments, ConstantVisitor initializerVisitor) {
    if (superConstructor != null && superConstructor.isConst) {
      EvaluationResultImpl evaluationResult = _evaluateConstructorCall(node, superArguments, superConstructor, initializerVisitor);
      if (evaluationResult is ValidResult) {
        ValidResult validResult = evaluationResult;
        fieldMap[GenericState.SUPERCLASS_FIELD] = validResult.value;
      }
    }
  }
  ConstructorElement _followConstantRedirectionChain(ConstructorElement constructor) {
    A_p.HashSet<ConstructorElement> constructorsVisited = new A_p.HashSet<ConstructorElement>();
    while (constructor.isFactory) {
      if (identical(constructor.enclosingElement.type, typeProvider.symbolType)) {
        break;
      }
      constructorsVisited.add(constructor);
      ConstructorElement redirectedConstructor = constructor.redirectedConstructor;
      if (redirectedConstructor == null) {
        break;
      }
      if (!redirectedConstructor.isConst) {
        break;
      }
      if (constructorsVisited.contains(redirectedConstructor)) {
        break;
      }
      constructor = redirectedConstructor;
    }
    return constructor;
  }
  void _generateCycleError(List<AstNode> constantsInCycle, AstNode constant) {}
  ConstructorElement _getConstructorBase(ConstructorElement constructor) {
    while (constructor is ConstructorMember) {
      constructor = (constructor as ConstructorMember).baseElement;
    }
    return constructor;
  }
}
class ConstantValueComputer_InitializerCloner extends AstCloner {
  InstanceCreationExpression visitInstanceCreationExpression(InstanceCreationExpression node) {
    InstanceCreationExpression expression = new InstanceCreationExpression(node.keyword, null, null);
    expression.evaluationResult = node.evaluationResult;
    return expression;
  }
  SimpleIdentifier visitSimpleIdentifier(SimpleIdentifier node) {
    SimpleIdentifier identifier = super.visitSimpleIdentifier(node);
    identifier.staticElement = node.staticElement;
    return identifier;
  }
  SuperConstructorInvocation visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    SuperConstructorInvocation invocation = super.visitSuperConstructorInvocation(node);
    invocation.staticElement = node.staticElement;
    return invocation;
  }
}
class ConstantVisitor extends UnifyingAstVisitor<EvaluationResultImpl> {
  final TypeProvider _typeProvider;
  DartObjectImpl _nullObject;
  A_p.HashMap<String, DartObjectImpl> _lexicalEnvironment;
  ConstantVisitor.A_con1(this._typeProvider) {
    this._lexicalEnvironment = null;
  }
  ConstantVisitor.A_con2(this._typeProvider, A_p.HashMap<String, DartObjectImpl> lexicalEnvironment) {
    this._lexicalEnvironment = lexicalEnvironment;
  }
  EvaluationResultImpl visitAdjacentStrings(AdjacentStrings node) {
    EvaluationResultImpl result = null;
    for (StringLiteral A_string in node.strings) {
      if (result == null) {
        result = A_string.accept(this);
      } else {
        result = result.concatenate(_typeProvider, node, A_string.accept(this));
      }
    }
    return result;
  }
  EvaluationResultImpl visitBinaryExpression(BinaryExpression node) {
    EvaluationResultImpl leftResult = node.leftOperand.accept(this);
    EvaluationResultImpl rightResult = node.rightOperand.accept(this);
    A_TokenType operatorType = node.operator.type;
    if (operatorType != A_TokenType.BANG_EQ && operatorType != A_TokenType.EQ_EQ) {
      if (leftResult is ValidResult && leftResult.isNull || rightResult is ValidResult && rightResult.isNull) {
        return B__error(node, CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
      }
    }
    while (true) {
      if (operatorType == A_TokenType.A_AMPERSAND) {
        return leftResult.bitAnd(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.AMPERSAND_AMPERSAND) {
        return leftResult.logicalAnd(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.BANG_EQ) {
        return leftResult.notEqual(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.BAR) {
        return leftResult.bitOr(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.BAR_BAR) {
        return leftResult.logicalOr(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.CARET) {
        return leftResult.bitXor(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.EQ_EQ) {
        return leftResult.equalEqual(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.A_GT) {
        return leftResult.greaterThan(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.GT_EQ) {
        return leftResult.greaterThanOrEqual(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.GT_GT) {
        return leftResult.shiftRight(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.A_LT) {
        return leftResult.lessThan(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.LT_EQ) {
        return leftResult.lessThanOrEqual(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.LT_LT) {
        return leftResult.shiftLeft(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.MINUS) {
        return leftResult.minus(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.PERCENT) {
        return leftResult.remainder(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.PLUS) {
        return leftResult.add(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.STAR) {
        return leftResult.times(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.A_SLASH) {
        return leftResult.divide(_typeProvider, node, rightResult);
      } else if (operatorType == A_TokenType.TILDE_SLASH) {
        return leftResult.integerDivide(_typeProvider, node, rightResult);
      } else {
        return B__error(node, null);
      }
      break;
    }
  }
  EvaluationResultImpl visitBooleanLiteral(BooleanLiteral node) => _valid(_typeProvider.boolType, BoolState.A_from(node.value));
  EvaluationResultImpl visitConditionalExpression(ConditionalExpression node) {
    Expression condition = node.condition;
    EvaluationResultImpl conditionResult = condition.accept(this);
    EvaluationResultImpl thenResult = node.thenExpression.accept(this);
    EvaluationResultImpl elseResult = node.elseExpression.accept(this);
    if (conditionResult is ErrorResult) {
      return _union(_union(conditionResult as ErrorResult, thenResult), elseResult);
    } else if (!(conditionResult as ValidResult).isBool) {
      return new ErrorResult.A_con1(condition, CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL);
    } else if (thenResult is ErrorResult) {
      return _union(thenResult, elseResult);
    } else if (elseResult is ErrorResult) {
      return elseResult;
    }
    conditionResult = conditionResult.applyBooleanConversion(_typeProvider, condition);
    if (conditionResult is ErrorResult) {
      return conditionResult;
    }
    ValidResult validResult = conditionResult as ValidResult;
    if (validResult.isTrue) {
      return thenResult;
    } else if (validResult.isFalse) {
      return elseResult;
    }
    InterfaceType thenType = (thenResult as ValidResult).value.type;
    InterfaceType elseType = (elseResult as ValidResult).value.type;
    return _validWithUnknownValue(thenType.getLeastUpperBound(elseType) as InterfaceType);
  }
  EvaluationResultImpl visitDoubleLiteral(DoubleLiteral node) => _valid(_typeProvider.doubleType, new DoubleState(node.value));
  EvaluationResultImpl visitInstanceCreationExpression(InstanceCreationExpression node) {
    if (!node.isConst) {
      return B__error(node, null);
    }
    beforeGetEvaluationResult(node);
    EvaluationResultImpl result = node.evaluationResult;
    if (result != null) {
      return result;
    }
    return B__error(node, null);
  }
  EvaluationResultImpl visitIntegerLiteral(IntegerLiteral node) => _valid(_typeProvider.intType, new IntState(node.value));
  EvaluationResultImpl visitInterpolationExpression(InterpolationExpression node) {
    EvaluationResultImpl result = node.expression.accept(this);
    if (result is ValidResult && !result.isBoolNumStringOrNull) {
      return B__error(node, CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING);
    }
    return result.performToString(_typeProvider, node);
  }
  EvaluationResultImpl visitInterpolationString(InterpolationString node) => _valid(_typeProvider.stringType, new StringState(node.value));
  EvaluationResultImpl visitListLiteral(ListLiteral node) {
    if (node.constKeyword == null) {
      return new ErrorResult.A_con1(node, CompileTimeErrorCode.MISSING_CONST_IN_LIST_LITERAL);
    }
    ErrorResult result = null;
    List<DartObjectImpl> elements = new List<DartObjectImpl>();
    for (Expression A_element in node.elements) {
      EvaluationResultImpl elementResult = A_element.accept(this);
      result = _union(result, elementResult);
      if (elementResult is ValidResult) {
        elements.add(elementResult.value);
      }
    }
    if (result != null) {
      return result;
    }
    return _valid(_typeProvider.listType, new ListState(new List.from(elements)));
  }
  EvaluationResultImpl visitMapLiteral(MapLiteral node) {
    if (node.constKeyword == null) {
      return new ErrorResult.A_con1(node, CompileTimeErrorCode.MISSING_CONST_IN_MAP_LITERAL);
    }
    ErrorResult result = null;
    A_p.HashMap<DartObjectImpl, DartObjectImpl> A_map = new A_p.HashMap<DartObjectImpl,DartObjectImpl>();
    for (MapLiteralEntry A_entry in node.entries) {
      EvaluationResultImpl keyResult = A_entry.key.accept(this);
      EvaluationResultImpl valueResult = A_entry.value.accept(this);
      result = _union(result, keyResult);
      result = _union(result, valueResult);
      if (keyResult is ValidResult && valueResult is ValidResult) {
        A_map[keyResult.value] = valueResult.value;
      }
    }
    if (result != null) {
      return result;
    }
    return _valid(_typeProvider.mapType, new MapState(A_map));
  }
  EvaluationResultImpl visitMethodInvocation(MethodInvocation node) {
    A_Element A_element = node.methodName.staticElement;
    if (A_element is FunctionElement) {
      FunctionElement A_function = A_element;
      if (A_function.name == "identical") {
        NodeList<Expression> A_arguments = node.argumentList.arguments;
        if (A_arguments.length == 2) {
          A_Element enclosingElement = A_function.enclosingElement;
          if (enclosingElement is CompilationUnitElement) {
            LibraryElement library = enclosingElement.library;
            if (library.isDartCore) {
              EvaluationResultImpl leftArgument = A_arguments[0].accept(this);
              EvaluationResultImpl rightArgument = A_arguments[1].accept(this);
              return leftArgument.equalEqual(_typeProvider, node, rightArgument);
            }
          }
        }
      }
    }
    return B__error(node, null);
  }
  EvaluationResultImpl visitNamedExpression(NamedExpression node) => node.expression.accept(this);
  EvaluationResultImpl visitNode(AstNode node) => B__error(node, null);
  EvaluationResultImpl visitNullLiteral(NullLiteral node) => new ValidResult(null2);
  EvaluationResultImpl visitParenthesizedExpression(ParenthesizedExpression node) => node.expression.accept(this);
  EvaluationResultImpl visitPrefixedIdentifier(PrefixedIdentifier node) {
    SimpleIdentifier prefixNode = node.prefix;
    A_Element prefixElement = prefixNode.staticElement;
    if (prefixElement is! PrefixElement) {
      EvaluationResultImpl prefixResult = prefixNode.accept(this);
      if (prefixResult is! ValidResult) {
        return B__error(node, null);
      }
    }
    return _getConstantValue(node, node.staticElement);
  }
  EvaluationResultImpl visitPrefixExpression(PrefixExpression node) {
    EvaluationResultImpl operand = node.operand.accept(this);
    if (operand is ValidResult && operand.isNull) {
      return B__error(node, CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
    }
    while (true) {
      if (node.operator.type == A_TokenType.BANG) {
        return operand.logicalNot(_typeProvider, node);
      } else if (node.operator.type == A_TokenType.TILDE) {
        return operand.bitNot(_typeProvider, node);
      } else if (node.operator.type == A_TokenType.MINUS) {
        return operand.negated(_typeProvider, node);
      } else {
        return B__error(node, null);
      }
      break;
    }
  }
  EvaluationResultImpl visitPropertyAccess(PropertyAccess node) => _getConstantValue(node, node.propertyName.staticElement);
  EvaluationResultImpl visitSimpleIdentifier(SimpleIdentifier node) {
    if (_lexicalEnvironment != null && _lexicalEnvironment.containsKey(node.name)) {
      return new ValidResult(_lexicalEnvironment[node.name]);
    }
    return _getConstantValue(node, node.staticElement);
  }
  EvaluationResultImpl visitSimpleStringLiteral(SimpleStringLiteral node) => _valid(_typeProvider.stringType, new StringState(node.value));
  EvaluationResultImpl visitStringInterpolation(StringInterpolation node) {
    EvaluationResultImpl result = null;
    for (InterpolationElement A_element in node.elements) {
      if (result == null) {
        result = A_element.accept(this);
      } else {
        result = result.concatenate(_typeProvider, node, A_element.accept(this));
      }
    }
    return result;
  }
  EvaluationResultImpl visitSymbolLiteral(SymbolLiteral node) {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    List<A_Token> components = node.components;
    for (int i = 0; i < components.length; i++) {
      if (i > 0) {
        A_builder.appendChar(0x2E);
      }
      A_builder.append(components[i].lexeme);
    }
    return _valid(_typeProvider.symbolType, new SymbolState(A_builder.toString()));
  }
  void beforeGetEvaluationResult(AstNode node) {}
  DartObjectImpl get null2 {
    if (_nullObject == null) {
      _nullObject = new DartObjectImpl(_typeProvider.nullType, NullState.NULL_STATE);
    }
    return _nullObject;
  }
  ValidResult _valid(InterfaceType A_type, InstanceState state) => new ValidResult(new DartObjectImpl(A_type, state));
  ValidResult _validWithUnknownValue(InterfaceType A_type) {
    if (A_type.element.library.isDartCore) {
      String typeName = A_type.name;
      if (typeName == "bool") {
        return _valid(A_type, BoolState.UNKNOWN_VALUE);
      } else if (typeName == "double") {
        return _valid(A_type, DoubleState.UNKNOWN_VALUE);
      } else if (typeName == "int") {
        return _valid(A_type, IntState.UNKNOWN_VALUE);
      } else if (typeName == "String") {
        return _valid(A_type, StringState.UNKNOWN_VALUE);
      }
    }
    return _valid(A_type, GenericState.UNKNOWN_VALUE);
  }
  DartObjectImpl _valueOf(Expression expression) {
    EvaluationResultImpl expressionValue = expression.accept(this);
    if (expressionValue is ValidResult) {
      return expressionValue.value;
    }
    return null2;
  }
  ErrorResult B__error(AstNode node, ErrorCode A_code) => new ErrorResult.A_con1(node, A_code == null ? CompileTimeErrorCode.INVALID_CONSTANT : A_code);
  EvaluationResultImpl _getConstantValue(AstNode node, A_Element A_element) {
    if (A_element is PropertyAccessorElement) {
      A_element = (A_element as PropertyAccessorElement).variable;
    }
    if (A_element is VariableElementImpl) {
      VariableElementImpl variableElementImpl = A_element;
      beforeGetEvaluationResult(node);
      EvaluationResultImpl A_value = variableElementImpl.evaluationResult;
      if (variableElementImpl.isConst && A_value != null) {
        return A_value;
      }
    } else if (A_element is ExecutableElement) {
      ExecutableElement A_function = A_element;
      if (A_function.isStatic) {
        return _valid(_typeProvider.functionType, new FunctionState(A_function));
      }
    } else if (A_element is ClassElement || A_element is FunctionTypeAliasElement) {
      return _valid(_typeProvider.typeType, new TypeState(A_element));
    }
    return B__error(node, null);
  }
  ErrorResult _union(ErrorResult leftResult, EvaluationResultImpl rightResult) {
    if (rightResult is ErrorResult) {
      if (leftResult != null) {
        return new ErrorResult.A_con2(leftResult, rightResult);
      } else {
        return rightResult;
      }
    }
    return leftResult;
  }
}
abstract class DartObject {
  String get stringValue;
  InterfaceType get type;
  Object get value;
  bool get hasExactValue;
  bool get isFalse;
  bool get isNull;
  bool get isTrue;
}
class DartObjectImpl implements DartObject {
  final InterfaceType type;
  final InstanceState A__state;
  DartObjectImpl(this.type, this.A__state);
  DartObjectImpl add(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    InstanceState result = A__state.add(rightOperand.A__state);
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("add returned a ${result.runtimeType.toString()}");
  }
  DartObjectImpl bitAnd(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.bitAnd(rightOperand.A__state));
  DartObjectImpl bitNot(TypeProvider typeProvider) => new DartObjectImpl(typeProvider.intType, A__state.bitNot());
  DartObjectImpl bitOr(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.bitOr(rightOperand.A__state));
  DartObjectImpl bitXor(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.bitXor(rightOperand.A__state));
  DartObjectImpl concatenate(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.stringType, A__state.concatenate(rightOperand.A__state));
  DartObjectImpl convertToBool(TypeProvider typeProvider) {
    InterfaceType boolType = typeProvider.boolType;
    if (identical(type, boolType)) {
      return this;
    }
    return new DartObjectImpl(boolType, A__state.convertToBool());
  }
  DartObjectImpl divide(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    InstanceState result = A__state.divide(rightOperand.A__state);
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("divide returned a ${result.runtimeType.toString()}");
  }
  DartObjectImpl equalEqual(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    if (type != rightOperand.type) {
      String typeName = type.name;
      if (!(typeName == "bool" || typeName == "double" || typeName == "int" || typeName == "num" || typeName == "String" || typeName == "Null" || type.isDynamic)) {
        throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING);
      }
    }
    return new DartObjectImpl(typeProvider.boolType, A__state.equalEqual(rightOperand.A__state));
  }
  bool operator==(Object object) {
    if (object is! DartObjectImpl) {
      return false;
    }
    DartObjectImpl dartObject = object as DartObjectImpl;
    return type == dartObject.type && A__state == dartObject.A__state;
  }
  A_p.HashMap<String, DartObjectImpl> get fields => A__state.fields;
  String get stringValue {
    if (A__state is StringState) {
      return (A__state as StringState).value;
    }
    return null;
  }
  Object get value => A__state.value;
  DartObjectImpl greaterThan(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.greaterThan(rightOperand.A__state));
  DartObjectImpl greaterThanOrEqual(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.greaterThanOrEqual(rightOperand.A__state));
  bool get hasExactValue => A__state.hasExactValue;
  int get hashCode => ObjectUtilities.combineHashCodes(type.hashCode, A__state.hashCode);
  DartObjectImpl integerDivide(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.integerDivide(rightOperand.A__state));
  bool get isBool => A__state.isBool;
  bool get isBoolNumStringOrNull => A__state.isBoolNumStringOrNull;
  bool get isFalse => A__state is BoolState && identical((A__state as BoolState).value, false);
  bool get isNull => A__state is NullState;
  bool get isTrue => A__state is BoolState && identical((A__state as BoolState).value, true);
  bool get isUnknown => A__state.isUnknown;
  bool get isUserDefinedObject => A__state is GenericState;
  DartObjectImpl lessThan(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.lessThan(rightOperand.A__state));
  DartObjectImpl lessThanOrEqual(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.lessThanOrEqual(rightOperand.A__state));
  DartObjectImpl logicalAnd(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.logicalAnd(rightOperand.A__state));
  DartObjectImpl logicalNot(TypeProvider typeProvider) => new DartObjectImpl(typeProvider.boolType, A__state.logicalNot());
  DartObjectImpl logicalOr(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.boolType, A__state.logicalOr(rightOperand.A__state));
  DartObjectImpl minus(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    InstanceState result = A__state.minus(rightOperand.A__state);
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("minus returned a ${result.runtimeType.toString()}");
  }
  DartObjectImpl negated(TypeProvider typeProvider) {
    InstanceState result = A__state.negated();
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("negated returned a ${result.runtimeType.toString()}");
  }
  DartObjectImpl notEqual(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    if (type != rightOperand.type) {
      String typeName = type.name;
      if (typeName != "bool" && typeName != "double" && typeName != "int" && typeName != "num" && typeName != "String") {
        return new DartObjectImpl(typeProvider.boolType, BoolState.TRUE_STATE);
      }
    }
    return new DartObjectImpl(typeProvider.boolType, A__state.equalEqual(rightOperand.A__state).logicalNot());
  }
  DartObjectImpl performToString(TypeProvider typeProvider) {
    InterfaceType stringType = typeProvider.stringType;
    if (identical(type, stringType)) {
      return this;
    }
    return new DartObjectImpl(stringType, A__state.convertToString());
  }
  DartObjectImpl remainder(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    InstanceState result = A__state.remainder(rightOperand.A__state);
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("remainder returned a ${result.runtimeType.toString()}");
  }
  DartObjectImpl shiftLeft(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.shiftLeft(rightOperand.A__state));
  DartObjectImpl shiftRight(TypeProvider typeProvider, DartObjectImpl rightOperand) => new DartObjectImpl(typeProvider.intType, A__state.shiftRight(rightOperand.A__state));
  DartObjectImpl times(TypeProvider typeProvider, DartObjectImpl rightOperand) {
    InstanceState result = A__state.times(rightOperand.A__state);
    if (result is IntState) {
      return new DartObjectImpl(typeProvider.intType, result);
    } else if (result is DoubleState) {
      return new DartObjectImpl(typeProvider.doubleType, result);
    } else if (result is NumState) {
      return new DartObjectImpl(typeProvider.numType, result);
    }
    throw new IllegalStateException("times returned a ${result.runtimeType.toString()}");
  }
  String toString() => "${type.displayName} (${A__state.toString()})";
}
class DeclaredVariables {
  A_p.HashMap<String, String> _declaredVariables = new A_p.HashMap<String,String>();
  DartObject getBool(TypeProvider typeProvider, String A_variableName) {
    String A_value = _declaredVariables[A_variableName];
    if (A_value == null) {
      return new DartObjectImpl(typeProvider.boolType, BoolState.UNKNOWN_VALUE);
    }
    if (A_value == "true") {
      return new DartObjectImpl(typeProvider.boolType, BoolState.TRUE_STATE);
    } else if (A_value == "false") {
      return new DartObjectImpl(typeProvider.boolType, BoolState.FALSE_STATE);
    }
    return new DartObjectImpl(typeProvider.nullType, NullState.NULL_STATE);
  }
  DartObject getInt(TypeProvider typeProvider, String A_variableName) {
    String A_value = _declaredVariables[A_variableName];
    if (A_value == null) {
      return new DartObjectImpl(typeProvider.intType, IntState.UNKNOWN_VALUE);
    }
    int bigInteger;
    try {
      bigInteger = int.parse(A_value);
    }on FormatException  catch (exception) {
      return new DartObjectImpl(typeProvider.nullType, NullState.NULL_STATE);
    }
    return new DartObjectImpl(typeProvider.intType, new IntState(bigInteger));
  }
  DartObject getString(TypeProvider typeProvider, String A_variableName) {
    String A_value = _declaredVariables[A_variableName];
    if (A_value == null) {
      return new DartObjectImpl(typeProvider.intType, IntState.UNKNOWN_VALUE);
    }
    return new DartObjectImpl(typeProvider.stringType, new StringState(A_value));
  }
}
class DoubleState extends NumState {
  final double value;
  static DoubleState UNKNOWN_VALUE = new DoubleState(null);
  DoubleState(this.value);
  NumState add(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value + rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value + rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  StringState convertToString() {
    if (value == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(value.toString());
  }
  NumState divide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value / rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value / rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value == rightValue);
    } else if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value == rightValue.toDouble());
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  bool operator==(Object object) => object is DoubleState && (value == object.value);
  BoolState greaterThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value > rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value > rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState greaterThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value >= rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value >= rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  bool get hasExactValue => true;
  int get hashCode => value == null ? 0 : value.hashCode;
  IntState integerDivide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return IntState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return IntState.UNKNOWN_VALUE;
      }
      double result = value / rightValue.toDouble();
      return new IntState(result.toInt());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return IntState.UNKNOWN_VALUE;
      }
      double result = value / rightValue;
      return new IntState(result.toInt());
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return IntState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  bool get isBoolNumStringOrNull => true;
  bool get isUnknown => value == null;
  BoolState lessThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value < rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value < rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState lessThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value <= rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value <= rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState minus(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value - rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value - rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState negated() {
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return new DoubleState(-(value));
  }
  NumState remainder(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value % rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value % rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState times(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value * rightValue.toDouble());
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new DoubleState(value * rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  String toString() => value == null ? "-unknown-" : value.toString();
}
class DynamicState extends InstanceState {
  static DynamicState DYNAMIC_STATE = new DynamicState();
  NumState add(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return _unknownNum(rightOperand);
  }
  IntState bitAnd(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  IntState bitNot() => IntState.UNKNOWN_VALUE;
  IntState bitOr(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  IntState bitXor(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  StringState concatenate(InstanceState rightOperand) {
    assertString(rightOperand);
    return StringState.UNKNOWN_VALUE;
  }
  BoolState convertToBool() => BoolState.UNKNOWN_VALUE;
  StringState convertToString() => StringState.UNKNOWN_VALUE;
  NumState divide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return _unknownNum(rightOperand);
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState greaterThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState greaterThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  IntState integerDivide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  bool get isBool => true;
  bool get isBoolNumStringOrNull => true;
  BoolState lessThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState lessThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState logicalAnd(InstanceState rightOperand) {
    assertBool(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState logicalNot() => BoolState.UNKNOWN_VALUE;
  BoolState logicalOr(InstanceState rightOperand) {
    assertBool(rightOperand);
    return rightOperand.convertToBool();
  }
  NumState minus(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return _unknownNum(rightOperand);
  }
  NumState negated() => NumState.UNKNOWN_VALUE;
  NumState remainder(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return _unknownNum(rightOperand);
  }
  IntState shiftLeft(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  IntState shiftRight(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    return IntState.UNKNOWN_VALUE;
  }
  NumState times(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return _unknownNum(rightOperand);
  }
  NumState _unknownNum(InstanceState rightOperand) {
    if (rightOperand is IntState) {
      return IntState.UNKNOWN_VALUE;
    } else if (rightOperand is DoubleState) {
      return DoubleState.UNKNOWN_VALUE;
    }
    return NumState.UNKNOWN_VALUE;
  }
}
class ErrorResult extends EvaluationResultImpl {
  List<ErrorResult_ErrorData> _errors = new List<ErrorResult_ErrorData>();
  ErrorResult.A_con1(AstNode node, ErrorCode A_errorCode) {
    _errors.add(new ErrorResult_ErrorData(node, A_errorCode));
  }
  ErrorResult.A_con2(ErrorResult firstResult, ErrorResult secondResult) {
    _errors.addAll(firstResult._errors);
    _errors.addAll(secondResult._errors);
  }
  EvaluationResultImpl add(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.addToError(node, this);
  EvaluationResultImpl applyBooleanConversion(TypeProvider typeProvider, AstNode node) => this;
  EvaluationResultImpl bitAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitAndError(node, this);
  EvaluationResultImpl bitNot(TypeProvider typeProvider, Expression node) => this;
  EvaluationResultImpl bitOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitOrError(node, this);
  EvaluationResultImpl bitXor(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitXorError(node, this);
  EvaluationResultImpl concatenate(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand) => rightOperand.concatenateError(node, this);
  EvaluationResultImpl divide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.divideError(node, this);
  EvaluationResultImpl equalEqual(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand) => rightOperand.equalEqualError(node, this);
  bool equalValues(TypeProvider typeProvider, EvaluationResultImpl result) => false;
  List<ErrorResult_ErrorData> get errorData => _errors;
  EvaluationResultImpl greaterThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.greaterThanError(node, this);
  EvaluationResultImpl greaterThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.greaterThanOrEqualError(node, this);
  EvaluationResultImpl integerDivide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.integerDivideError(node, this);
  EvaluationResultImpl integerDivideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl lessThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.lessThanError(node, this);
  EvaluationResultImpl lessThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.lessThanOrEqualError(node, this);
  EvaluationResultImpl logicalAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.logicalAndError(node, this);
  EvaluationResultImpl logicalNot(TypeProvider typeProvider, Expression node) => this;
  EvaluationResultImpl logicalOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.logicalOrError(node, this);
  EvaluationResultImpl minus(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.minusError(node, this);
  EvaluationResultImpl negated(TypeProvider typeProvider, Expression node) => this;
  EvaluationResultImpl notEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.notEqualError(node, this);
  EvaluationResultImpl performToString(TypeProvider typeProvider, AstNode node) => this;
  EvaluationResultImpl remainder(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.remainderError(node, this);
  EvaluationResultImpl shiftLeft(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.shiftLeftError(node, this);
  EvaluationResultImpl shiftRight(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.shiftRightError(node, this);
  EvaluationResultImpl times(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.timesError(node, this);
  EvaluationResultImpl addToError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl addToValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl bitAndError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl bitAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl bitOrError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl bitOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl bitXorError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl bitXorValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl concatenateError(Expression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl concatenateValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand) => this;
  EvaluationResultImpl divideError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl divideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl equalEqualError(Expression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl equalEqualValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand) => this;
  EvaluationResultImpl greaterThanError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl greaterThanOrEqualError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl greaterThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl greaterThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl integerDivideError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl lessThanError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl lessThanOrEqualError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl lessThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl lessThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl logicalAndError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl logicalAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl logicalOrError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl logicalOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl minusError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl minusValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl notEqualError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl notEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl remainderError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl remainderValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl shiftLeftError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl shiftLeftValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl shiftRightError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl shiftRightValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
  EvaluationResultImpl timesError(BinaryExpression node, ErrorResult leftOperand) => new ErrorResult.A_con2(this, leftOperand);
  EvaluationResultImpl timesValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) => this;
}
class ErrorResult_ErrorData {
  final AstNode node;
  final ErrorCode errorCode;
  ErrorResult_ErrorData(this.node, this.errorCode);
}
class EvaluationException extends JavaException {
  final ErrorCode errorCode;
  EvaluationException(this.errorCode);
}
abstract class EvaluationResultImpl {
  EvaluationResultImpl add(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl applyBooleanConversion(TypeProvider typeProvider, AstNode node);
  EvaluationResultImpl bitAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl bitNot(TypeProvider typeProvider, Expression node);
  EvaluationResultImpl bitOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl bitXor(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl concatenate(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl divide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl equalEqual(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand);
  bool equalValues(TypeProvider typeProvider, EvaluationResultImpl result);
  EvaluationResultImpl greaterThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl greaterThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl integerDivide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl lessThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl lessThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl logicalAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl logicalNot(TypeProvider typeProvider, Expression node);
  EvaluationResultImpl logicalOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl minus(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl negated(TypeProvider typeProvider, Expression node);
  EvaluationResultImpl notEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl performToString(TypeProvider typeProvider, AstNode node);
  EvaluationResultImpl remainder(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl shiftLeft(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl shiftRight(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl times(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand);
  EvaluationResultImpl addToError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl addToValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl bitAndError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl bitAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl bitOrError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl bitOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl bitXorError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl bitXorValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl concatenateError(Expression node, ErrorResult leftOperand);
  EvaluationResultImpl concatenateValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand);
  EvaluationResultImpl divideError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl divideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl equalEqualError(Expression node, ErrorResult leftOperand);
  EvaluationResultImpl equalEqualValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand);
  EvaluationResultImpl greaterThanError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl greaterThanOrEqualError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl greaterThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl greaterThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl integerDivideError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl integerDivideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl lessThanError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl lessThanOrEqualError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl lessThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl lessThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl logicalAndError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl logicalAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl logicalOrError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl logicalOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl minusError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl minusValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl notEqualError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl notEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl remainderError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl remainderValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl shiftLeftError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl shiftLeftValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl shiftRightError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl shiftRightValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
  EvaluationResultImpl timesError(BinaryExpression node, ErrorResult leftOperand);
  EvaluationResultImpl timesValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand);
}
class FunctionState extends InstanceState {
  final ExecutableElement D__element;
  FunctionState(this.D__element);
  StringState convertToString() {
    if (D__element == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(D__element.name);
  }
  bool operator==(Object object) => object is FunctionState && (D__element == object.D__element);
  BoolState equalEqual(InstanceState rightOperand) {
    if (D__element == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is FunctionState) {
      ExecutableElement rightElement = rightOperand.D__element;
      if (rightElement == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(D__element == rightElement);
    } else if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  int get hashCode => D__element == null ? 0 : D__element.hashCode;
  String toString() => D__element == null ? "-unknown-" : D__element.name;
}
class GenericState extends InstanceState {
  final A_p.HashMap<String, DartObjectImpl> _fieldMap;
  static String SUPERCLASS_FIELD = "(super)";
  static GenericState UNKNOWN_VALUE = new GenericState(new A_p.HashMap<String,DartObjectImpl>());
  GenericState(this._fieldMap);
  StringState convertToString() => StringState.UNKNOWN_VALUE;
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.A_from(this == rightOperand);
  }
  bool operator==(Object object) {
    if (object is! GenericState) {
      return false;
    }
    GenericState state = object as GenericState;
    A_p.HashSet<String> otherFields = new A_p.HashSet<String>.from(state._fieldMap.keys.toSet());
    for (String fieldName in _fieldMap.keys.toSet()) {
      if (_fieldMap[fieldName] != state._fieldMap[fieldName]) {
        return false;
      }
      otherFields.remove(fieldName);
    }
    for (String fieldName in otherFields) {
      if (state._fieldMap[fieldName] != _fieldMap[fieldName]) {
        return false;
      }
    }
    return true;
  }
  A_p.HashMap<String, DartObjectImpl> get fields => _fieldMap;
  int get hashCode {
    int A_hashCode = 0;
    for (DartObjectImpl A_value in _fieldMap.values) {
      A_hashCode += A_value.hashCode;
    }
    return A_hashCode;
  }
  bool get isUnknown => identical(this, UNKNOWN_VALUE);
}
abstract class InstanceState {
  NumState add(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState bitAnd(InstanceState rightOperand) {
    assertIntOrNull(this);
    assertIntOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState bitNot() {
    assertIntOrNull(this);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState bitOr(InstanceState rightOperand) {
    assertIntOrNull(this);
    assertIntOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState bitXor(InstanceState rightOperand) {
    assertIntOrNull(this);
    assertIntOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  StringState concatenate(InstanceState rightOperand) {
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  BoolState convertToBool() => BoolState.FALSE_STATE;
  StringState convertToString();
  NumState divide(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  BoolState equalEqual(InstanceState rightOperand);
  A_p.HashMap<String, DartObjectImpl> get fields => null;
  Object get value => null;
  BoolState greaterThan(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  BoolState greaterThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  bool get hasExactValue => false;
  IntState integerDivide(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  bool get isBool => false;
  bool get isBoolNumStringOrNull => false;
  bool get isUnknown => false;
  BoolState lessThan(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  BoolState lessThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  BoolState logicalAnd(InstanceState rightOperand) {
    assertBool(this);
    assertBool(rightOperand);
    return BoolState.FALSE_STATE;
  }
  BoolState logicalNot() {
    assertBool(this);
    return BoolState.TRUE_STATE;
  }
  BoolState logicalOr(InstanceState rightOperand) {
    assertBool(this);
    assertBool(rightOperand);
    return rightOperand.convertToBool();
  }
  NumState minus(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  NumState negated() {
    assertNumOrNull(this);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  NumState remainder(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState shiftLeft(InstanceState rightOperand) {
    assertIntOrNull(this);
    assertIntOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  IntState shiftRight(InstanceState rightOperand) {
    assertIntOrNull(this);
    assertIntOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  NumState times(InstanceState rightOperand) {
    assertNumOrNull(this);
    assertNumOrNull(rightOperand);
    throw new EvaluationException(CompileTimeErrorCode.INVALID_CONSTANT);
  }
  void assertBool(InstanceState state) {
    if (!(state is BoolState || state is DynamicState)) {
      throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL);
    }
  }
  void assertBoolNumStringOrNull(InstanceState state) {
    if (!(state is BoolState || state is DoubleState || state is IntState || state is NumState || state is StringState || state is NullState || state is DynamicState)) {
      throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING);
    }
  }
  void assertIntOrNull(InstanceState state) {
    if (!(state is IntState || state is NumState || state is NullState || state is DynamicState)) {
      throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_INT);
    }
  }
  void assertNumOrNull(InstanceState state) {
    if (!(state is DoubleState || state is IntState || state is NumState || state is NullState || state is DynamicState)) {
      throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_NUM);
    }
  }
  void assertString(InstanceState state) {
    if (!(state is StringState || state is DynamicState)) {
      throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL);
    }
  }
}
class IntState extends NumState {
  final int value;
  static IntState UNKNOWN_VALUE = new IntState(null);
  IntState(this.value);
  NumState add(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      if (rightOperand is DoubleState) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value + rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return new DoubleState(value.toDouble() + rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  IntState bitAnd(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value & rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  IntState bitNot() {
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return new IntState(~value);
  }
  IntState bitOr(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value | rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  IntState bitXor(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value ^ rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  StringState convertToString() {
    if (value == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(value.toString());
  }
  NumState divide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      if (rightOperand is DoubleState) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      } else if (rightValue == 0) {
        return new DoubleState(value.toDouble() / rightValue.toDouble());
      }
      return new IntState(value ~/ rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return new DoubleState(value.toDouble() / rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value == rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(rightValue == value.toDouble());
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  bool operator==(Object object) => object is IntState && (value == object.value);
  BoolState greaterThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.compareTo(rightValue) > 0);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.toDouble() > rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState greaterThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.compareTo(rightValue) >= 0);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.toDouble() >= rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  bool get hasExactValue => true;
  int get hashCode => value == null ? 0 : value.hashCode;
  IntState integerDivide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      } else if (rightValue == 0) {
        throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_IDBZE);
      }
      return new IntState(value ~/ rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      double result = value.toDouble() / rightValue;
      return new IntState(result.toInt());
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  bool get isBoolNumStringOrNull => true;
  bool get isUnknown => value == null;
  BoolState lessThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.compareTo(rightValue) < 0);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.toDouble() < rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  BoolState lessThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.compareTo(rightValue) <= 0);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value.toDouble() <= rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return BoolState.UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState minus(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      if (rightOperand is DoubleState) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value - rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return new DoubleState(value.toDouble() - rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState negated() {
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    return new IntState(-value);
  }
  NumState remainder(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      if (rightOperand is DoubleState) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      } else if (rightValue == 0) {
        return new DoubleState(value.toDouble() % rightValue.toDouble());
      }
      return new IntState(value.remainder(rightValue));
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return new DoubleState(value.toDouble() % rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  IntState shiftLeft(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      } else if (rightValue.bitLength > 31) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value << rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  IntState shiftRight(InstanceState rightOperand) {
    assertIntOrNull(rightOperand);
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      } else if (rightValue.bitLength > 31) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value >> rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  NumState times(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (value == null) {
      if (rightOperand is DoubleState) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return UNKNOWN_VALUE;
    }
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new IntState(value * rightValue);
    } else if (rightOperand is DoubleState) {
      double rightValue = rightOperand.value;
      if (rightValue == null) {
        return DoubleState.UNKNOWN_VALUE;
      }
      return new DoubleState(value.toDouble() * rightValue);
    } else if (rightOperand is DynamicState || rightOperand is NumState) {
      return UNKNOWN_VALUE;
    }
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  String toString() => value == null ? "-unknown-" : value.toString();
}
class ListState extends InstanceState {
  final List<DartObjectImpl> A__elements;
  ListState(this.A__elements);
  StringState convertToString() => StringState.UNKNOWN_VALUE;
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.A_from(this == rightOperand);
  }
  bool operator==(Object object) {
    if (object is! ListState) {
      return false;
    }
    List<DartObjectImpl> otherElements = (object as ListState).A__elements;
    int count = A__elements.length;
    if (otherElements.length != count) {
      return false;
    } else if (count == 0) {
      return true;
    }
    for (int i = 0; i < count; i++) {
      if (A__elements[i] != otherElements[i]) {
        return false;
      }
    }
    return true;
  }
  List<Object> get value {
    int count = A__elements.length;
    List<Object> result = new List<Object>(count);
    for (int i = 0; i < count; i++) {
      DartObjectImpl A_element = A__elements[i];
      if (!A_element.hasExactValue) {
        return null;
      }
      result[i] = A_element.value;
    }
    return result;
  }
  bool get hasExactValue {
    int count = A__elements.length;
    for (int i = 0; i < count; i++) {
      if (!A__elements[i].hasExactValue) {
        return false;
      }
    }
    return true;
  }
  int get hashCode {
    int A_value = 0;
    int count = A__elements.length;
    for (int i = 0; i < count; i++) {
      A_value = (A_value << 3) ^ A__elements[i].hashCode;
    }
    return A_value;
  }
}
class MapState extends InstanceState {
  final A_p.HashMap<DartObjectImpl, DartObjectImpl> A__entries;
  MapState(this.A__entries);
  StringState convertToString() => StringState.UNKNOWN_VALUE;
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.A_from(this == rightOperand);
  }
  bool operator==(Object object) {
    if (object is! MapState) {
      return false;
    }
    A_p.HashMap<DartObjectImpl, DartObjectImpl> otherElements = (object as MapState).A__entries;
    int count = A__entries.length;
    if (otherElements.length != count) {
      return false;
    } else if (count == 0) {
      return true;
    }
    for (MapEntry<DartObjectImpl, DartObjectImpl> A_entry in getMapEntrySet(A__entries)) {
      DartObjectImpl A_key = A_entry.getKey();
      DartObjectImpl A_value = A_entry.getValue();
      DartObjectImpl otherValue = otherElements[A_key];
      if (A_value != otherValue) {
        return false;
      }
    }
    return true;
  }
  Map<Object, Object> get value {
    A_p.HashMap<Object, Object> result = new A_p.HashMap<Object,Object>();
    for (MapEntry<DartObjectImpl, DartObjectImpl> A_entry in getMapEntrySet(A__entries)) {
      DartObjectImpl A_key = A_entry.getKey();
      DartObjectImpl A_value = A_entry.getValue();
      if (!A_key.hasExactValue || !A_value.hasExactValue) {
        return null;
      }
      result[A_key.value] = A_value.value;
    }
    return result;
  }
  bool get hasExactValue {
    for (MapEntry<DartObjectImpl, DartObjectImpl> A_entry in getMapEntrySet(A__entries)) {
      if (!A_entry.getKey().hasExactValue || !A_entry.getValue().hasExactValue) {
        return false;
      }
    }
    return true;
  }
  int get hashCode {
    int A_value = 0;
    for (DartObjectImpl A_key in A__entries.keys.toSet()) {
      A_value = (A_value << 3) ^ A_key.hashCode;
    }
    return A_value;
  }
}
class NullState extends InstanceState {
  static NullState NULL_STATE = new NullState();
  BoolState convertToBool() {
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  StringState convertToString() => new StringState("null");
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.A_from(rightOperand is NullState);
  }
  bool operator==(Object object) => object is NullState;
  bool get hasExactValue => true;
  int get hashCode => 0;
  bool get isBoolNumStringOrNull => true;
  BoolState logicalNot() {
    throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION);
  }
  String toString() => "null";
}
class NumState extends InstanceState {
  static NumState UNKNOWN_VALUE = new NumState();
  NumState add(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return UNKNOWN_VALUE;
  }
  StringState convertToString() => StringState.UNKNOWN_VALUE;
  NumState divide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return UNKNOWN_VALUE;
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  bool operator==(Object object) => object is NumState;
  BoolState greaterThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState greaterThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  int get hashCode => 7;
  IntState integerDivide(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    if (rightOperand is IntState) {
      int rightValue = rightOperand.value;
      if (rightValue == null) {
        return IntState.UNKNOWN_VALUE;
      } else if (rightValue == 0) {
        throw new EvaluationException(CompileTimeErrorCode.CONST_EVAL_THROWS_IDBZE);
      }
    } else if (rightOperand is DynamicState) {
      return IntState.UNKNOWN_VALUE;
    }
    return IntState.UNKNOWN_VALUE;
  }
  bool get isBoolNumStringOrNull => true;
  bool get isUnknown => identical(this, UNKNOWN_VALUE);
  BoolState lessThan(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  BoolState lessThanOrEqual(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return BoolState.UNKNOWN_VALUE;
  }
  NumState minus(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return UNKNOWN_VALUE;
  }
  NumState negated() => UNKNOWN_VALUE;
  NumState remainder(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return UNKNOWN_VALUE;
  }
  NumState times(InstanceState rightOperand) {
    assertNumOrNull(rightOperand);
    return UNKNOWN_VALUE;
  }
  String toString() => "-unknown-";
}
class ReferenceFinder extends RecursiveAstVisitor<Object> {
  final AstNode A__source;
  final DirectedGraph<AstNode> _referenceGraph;
  final A_p.HashMap<VariableElement, VariableDeclaration> _variableDeclarationMap;
  final A_p.HashMap<ConstructorElement, ConstructorDeclaration> _constructorDeclarationMap;
  ReferenceFinder(this.A__source, this._referenceGraph, this._variableDeclarationMap, this._constructorDeclarationMap);
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    if (node.isConst) {
      _referenceGraph.addEdge(A__source, node);
    }
    return null;
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    if (A_element is PropertyAccessorElement) {
      A_element = (A_element as PropertyAccessorElement).variable;
    }
    if (A_element is VariableElement) {
      VariableElement variable = A_element as VariableElement;
      if (variable.isConst) {
        VariableDeclaration variableDeclaration = _variableDeclarationMap[variable];
        if (variableDeclaration != null) {
          _referenceGraph.addEdge(A__source, variableDeclaration);
        }
      }
    }
    return null;
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    super.visitSuperConstructorInvocation(node);
    ConstructorElement constructor = node.staticElement;
    if (constructor != null && constructor.isConst) {
      ConstructorDeclaration constructorDeclaration = _constructorDeclarationMap[constructor];
      if (constructorDeclaration != null) {
        _referenceGraph.addEdge(A__source, constructorDeclaration);
      }
    }
    return null;
  }
}
class StringState extends InstanceState {
  final String value;
  static StringState UNKNOWN_VALUE = new StringState(null);
  StringState(this.value);
  StringState concatenate(InstanceState rightOperand) {
    if (value == null) {
      return UNKNOWN_VALUE;
    }
    if (rightOperand is StringState) {
      String rightValue = rightOperand.value;
      if (rightValue == null) {
        return UNKNOWN_VALUE;
      }
      return new StringState("${value}${rightValue}");
    } else if (rightOperand is DynamicState) {
      return UNKNOWN_VALUE;
    }
    return super.concatenate(rightOperand);
  }
  StringState convertToString() => this;
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is StringState) {
      String rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value == rightValue);
    } else if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  bool operator==(Object object) => object is StringState && (value == object.value);
  bool get hasExactValue => true;
  int get hashCode => value == null ? 0 : value.hashCode;
  bool get isBoolNumStringOrNull => true;
  bool get isUnknown => value == null;
  String toString() => value == null ? "-unknown-" : "'${value}'";
}
class SymbolState extends InstanceState {
  final String value;
  SymbolState(this.value);
  StringState convertToString() {
    if (value == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(value);
  }
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (value == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is SymbolState) {
      String rightValue = rightOperand.value;
      if (rightValue == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(value == rightValue);
    } else if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  bool operator==(Object object) => object is SymbolState && (value == object.value);
  bool get hasExactValue => true;
  int get hashCode => value == null ? 0 : value.hashCode;
  String toString() => value == null ? "-unknown-" : "#${value}";
}
class TypeState extends InstanceState {
  final A_Element D__element;
  TypeState(this.D__element);
  StringState convertToString() {
    if (D__element == null) {
      return StringState.UNKNOWN_VALUE;
    }
    return new StringState(D__element.name);
  }
  bool operator==(Object object) => object is TypeState && (D__element == object.D__element);
  BoolState equalEqual(InstanceState rightOperand) {
    assertBoolNumStringOrNull(rightOperand);
    if (D__element == null) {
      return BoolState.UNKNOWN_VALUE;
    }
    if (rightOperand is TypeState) {
      A_Element rightElement = rightOperand.D__element;
      if (rightElement == null) {
        return BoolState.UNKNOWN_VALUE;
      }
      return BoolState.A_from(D__element == rightElement);
    } else if (rightOperand is DynamicState) {
      return BoolState.UNKNOWN_VALUE;
    }
    return BoolState.FALSE_STATE;
  }
  int get hashCode => D__element == null ? 0 : D__element.hashCode;
  String toString() => D__element == null ? "-unknown-" : D__element.name;
}
class ValidResult extends EvaluationResultImpl {
  final DartObjectImpl value;
  ValidResult(this.value);
  EvaluationResultImpl add(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.addToValid(typeProvider, node, this);
  EvaluationResultImpl applyBooleanConversion(TypeProvider typeProvider, AstNode node) {
    try {
      return _valueOf(value.convertToBool(typeProvider));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl bitAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitAndValid(typeProvider, node, this);
  EvaluationResultImpl bitNot(TypeProvider typeProvider, Expression node) {
    try {
      return _valueOf(value.bitNot(typeProvider));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl bitOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitOrValid(typeProvider, node, this);
  EvaluationResultImpl bitXor(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.bitXorValid(typeProvider, node, this);
  EvaluationResultImpl concatenate(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand) => rightOperand.concatenateValid(typeProvider, node, this);
  EvaluationResultImpl divide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.divideValid(typeProvider, node, this);
  EvaluationResultImpl equalEqual(TypeProvider typeProvider, Expression node, EvaluationResultImpl rightOperand) => rightOperand.equalEqualValid(typeProvider, node, this);
  bool equalValues(TypeProvider typeProvider, EvaluationResultImpl result) {
    if (result is! ValidResult) {
      return false;
    }
    return value == (result as ValidResult).value;
  }
  EvaluationResultImpl greaterThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.greaterThanValid(typeProvider, node, this);
  EvaluationResultImpl greaterThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.greaterThanOrEqualValid(typeProvider, node, this);
  EvaluationResultImpl integerDivide(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.integerDivideValid(typeProvider, node, this);
  bool get isBool => value.isBool;
  bool get isBoolNumStringOrNull => value.isBoolNumStringOrNull;
  bool get isFalse => value.isFalse;
  bool get isNull => value.isNull;
  bool get isTrue => value.isTrue;
  bool get isUserDefinedObject => value.isUserDefinedObject;
  EvaluationResultImpl lessThan(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.lessThanValid(typeProvider, node, this);
  EvaluationResultImpl lessThanOrEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.lessThanOrEqualValid(typeProvider, node, this);
  EvaluationResultImpl logicalAnd(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.logicalAndValid(typeProvider, node, this);
  EvaluationResultImpl logicalNot(TypeProvider typeProvider, Expression node) {
    try {
      return _valueOf(value.logicalNot(typeProvider));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl logicalOr(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.logicalOrValid(typeProvider, node, this);
  EvaluationResultImpl minus(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.minusValid(typeProvider, node, this);
  EvaluationResultImpl negated(TypeProvider typeProvider, Expression node) {
    try {
      return _valueOf(value.negated(typeProvider));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl notEqual(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.notEqualValid(typeProvider, node, this);
  EvaluationResultImpl performToString(TypeProvider typeProvider, AstNode node) {
    try {
      return _valueOf(value.performToString(typeProvider));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl remainder(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.remainderValid(typeProvider, node, this);
  EvaluationResultImpl shiftLeft(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.shiftLeftValid(typeProvider, node, this);
  EvaluationResultImpl shiftRight(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.shiftRightValid(typeProvider, node, this);
  EvaluationResultImpl times(TypeProvider typeProvider, BinaryExpression node, EvaluationResultImpl rightOperand) => rightOperand.timesValid(typeProvider, node, this);
  String toString() {
    if (value == null) {
      return "null";
    }
    return value.toString();
  }
  EvaluationResultImpl addToError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl addToValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.add(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl bitAndError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl bitAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.bitAnd(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl bitOrError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl bitOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.bitOr(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl bitXorError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl bitXorValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.bitXor(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl concatenateError(Expression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl concatenateValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.concatenate(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl divideError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl divideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.divide(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl equalEqualError(Expression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl equalEqualValid(TypeProvider typeProvider, Expression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.equalEqual(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl greaterThanError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl greaterThanOrEqualError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl greaterThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.greaterThanOrEqual(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl greaterThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.greaterThan(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl integerDivideError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl integerDivideValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.integerDivide(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl lessThanError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl lessThanOrEqualError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl lessThanOrEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.lessThanOrEqual(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl lessThanValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.lessThan(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl logicalAndError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl logicalAndValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.logicalAnd(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl logicalOrError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl logicalOrValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.logicalOr(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl minusError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl minusValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.minus(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl notEqualError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl notEqualValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.notEqual(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl remainderError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl remainderValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.remainder(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl shiftLeftError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl shiftLeftValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.shiftLeft(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl shiftRightError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl shiftRightValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.shiftRight(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  EvaluationResultImpl timesError(BinaryExpression node, ErrorResult leftOperand) => leftOperand;
  EvaluationResultImpl timesValid(TypeProvider typeProvider, BinaryExpression node, ValidResult leftOperand) {
    try {
      return _valueOf(leftOperand.value.times(typeProvider, value));
    }on EvaluationException  catch (exception) {
      return B__error(node, exception.errorCode);
    }
  }
  ErrorResult B__error(AstNode node, ErrorCode A_code) => new ErrorResult.A_con1(node, A_code);
  ValidResult _valueOf(DartObjectImpl A_value) => new ValidResult(A_value);
}
class AngularApplication {
  final Source entryPoint;
  final Set<Source> _librarySources;
  final List<AngularElement> elements;
  final List<Source> elementSources;
  AngularApplication(this.entryPoint, this._librarySources, this.elements, this.elementSources);
  bool dependsOn(Source librarySource) => _librarySources.contains(librarySource);
}
abstract class AngularComponentElement implements AngularHasSelectorElement, AngularHasTemplateElement {
  List<AngularPropertyElement> get properties;
  List<AngularScopePropertyElement> get scopeProperties;
}
class AngularComponentElementImpl extends AngularHasSelectorElementImpl implements AngularComponentElement {
  final int _annotationOffset;
  List<AngularPropertyElement> A__properties = AngularPropertyElement.B_EMPTY_ARRAY;
  List<AngularScopePropertyElement> _scopeProperties = AngularScopePropertyElement.B_EMPTY_ARRAY;
  String styleUri;
  int styleUriOffset = 0;
  String templateUri;
  Source templateSource;
  int templateUriOffset = 0;
  AngularComponentElementImpl(String A_name, int nameOffset, this._annotationOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularComponentElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_COMPONENT;
  List<AngularPropertyElement> get properties => A__properties;
  List<AngularScopePropertyElement> get scopeProperties => _scopeProperties;
  void set properties(List<AngularPropertyElement> A_properties) {
    for (AngularPropertyElement property in A_properties) {
      encloseElement(property as AngularPropertyElementImpl);
    }
    this.A__properties = A_properties;
  }
  void set scopeProperties(List<AngularScopePropertyElement> A_properties) {
    for (AngularScopePropertyElement property in A_properties) {
      encloseElement(property as AngularScopePropertyElementImpl);
    }
    this._scopeProperties = A_properties;
  }
  void visitChildren(ElementVisitor visitor) {
    safelyVisitChildren(A__properties, visitor);
    safelyVisitChildren(_scopeProperties, visitor);
    super.visitChildren(visitor);
  }
  String get identifier => "AngularComponent@${_annotationOffset}";
}
abstract class AngularControllerElement implements AngularHasSelectorElement {}
class AngularControllerElementImpl extends AngularHasSelectorElementImpl implements AngularControllerElement {
  AngularControllerElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularControllerElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_CONTROLLER;
}
abstract class AngularDecoratorElement implements AngularHasSelectorElement {
  List<AngularPropertyElement> get properties;
  bool isClass(String A_name);
}
class AngularDecoratorElementImpl extends AngularHasSelectorElementImpl implements AngularDecoratorElement {
  final int B__offset;
  List<AngularPropertyElement> A__properties = AngularPropertyElement.B_EMPTY_ARRAY;
  AngularDecoratorElementImpl(this.B__offset) : super(null, -1);
  accept(ElementVisitor visitor) => visitor.visitAngularDirectiveElement(this);
  String get displayName => selector.displayName;
  A_ElementKind get kind => A_ElementKind.ANGULAR_DIRECTIVE;
  List<AngularPropertyElement> get properties => A__properties;
  bool isClass(String A_name) {
    A_Element enclosing = enclosingElement;
    return enclosing is ClassElement && enclosing.name == A_name;
  }
  void set properties(List<AngularPropertyElement> A_properties) {
    for (AngularPropertyElement property in A_properties) {
      encloseElement(property as AngularPropertyElementImpl);
    }
    this.A__properties = A_properties;
  }
  void visitChildren(ElementVisitor visitor) {
    safelyVisitChildren(A__properties, visitor);
    super.visitChildren(visitor);
  }
  String get identifier => "Decorator@${B__offset}";
}
abstract class AngularElement implements ToolkitObjectElement {
  AngularApplication get application;
}
abstract class AngularElementImpl extends ToolkitObjectElementImpl implements AngularElement {
  AngularApplication _application;
  AngularElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  AngularApplication get application => _application;
  void set application(AngularApplication A_application) {
    this._application = A_application;
  }
}
abstract class AngularFormatterElement implements AngularElement {}
class AngularFormatterElementImpl extends AngularElementImpl implements AngularFormatterElement {
  AngularFormatterElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularFormatterElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_FORMATTER;
}
abstract class AngularHasAttributeSelectorElement implements AngularSelectorElement {}
abstract class AngularHasClassSelectorElement implements AngularSelectorElement {}
class AngularHasClassSelectorElementImpl extends AngularSelectorElementImpl implements AngularHasClassSelectorElement {
  AngularHasClassSelectorElementImpl(String A_name, int A_offset) : super(A_name, A_offset);
  bool apply(XmlTagNode node) {
    XmlAttributeNode attribute = node.getAttribute("class");
    if (attribute != null) {
      String text = attribute.text;
      if (text != null) {
        String A_name = this.name;
        for (String className in StringUtils.A_split(text)) {
          if (className == A_name) {
            return true;
          }
        }
      }
    }
    return false;
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(".");
    A_builder.append(name);
  }
}
abstract class AngularHasSelectorElement implements AngularElement {
  AngularSelectorElement get selector;
}
abstract class AngularHasSelectorElementImpl extends AngularElementImpl implements AngularHasSelectorElement {
  AngularSelectorElement _selector;
  AngularHasSelectorElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  AngularSelectorElement get selector => _selector;
  void set selector(AngularSelectorElement A_selector) {
    encloseElement(A_selector as AngularSelectorElementImpl);
    this._selector = A_selector;
  }
  void visitChildren(ElementVisitor visitor) {
    safelyVisitChild(_selector, visitor);
    super.visitChildren(visitor);
  }
}
abstract class AngularHasTemplateElement implements AngularElement {
  Source get templateSource;
  String get templateUri;
  int get templateUriOffset;
}
abstract class AngularPropertyElement implements AngularElement {
  static final List<AngularPropertyElement> B_EMPTY_ARRAY = [];
  FieldElement get field;
  int get fieldNameOffset;
  AngularPropertyKind get propertyKind;
}
class AngularPropertyElementImpl extends AngularElementImpl implements AngularPropertyElement {
  FieldElement field;
  int fieldNameOffset = -1;
  AngularPropertyKind propertyKind;
  AngularPropertyElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularPropertyElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_PROPERTY;
}
class AngularPropertyKind extends Enum<AngularPropertyKind> {
  static const AngularPropertyKind ATTR = const AngularPropertyKind('ATTR', 0);
  static const AngularPropertyKind CALLBACK = const AngularPropertyKind('CALLBACK', 1);
  static const AngularPropertyKind ONE_WAY = const AngularPropertyKind('ONE_WAY', 2);
  static const AngularPropertyKind ONE_WAY_ONE_TIME = const AngularPropertyKind('ONE_WAY_ONE_TIME', 3);
  static const AngularPropertyKind TWO_WAY = const AngularPropertyKind_TWO_WAY('TWO_WAY', 4);
  bool callsGetter() => false;
  bool callsSetter() => true;
  const AngularPropertyKind(String A_name, int ordinal) : super(A_name, ordinal);
}
class AngularPropertyKind_TWO_WAY extends AngularPropertyKind {
  const AngularPropertyKind_TWO_WAY(String A_name, int ordinal) : super(A_name, ordinal);
  bool callsGetter() => true;
}
abstract class AngularScopePropertyElement implements AngularElement {
  static final List<AngularScopePropertyElement> B_EMPTY_ARRAY = [];
  DartType get type;
}
class AngularScopePropertyElementImpl extends AngularElementImpl implements AngularScopePropertyElement {
  final DartType type;
  AngularScopePropertyElementImpl(String A_name, int nameOffset, this.type) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularScopePropertyElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_SCOPE_PROPERTY;
}
abstract class AngularSelectorElement implements AngularElement {
  bool apply(XmlTagNode node);
}
abstract class AngularSelectorElementImpl extends AngularElementImpl implements AngularSelectorElement {
  AngularSelectorElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitAngularSelectorElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_SELECTOR;
}
abstract class AngularTagSelectorElement implements AngularSelectorElement {}
class AngularTagSelectorElementImpl extends AngularSelectorElementImpl implements AngularTagSelectorElement {
  AngularTagSelectorElementImpl(String A_name, int A_offset) : super(A_name, A_offset);
  bool apply(XmlTagNode node) {
    String tagName = name;
    return node.tag == tagName;
  }
  AngularApplication get application => (enclosingElement as AngularElementImpl).application;
}
abstract class AngularViewElement implements AngularHasTemplateElement {
  static final List<AngularViewElement> B_EMPTY_ARRAY = new List<AngularViewElement>(0);
}
class AngularViewElementImpl extends AngularElementImpl implements AngularViewElement {
  final String templateUri;
  final int templateUriOffset;
  Source templateSource;
  AngularViewElementImpl(this.templateUri, this.templateUriOffset) : super(null, -1);
  accept(ElementVisitor visitor) => visitor.visitAngularViewElement(this);
  A_ElementKind get kind => A_ElementKind.ANGULAR_VIEW;
  String get identifier => "AngularView@${templateUriOffset}";
}
class AuxiliaryElements {
  final ExecutableElement propagatedElement;
  final ExecutableElement staticElement;
  AuxiliaryElements(this.staticElement, this.propagatedElement);
}
class BottomTypeImpl extends A_TypeImpl {
  static BottomTypeImpl _INSTANCE = new BottomTypeImpl();
  static BottomTypeImpl get instance => _INSTANCE;
  BottomTypeImpl() : super(null, "<bottom>");
  bool operator==(Object object) => identical(object, this);
  int get hashCode => 0;
  bool get isBottom => true;
  BottomTypeImpl substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) => this;
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) => identical(object, this);
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) => true;
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) => true;
}
abstract class ClassElement implements A_Element {
  List<PropertyAccessorElement> get accessors;
  List<ConstructorElement> get constructors;
  FieldElement getField(String fieldName);
  List<FieldElement> get fields;
  PropertyAccessorElement getGetter(String getterName);
  List<InterfaceType> get interfaces;
  MethodElement getMethod(String methodName);
  List<MethodElement> get methods;
  List<InterfaceType> get mixins;
  ConstructorElement getNamedConstructor(String A_name);
  ClassDeclaration get node;
  PropertyAccessorElement getSetter(String setterName);
  InterfaceType get supertype;
  List<ToolkitObjectElement> get toolkitObjects;
  InterfaceType get type;
  List<TypeParameterElement> get typeParameters;
  ConstructorElement get unnamedConstructor;
  bool get hasNonFinalField;
  bool get hasReferenceToSuper;
  bool get isAbstract;
  bool get isOrInheritsProxy;
  bool get isProxy;
  bool get isTypedef;
  MethodElement lookUpConcreteMethod(String methodName, LibraryElement library);
  PropertyAccessorElement lookUpGetter(String getterName, LibraryElement library);
  PropertyAccessorElement lookUpInheritedConcreteGetter(String getterName, LibraryElement library);
  MethodElement lookUpInheritedConcreteMethod(String methodName, LibraryElement library);
  PropertyAccessorElement lookUpInheritedConcreteSetter(String setterName, LibraryElement library);
  MethodElement lookUpInheritedMethod(String methodName, LibraryElement library);
  MethodElement lookUpMethod(String methodName, LibraryElement library);
  PropertyAccessorElement lookUpSetter(String setterName, LibraryElement library);
}
class ClassElementImpl extends ElementImpl implements ClassElement {
  List<PropertyAccessorElement> _accessors = PropertyAccessorElementImpl.B_EMPTY_ARRAY;
  List<ConstructorElement> _constructors = ConstructorElementImpl.B_EMPTY_ARRAY;
  List<FieldElement> _fields = FieldElementImpl.B_EMPTY_ARRAY;
  List<InterfaceType> mixins = InterfaceType.B_EMPTY_ARRAY;
  List<InterfaceType> interfaces = InterfaceType.B_EMPTY_ARRAY;
  List<MethodElement> _methods = MethodElementImpl.B_EMPTY_ARRAY;
  InterfaceType supertype;
  List<ToolkitObjectElement> _toolkitObjects = ToolkitObjectElement.B_EMPTY_ARRAY;
  InterfaceType type;
  List<TypeParameterElement> A__typeParameters = TypeParameterElementImpl.B_EMPTY_ARRAY;
  static List<ClassElement> B_EMPTY_ARRAY = new List<ClassElement>(0);
  ClassElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitClassElement(this);
  void addToolkitObjects(ToolkitObjectElement toolkitObject) {
    (toolkitObject as ToolkitObjectElementImpl).enclosingElement = this;
    _toolkitObjects = ArrayUtils.A_add(_toolkitObjects, toolkitObject);
  }
  List<PropertyAccessorElement> get accessors => _accessors;
  ElementImpl getChild(String identifier) {
    for (PropertyAccessorElement accessor in _accessors) {
      if ((accessor as PropertyAccessorElementImpl).identifier == identifier) {
        return accessor as PropertyAccessorElementImpl;
      }
    }
    for (ConstructorElement constructor in _constructors) {
      if ((constructor as ConstructorElementImpl).identifier == identifier) {
        return constructor as ConstructorElementImpl;
      }
    }
    for (FieldElement field in _fields) {
      if ((field as FieldElementImpl).identifier == identifier) {
        return field as FieldElementImpl;
      }
    }
    for (MethodElement A_method in _methods) {
      if ((A_method as MethodElementImpl).identifier == identifier) {
        return A_method as MethodElementImpl;
      }
    }
    for (TypeParameterElement typeParameter in A__typeParameters) {
      if ((typeParameter as TypeParameterElementImpl).identifier == identifier) {
        return typeParameter as TypeParameterElementImpl;
      }
    }
    return null;
  }
  List<ConstructorElement> get constructors => _constructors;
  FieldElement getField(String A_name) {
    for (FieldElement fieldElement in _fields) {
      if (A_name == fieldElement.name) {
        return fieldElement;
      }
    }
    return null;
  }
  List<FieldElement> get fields => _fields;
  PropertyAccessorElement getGetter(String getterName) {
    for (PropertyAccessorElement accessor in _accessors) {
      if (accessor.isGetter && accessor.name == getterName) {
        return accessor;
      }
    }
    return null;
  }
  A_ElementKind get kind => A_ElementKind.C_CLASS;
  MethodElement getMethod(String methodName) {
    for (MethodElement A_method in _methods) {
      if (A_method.name == methodName) {
        return A_method;
      }
    }
    return null;
  }
  List<MethodElement> get methods => _methods;
  ConstructorElement getNamedConstructor(String A_name) {
    for (ConstructorElement A_element in constructors) {
      String elementName = A_element.name;
      if (elementName != null && elementName == A_name) {
        return A_element;
      }
    }
    return null;
  }
  ClassDeclaration get node => getNodeMatching((A_node) => A_node is ClassDeclaration);
  PropertyAccessorElement getSetter(String setterName) {
    if (!StringUtilities.endsWithChar(setterName, 0x3D)) {
      setterName += '=';
    }
    for (PropertyAccessorElement accessor in _accessors) {
      if (accessor.isSetter && accessor.name == setterName) {
        return accessor;
      }
    }
    return null;
  }
  List<ToolkitObjectElement> get toolkitObjects => _toolkitObjects;
  List<TypeParameterElement> get typeParameters => A__typeParameters;
  ConstructorElement get unnamedConstructor {
    for (ConstructorElement A_element in constructors) {
      String A_name = A_element.displayName;
      if (A_name == null || A_name.isEmpty) {
        return A_element;
      }
    }
    return null;
  }
  bool get hasNonFinalField {
    List<ClassElement> classesToVisit = new List<ClassElement>();
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    classesToVisit.add(this);
    while (!classesToVisit.isEmpty) {
      ClassElement currentElement = classesToVisit.removeAt(0);
      if (visitedClasses.add(currentElement)) {
        for (FieldElement field in currentElement.fields) {
          if (!field.isFinal && !field.isConst && !field.isStatic && !field.isSynthetic) {
            return true;
          }
        }
        for (InterfaceType mixinType in currentElement.mixins) {
          ClassElement mixinElement = mixinType.element;
          classesToVisit.add(mixinElement);
        }
        InterfaceType A_supertype = currentElement.supertype;
        if (A_supertype != null) {
          ClassElement superElement = A_supertype.element;
          if (superElement != null) {
            classesToVisit.add(superElement);
          }
        }
      }
    }
    return false;
  }
  bool get hasReferenceToSuper => hasModifier(Modifier.REFERENCES_SUPER);
  bool get isAbstract => hasModifier(Modifier.ABSTRACT);
  bool get isOrInheritsProxy => _safeIsOrInheritsProxy(this, new A_p.HashSet<ClassElement>());
  bool get isProxy {
    for (ElementAnnotation annotation in metadata) {
      if (annotation.isProxy) {
        return true;
      }
    }
    return false;
  }
  bool get isTypedef => hasModifier(Modifier.TYPEDEF);
  MethodElement lookUpConcreteMethod(String methodName, LibraryElement library) => _internalLookUpConcreteMethod(methodName, library, true);
  PropertyAccessorElement lookUpGetter(String getterName, LibraryElement library) => _internalLookUpGetter(getterName, library, true);
  PropertyAccessorElement lookUpInheritedConcreteGetter(String getterName, LibraryElement library) => _internalLookUpConcreteGetter(getterName, library, false);
  MethodElement lookUpInheritedConcreteMethod(String methodName, LibraryElement library) => _internalLookUpConcreteMethod(methodName, library, false);
  PropertyAccessorElement lookUpInheritedConcreteSetter(String setterName, LibraryElement library) => _internalLookUpConcreteSetter(setterName, library, false);
  MethodElement lookUpInheritedMethod(String methodName, LibraryElement library) => _internalLookUpMethod(methodName, library, false);
  MethodElement lookUpMethod(String methodName, LibraryElement library) => _internalLookUpMethod(methodName, library, true);
  PropertyAccessorElement lookUpSetter(String setterName, LibraryElement library) => _internalLookUpSetter(setterName, library, true);
  void set abstract(bool A_isAbstract) {
    setModifier(Modifier.ABSTRACT, A_isAbstract);
  }
  void set accessors(List<PropertyAccessorElement> A_accessors) {
    for (PropertyAccessorElement accessor in A_accessors) {
      (accessor as PropertyAccessorElementImpl).enclosingElement = this;
    }
    this._accessors = A_accessors;
  }
  void set constructors(List<ConstructorElement> A_constructors) {
    for (ConstructorElement constructor in A_constructors) {
      (constructor as ConstructorElementImpl).enclosingElement = this;
    }
    this._constructors = A_constructors;
  }
  void set fields(List<FieldElement> A_fields) {
    for (FieldElement field in A_fields) {
      (field as FieldElementImpl).enclosingElement = this;
    }
    this._fields = A_fields;
  }
  void set hasReferenceToSuper(bool isReferencedSuper) {
    setModifier(Modifier.REFERENCES_SUPER, isReferencedSuper);
  }
  void set methods(List<MethodElement> A_methods) {
    for (MethodElement A_method in A_methods) {
      (A_method as MethodElementImpl).enclosingElement = this;
    }
    this._methods = A_methods;
  }
  void set typedef(bool A_isTypedef) {
    setModifier(Modifier.TYPEDEF, A_isTypedef);
  }
  void set typeParameters(List<TypeParameterElement> A_typeParameters) {
    for (TypeParameterElement typeParameter in A_typeParameters) {
      (typeParameter as TypeParameterElementImpl).enclosingElement = this;
    }
    this.A__typeParameters = A_typeParameters;
  }
  void set validMixin(bool A_isValidMixin) {
    setModifier(Modifier.MIXIN, A_isValidMixin);
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(_accessors, visitor);
    safelyVisitChildren(_constructors, visitor);
    safelyVisitChildren(_fields, visitor);
    safelyVisitChildren(_methods, visitor);
    safelyVisitChildren(_toolkitObjects, visitor);
    safelyVisitChildren(A__typeParameters, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    String A_name = displayName;
    if (A_name == null) {
      A_builder.append("{unnamed class}");
    } else {
      A_builder.append(A_name);
    }
    int variableCount = A__typeParameters.length;
    if (variableCount > 0) {
      A_builder.append("<");
      for (int i = 0; i < variableCount; i++) {
        if (i > 0) {
          A_builder.append(", ");
        }
        (A__typeParameters[i] as TypeParameterElementImpl).appendTo(A_builder);
      }
      A_builder.append(">");
    }
  }
  PropertyAccessorElement _internalLookUpConcreteGetter(String getterName, LibraryElement library, bool includeThisClass) {
    PropertyAccessorElement getter = _internalLookUpGetter(getterName, library, includeThisClass);
    while (getter != null && getter.isAbstract) {
      A_Element definingClass = getter.enclosingElement;
      if (definingClass is! ClassElementImpl) {
        return null;
      }
      getter = (definingClass as ClassElementImpl)._internalLookUpGetter(getterName, library, false);
    }
    return getter;
  }
  MethodElement _internalLookUpConcreteMethod(String methodName, LibraryElement library, bool includeThisClass) {
    MethodElement A_method = _internalLookUpMethod(methodName, library, includeThisClass);
    while (A_method != null && A_method.isAbstract) {
      ClassElement definingClass = A_method.enclosingElement;
      if (definingClass == null) {
        return null;
      }
      A_method = definingClass.lookUpInheritedMethod(methodName, library);
    }
    return A_method;
  }
  PropertyAccessorElement _internalLookUpConcreteSetter(String setterName, LibraryElement library, bool includeThisClass) {
    PropertyAccessorElement setter = _internalLookUpSetter(setterName, library, includeThisClass);
    while (setter != null && setter.isAbstract) {
      A_Element definingClass = setter.enclosingElement;
      if (definingClass is! ClassElementImpl) {
        return null;
      }
      setter = (definingClass as ClassElementImpl)._internalLookUpSetter(setterName, library, false);
    }
    return setter;
  }
  PropertyAccessorElement _internalLookUpGetter(String getterName, LibraryElement library, bool includeThisClass) {
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    ClassElement currentElement = this;
    if (includeThisClass) {
      PropertyAccessorElement A_element = currentElement.getGetter(getterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    while (currentElement != null && visitedClasses.add(currentElement)) {
      for (InterfaceType mixin in currentElement.mixins) {
        ClassElement mixinElement = mixin.element;
        if (mixinElement != null) {
          PropertyAccessorElement A_element = mixinElement.getGetter(getterName);
          if (A_element != null && A_element.isAccessibleIn(library)) {
            return A_element;
          }
        }
      }
      InterfaceType A_supertype = currentElement.supertype;
      if (A_supertype == null) {
        return null;
      }
      currentElement = A_supertype.element;
      PropertyAccessorElement A_element = currentElement.getGetter(getterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    return null;
  }
  MethodElement _internalLookUpMethod(String methodName, LibraryElement library, bool includeThisClass) {
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    ClassElement currentElement = this;
    if (includeThisClass) {
      MethodElement A_element = currentElement.getMethod(methodName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    while (currentElement != null && visitedClasses.add(currentElement)) {
      for (InterfaceType mixin in currentElement.mixins) {
        ClassElement mixinElement = mixin.element;
        if (mixinElement != null) {
          MethodElement A_element = mixinElement.getMethod(methodName);
          if (A_element != null && A_element.isAccessibleIn(library)) {
            return A_element;
          }
        }
      }
      InterfaceType A_supertype = currentElement.supertype;
      if (A_supertype == null) {
        return null;
      }
      currentElement = A_supertype.element;
      MethodElement A_element = currentElement.getMethod(methodName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    return null;
  }
  PropertyAccessorElement _internalLookUpSetter(String setterName, LibraryElement library, bool includeThisClass) {
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    ClassElement currentElement = this;
    if (includeThisClass) {
      PropertyAccessorElement A_element = currentElement.getSetter(setterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    while (currentElement != null && visitedClasses.add(currentElement)) {
      for (InterfaceType mixin in currentElement.mixins) {
        ClassElement mixinElement = mixin.element;
        if (mixinElement != null) {
          PropertyAccessorElement A_element = mixinElement.getSetter(setterName);
          if (A_element != null && A_element.isAccessibleIn(library)) {
            return A_element;
          }
        }
      }
      InterfaceType A_supertype = currentElement.supertype;
      if (A_supertype == null) {
        return null;
      }
      currentElement = A_supertype.element;
      PropertyAccessorElement A_element = currentElement.getSetter(setterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    return null;
  }
  bool _safeIsOrInheritsProxy(ClassElement classElt, A_p.HashSet<ClassElement> visitedClassElts) {
    if (visitedClassElts.contains(classElt)) {
      return false;
    }
    visitedClassElts.add(classElt);
    if (classElt.isProxy) {
      return true;
    } else if (classElt.supertype != null && _safeIsOrInheritsProxy(classElt.supertype.element, visitedClassElts)) {
      return true;
    }
    List<InterfaceType> supertypes = classElt.interfaces;
    for (int i = 0; i < supertypes.length; i++) {
      if (_safeIsOrInheritsProxy(supertypes[i].element, visitedClassElts)) {
        return true;
      }
    }
    supertypes = classElt.mixins;
    for (int i = 0; i < supertypes.length; i++) {
      if (_safeIsOrInheritsProxy(supertypes[i].element, visitedClassElts)) {
        return true;
      }
    }
    return false;
  }
}
abstract class ClassMemberElement implements A_Element {
  ClassElement get enclosingElement;
  bool get isStatic;
}
abstract class CompilationUnitElement implements A_Element, UriReferencedElement {
  List<PropertyAccessorElement> get accessors;
  List<AngularViewElement> get angularViews;
  LibraryElement get enclosingElement;
  List<ClassElement> get enums;
  List<FunctionElement> get functions;
  List<FunctionTypeAliasElement> get functionTypeAliases;
  CompilationUnit get node;
  List<TopLevelVariableElement> get topLevelVariables;
  ClassElement getType(String className);
  List<ClassElement> get types;
  bool get hasLoadLibraryFunction;
}
class CompilationUnitElementImpl extends UriReferencedElementImpl implements CompilationUnitElement {
  static List<CompilationUnitElement> B_EMPTY_ARRAY = new List<CompilationUnitElement>(0);
  Source source;
  List<PropertyAccessorElement> _accessors = PropertyAccessorElementImpl.B_EMPTY_ARRAY;
  List<ClassElement> _enums = ClassElementImpl.B_EMPTY_ARRAY;
  List<FunctionElement> _functions = FunctionElementImpl.B_EMPTY_ARRAY;
  Map<A_Element, List<ToolkitObjectElement>> _toolkitObjects = {};
  List<FunctionTypeAliasElement> _typeAliases = FunctionTypeAliasElementImpl.B_EMPTY_ARRAY;
  List<ClassElement> _types = ClassElementImpl.B_EMPTY_ARRAY;
  List<TopLevelVariableElement> A__variables = TopLevelVariableElementImpl.B_EMPTY_ARRAY;
  List<AngularViewElement> _angularViews = AngularViewElement.B_EMPTY_ARRAY;
  CompilationUnitElementImpl(String A_name) : super(A_name, -1);
  accept(ElementVisitor visitor) => visitor.visitCompilationUnitElement(this);
  bool operator==(Object object) => object != null && runtimeType == object.runtimeType && source == (object as CompilationUnitElementImpl).source;
  List<PropertyAccessorElement> get accessors => _accessors;
  List<AngularViewElement> get angularViews => _angularViews;
  ElementImpl getChild(String A_identifier) {
    for (PropertyAccessorElement accessor in _accessors) {
      if ((accessor as PropertyAccessorElementImpl).identifier == A_identifier) {
        return accessor as PropertyAccessorElementImpl;
      }
    }
    for (VariableElement variable in A__variables) {
      if ((variable as VariableElementImpl).identifier == A_identifier) {
        return variable as VariableElementImpl;
      }
    }
    for (ExecutableElement A_function in _functions) {
      if ((A_function as ExecutableElementImpl).identifier == A_identifier) {
        return A_function as ExecutableElementImpl;
      }
    }
    for (FunctionTypeAliasElement typeAlias in _typeAliases) {
      if ((typeAlias as FunctionTypeAliasElementImpl).identifier == A_identifier) {
        return typeAlias as FunctionTypeAliasElementImpl;
      }
    }
    for (ClassElement A_type in _types) {
      if ((A_type as ClassElementImpl).identifier == A_identifier) {
        return A_type as ClassElementImpl;
      }
    }
    return null;
  }
  LibraryElement get enclosingElement => super.enclosingElement as LibraryElement;
  List<ClassElement> get enums => _enums;
  List<FunctionElement> get functions => _functions;
  List<FunctionTypeAliasElement> get functionTypeAliases => _typeAliases;
  A_ElementKind get kind => A_ElementKind.A_COMPILATION_UNIT;
  CompilationUnit get node => unit;
  List<TopLevelVariableElement> get topLevelVariables => A__variables;
  ClassElement getType(String className) {
    for (ClassElement A_type in _types) {
      if (A_type.name == className) {
        return A_type;
      }
    }
    return null;
  }
  List<ClassElement> get types => _types;
  int get hashCode => source.hashCode;
  bool get hasLoadLibraryFunction {
    for (int i = 0; i < _functions.length; i++) {
      if (_functions[i].name == FunctionElement.LOAD_LIBRARY_NAME) {
        return true;
      }
    }
    return false;
  }
  void set accessors(List<PropertyAccessorElement> A_accessors) {
    for (PropertyAccessorElement accessor in A_accessors) {
      (accessor as PropertyAccessorElementImpl).enclosingElement = this;
    }
    this._accessors = A_accessors;
  }
  void set angularViews(List<AngularViewElement> A_angularViews) {
    for (AngularViewElement A_view in A_angularViews) {
      (A_view as AngularViewElementImpl).enclosingElement = this;
    }
    this._angularViews = A_angularViews;
  }
  void set enums(List<ClassElement> A_enums) {
    for (ClassElement enumDeclaration in A_enums) {
      (enumDeclaration as ClassElementImpl).enclosingElement = this;
    }
    this._enums = A_enums;
  }
  void set functions(List<FunctionElement> A_functions) {
    for (FunctionElement A_function in A_functions) {
      (A_function as FunctionElementImpl).enclosingElement = this;
    }
    this._functions = A_functions;
  }
  void set topLevelVariables(List<TopLevelVariableElement> variables) {
    for (TopLevelVariableElement field in variables) {
      (field as TopLevelVariableElementImpl).enclosingElement = this;
    }
    this.A__variables = variables;
  }
  void set typeAliases(List<FunctionTypeAliasElement> A_typeAliases) {
    for (FunctionTypeAliasElement typeAlias in A_typeAliases) {
      (typeAlias as FunctionTypeAliasElementImpl).enclosingElement = this;
    }
    this._typeAliases = A_typeAliases;
  }
  void set types(List<ClassElement> A_types) {
    for (ClassElement A_type in A_types) {
      (A_type as ClassElementImpl).enclosingElement = this;
    }
    this._types = A_types;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(_accessors, visitor);
    safelyVisitChildren(_functions, visitor);
    safelyVisitChildren(_typeAliases, visitor);
    safelyVisitChildren(_types, visitor);
    safelyVisitChildren(A__variables, visitor);
    safelyVisitChildren(_angularViews, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    if (source == null) {
      A_builder.append("{compilation unit}");
    } else {
      A_builder.append(source.fullName);
    }
  }
  String get identifier => source.encoding;
  List<ToolkitObjectElement> _getToolkitObjects(A_Element A_element) {
    List<ToolkitObjectElement> objects = _toolkitObjects[A_element];
    if (objects != null) {
      return objects;
    }
    return ToolkitObjectElement.B_EMPTY_ARRAY;
  }
  void _setToolkitObjects(A_Element A_element, List<ToolkitObjectElement> objects) {
    _toolkitObjects[A_element] = objects;
  }
}
class ConstFieldElementImpl extends FieldElementImpl {
  EvaluationResultImpl A__result;
  ConstFieldElementImpl.B_con1(Identifier A_name) : super.forNode(A_name);
  EvaluationResultImpl get evaluationResult => A__result;
  void set evaluationResult(EvaluationResultImpl result) {
    this.A__result = result;
  }
}
class ConstLocalVariableElementImpl extends LocalVariableElementImpl {
  EvaluationResultImpl A__result;
  ConstLocalVariableElementImpl(Identifier A_name) : super.forNode(A_name);
  EvaluationResultImpl get evaluationResult => A__result;
  void set evaluationResult(EvaluationResultImpl result) {
    this.A__result = result;
  }
}
class ConstTopLevelVariableElementImpl extends TopLevelVariableElementImpl {
  EvaluationResultImpl A__result;
  ConstTopLevelVariableElementImpl(Identifier A_name) : super.forNode(A_name);
  EvaluationResultImpl get evaluationResult => A__result;
  void set evaluationResult(EvaluationResultImpl result) {
    this.A__result = result;
  }
}
abstract class ConstructorElement implements ClassMemberElement, ExecutableElement {
  ConstructorDeclaration get node;
  ConstructorElement get redirectedConstructor;
  bool get isConst;
  bool get isDefaultConstructor;
  bool get isFactory;
}
class ConstructorElementImpl extends ExecutableElementImpl implements ConstructorElement {
  static List<ConstructorElement> B_EMPTY_ARRAY = new List<ConstructorElement>(0);
  ConstructorElement redirectedConstructor;
  List<ConstructorInitializer> constantInitializers;
  ConstructorElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  ConstructorElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitConstructorElement(this);
  ClassElement get enclosingElement => super.enclosingElement as ClassElement;
  A_ElementKind get kind => A_ElementKind.C_CONSTRUCTOR;
  ConstructorDeclaration get node => getNodeMatching((A_node) => A_node is ConstructorDeclaration);
  bool get isConst => hasModifier(Modifier.CONST);
  bool get isDefaultConstructor {
    String A_name = this.name;
    if (A_name != null && A_name.length != 0) {
      return false;
    }
    for (ParameterElement parameter in parameters) {
      if (parameter.parameterKind == ParameterKind.REQUIRED) {
        return false;
      }
    }
    return true;
  }
  bool get isFactory => hasModifier(Modifier.FACTORY);
  bool get isStatic => false;
  void set const2(bool A_isConst) {
    setModifier(Modifier.CONST, A_isConst);
  }
  void set factory(bool A_isFactory) {
    setModifier(Modifier.FACTORY, A_isFactory);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(enclosingElement.displayName);
    String A_name = displayName;
    if (A_name != null && !A_name.isEmpty) {
      A_builder.append(".");
      A_builder.append(A_name);
    }
    super.appendTo(A_builder);
  }
}
class ConstructorMember extends ExecutableMember implements ConstructorElement {
  static ConstructorElement B_from(ConstructorElement baseConstructor, InterfaceType A_definingType) {
    if (baseConstructor == null || A_definingType.typeArguments.length == 0) {
      return baseConstructor;
    }
    FunctionType baseType = baseConstructor.type;
    if (baseType == null) {
      return baseConstructor;
    }
    List<DartType> argumentTypes = A_definingType.typeArguments;
    List<DartType> A_parameterTypes = A_definingType.element.type.typeArguments;
    FunctionType substitutedType = baseType.substitute2(argumentTypes, A_parameterTypes);
    if (baseType == substitutedType) {
      return baseConstructor;
    }
    return new ConstructorMember(baseConstructor, A_definingType);
  }
  ConstructorMember(ConstructorElement A_baseElement, InterfaceType A_definingType) : super(A_baseElement, A_definingType);
  accept(ElementVisitor visitor) => visitor.visitConstructorElement(this);
  ConstructorElement get baseElement => super.baseElement as ConstructorElement;
  ClassElement get enclosingElement => baseElement.enclosingElement;
  ConstructorDeclaration get node => baseElement.node;
  ConstructorElement get redirectedConstructor => B_from(baseElement.redirectedConstructor, definingType);
  bool get isConst => baseElement.isConst;
  bool get isDefaultConstructor => baseElement.isDefaultConstructor;
  bool get isFactory => baseElement.isFactory;
  String toString() {
    ConstructorElement A_baseElement = this.baseElement;
    List<ParameterElement> A_parameters = this.parameters;
    FunctionType A_type = this.type;
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append(A_baseElement.enclosingElement.displayName);
    String A_name = displayName;
    if (A_name != null && !A_name.isEmpty) {
      A_builder.append(".");
      A_builder.append(A_name);
    }
    A_builder.append("(");
    int parameterCount = A_parameters.length;
    for (int i = 0; i < parameterCount; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      A_builder.append(A_parameters[i]).toString();
    }
    A_builder.append(")");
    if (A_type != null) {
      A_builder.append(A_Element.RIGHT_ARROW);
      A_builder.append(A_type.returnType);
    }
    return A_builder.toString();
  }
  InterfaceType get definingType => super.definingType as InterfaceType;
}
abstract class DartType {
  String get displayName;
  A_Element get element;
  DartType getLeastUpperBound(DartType A_type);
  String get name;
  bool isAssignableTo(DartType A_type);
  bool get isBottom;
  bool get isDartCoreFunction;
  bool get isDynamic;
  bool isMoreSpecificThan(DartType A_type);
  bool get isObject;
  bool isSubtypeOf(DartType A_type);
  bool get isVoid;
  DartType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes);
}
class DefaultFieldFormalParameterElementImpl extends FieldFormalParameterElementImpl {
  EvaluationResultImpl A__result;
  DefaultFieldFormalParameterElementImpl(Identifier A_name) : super(A_name);
  EvaluationResultImpl get evaluationResult => A__result;
  void set evaluationResult(EvaluationResultImpl result) {
    this.A__result = result;
  }
}
class DefaultParameterElementImpl extends ParameterElementImpl {
  EvaluationResultImpl A__result;
  DefaultParameterElementImpl(Identifier A_name) : super.forNode(A_name);
  EvaluationResultImpl get evaluationResult => A__result;
  void set evaluationResult(EvaluationResultImpl result) {
    this.A__result = result;
  }
}
class DynamicElementImpl extends ElementImpl {
  static DynamicElementImpl get instance => DynamicTypeImpl.instance.element as DynamicElementImpl;
  DynamicTypeImpl type;
  DynamicElementImpl() : super(Keyword.A_DYNAMIC.syntax, -1) {
    setModifier(Modifier.SYNTHETIC, true);
  }
  accept(ElementVisitor visitor) => null;
  A_ElementKind get kind => A_ElementKind.DYNAMIC;
}
class DynamicTypeImpl extends A_TypeImpl {
  static DynamicTypeImpl _INSTANCE = new DynamicTypeImpl();
  static DynamicTypeImpl get instance => _INSTANCE;
  DynamicTypeImpl() : super(new DynamicElementImpl(), Keyword.A_DYNAMIC.syntax) {
    (element as DynamicElementImpl).type = this;
  }
  bool operator==(Object object) => identical(object, this);
  int get hashCode => 1;
  bool get isDynamic => true;
  DartType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) {
    int A_length = A_parameterTypes.length;
    for (int i = 0; i < A_length; i++) {
      if (A_parameterTypes[i] == this) {
        return argumentTypes[i];
      }
    }
    return this;
  }
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) => identical(object, this);
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (identical(this, A_type)) {
      return true;
    }
    return withDynamic;
  }
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) => true;
}
abstract class A_Element {
  static final String RIGHT_ARROW = " \u2192 ";
  accept(ElementVisitor visitor);
  String computeDocumentationComment();
  A_Element getAncestor(A_Predicate<A_Element> predicate);
  AnalysisContext get context;
  String get displayName;
  A_Element get enclosingElement;
  String getExtendedDisplayName(String shortName);
  A_ElementKind get kind;
  LibraryElement get library;
  ElementLocation get location;
  List<ElementAnnotation> get metadata;
  String get name;
  int get nameOffset;
  AstNode get node;
  Source get source;
  CompilationUnit get unit;
  bool isAccessibleIn(LibraryElement A_library);
  bool get isDeprecated;
  bool get isOverride;
  bool get isPrivate;
  bool get isPublic;
  bool get isSynthetic;
  void visitChildren(ElementVisitor visitor);
}
abstract class ElementAnnotation {
  A_Element get element;
  bool get isDeprecated;
  bool get isOverride;
  bool get isProxy;
}
class ElementAnnotationImpl implements ElementAnnotation {
  final A_Element element;
  static List<ElementAnnotationImpl> B_EMPTY_ARRAY = new List<ElementAnnotationImpl>(0);
  static String _DEPRECATED_CLASS_NAME = "Deprecated";
  static String _DEPRECATED_VARIABLE_NAME = "deprecated";
  static String _OVERRIDE_VARIABLE_NAME = "override";
  static String PROXY_VARIABLE_NAME = "proxy";
  ElementAnnotationImpl(this.element);
  bool get isDeprecated {
    if (element != null) {
      LibraryElement library = element.library;
      if (library != null && library.isDartCore) {
        if (element is ConstructorElement) {
          ConstructorElement constructorElement = element as ConstructorElement;
          if (constructorElement.enclosingElement.name == _DEPRECATED_CLASS_NAME) {
            return true;
          }
        } else if (element is PropertyAccessorElement && element.name == _DEPRECATED_VARIABLE_NAME) {
          return true;
        }
      }
    }
    return false;
  }
  bool get isOverride {
    if (element != null) {
      LibraryElement library = element.library;
      if (library != null && library.isDartCore) {
        if (element is PropertyAccessorElement && element.name == _OVERRIDE_VARIABLE_NAME) {
          return true;
        }
      }
    }
    return false;
  }
  bool get isProxy {
    if (element != null) {
      LibraryElement library = element.library;
      if (library != null && library.isDartCore) {
        if (element is PropertyAccessorElement && element.name == PROXY_VARIABLE_NAME) {
          return true;
        }
      }
    }
    return false;
  }
  String toString() => "@${element.toString()}";
}
abstract class ElementImpl implements A_Element {
  ElementImpl _enclosingElement;
  String B__name;
  int nameOffset = 0;
  int _modifiers = 0;
  List<ElementAnnotation> metadata = ElementAnnotationImpl.B_EMPTY_ARRAY;
  int _cachedHashCode = 0;
  ElementImpl.forNode(Identifier A_name) : this(A_name == null ? "" : A_name.name, A_name == null ? -1 : A_name.offset);
  ElementImpl(String A_name, this.nameOffset) {
    this.B__name = StringUtilities.intern(A_name);
  }
  String computeDocumentationComment() {
    AnalysisContext A_context = this.context;
    if (A_context == null) {
      return null;
    }
    return A_context.computeDocumentationComment(this);
  }
  bool operator==(Object object) {
    if (identical(this, object)) {
      return true;
    }
    if (object == null || hashCode != object.hashCode) {
      return false;
    }
    return object.runtimeType == runtimeType && (object as A_Element).location == location;
  }
  A_Element getAncestor(A_Predicate<A_Element> predicate) {
    A_Element ancestor = _enclosingElement;
    while (ancestor != null && !predicate(ancestor)) {
      ancestor = ancestor.enclosingElement;
    }
    return ancestor;
  }
  ElementImpl getChild(String A_identifier) => null;
  AnalysisContext get context {
    if (_enclosingElement == null) {
      return null;
    }
    return _enclosingElement.context;
  }
  String get displayName => B__name;
  A_Element get enclosingElement => _enclosingElement;
  String getExtendedDisplayName(String shortName) {
    if (shortName == null) {
      shortName = displayName;
    }
    Source A_source = this.source;
    if (A_source != null) {
      return "${shortName} (${A_source.fullName})";
    }
    return shortName;
  }
  LibraryElement get library => getAncestor((A_element) => A_element is LibraryElement);
  ElementLocation get location => new ElementLocationImpl.B_con1(this);
  String get name => B__name;
  AstNode get node => getNodeMatching((A_node) => A_node is AstNode);
  Source get source {
    if (_enclosingElement == null) {
      return null;
    }
    return _enclosingElement.source;
  }
  CompilationUnit get unit => context.resolveCompilationUnit(source, library);
  int get hashCode {
    if (_cachedHashCode == 0) {
      int hashIdentifier = identifier.hashCode;
      A_Element enclosing = enclosingElement;
      if (enclosing != null) {
        _cachedHashCode = hashIdentifier + enclosing.hashCode;
      } else {
        _cachedHashCode = hashIdentifier;
      }
    }
    return _cachedHashCode;
  }
  bool isAccessibleIn(LibraryElement A_library) {
    if (Identifier.isPrivateName(B__name)) {
      return A_library == this.library;
    }
    return true;
  }
  bool get isDeprecated {
    for (ElementAnnotation annotation in metadata) {
      if (annotation.isDeprecated) {
        return true;
      }
    }
    return false;
  }
  bool get isOverride {
    for (ElementAnnotation annotation in metadata) {
      if (annotation.isOverride) {
        return true;
      }
    }
    return false;
  }
  bool get isPrivate {
    String A_name = displayName;
    if (A_name == null) {
      return true;
    }
    return Identifier.isPrivateName(A_name);
  }
  bool get isPublic => !isPrivate;
  bool get isSynthetic => hasModifier(Modifier.SYNTHETIC);
  void set enclosingElement(A_Element A_element) {
    _enclosingElement = A_element as ElementImpl;
  }
  void set synthetic(bool A_isSynthetic) {
    setModifier(Modifier.SYNTHETIC, A_isSynthetic);
  }
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    appendTo(A_builder);
    return A_builder.toString();
  }
  void visitChildren(ElementVisitor visitor) {}
  void appendTo(JavaStringBuilder A_builder) {
    if (B__name == null) {
      A_builder.append("<unnamed ");
      A_builder.append(runtimeType.toString());
      A_builder.append(">");
    } else {
      A_builder.append(B__name);
    }
  }
  void encloseElement(ElementImpl A_element) {
    A_element.enclosingElement = this;
  }
  String get identifier => name;
  AstNode getNodeMatching(A_Predicate<AstNode> predicate) {
    CompilationUnit A_unit = this.unit;
    if (A_unit == null) {
      return null;
    }
    int A_offset = nameOffset;
    AstNode A_node = new NodeLocator.con1(A_offset).searchWithin(A_unit);
    if (A_node == null) {
      return null;
    }
    return A_node.getAncestor(predicate);
  }
  bool hasModifier(Modifier modifier) => BooleanArray.getEnum(_modifiers, modifier);
  void safelyVisitChild(A_Element child, ElementVisitor visitor) {
    if (child != null) {
      child.accept(visitor);
    }
  }
  void safelyVisitChildren(List<A_Element> children, ElementVisitor visitor) {
    if (children != null) {
      for (A_Element child in children) {
        child.accept(visitor);
      }
    }
  }
  void setModifier(Modifier modifier, bool A_value) {
    _modifiers = BooleanArray.setEnum(_modifiers, modifier, A_value);
  }
}
class A_ElementKind extends Enum<A_ElementKind> {
  static const A_ElementKind ANGULAR_FORMATTER = const A_ElementKind('ANGULAR_FORMATTER', 0, "Angular formatter");
  static const A_ElementKind ANGULAR_COMPONENT = const A_ElementKind('ANGULAR_COMPONENT', 1, "Angular component");
  static const A_ElementKind ANGULAR_CONTROLLER = const A_ElementKind('ANGULAR_CONTROLLER', 2, "Angular controller");
  static const A_ElementKind ANGULAR_DIRECTIVE = const A_ElementKind('ANGULAR_DIRECTIVE', 3, "Angular directive");
  static const A_ElementKind ANGULAR_PROPERTY = const A_ElementKind('ANGULAR_PROPERTY', 4, "Angular property");
  static const A_ElementKind ANGULAR_SCOPE_PROPERTY = const A_ElementKind('ANGULAR_SCOPE_PROPERTY', 5, "Angular scope property");
  static const A_ElementKind ANGULAR_SELECTOR = const A_ElementKind('ANGULAR_SELECTOR', 6, "Angular selector");
  static const A_ElementKind ANGULAR_VIEW = const A_ElementKind('ANGULAR_VIEW', 7, "Angular view");
  static const A_ElementKind C_CLASS = const A_ElementKind('CLASS', 8, "class");
  static const A_ElementKind A_COMPILATION_UNIT = const A_ElementKind('COMPILATION_UNIT', 9, "compilation unit");
  static const A_ElementKind C_CONSTRUCTOR = const A_ElementKind('CONSTRUCTOR', 10, "constructor");
  static const A_ElementKind DYNAMIC = const A_ElementKind('DYNAMIC', 11, "<dynamic>");
  static const A_ElementKind EMBEDDED_HTML_SCRIPT = const A_ElementKind('EMBEDDED_HTML_SCRIPT', 12, "embedded html script");
  static const A_ElementKind B_ERROR = const A_ElementKind('ERROR', 13, "<error>");
  static const A_ElementKind EXPORT = const A_ElementKind('EXPORT', 14, "export directive");
  static const A_ElementKind EXTERNAL_HTML_SCRIPT = const A_ElementKind('EXTERNAL_HTML_SCRIPT', 15, "external html script");
  static const A_ElementKind C_FIELD = const A_ElementKind('FIELD', 16, "field");
  static const A_ElementKind C_FUNCTION = const A_ElementKind('FUNCTION', 17, "function");
  static const A_ElementKind C_GETTER = const A_ElementKind('GETTER', 18, "getter");
  static const A_ElementKind A_HTML = const A_ElementKind('HTML', 19, "html");
  static const A_ElementKind A_IMPORT = const A_ElementKind('IMPORT', 20, "import directive");
  static const A_ElementKind LABEL = const A_ElementKind('LABEL', 21, "label");
  static const A_ElementKind A_LIBRARY = const A_ElementKind('LIBRARY', 22, "library");
  static const A_ElementKind B_LOCAL_VARIABLE = const A_ElementKind('LOCAL_VARIABLE', 23, "local variable");
  static const A_ElementKind E_METHOD = const A_ElementKind('METHOD', 24, "method");
  static const A_ElementKind A_NAME = const A_ElementKind('NAME', 25, "<name>");
  static const A_ElementKind E_PARAMETER = const A_ElementKind('PARAMETER', 26, "parameter");
  static const A_ElementKind POLYMER_ATTRIBUTE = const A_ElementKind('POLYMER_ATTRIBUTE', 27, "Polymer attribute");
  static const A_ElementKind POLYMER_TAG_DART = const A_ElementKind('POLYMER_TAG_DART', 28, "Polymer Dart tag");
  static const A_ElementKind POLYMER_TAG_HTML = const A_ElementKind('POLYMER_TAG_HTML', 29, "Polymer HTML tag");
  static const A_ElementKind PREFIX = const A_ElementKind('PREFIX', 30, "import prefix");
  static const A_ElementKind C_SETTER = const A_ElementKind('SETTER', 31, "setter");
  static const A_ElementKind C_TOP_LEVEL_VARIABLE = const A_ElementKind('TOP_LEVEL_VARIABLE', 32, "top level variable");
  static const A_ElementKind C_FUNCTION_TYPE_ALIAS = const A_ElementKind('FUNCTION_TYPE_ALIAS', 33, "function type alias");
  static const A_ElementKind B_TYPE_PARAMETER = const A_ElementKind('TYPE_PARAMETER', 34, "type parameter");
  static const A_ElementKind UNIVERSE = const A_ElementKind('UNIVERSE', 35, "<universe>");
  final String displayName;
  const A_ElementKind(String A_name, int ordinal, this.displayName) : super(A_name, ordinal);
}
abstract class ElementLocation {
  List<String> get components;
  String get encoding;
}
class ElementLocationImpl implements ElementLocation {
  List<String> A__components;
  static int _SEPARATOR_CHAR = 0x3B;
  ElementLocationImpl.B_con1(A_Element A_element) {
    List<String> A_components = new List<String>();
    A_Element ancestor = A_element;
    while (ancestor != null) {
      A_components.insert(0, (ancestor as ElementImpl).identifier);
      ancestor = ancestor.enclosingElement;
    }
    this.A__components = new List.from(A_components);
  }
  ElementLocationImpl.con3(List<String> A_components) {
    this.A__components = A_components;
  }
  bool operator==(Object object) {
    if (identical(this, object)) {
      return true;
    }
    if (object is! ElementLocationImpl) {
      return false;
    }
    ElementLocationImpl A_location = object as ElementLocationImpl;
    List<String> otherComponents = A_location.A__components;
    int A_length = A__components.length;
    if (otherComponents.length != A_length) {
      return false;
    }
    for (int i = 0; i < A_length; i++) {
      if (A__components[i] != otherComponents[i]) {
        return false;
      }
    }
    return true;
  }
  List<String> get components => A__components;
  String get encoding {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    int A_length = A__components.length;
    for (int i = 0; i < A_length; i++) {
      if (i > 0) {
        A_builder.appendChar(_SEPARATOR_CHAR);
      }
      _encode(A_builder, A__components[i]);
    }
    return A_builder.toString();
  }
  int get hashCode {
    int result = 1;
    for (int i = 0; i < A__components.length; i++) {
      String component = A__components[i];
      result = 31 * result + component.hashCode;
    }
    return result;
  }
  String toString() => encoding;
  void _encode(JavaStringBuilder A_builder, String component) {
    int A_length = component.length;
    for (int i = 0; i < A_length; i++) {
      int currentChar = component.codeUnitAt(i);
      if (currentChar == _SEPARATOR_CHAR) {
        A_builder.appendChar(_SEPARATOR_CHAR);
      }
      A_builder.appendChar(currentChar);
    }
  }
}
class ElementPair {
  final A_Element A__first;
  final A_Element A__second;
  ElementPair(this.A__first, this.A__second);
  bool operator==(Object object) {
    if (identical(object, this)) {
      return true;
    }
    if (object is ElementPair) {
      ElementPair elementPair = object;
      return (A__first == elementPair.A__first) && (A__second == elementPair.A__second);
    }
    return false;
  }
  A_Element get firstElt => A__first;
  A_Element get secondElt => A__second;
  int get hashCode => ObjectUtilities.combineHashCodes(A__first.hashCode, A__second.hashCode);
}
abstract class ElementVisitor<A_R> {
  A_R visitAngularComponentElement(AngularComponentElement A_element);
  A_R visitAngularControllerElement(AngularControllerElement A_element);
  A_R visitAngularDirectiveElement(AngularDecoratorElement A_element);
  A_R visitAngularFormatterElement(AngularFormatterElement A_element);
  A_R visitAngularPropertyElement(AngularPropertyElement A_element);
  A_R visitAngularScopePropertyElement(AngularScopePropertyElement A_element);
  A_R visitAngularSelectorElement(AngularSelectorElement A_element);
  A_R visitAngularViewElement(AngularViewElement A_element);
  A_R visitClassElement(ClassElement A_element);
  A_R visitCompilationUnitElement(CompilationUnitElement A_element);
  A_R visitConstructorElement(ConstructorElement A_element);
  A_R visitEmbeddedHtmlScriptElement(EmbeddedHtmlScriptElement A_element);
  A_R visitExportElement(ExportElement A_element);
  A_R visitExternalHtmlScriptElement(ExternalHtmlScriptElement A_element);
  A_R visitFieldElement(FieldElement A_element);
  A_R visitFieldFormalParameterElement(FieldFormalParameterElement A_element);
  A_R visitFunctionElement(FunctionElement A_element);
  A_R visitFunctionTypeAliasElement(FunctionTypeAliasElement A_element);
  A_R visitHtmlElement(HtmlElement A_element);
  A_R visitImportElement(ImportElement A_element);
  A_R visitLabelElement(LabelElement A_element);
  A_R visitLibraryElement(LibraryElement A_element);
  A_R visitLocalVariableElement(LocalVariableElement A_element);
  A_R visitMethodElement(MethodElement A_element);
  A_R visitMultiplyDefinedElement(MultiplyDefinedElement A_element);
  A_R visitParameterElement(ParameterElement A_element);
  A_R visitPolymerAttributeElement(PolymerAttributeElement A_element);
  A_R visitPolymerTagDartElement(PolymerTagDartElement A_element);
  A_R visitPolymerTagHtmlElement(PolymerTagHtmlElement A_element);
  A_R visitPrefixElement(PrefixElement A_element);
  A_R visitPropertyAccessorElement(PropertyAccessorElement A_element);
  A_R visitTopLevelVariableElement(TopLevelVariableElement A_element);
  A_R visitTypeParameterElement(TypeParameterElement A_element);
}
abstract class EmbeddedHtmlScriptElement implements HtmlScriptElement {}
class EmbeddedHtmlScriptElementImpl extends HtmlScriptElementImpl implements EmbeddedHtmlScriptElement {
  LibraryElement _scriptLibrary;
  EmbeddedHtmlScriptElementImpl(XmlTagNode node) : super(node);
  accept(ElementVisitor visitor) => visitor.visitEmbeddedHtmlScriptElement(this);
  A_ElementKind get kind => A_ElementKind.EMBEDDED_HTML_SCRIPT;
  void set scriptLibrary(LibraryElementImpl A_scriptLibrary) {
    A_scriptLibrary.enclosingElement = this;
    this._scriptLibrary = A_scriptLibrary;
  }
  void visitChildren(ElementVisitor visitor) {
    safelyVisitChild(_scriptLibrary, visitor);
  }
}
abstract class ExecutableElement implements A_Element {
  List<FunctionElement> get functions;
  List<LabelElement> get labels;
  List<LocalVariableElement> get localVariables;
  List<ParameterElement> get parameters;
  DartType get returnType;
  FunctionType get type;
  bool get isOperator;
  bool get isStatic;
}
abstract class ExecutableElementImpl extends ElementImpl implements ExecutableElement {
  List<FunctionElement> _functions = FunctionElementImpl.B_EMPTY_ARRAY;
  List<LabelElement> A__labels = LabelElementImpl.B_EMPTY_ARRAY;
  List<LocalVariableElement> _localVariables = LocalVariableElementImpl.B_EMPTY_ARRAY;
  List<ParameterElement> B__parameters = ParameterElementImpl.B_EMPTY_ARRAY;
  DartType returnType;
  FunctionType type;
  ExecutableElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  ExecutableElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  ElementImpl getChild(String identifier) {
    for (ExecutableElement A_function in _functions) {
      if ((A_function as ExecutableElementImpl).identifier == identifier) {
        return A_function as ExecutableElementImpl;
      }
    }
    for (LabelElement label in A__labels) {
      if ((label as LabelElementImpl).identifier == identifier) {
        return label as LabelElementImpl;
      }
    }
    for (VariableElement variable in _localVariables) {
      if ((variable as VariableElementImpl).identifier == identifier) {
        return variable as VariableElementImpl;
      }
    }
    for (ParameterElement parameter in B__parameters) {
      if ((parameter as ParameterElementImpl).identifier == identifier) {
        return parameter as ParameterElementImpl;
      }
    }
    return null;
  }
  List<FunctionElement> get functions => _functions;
  List<LabelElement> get labels => A__labels;
  List<LocalVariableElement> get localVariables => _localVariables;
  List<ParameterElement> get parameters => B__parameters;
  bool get isOperator => false;
  void set functions(List<FunctionElement> A_functions) {
    for (FunctionElement A_function in A_functions) {
      (A_function as FunctionElementImpl).enclosingElement = this;
    }
    this._functions = A_functions;
  }
  void set labels(List<LabelElement> A_labels) {
    for (LabelElement label in A_labels) {
      (label as LabelElementImpl).enclosingElement = this;
    }
    this.A__labels = A_labels;
  }
  void set localVariables(List<LocalVariableElement> A_localVariables) {
    for (LocalVariableElement variable in A_localVariables) {
      (variable as LocalVariableElementImpl).enclosingElement = this;
    }
    this._localVariables = A_localVariables;
  }
  void set parameters(List<ParameterElement> A_parameters) {
    for (ParameterElement parameter in A_parameters) {
      (parameter as ParameterElementImpl).enclosingElement = this;
    }
    this.B__parameters = A_parameters;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(_functions, visitor);
    safelyVisitChildren(A__labels, visitor);
    safelyVisitChildren(_localVariables, visitor);
    safelyVisitChildren(B__parameters, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    if (this.kind != A_ElementKind.C_GETTER) {
      A_builder.append("(");
      String A_closing = null;
      ParameterKind kind = ParameterKind.REQUIRED;
      int parameterCount = B__parameters.length;
      for (int i = 0; i < parameterCount; i++) {
        if (i > 0) {
          A_builder.append(", ");
        }
        ParameterElementImpl parameter = B__parameters[i] as ParameterElementImpl;
        ParameterKind parameterKind = parameter.parameterKind;
        if (parameterKind != kind) {
          if (A_closing != null) {
            A_builder.append(A_closing);
          }
          if (parameterKind == ParameterKind.POSITIONAL) {
            A_builder.append("[");
            A_closing = "]";
          } else if (parameterKind == ParameterKind.NAMED) {
            A_builder.append("{");
            A_closing = "}";
          } else {
            A_closing = null;
          }
        }
        kind = parameterKind;
        parameter.appendToWithoutDelimiters(A_builder);
      }
      if (A_closing != null) {
        A_builder.append(A_closing);
      }
      A_builder.append(")");
    }
    if (type != null) {
      A_builder.append(A_Element.RIGHT_ARROW);
      A_builder.append(type.returnType);
    }
  }
}
abstract class ExecutableMember extends Member implements ExecutableElement {
  ExecutableMember(ExecutableElement A_baseElement, InterfaceType definingType) : super(A_baseElement, definingType);
  ExecutableElement get baseElement => super.baseElement as ExecutableElement;
  List<FunctionElement> get functions {
    throw new UnsupportedOperationException();
  }
  List<LabelElement> get labels => baseElement.labels;
  List<LocalVariableElement> get localVariables {
    throw new UnsupportedOperationException();
  }
  List<ParameterElement> get parameters {
    List<ParameterElement> baseParameters = baseElement.parameters;
    int parameterCount = baseParameters.length;
    if (parameterCount == 0) {
      return baseParameters;
    }
    List<ParameterElement> parameterizedParameters = new List<ParameterElement>(parameterCount);
    for (int i = 0; i < parameterCount; i++) {
      parameterizedParameters[i] = ParameterMember.B_from(baseParameters[i], definingType);
    }
    return parameterizedParameters;
  }
  DartType get returnType => substituteFor(baseElement.returnType);
  FunctionType get type => substituteFor(baseElement.type);
  bool get isOperator => baseElement.isOperator;
  bool get isStatic => baseElement.isStatic;
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(baseElement.functions, visitor);
    safelyVisitChildren(labels, visitor);
    safelyVisitChildren(baseElement.localVariables, visitor);
    safelyVisitChildren(parameters, visitor);
  }
}
abstract class ExportElement implements A_Element, UriReferencedElement {
  static final List<ExportElement> B_EMPTY_ARRAY = new List<ExportElement>(0);
  List<NamespaceCombinator> get combinators;
  LibraryElement get exportedLibrary;
}
class ExportElementImpl extends UriReferencedElementImpl implements ExportElement {
  LibraryElement exportedLibrary;
  List<NamespaceCombinator> combinators = NamespaceCombinator.B_EMPTY_ARRAY;
  ExportElementImpl() : super(null, -1);
  accept(ElementVisitor visitor) => visitor.visitExportElement(this);
  A_ElementKind get kind => A_ElementKind.EXPORT;
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append("export ");
    (exportedLibrary as LibraryElementImpl).appendTo(A_builder);
  }
  String get identifier => exportedLibrary.name;
}
abstract class ExternalHtmlScriptElement implements HtmlScriptElement {
  Source get scriptSource;
}
class ExternalHtmlScriptElementImpl extends HtmlScriptElementImpl implements ExternalHtmlScriptElement {
  Source scriptSource;
  ExternalHtmlScriptElementImpl(XmlTagNode node) : super(node);
  accept(ElementVisitor visitor) => visitor.visitExternalHtmlScriptElement(this);
  A_ElementKind get kind => A_ElementKind.EXTERNAL_HTML_SCRIPT;
}
abstract class FieldElement implements ClassMemberElement, PropertyInducingElement {}
class FieldElementImpl extends PropertyInducingElementImpl implements FieldElement {
  static List<FieldElement> B_EMPTY_ARRAY = new List<FieldElement>(0);
  FieldElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  FieldElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitFieldElement(this);
  ClassElement get enclosingElement => super.enclosingElement as ClassElement;
  A_ElementKind get kind => A_ElementKind.C_FIELD;
  bool get isStatic => hasModifier(Modifier.STATIC);
  void set static(bool A_isStatic) {
    setModifier(Modifier.STATIC, A_isStatic);
  }
}
abstract class FieldFormalParameterElement implements ParameterElement {
  FieldElement get field;
}
class FieldFormalParameterElementImpl extends ParameterElementImpl implements FieldFormalParameterElement {
  FieldElement field;
  FieldFormalParameterElementImpl(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitFieldFormalParameterElement(this);
  bool get isInitializingFormal => true;
}
class FieldFormalParameterMember extends ParameterMember implements FieldFormalParameterElement {
  FieldFormalParameterMember(FieldFormalParameterElement baseElement, ParameterizedType definingType) : super(baseElement, definingType);
  accept(ElementVisitor visitor) => visitor.visitFieldFormalParameterElement(this);
  FieldElement get field => (baseElement as FieldFormalParameterElement).field;
}
class FieldMember extends VariableMember implements FieldElement {
  static FieldElement B_from(FieldElement baseField, InterfaceType A_definingType) {
    if (!_isChangedByTypeSubstitution(baseField, A_definingType)) {
      return baseField;
    }
    return new FieldMember(baseField, A_definingType);
  }
  static bool _isChangedByTypeSubstitution(FieldElement baseField, InterfaceType A_definingType) {
    List<DartType> argumentTypes = A_definingType.typeArguments;
    if (baseField != null && argumentTypes.length != 0) {
      DartType baseType = baseField.type;
      List<DartType> A_parameterTypes = A_definingType.element.type.typeArguments;
      if (baseType != null) {
        DartType substitutedType = baseType.substitute2(argumentTypes, A_parameterTypes);
        if (baseType != substitutedType) {
          return true;
        }
      }
      DartType basePropagatedType = baseField.propagatedType;
      if (basePropagatedType != null) {
        DartType substitutedPropagatedType = basePropagatedType.substitute2(argumentTypes, A_parameterTypes);
        if (basePropagatedType != substitutedPropagatedType) {
          return true;
        }
      }
    }
    return false;
  }
  FieldMember(FieldElement A_baseElement, InterfaceType A_definingType) : super(A_baseElement, A_definingType);
  accept(ElementVisitor visitor) => visitor.visitFieldElement(this);
  FieldElement get baseElement => super.baseElement as FieldElement;
  ClassElement get enclosingElement => baseElement.enclosingElement;
  PropertyAccessorElement get getter => PropertyAccessorMember.B_from(baseElement.getter, definingType);
  DartType get propagatedType => substituteFor(baseElement.propagatedType);
  PropertyAccessorElement get setter => PropertyAccessorMember.B_from(baseElement.setter, definingType);
  bool get isStatic => baseElement.isStatic;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append(type);
    A_builder.append(" ");
    A_builder.append(displayName);
    return A_builder.toString();
  }
  InterfaceType get definingType => super.definingType as InterfaceType;
}
abstract class FunctionElement implements ExecutableElement, LocalElement {
  static final String CALL_METHOD_NAME = "call";
  static final String NO_SUCH_METHOD_METHOD_NAME = "noSuchMethod";
  static final String LOAD_LIBRARY_NAME = "loadLibrary";
  FunctionDeclaration get node;
}
class FunctionElementImpl extends ExecutableElementImpl implements FunctionElement {
  int _visibleRangeOffset = 0;
  int _visibleRangeLength = -1;
  static List<FunctionElement> B_EMPTY_ARRAY = new List<FunctionElement>(0);
  FunctionElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  FunctionElementImpl.forOffset(int nameOffset) : super("", nameOffset);
  FunctionElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitFunctionElement(this);
  A_ElementKind get kind => A_ElementKind.C_FUNCTION;
  FunctionDeclaration get node => getNodeMatching((A_node) => A_node is FunctionDeclaration);
  bool get isStatic => enclosingElement is CompilationUnitElement;
  void setVisibleRange(int A_offset, int A_length) {
    _visibleRangeOffset = A_offset;
    _visibleRangeLength = A_length;
  }
  void appendTo(JavaStringBuilder A_builder) {
    String A_name = displayName;
    if (A_name != null) {
      A_builder.append(A_name);
    }
    super.appendTo(A_builder);
  }
  String get identifier {
    String A_identifier = super.identifier;
    if (!isStatic) {
      A_identifier += "@${nameOffset}";
    }
    return A_identifier;
  }
}
abstract class FunctionType implements ParameterizedType {
  Map<String, DartType> get namedParameterTypes;
  List<DartType> get normalParameterTypes;
  List<DartType> get optionalParameterTypes;
  List<ParameterElement> get parameters;
  DartType get returnType;
  bool isSubtypeOf(DartType A_type);
  FunctionType substitute3(List<DartType> argumentTypes);
  FunctionType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes);
}
abstract class FunctionTypeAliasElement implements A_Element {
  CompilationUnitElement get enclosingElement;
  FunctionTypeAlias get node;
  List<ParameterElement> get parameters;
  DartType get returnType;
  FunctionType get type;
  List<TypeParameterElement> get typeParameters;
}
class FunctionTypeAliasElementImpl extends ElementImpl implements FunctionTypeAliasElement {
  List<ParameterElement> B__parameters = ParameterElementImpl.B_EMPTY_ARRAY;
  DartType returnType;
  FunctionType type;
  List<TypeParameterElement> A__typeParameters = TypeParameterElementImpl.B_EMPTY_ARRAY;
  static List<FunctionTypeAliasElement> B_EMPTY_ARRAY = new List<FunctionTypeAliasElement>(0);
  FunctionTypeAliasElementImpl(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitFunctionTypeAliasElement(this);
  ElementImpl getChild(String identifier) {
    for (VariableElement parameter in B__parameters) {
      if ((parameter as VariableElementImpl).identifier == identifier) {
        return parameter as VariableElementImpl;
      }
    }
    for (TypeParameterElement typeParameter in A__typeParameters) {
      if ((typeParameter as TypeParameterElementImpl).identifier == identifier) {
        return typeParameter as TypeParameterElementImpl;
      }
    }
    return null;
  }
  CompilationUnitElement get enclosingElement => super.enclosingElement as CompilationUnitElement;
  A_ElementKind get kind => A_ElementKind.C_FUNCTION_TYPE_ALIAS;
  FunctionTypeAlias get node => getNodeMatching((A_node) => A_node is FunctionTypeAlias);
  List<ParameterElement> get parameters => B__parameters;
  List<TypeParameterElement> get typeParameters => A__typeParameters;
  void set parameters(List<ParameterElement> A_parameters) {
    if (A_parameters != null) {
      for (ParameterElement parameter in A_parameters) {
        (parameter as ParameterElementImpl).enclosingElement = this;
      }
    }
    this.B__parameters = A_parameters;
  }
  void set typeParameters(List<TypeParameterElement> A_typeParameters) {
    for (TypeParameterElement typeParameter in A_typeParameters) {
      (typeParameter as TypeParameterElementImpl).enclosingElement = this;
    }
    this.A__typeParameters = A_typeParameters;
  }
  void shareParameters(List<ParameterElement> A_parameters) {
    this.B__parameters = A_parameters;
  }
  void shareTypeParameters(List<TypeParameterElement> A_typeParameters) {
    this.A__typeParameters = A_typeParameters;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(B__parameters, visitor);
    safelyVisitChildren(A__typeParameters, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append("typedef ");
    A_builder.append(displayName);
    int typeParameterCount = A__typeParameters.length;
    if (typeParameterCount > 0) {
      A_builder.append("<");
      for (int i = 0; i < typeParameterCount; i++) {
        if (i > 0) {
          A_builder.append(", ");
        }
        (A__typeParameters[i] as TypeParameterElementImpl).appendTo(A_builder);
      }
      A_builder.append(">");
    }
    A_builder.append("(");
    int parameterCount = B__parameters.length;
    for (int i = 0; i < parameterCount; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      (B__parameters[i] as ParameterElementImpl).appendTo(A_builder);
    }
    A_builder.append(")");
    if (type != null) {
      A_builder.append(A_Element.RIGHT_ARROW);
      A_builder.append(type.returnType);
    }
  }
}
class FunctionTypeImpl extends A_TypeImpl implements FunctionType {
  static bool A__equals(Map<String, DartType> firstTypes, Map<String, DartType> secondTypes, Set<ElementPair> visitedElementPairs) {
    if (secondTypes.length != firstTypes.length) {
      return false;
    }
    JavaIterator<MapEntry<String, DartType>> firstIterator = new JavaIterator(getMapEntrySet(firstTypes));
    JavaIterator<MapEntry<String, DartType>> secondIterator = new JavaIterator(getMapEntrySet(secondTypes));
    while (firstIterator.hasNext) {
      MapEntry<String, DartType> A_firstEntry = firstIterator.next();
      MapEntry<String, DartType> secondEntry = secondIterator.next();
      if (A_firstEntry.getKey() != secondEntry.getKey() || !(A_firstEntry.getValue() as A_TypeImpl).internalEquals(secondEntry.getValue(), visitedElementPairs)) {
        return false;
      }
    }
    return true;
  }
  List<DartType> typeArguments = A_TypeImpl.B_EMPTY_ARRAY;
  FunctionTypeImpl.B_con1(ExecutableElement A_element) : super(A_element, A_element == null ? null : A_element.name);
  FunctionTypeImpl.B_con2(FunctionTypeAliasElement A_element) : super(A_element, A_element == null ? null : A_element.name);
  bool operator==(Object object) => internalEquals(object, new A_p.HashSet<ElementPair>());
  String get displayName {
    String A_name = this.name;
    if (A_name == null || A_name.length == 0) {
      List<DartType> A_normalParameterTypes = this.normalParameterTypes;
      List<DartType> A_optionalParameterTypes = this.optionalParameterTypes;
      Map<String, DartType> A_namedParameterTypes = this.namedParameterTypes;
      DartType A_returnType = this.returnType;
      JavaStringBuilder A_builder = new JavaStringBuilder();
      A_builder.append("(");
      bool needsComma = false;
      if (A_normalParameterTypes.length > 0) {
        for (DartType A_type in A_normalParameterTypes) {
          if (needsComma) {
            A_builder.append(", ");
          } else {
            needsComma = true;
          }
          A_builder.append(A_type.displayName);
        }
      }
      if (A_optionalParameterTypes.length > 0) {
        if (needsComma) {
          A_builder.append(", ");
          needsComma = false;
        }
        A_builder.append("[");
        for (DartType A_type in A_optionalParameterTypes) {
          if (needsComma) {
            A_builder.append(", ");
          } else {
            needsComma = true;
          }
          A_builder.append(A_type.displayName);
        }
        A_builder.append("]");
        needsComma = true;
      }
      if (A_namedParameterTypes.length > 0) {
        if (needsComma) {
          A_builder.append(", ");
          needsComma = false;
        }
        A_builder.append("{");
        for (MapEntry<String, DartType> A_entry in getMapEntrySet(A_namedParameterTypes)) {
          if (needsComma) {
            A_builder.append(", ");
          } else {
            needsComma = true;
          }
          A_builder.append(A_entry.getKey());
          A_builder.append(": ");
          A_builder.append(A_entry.getValue().displayName);
        }
        A_builder.append("}");
        needsComma = true;
      }
      A_builder.append(")");
      A_builder.append(A_Element.RIGHT_ARROW);
      if (A_returnType == null) {
        A_builder.append("null");
      } else {
        A_builder.append(A_returnType.displayName);
      }
      A_name = A_builder.toString();
    }
    return A_name;
  }
  Map<String, DartType> get namedParameterTypes {
    A_p.LinkedHashMap<String, DartType> A_namedParameterTypes = new A_p.LinkedHashMap<String,DartType>();
    List<ParameterElement> A_parameters = baseParameters;
    if (A_parameters.length == 0) {
      return A_namedParameterTypes;
    }
    List<DartType> A_typeParameters = TypeParameterTypeImpl.getTypes(this.typeParameters);
    for (ParameterElement parameter in A_parameters) {
      if (parameter.parameterKind == ParameterKind.NAMED) {
        DartType A_type = parameter.type;
        if (typeArguments.length != 0 && typeArguments.length == A_typeParameters.length) {
          A_type = A_type.substitute2(typeArguments, A_typeParameters);
        }
        A_namedParameterTypes[parameter.name] = A_type;
      }
    }
    return A_namedParameterTypes;
  }
  List<DartType> get normalParameterTypes {
    List<ParameterElement> A_parameters = baseParameters;
    if (A_parameters.length == 0) {
      return A_TypeImpl.B_EMPTY_ARRAY;
    }
    List<DartType> A_typeParameters = TypeParameterTypeImpl.getTypes(this.typeParameters);
    List<DartType> A_types = new List<DartType>();
    for (ParameterElement parameter in A_parameters) {
      if (parameter.parameterKind == ParameterKind.REQUIRED) {
        DartType A_type = parameter.type;
        if (typeArguments.length != 0 && typeArguments.length == A_typeParameters.length) {
          A_type = A_type.substitute2(typeArguments, A_typeParameters);
        }
        A_types.add(A_type);
      }
    }
    return new List.from(A_types);
  }
  List<DartType> get optionalParameterTypes {
    List<ParameterElement> A_parameters = baseParameters;
    if (A_parameters.length == 0) {
      return A_TypeImpl.B_EMPTY_ARRAY;
    }
    List<DartType> A_typeParameters = TypeParameterTypeImpl.getTypes(this.typeParameters);
    List<DartType> A_types = new List<DartType>();
    for (ParameterElement parameter in A_parameters) {
      if (parameter.parameterKind == ParameterKind.POSITIONAL) {
        DartType A_type = parameter.type;
        if (typeArguments.length != 0 && typeArguments.length == A_typeParameters.length) {
          A_type = A_type.substitute2(typeArguments, A_typeParameters);
        }
        A_types.add(A_type);
      }
    }
    return new List.from(A_types);
  }
  List<ParameterElement> get parameters {
    List<ParameterElement> A_baseParameters = this.baseParameters;
    int parameterCount = A_baseParameters.length;
    if (parameterCount == 0) {
      return A_baseParameters;
    }
    List<ParameterElement> specializedParameters = new List<ParameterElement>(parameterCount);
    for (int i = 0; i < parameterCount; i++) {
      specializedParameters[i] = ParameterMember.B_from(A_baseParameters[i], this);
    }
    return specializedParameters;
  }
  DartType get returnType {
    DartType A_baseReturnType = this.baseReturnType;
    if (A_baseReturnType == null) {
      return DynamicTypeImpl.instance;
    }
    if (typeArguments.length == 0 || typeArguments.length != typeParameters.length) {
      return A_baseReturnType;
    }
    return A_baseReturnType.substitute2(typeArguments, TypeParameterTypeImpl.getTypes(typeParameters));
  }
  List<TypeParameterElement> get typeParameters {
    A_Element A_element = this.element;
    if (A_element is FunctionTypeAliasElement) {
      return A_element.typeParameters;
    }
    ClassElement definingClass = A_element.getAncestor((A_element) => A_element is ClassElement);
    if (definingClass != null) {
      return definingClass.typeParameters;
    }
    return TypeParameterElementImpl.B_EMPTY_ARRAY;
  }
  int get hashCode {
    if (element == null) {
      return 0;
    }
    List<DartType> A_normalParameterTypes = this.normalParameterTypes;
    List<DartType> A_optionalParameterTypes = this.optionalParameterTypes;
    Iterable<DartType> A_namedParameterTypes = this.namedParameterTypes.values;
    int A_hashCode = returnType.hashCode;
    for (int i = 0; i < A_normalParameterTypes.length; i++) {
      A_hashCode = (A_hashCode << 1) + A_normalParameterTypes[i].hashCode;
    }
    for (int i = 0; i < A_optionalParameterTypes.length; i++) {
      A_hashCode = (A_hashCode << 1) + A_optionalParameterTypes[i].hashCode;
    }
    for (DartType A_type in A_namedParameterTypes) {
      A_hashCode = (A_hashCode << 1) + A_type.hashCode;
    }
    return A_hashCode;
  }
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (A_type == null) {
      return false;
    } else if (identical(this, A_type) || A_type.isDynamic || A_type.isDartCoreFunction || A_type.isObject) {
      return true;
    } else if (A_type is! FunctionType) {
      return false;
    } else if (this == A_type) {
      return true;
    }
    FunctionType t = this;
    FunctionType s = A_type as FunctionType;
    List<DartType> tTypes = t.normalParameterTypes;
    List<DartType> tOpTypes = t.optionalParameterTypes;
    List<DartType> sTypes = s.normalParameterTypes;
    List<DartType> sOpTypes = s.optionalParameterTypes;
    if ((sOpTypes.length > 0 && t.namedParameterTypes.length > 0) || (tOpTypes.length > 0 && s.namedParameterTypes.length > 0)) {
      return false;
    }
    if (t.namedParameterTypes.length > 0) {
      if (t.normalParameterTypes.length != s.normalParameterTypes.length) {
        return false;
      } else if (t.normalParameterTypes.length > 0) {
        for (int i = 0; i < tTypes.length; i++) {
          if (!(tTypes[i] as A_TypeImpl).isMoreSpecificThan2(sTypes[i], withDynamic, visitedTypePairs)) {
            return false;
          }
        }
      }
      Map<String, DartType> namedTypesT = t.namedParameterTypes;
      Map<String, DartType> namedTypesS = s.namedParameterTypes;
      if (namedTypesT.length < namedTypesS.length) {
        return false;
      }
      JavaIterator<MapEntry<String, DartType>> iteratorS = new JavaIterator(getMapEntrySet(namedTypesS));
      while (iteratorS.hasNext) {
        MapEntry<String, DartType> entryS = iteratorS.next();
        DartType typeT = namedTypesT[entryS.getKey()];
        if (typeT == null) {
          return false;
        }
        if (!(typeT as A_TypeImpl).isMoreSpecificThan2(entryS.getValue(), withDynamic, visitedTypePairs)) {
          return false;
        }
      }
    } else if (s.namedParameterTypes.length > 0) {
      return false;
    } else {
      int tArgLength = tTypes.length + tOpTypes.length;
      int sArgLength = sTypes.length + sOpTypes.length;
      if (tArgLength < sArgLength || sTypes.length < tTypes.length) {
        return false;
      }
      if (tOpTypes.length == 0 && sOpTypes.length == 0) {
        for (int i = 0; i < sTypes.length; i++) {
          if (!(tTypes[i] as A_TypeImpl).isMoreSpecificThan2(sTypes[i], withDynamic, visitedTypePairs)) {
            return false;
          }
        }
      } else {
        List<DartType> tAllTypes = new List<DartType>(sArgLength);
        for (int i = 0; i < tTypes.length; i++) {
          tAllTypes[i] = tTypes[i];
        }
        for (int i = tTypes.length, j = 0; i < sArgLength; i++, j++) {
          tAllTypes[i] = tOpTypes[j];
        }
        List<DartType> sAllTypes = new List<DartType>(sArgLength);
        for (int i = 0; i < sTypes.length; i++) {
          sAllTypes[i] = sTypes[i];
        }
        for (int i = sTypes.length, j = 0; i < sArgLength; i++, j++) {
          sAllTypes[i] = sOpTypes[j];
        }
        for (int i = 0; i < sAllTypes.length; i++) {
          if (!(tAllTypes[i] as A_TypeImpl).isMoreSpecificThan2(sAllTypes[i], withDynamic, visitedTypePairs)) {
            return false;
          }
        }
      }
    }
    DartType tRetType = t.returnType;
    DartType sRetType = s.returnType;
    return sRetType.isVoid || (tRetType as A_TypeImpl).isMoreSpecificThan2(sRetType, withDynamic, visitedTypePairs);
  }
  bool isAssignableTo(DartType A_type) => isSubtypeOf2(A_type, new A_p.HashSet<TypeImpl_TypePair>());
  FunctionTypeImpl substitute3(List<DartType> argumentTypes) => substitute2(argumentTypes, typeArguments);
  FunctionTypeImpl substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) {
    if (argumentTypes.length != A_parameterTypes.length) {
      throw new IllegalArgumentException("argumentTypes.length (${argumentTypes.length}) != parameterTypes.length (${A_parameterTypes.length})");
    }
    if (argumentTypes.length == 0) {
      return this;
    }
    A_Element A_element = this.element;
    FunctionTypeImpl newType = (A_element is ExecutableElement) ? new FunctionTypeImpl.B_con1(A_element) : new FunctionTypeImpl.B_con2(A_element as FunctionTypeAliasElement);
    newType.typeArguments = A_TypeImpl.A_substitute(typeArguments, argumentTypes, A_parameterTypes);
    return newType;
  }
  void appendTo(JavaStringBuilder A_builder) {
    List<DartType> A_normalParameterTypes = this.normalParameterTypes;
    List<DartType> A_optionalParameterTypes = this.optionalParameterTypes;
    Map<String, DartType> A_namedParameterTypes = this.namedParameterTypes;
    DartType A_returnType = this.returnType;
    A_builder.append("(");
    bool needsComma = false;
    if (A_normalParameterTypes.length > 0) {
      for (DartType A_type in A_normalParameterTypes) {
        if (needsComma) {
          A_builder.append(", ");
        } else {
          needsComma = true;
        }
        (A_type as A_TypeImpl).appendTo(A_builder);
      }
    }
    if (A_optionalParameterTypes.length > 0) {
      if (needsComma) {
        A_builder.append(", ");
        needsComma = false;
      }
      A_builder.append("[");
      for (DartType A_type in A_optionalParameterTypes) {
        if (needsComma) {
          A_builder.append(", ");
        } else {
          needsComma = true;
        }
        (A_type as A_TypeImpl).appendTo(A_builder);
      }
      A_builder.append("]");
      needsComma = true;
    }
    if (A_namedParameterTypes.length > 0) {
      if (needsComma) {
        A_builder.append(", ");
        needsComma = false;
      }
      A_builder.append("{");
      for (MapEntry<String, DartType> A_entry in getMapEntrySet(A_namedParameterTypes)) {
        if (needsComma) {
          A_builder.append(", ");
        } else {
          needsComma = true;
        }
        A_builder.append(A_entry.getKey());
        A_builder.append(": ");
        (A_entry.getValue() as A_TypeImpl).appendTo(A_builder);
      }
      A_builder.append("}");
      needsComma = true;
    }
    A_builder.append(")");
    A_builder.append(A_Element.RIGHT_ARROW);
    if (A_returnType == null) {
      A_builder.append("null");
    } else {
      (A_returnType as A_TypeImpl).appendTo(A_builder);
    }
  }
  List<ParameterElement> get baseParameters {
    A_Element A_element = this.element;
    if (A_element is ExecutableElement) {
      return A_element.parameters;
    } else {
      return (A_element as FunctionTypeAliasElement).parameters;
    }
  }
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) {
    if (object is! FunctionTypeImpl) {
      return false;
    }
    FunctionTypeImpl otherType = object as FunctionTypeImpl;
    ElementPair elementPair = new ElementPair(element, otherType.element);
    if (!visitedElementPairs.add(elementPair)) {
      return elementPair.firstElt == elementPair.secondElt;
    }
    bool result = A_TypeImpl.equalArrays(normalParameterTypes, otherType.normalParameterTypes, visitedElementPairs) && A_TypeImpl.equalArrays(optionalParameterTypes, otherType.optionalParameterTypes, visitedElementPairs) && A__equals(namedParameterTypes, otherType.namedParameterTypes, visitedElementPairs) && (returnType as A_TypeImpl).internalEquals(otherType.returnType, visitedElementPairs);
    visitedElementPairs.remove(elementPair);
    return result;
  }
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (A_type == null) {
      return false;
    } else if (identical(this, A_type) || A_type.isDynamic || A_type.isDartCoreFunction || A_type.isObject) {
      return true;
    } else if (A_type is! FunctionType) {
      return false;
    } else if (this == A_type) {
      return true;
    }
    FunctionType t = this;
    FunctionType s = A_type as FunctionType;
    List<DartType> tTypes = t.normalParameterTypes;
    List<DartType> tOpTypes = t.optionalParameterTypes;
    List<DartType> sTypes = s.normalParameterTypes;
    List<DartType> sOpTypes = s.optionalParameterTypes;
    if ((sOpTypes.length > 0 && t.namedParameterTypes.length > 0) || (tOpTypes.length > 0 && s.namedParameterTypes.length > 0)) {
      return false;
    }
    if (t.namedParameterTypes.length > 0) {
      if (t.normalParameterTypes.length != s.normalParameterTypes.length) {
        return false;
      } else if (t.normalParameterTypes.length > 0) {
        for (int i = 0; i < tTypes.length; i++) {
          if (!(tTypes[i] as A_TypeImpl).isAssignableTo2(sTypes[i], visitedTypePairs)) {
            return false;
          }
        }
      }
      Map<String, DartType> namedTypesT = t.namedParameterTypes;
      Map<String, DartType> namedTypesS = s.namedParameterTypes;
      if (namedTypesT.length < namedTypesS.length) {
        return false;
      }
      JavaIterator<MapEntry<String, DartType>> iteratorS = new JavaIterator(getMapEntrySet(namedTypesS));
      while (iteratorS.hasNext) {
        MapEntry<String, DartType> entryS = iteratorS.next();
        DartType typeT = namedTypesT[entryS.getKey()];
        if (typeT == null) {
          return false;
        }
        if (!(typeT as A_TypeImpl).isAssignableTo2(entryS.getValue(), visitedTypePairs)) {
          return false;
        }
      }
    } else if (s.namedParameterTypes.length > 0) {
      return false;
    } else {
      int tArgLength = tTypes.length + tOpTypes.length;
      int sArgLength = sTypes.length + sOpTypes.length;
      if (tArgLength < sArgLength || sTypes.length < tTypes.length) {
        return false;
      }
      if (tOpTypes.length == 0 && sOpTypes.length == 0) {
        for (int i = 0; i < sTypes.length; i++) {
          if (!(tTypes[i] as A_TypeImpl).isAssignableTo2(sTypes[i], visitedTypePairs)) {
            return false;
          }
        }
      } else {
        List<DartType> tAllTypes = new List<DartType>(sArgLength);
        for (int i = 0; i < tTypes.length; i++) {
          tAllTypes[i] = tTypes[i];
        }
        for (int i = tTypes.length, j = 0; i < sArgLength; i++, j++) {
          tAllTypes[i] = tOpTypes[j];
        }
        List<DartType> sAllTypes = new List<DartType>(sArgLength);
        for (int i = 0; i < sTypes.length; i++) {
          sAllTypes[i] = sTypes[i];
        }
        for (int i = sTypes.length, j = 0; i < sArgLength; i++, j++) {
          sAllTypes[i] = sOpTypes[j];
        }
        for (int i = 0; i < sAllTypes.length; i++) {
          if (!(tAllTypes[i] as A_TypeImpl).isAssignableTo2(sAllTypes[i], visitedTypePairs)) {
            return false;
          }
        }
      }
    }
    DartType tRetType = t.returnType;
    DartType sRetType = s.returnType;
    return sRetType.isVoid || (tRetType as A_TypeImpl).isAssignableTo2(sRetType, visitedTypePairs);
  }
  DartType get baseReturnType {
    A_Element A_element = this.element;
    if (A_element is ExecutableElement) {
      return A_element.returnType;
    } else {
      return (A_element as FunctionTypeAliasElement).returnType;
    }
  }
}
class GeneralizingElementVisitor<A_R> implements ElementVisitor<A_R> {
  A_R visitAngularComponentElement(AngularComponentElement A_element) => visitAngularHasSelectorElement(A_element);
  A_R visitAngularControllerElement(AngularControllerElement A_element) => visitAngularHasSelectorElement(A_element);
  A_R visitAngularDirectiveElement(AngularDecoratorElement A_element) => visitAngularHasSelectorElement(A_element);
  A_R visitAngularElement(AngularElement A_element) => visitToolkitObjectElement(A_element);
  A_R visitAngularFormatterElement(AngularFormatterElement A_element) => visitAngularElement(A_element);
  A_R visitAngularHasSelectorElement(AngularHasSelectorElement A_element) => visitAngularElement(A_element);
  A_R visitAngularPropertyElement(AngularPropertyElement A_element) => visitAngularElement(A_element);
  A_R visitAngularScopePropertyElement(AngularScopePropertyElement A_element) => visitAngularElement(A_element);
  A_R visitAngularSelectorElement(AngularSelectorElement A_element) => visitAngularElement(A_element);
  A_R visitAngularViewElement(AngularViewElement A_element) => visitAngularElement(A_element);
  A_R visitClassElement(ClassElement A_element) => visitElement(A_element);
  A_R visitCompilationUnitElement(CompilationUnitElement A_element) => visitElement(A_element);
  A_R visitConstructorElement(ConstructorElement A_element) => visitExecutableElement(A_element);
  A_R visitElement(A_Element A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitEmbeddedHtmlScriptElement(EmbeddedHtmlScriptElement A_element) => visitHtmlScriptElement(A_element);
  A_R visitExecutableElement(ExecutableElement A_element) => visitElement(A_element);
  A_R visitExportElement(ExportElement A_element) => visitElement(A_element);
  A_R visitExternalHtmlScriptElement(ExternalHtmlScriptElement A_element) => visitHtmlScriptElement(A_element);
  A_R visitFieldElement(FieldElement A_element) => visitPropertyInducingElement(A_element);
  A_R visitFieldFormalParameterElement(FieldFormalParameterElement A_element) => visitParameterElement(A_element);
  A_R visitFunctionElement(FunctionElement A_element) => visitLocalElement(A_element);
  A_R visitFunctionTypeAliasElement(FunctionTypeAliasElement A_element) => visitElement(A_element);
  A_R visitHtmlElement(HtmlElement A_element) => visitElement(A_element);
  A_R visitHtmlScriptElement(HtmlScriptElement A_element) => visitElement(A_element);
  A_R visitImportElement(ImportElement A_element) => visitElement(A_element);
  A_R visitLabelElement(LabelElement A_element) => visitElement(A_element);
  A_R visitLibraryElement(LibraryElement A_element) => visitElement(A_element);
  A_R visitLocalElement(LocalElement A_element) {
    if (A_element is LocalVariableElement) {
      return visitVariableElement(A_element);
    } else if (A_element is ParameterElement) {
      return visitVariableElement(A_element);
    } else if (A_element is FunctionElement) {
      return visitExecutableElement(A_element);
    }
    return null;
  }
  A_R visitLocalVariableElement(LocalVariableElement A_element) => visitLocalElement(A_element);
  A_R visitMethodElement(MethodElement A_element) => visitExecutableElement(A_element);
  A_R visitMultiplyDefinedElement(MultiplyDefinedElement A_element) => visitElement(A_element);
  A_R visitParameterElement(ParameterElement A_element) => visitLocalElement(A_element);
  A_R visitPolymerAttributeElement(PolymerAttributeElement A_element) => visitPolymerElement(A_element);
  A_R visitPolymerElement(PolymerElement A_element) => visitToolkitObjectElement(A_element);
  A_R visitPolymerTagDartElement(PolymerTagDartElement A_element) => visitPolymerElement(A_element);
  A_R visitPolymerTagHtmlElement(PolymerTagHtmlElement A_element) => visitPolymerElement(A_element);
  A_R visitPrefixElement(PrefixElement A_element) => visitElement(A_element);
  A_R visitPropertyAccessorElement(PropertyAccessorElement A_element) => visitExecutableElement(A_element);
  A_R visitPropertyInducingElement(PropertyInducingElement A_element) => visitVariableElement(A_element);
  A_R visitToolkitObjectElement(ToolkitObjectElement A_element) => visitElement(A_element);
  A_R visitTopLevelVariableElement(TopLevelVariableElement A_element) => visitPropertyInducingElement(A_element);
  A_R visitTypeParameterElement(TypeParameterElement A_element) => visitElement(A_element);
  A_R visitVariableElement(VariableElement A_element) => visitElement(A_element);
}
class HasAttributeSelectorElementImpl extends AngularSelectorElementImpl implements AngularHasAttributeSelectorElement {
  HasAttributeSelectorElementImpl(String attributeName, int A_offset) : super(attributeName, A_offset);
  bool apply(XmlTagNode node) {
    String attributeName = name;
    return node.getAttribute(attributeName) != null;
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append("[");
    A_builder.append(name);
    A_builder.append("]");
  }
}
abstract class HideElementCombinator implements NamespaceCombinator {
  List<String> get hiddenNames;
}
class HideElementCombinatorImpl implements HideElementCombinator {
  List<String> hiddenNames = StringUtilities.E_EMPTY_ARRAY;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("show ");
    int count = hiddenNames.length;
    for (int i = 0; i < count; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      A_builder.append(hiddenNames[i]);
    }
    return A_builder.toString();
  }
}
abstract class HtmlElement implements A_Element {
  CompilationUnitElement get angularCompilationUnit;
  List<HtmlScriptElement> get scripts;
}
class HtmlElementImpl extends ElementImpl implements HtmlElement {
  final AnalysisContext context;
  List<HtmlScriptElement> _scripts = HtmlScriptElementImpl.B_EMPTY_ARRAY;
  List<PolymerTagHtmlElement> _polymerTags = PolymerTagHtmlElement.B_EMPTY_ARRAY;
  Source source;
  CompilationUnitElement angularCompilationUnit;
  HtmlElementImpl(this.context, String A_name) : super(A_name, -1);
  accept(ElementVisitor visitor) => visitor.visitHtmlElement(this);
  bool operator==(Object object) {
    if (identical(object, this)) {
      return true;
    }
    if (object == null) {
      return false;
    }
    return runtimeType == object.runtimeType && source == (object as HtmlElementImpl).source;
  }
  A_ElementKind get kind => A_ElementKind.A_HTML;
  List<HtmlScriptElement> get scripts => _scripts;
  int get hashCode => source.hashCode;
  void set polymerTags(List<PolymerTagHtmlElement> A_polymerTags) {
    if (A_polymerTags.length == 0) {
      this._polymerTags = PolymerTagHtmlElement.B_EMPTY_ARRAY;
      return;
    }
    for (PolymerTagHtmlElement tag in A_polymerTags) {
      (tag as PolymerTagHtmlElementImpl).enclosingElement = this;
    }
    this._polymerTags = A_polymerTags;
  }
  void set scripts(List<HtmlScriptElement> A_scripts) {
    if (A_scripts.length == 0) {
      this._scripts = HtmlScriptElementImpl.B_EMPTY_ARRAY;
      return;
    }
    for (HtmlScriptElement A_script in A_scripts) {
      (A_script as HtmlScriptElementImpl).enclosingElement = this;
    }
    this._scripts = A_scripts;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(_scripts, visitor);
    safelyVisitChildren(_polymerTags, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    if (source == null) {
      A_builder.append("{HTML file}");
    } else {
      A_builder.append(source.fullName);
    }
  }
  String get identifier => source.encoding;
}
abstract class HtmlScriptElement implements A_Element {}
abstract class HtmlScriptElementImpl extends ElementImpl implements HtmlScriptElement {
  static List<HtmlScriptElement> B_EMPTY_ARRAY = new List<HtmlScriptElement>(0);
  HtmlScriptElementImpl(XmlTagNode node) : super(node.tag, node.tagToken.offset);
}
abstract class ImportElement implements A_Element, UriReferencedElement {
  static final List<ImportElement> B_EMPTY_ARRAY = new List<ImportElement>(0);
  List<NamespaceCombinator> get combinators;
  LibraryElement get importedLibrary;
  PrefixElement get prefix;
  bool get isDeferred;
}
class ImportElementImpl extends UriReferencedElementImpl implements ImportElement {
  int prefixOffset = 0;
  LibraryElement importedLibrary;
  List<NamespaceCombinator> combinators = NamespaceCombinator.B_EMPTY_ARRAY;
  PrefixElement prefix;
  ImportElementImpl(int A_offset) : super(null, A_offset);
  accept(ElementVisitor visitor) => visitor.visitImportElement(this);
  A_ElementKind get kind => A_ElementKind.A_IMPORT;
  bool get isDeferred => hasModifier(Modifier.DEFERRED);
  void set deferred(bool A_isDeferred) {
    setModifier(Modifier.DEFERRED, A_isDeferred);
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(prefix, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append("import ");
    (importedLibrary as LibraryElementImpl).appendTo(A_builder);
  }
  String get identifier => "${(importedLibrary as LibraryElementImpl).identifier}@${nameOffset}";
}
abstract class InterfaceType implements ParameterizedType {
  static final List<InterfaceType> B_EMPTY_ARRAY = new List<InterfaceType>(0);
  List<PropertyAccessorElement> get accessors;
  ClassElement get element;
  PropertyAccessorElement getGetter(String getterName);
  List<InterfaceType> get interfaces;
  DartType getLeastUpperBound(DartType A_type);
  MethodElement getMethod(String methodName);
  List<MethodElement> get methods;
  List<InterfaceType> get mixins;
  PropertyAccessorElement getSetter(String setterName);
  InterfaceType get superclass;
  bool isDirectSupertypeOf(InterfaceType A_type);
  bool isMoreSpecificThan(DartType A_type);
  bool isSubtypeOf(DartType A_type);
  ConstructorElement lookUpConstructor(String constructorName, LibraryElement library);
  PropertyAccessorElement lookUpGetter(String getterName, LibraryElement library);
  PropertyAccessorElement lookUpGetterInSuperclass(String getterName, LibraryElement library);
  MethodElement lookUpMethod(String methodName, LibraryElement library);
  MethodElement lookUpMethodInSuperclass(String methodName, LibraryElement library);
  PropertyAccessorElement lookUpSetter(String setterName, LibraryElement library);
  PropertyAccessorElement lookUpSetterInSuperclass(String setterName, LibraryElement library);
  InterfaceType substitute4(List<DartType> argumentTypes);
  InterfaceType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes);
}
class InterfaceTypeImpl extends A_TypeImpl implements InterfaceType {
  static int computeLongestInheritancePathToObject(InterfaceType A_type) => _computeLongestInheritancePathToObject(A_type, 0, new A_p.HashSet<ClassElement>());
  static Set<InterfaceType> computeSuperinterfaceSet(InterfaceType A_type) => _computeSuperinterfaceSet(A_type, new A_p.HashSet<InterfaceType>());
  static int _computeLongestInheritancePathToObject(InterfaceType A_type, int depth, A_p.HashSet<ClassElement> visitedClasses) {
    ClassElement classElement = A_type.element;
    if (classElement.supertype == null || visitedClasses.contains(classElement)) {
      return depth;
    }
    int longestPath = 1;
    try {
      visitedClasses.add(classElement);
      List<InterfaceType> superinterfaces = classElement.interfaces;
      int pathLength;
      if (superinterfaces.length > 0) {
        for (InterfaceType superinterface in superinterfaces) {
          pathLength = _computeLongestInheritancePathToObject(superinterface, depth + 1, visitedClasses);
          if (pathLength > longestPath) {
            longestPath = pathLength;
          }
        }
      }
      InterfaceType supertype = classElement.supertype;
      pathLength = _computeLongestInheritancePathToObject(supertype, depth + 1, visitedClasses);
      if (pathLength > longestPath) {
        longestPath = pathLength;
      }
    } finally {
      visitedClasses.remove(classElement);
    }
    return longestPath;
  }
  static Set<InterfaceType> _computeSuperinterfaceSet(InterfaceType A_type, A_p.HashSet<InterfaceType> B_set) {
    A_Element A_element = A_type.element;
    if (A_element != null) {
      List<InterfaceType> superinterfaces = A_type.interfaces;
      for (InterfaceType superinterface in superinterfaces) {
        if (B_set.add(superinterface)) {
          _computeSuperinterfaceSet(superinterface, B_set);
        }
      }
      InterfaceType supertype = A_type.superclass;
      if (supertype != null) {
        if (B_set.add(supertype)) {
          _computeSuperinterfaceSet(supertype, B_set);
        }
      }
    }
    return B_set;
  }
  static List<InterfaceType> _intersection(Set<InterfaceType> A_first, Set<InterfaceType> A_second) {
    Set<InterfaceType> result = new A_p.HashSet<InterfaceType>.from(A_first);
    result.retainAll(A_second);
    return new List.from(result);
  }
  List<DartType> typeArguments = A_TypeImpl.B_EMPTY_ARRAY;
  InterfaceTypeImpl.B_con1(ClassElement A_element) : super(A_element, A_element.displayName);
  bool operator==(Object object) => internalEquals(object, new A_p.HashSet<ElementPair>());
  List<PropertyAccessorElement> get accessors {
    List<PropertyAccessorElement> A_accessors = element.accessors;
    List<PropertyAccessorElement> members = new List<PropertyAccessorElement>(A_accessors.length);
    for (int i = 0; i < A_accessors.length; i++) {
      members[i] = PropertyAccessorMember.B_from(A_accessors[i], this);
    }
    return members;
  }
  String get displayName {
    String A_name = this.name;
    List<DartType> A_typeArguments = this.typeArguments;
    bool allDynamic = true;
    for (DartType A_type in A_typeArguments) {
      if (A_type != null && !A_type.isDynamic) {
        allDynamic = false;
        break;
      }
    }
    if (!allDynamic) {
      JavaStringBuilder A_builder = new JavaStringBuilder();
      A_builder.append(A_name);
      A_builder.append("<");
      for (int i = 0; i < A_typeArguments.length; i++) {
        if (i != 0) {
          A_builder.append(", ");
        }
        DartType typeArg = A_typeArguments[i];
        A_builder.append(typeArg.displayName);
      }
      A_builder.append(">");
      A_name = A_builder.toString();
    }
    return A_name;
  }
  ClassElement get element => super.element as ClassElement;
  PropertyAccessorElement getGetter(String getterName) => PropertyAccessorMember.B_from((element as ClassElementImpl).getGetter(getterName), this);
  List<InterfaceType> get interfaces {
    ClassElement classElement = element;
    List<InterfaceType> A_interfaces = classElement.interfaces;
    List<TypeParameterElement> A_typeParameters = classElement.typeParameters;
    List<DartType> A_parameterTypes = classElement.type.typeArguments;
    if (A_typeParameters.length == 0) {
      return A_interfaces;
    }
    int count = A_interfaces.length;
    List<InterfaceType> typedInterfaces = new List<InterfaceType>(count);
    for (int i = 0; i < count; i++) {
      typedInterfaces[i] = A_interfaces[i].substitute2(typeArguments, A_parameterTypes);
    }
    return typedInterfaces;
  }
  DartType getLeastUpperBound(DartType A_type) {
    if (identical(A_type, this)) {
      return this;
    }
    DartType dynamicType = DynamicTypeImpl.instance;
    if (identical(this, dynamicType) || identical(A_type, dynamicType)) {
      return dynamicType;
    }
    if (A_type is! InterfaceType) {
      return null;
    }
    InterfaceType i = this;
    InterfaceType j = A_type as InterfaceType;
    Set<InterfaceType> si = computeSuperinterfaceSet(i);
    Set<InterfaceType> sj = computeSuperinterfaceSet(j);
    si.add(i);
    sj.add(j);
    List<InterfaceType> s = _intersection(si, sj);
    List<int> depths = new List<int>.filled(s.length, 0);
    int maxDepth = 0;
    for (int n = 0; n < s.length; n++) {
      depths[n] = computeLongestInheritancePathToObject(s[n]);
      if (depths[n] > maxDepth) {
        maxDepth = depths[n];
      }
    }
    for (; maxDepth >= 0; maxDepth--) {
      int indexOfLeastUpperBound = -1;
      int numberOfTypesAtMaxDepth = 0;
      for (int m = 0; m < depths.length; m++) {
        if (depths[m] == maxDepth) {
          numberOfTypesAtMaxDepth++;
          indexOfLeastUpperBound = m;
        }
      }
      if (numberOfTypesAtMaxDepth == 1) {
        return s[indexOfLeastUpperBound];
      }
    }
    return null;
  }
  MethodElement getMethod(String methodName) => MethodMember.B_from((element as ClassElementImpl).getMethod(methodName), this);
  List<MethodElement> get methods {
    List<MethodElement> A_methods = element.methods;
    List<MethodElement> members = new List<MethodElement>(A_methods.length);
    for (int i = 0; i < A_methods.length; i++) {
      members[i] = MethodMember.B_from(A_methods[i], this);
    }
    return members;
  }
  List<InterfaceType> get mixins {
    ClassElement classElement = element;
    List<InterfaceType> A_mixins = classElement.mixins;
    List<TypeParameterElement> A_typeParameters = classElement.typeParameters;
    List<DartType> A_parameterTypes = classElement.type.typeArguments;
    if (A_typeParameters.length == 0) {
      return A_mixins;
    }
    int count = A_mixins.length;
    List<InterfaceType> typedMixins = new List<InterfaceType>(count);
    for (int i = 0; i < count; i++) {
      typedMixins[i] = A_mixins[i].substitute2(typeArguments, A_parameterTypes);
    }
    return typedMixins;
  }
  PropertyAccessorElement getSetter(String setterName) => PropertyAccessorMember.B_from((element as ClassElementImpl).getSetter(setterName), this);
  InterfaceType get superclass {
    ClassElement classElement = element;
    InterfaceType supertype = classElement.supertype;
    if (supertype == null) {
      return null;
    }
    List<DartType> A_typeParameters = classElement.type.typeArguments;
    if (typeArguments.length == 0 || typeArguments.length != A_typeParameters.length) {
      return supertype;
    }
    return supertype.substitute2(typeArguments, A_typeParameters);
  }
  List<TypeParameterElement> get typeParameters => element.typeParameters;
  int get hashCode {
    ClassElement A_element = this.element;
    if (A_element == null) {
      return 0;
    }
    return A_element.hashCode;
  }
  bool get isDartCoreFunction {
    ClassElement A_element = this.element;
    if (A_element == null) {
      return false;
    }
    return A_element.name == "Function" && A_element.library.isDartCore;
  }
  bool isDirectSupertypeOf(InterfaceType A_type) {
    InterfaceType i = this;
    InterfaceType j = A_type;
    ClassElement jElement = j.element;
    InterfaceType supertype = jElement.supertype;
    if (supertype == null) {
      return false;
    }
    List<DartType> jArgs = j.typeArguments;
    List<DartType> jVars = jElement.type.typeArguments;
    supertype = supertype.substitute2(jArgs, jVars);
    if (supertype == i) {
      return true;
    }
    for (InterfaceType interfaceType in jElement.interfaces) {
      interfaceType = interfaceType.substitute2(jArgs, jVars);
      if (interfaceType == i) {
        return true;
      }
    }
    for (InterfaceType mixinType in jElement.mixins) {
      mixinType = mixinType.substitute2(jArgs, jVars);
      if (mixinType == i) {
        return true;
      }
    }
    return false;
  }
  bool get isObject => element.supertype == null;
  ConstructorElement lookUpConstructor(String constructorName, LibraryElement library) {
    ConstructorElement constructorElement;
    if (constructorName == null) {
      constructorElement = element.unnamedConstructor;
    } else {
      constructorElement = element.getNamedConstructor(constructorName);
    }
    if (constructorElement == null || !constructorElement.isAccessibleIn(library)) {
      return null;
    }
    return ConstructorMember.B_from(constructorElement, this);
  }
  PropertyAccessorElement lookUpGetter(String getterName, LibraryElement library) {
    PropertyAccessorElement A_element = getGetter(getterName);
    if (A_element != null && A_element.isAccessibleIn(library)) {
      return A_element;
    }
    return lookUpGetterInSuperclass(getterName, library);
  }
  PropertyAccessorElement lookUpGetterInSuperclass(String getterName, LibraryElement library) {
    for (InterfaceType mixin in mixins) {
      PropertyAccessorElement A_element = mixin.getGetter(getterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    InterfaceType supertype = superclass;
    ClassElement supertypeElement = supertype == null ? null : supertype.element;
    while (supertype != null && !visitedClasses.contains(supertypeElement)) {
      visitedClasses.add(supertypeElement);
      PropertyAccessorElement A_element = supertype.getGetter(getterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
      for (InterfaceType mixin in supertype.mixins) {
        A_element = mixin.getGetter(getterName);
        if (A_element != null && A_element.isAccessibleIn(library)) {
          return A_element;
        }
      }
      supertype = supertype.superclass;
      supertypeElement = supertype == null ? null : supertype.element;
    }
    return null;
  }
  MethodElement lookUpMethod(String methodName, LibraryElement library) {
    MethodElement A_element = getMethod(methodName);
    if (A_element != null && A_element.isAccessibleIn(library)) {
      return A_element;
    }
    return lookUpMethodInSuperclass(methodName, library);
  }
  MethodElement lookUpMethodInSuperclass(String methodName, LibraryElement library) {
    for (InterfaceType mixin in mixins) {
      MethodElement A_element = mixin.getMethod(methodName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    InterfaceType supertype = superclass;
    ClassElement supertypeElement = supertype == null ? null : supertype.element;
    while (supertype != null && !visitedClasses.contains(supertypeElement)) {
      visitedClasses.add(supertypeElement);
      MethodElement A_element = supertype.getMethod(methodName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
      for (InterfaceType mixin in supertype.mixins) {
        A_element = mixin.getMethod(methodName);
        if (A_element != null && A_element.isAccessibleIn(library)) {
          return A_element;
        }
      }
      supertype = supertype.superclass;
      supertypeElement = supertype == null ? null : supertype.element;
    }
    return null;
  }
  PropertyAccessorElement lookUpSetter(String setterName, LibraryElement library) {
    PropertyAccessorElement A_element = getSetter(setterName);
    if (A_element != null && A_element.isAccessibleIn(library)) {
      return A_element;
    }
    return lookUpSetterInSuperclass(setterName, library);
  }
  PropertyAccessorElement lookUpSetterInSuperclass(String setterName, LibraryElement library) {
    for (InterfaceType mixin in mixins) {
      PropertyAccessorElement A_element = mixin.getSetter(setterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
    }
    A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
    InterfaceType supertype = superclass;
    ClassElement supertypeElement = supertype == null ? null : supertype.element;
    while (supertype != null && !visitedClasses.contains(supertypeElement)) {
      visitedClasses.add(supertypeElement);
      PropertyAccessorElement A_element = supertype.getSetter(setterName);
      if (A_element != null && A_element.isAccessibleIn(library)) {
        return A_element;
      }
      for (InterfaceType mixin in supertype.mixins) {
        A_element = mixin.getSetter(setterName);
        if (A_element != null && A_element.isAccessibleIn(library)) {
          return A_element;
        }
      }
      supertype = supertype.superclass;
      supertypeElement = supertype == null ? null : supertype.element;
    }
    return null;
  }
  InterfaceTypeImpl substitute4(List<DartType> argumentTypes) => substitute2(argumentTypes, typeArguments);
  InterfaceTypeImpl substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) {
    if (argumentTypes.length != A_parameterTypes.length) {
      throw new IllegalArgumentException("argumentTypes.length (${argumentTypes.length}) != parameterTypes.length (${A_parameterTypes.length})");
    }
    if (argumentTypes.length == 0 || typeArguments.length == 0) {
      return this;
    }
    List<DartType> newTypeArguments = A_TypeImpl.A_substitute(typeArguments, argumentTypes, A_parameterTypes);
    if (JavaArrays.equals(newTypeArguments, typeArguments)) {
      return this;
    }
    InterfaceTypeImpl newType = new InterfaceTypeImpl.B_con1(element);
    newType.typeArguments = newTypeArguments;
    return newType;
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(name);
    int argumentCount = typeArguments.length;
    if (argumentCount > 0) {
      A_builder.append("<");
      for (int i = 0; i < argumentCount; i++) {
        if (i > 0) {
          A_builder.append(", ");
        }
        (typeArguments[i] as A_TypeImpl).appendTo(A_builder);
      }
      A_builder.append(">");
    }
  }
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) {
    if (object is! InterfaceTypeImpl) {
      return false;
    }
    InterfaceTypeImpl otherType = object as InterfaceTypeImpl;
    return (element == otherType.element) && A_TypeImpl.equalArrays(typeArguments, otherType.typeArguments, visitedElementPairs);
  }
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (identical(A_type, DynamicTypeImpl.instance)) {
      return true;
    } else if (A_type is! InterfaceType) {
      return false;
    }
    return _isMoreSpecificThan(A_type as InterfaceType, new A_p.HashSet<ClassElement>(), withDynamic, visitedTypePairs);
  }
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (A_type.isDynamic) {
      return true;
    } else if (A_type is TypeParameterType) {
      return false;
    } else if (A_type is FunctionType) {
      ClassElement A_element = this.element;
      InheritanceManager manager = new InheritanceManager(A_element.library);
      FunctionType callType = manager.lookupMemberType(this, "call");
      if (callType != null) {
        return callType.isSubtypeOf(A_type);
      }
      return false;
    } else if (A_type is! InterfaceType) {
      return false;
    } else if (this == A_type) {
      return true;
    }
    return _isSubtypeOf(A_type as InterfaceType, new A_p.HashSet<ClassElement>(), visitedTypePairs);
  }
  bool _isMoreSpecificThan(InterfaceType s, A_p.HashSet<ClassElement> visitedClasses, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (this == s) {
      return true;
    }
    if (s.isDirectSupertypeOf(this)) {
      return true;
    }
    ClassElement tElement = this.element;
    ClassElement sElement = s.element;
    if (tElement == sElement) {
      List<DartType> tArguments = typeArguments;
      List<DartType> sArguments = s.typeArguments;
      if (tArguments.length != sArguments.length) {
        return false;
      }
      for (int i = 0; i < tArguments.length; i++) {
        if (!(tArguments[i] as A_TypeImpl).isMoreSpecificThan2(sArguments[i], withDynamic, visitedTypePairs)) {
          return false;
        }
      }
      return true;
    }
    ClassElement A_element = this.element;
    if (A_element == null || visitedClasses.contains(A_element)) {
      return false;
    }
    visitedClasses.add(A_element);
    InterfaceType supertype = superclass;
    if (supertype != null && (supertype as InterfaceTypeImpl)._isMoreSpecificThan(s, visitedClasses, withDynamic, visitedTypePairs)) {
      return true;
    }
    for (InterfaceType interfaceType in interfaces) {
      if ((interfaceType as InterfaceTypeImpl)._isMoreSpecificThan(s, visitedClasses, withDynamic, visitedTypePairs)) {
        return true;
      }
    }
    for (InterfaceType mixinType in mixins) {
      if ((mixinType as InterfaceTypeImpl)._isMoreSpecificThan(s, visitedClasses, withDynamic, visitedTypePairs)) {
        return true;
      }
    }
    return false;
  }
  bool _isSubtypeOf(InterfaceType A_type, A_p.HashSet<ClassElement> visitedClasses, Set<TypeImpl_TypePair> visitedTypePairs) {
    InterfaceType typeT = this;
    InterfaceType typeS = A_type;
    ClassElement elementT = element;
    if (elementT == null || visitedClasses.contains(elementT)) {
      return false;
    }
    visitedClasses.add(elementT);
    if (typeT == typeS) {
      return true;
    } else if (elementT == typeS.element) {
      List<DartType> typeTArgs = typeT.typeArguments;
      List<DartType> typeSArgs = typeS.typeArguments;
      if (typeTArgs.length != typeSArgs.length) {
        return false;
      }
      for (int i = 0; i < typeTArgs.length; i++) {
        if (!(typeTArgs[i] as A_TypeImpl).isSubtypeOf2(typeSArgs[i], visitedTypePairs)) {
          return false;
        }
      }
      return true;
    } else if (typeS.isDartCoreFunction && elementT.getMethod("call") != null) {
      return true;
    }
    InterfaceType supertype = superclass;
    if (supertype != null && (supertype as InterfaceTypeImpl)._isSubtypeOf(typeS, visitedClasses, visitedTypePairs)) {
      return true;
    }
    List<InterfaceType> interfaceTypes = interfaces;
    for (InterfaceType interfaceType in interfaceTypes) {
      if ((interfaceType as InterfaceTypeImpl)._isSubtypeOf(typeS, visitedClasses, visitedTypePairs)) {
        return true;
      }
    }
    List<InterfaceType> mixinTypes = mixins;
    for (InterfaceType mixinType in mixinTypes) {
      if ((mixinType as InterfaceTypeImpl)._isSubtypeOf(typeS, visitedClasses, visitedTypePairs)) {
        return true;
      }
    }
    return false;
  }
}
class IsTagHasAttributeSelectorElementImpl extends AngularSelectorElementImpl {
  String _tagName;
  String _attributeName;
  IsTagHasAttributeSelectorElementImpl(String A_tagName, String A_attributeName) : super("${A_tagName}[${A_attributeName}]", -1) {
    this._tagName = A_tagName;
    this._attributeName = A_attributeName;
  }
  bool apply(XmlTagNode node) => node.tag == _tagName && node.getAttribute(_attributeName) != null;
}
abstract class LabelElement implements A_Element {
  ExecutableElement get enclosingElement;
}
class LabelElementImpl extends ElementImpl implements LabelElement {
  final bool _onSwitchStatement;
  final bool _onSwitchMember;
  static List<LabelElement> B_EMPTY_ARRAY = new List<LabelElement>(0);
  LabelElementImpl(Identifier A_name, this._onSwitchStatement, this._onSwitchMember) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitLabelElement(this);
  ExecutableElement get enclosingElement => super.enclosingElement as ExecutableElement;
  A_ElementKind get kind => A_ElementKind.LABEL;
  bool get isOnSwitchMember => _onSwitchMember;
  bool get isOnSwitchStatement => _onSwitchStatement;
}
abstract class LibraryElement implements A_Element {
  CompilationUnitElement get definingCompilationUnit;
  FunctionElement get entryPoint;
  List<LibraryElement> get exportedLibraries;
  List<ExportElement> get exports;
  List<LibraryElement> get importedLibraries;
  List<ImportElement> get imports;
  List<ImportElement> getImportsWithPrefix(PrefixElement prefixElement);
  FunctionElement get loadLibraryFunction;
  List<CompilationUnitElement> get parts;
  List<PrefixElement> get prefixes;
  ClassElement getType(String className);
  List<CompilationUnitElement> get units;
  bool get hasExtUri;
  bool get hasLoadLibraryFunction;
  bool get isDartCore;
  bool get isInSdk;
}
class LibraryElementImpl extends ElementImpl implements LibraryElement {
  static List<LibraryElement> B_EMPTY_ARRAY = new List<LibraryElement>(0);
  final AnalysisContext context;
  CompilationUnitElement _definingCompilationUnit;
  FunctionElement entryPoint;
  List<ImportElement> _imports = ImportElement.B_EMPTY_ARRAY;
  List<ExportElement> _exports = ExportElement.B_EMPTY_ARRAY;
  List<CompilationUnitElement> _parts = CompilationUnitElementImpl.B_EMPTY_ARRAY;
  bool _isAngularHtml = false;
  FunctionElement _loadLibraryFunction;
  LibraryElementImpl.forNode(this.context, LibraryIdentifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitLibraryElement(this);
  bool operator==(Object object) => object != null && runtimeType == object.runtimeType && _definingCompilationUnit == (object as LibraryElementImpl).definingCompilationUnit;
  ElementImpl getChild(String A_identifier) {
    if ((_definingCompilationUnit as CompilationUnitElementImpl).identifier == A_identifier) {
      return _definingCompilationUnit as CompilationUnitElementImpl;
    }
    for (CompilationUnitElement part in _parts) {
      if ((part as CompilationUnitElementImpl).identifier == A_identifier) {
        return part as CompilationUnitElementImpl;
      }
    }
    for (ImportElement importElement in _imports) {
      if ((importElement as ImportElementImpl).identifier == A_identifier) {
        return importElement as ImportElementImpl;
      }
    }
    for (ExportElement exportElement in _exports) {
      if ((exportElement as ExportElementImpl).identifier == A_identifier) {
        return exportElement as ExportElementImpl;
      }
    }
    return null;
  }
  CompilationUnitElement get definingCompilationUnit => _definingCompilationUnit;
  List<LibraryElement> get exportedLibraries {
    A_p.HashSet<LibraryElement> libraries = new A_p.HashSet<LibraryElement>();
    for (ExportElement A_element in _exports) {
      LibraryElement A_library = A_element.exportedLibrary;
      if (A_library != null) {
        libraries.add(A_library);
      }
    }
    return new List.from(libraries);
  }
  List<ExportElement> get exports => _exports;
  List<LibraryElement> get importedLibraries {
    A_p.HashSet<LibraryElement> libraries = new A_p.HashSet<LibraryElement>();
    for (ImportElement A_element in _imports) {
      LibraryElement A_library = A_element.importedLibrary;
      if (A_library != null) {
        libraries.add(A_library);
      }
    }
    return new List.from(libraries);
  }
  List<ImportElement> get imports => _imports;
  List<ImportElement> getImportsWithPrefix(PrefixElement prefixElement) {
    int count = _imports.length;
    List<ImportElement> importList = new List<ImportElement>();
    for (int i = 0; i < count; i++) {
      if (identical(_imports[i].prefix, prefixElement)) {
        importList.add(_imports[i]);
      }
    }
    return new List.from(importList);
  }
  A_ElementKind get kind => A_ElementKind.A_LIBRARY;
  LibraryElement get library => this;
  FunctionElement get loadLibraryFunction {
    if (_loadLibraryFunction == null) {
      FunctionElementImpl A_function = new FunctionElementImpl(FunctionElement.LOAD_LIBRARY_NAME, -1);
      A_function.synthetic = true;
      A_function.enclosingElement = this;
      A_function.returnType = loadLibraryReturnType;
      A_function.type = new FunctionTypeImpl.B_con1(A_function);
      _loadLibraryFunction = A_function;
    }
    return _loadLibraryFunction;
  }
  List<CompilationUnitElement> get parts => _parts;
  List<PrefixElement> get prefixes {
    A_p.HashSet<PrefixElement> A_prefixes = new A_p.HashSet<PrefixElement>();
    for (ImportElement A_element in _imports) {
      PrefixElement prefix = A_element.prefix;
      if (prefix != null) {
        A_prefixes.add(prefix);
      }
    }
    return new List.from(A_prefixes);
  }
  Source get source {
    if (_definingCompilationUnit == null) {
      return null;
    }
    return _definingCompilationUnit.source;
  }
  ClassElement getType(String className) {
    ClassElement A_type = _definingCompilationUnit.getType(className);
    if (A_type != null) {
      return A_type;
    }
    for (CompilationUnitElement part in _parts) {
      A_type = part.getType(className);
      if (A_type != null) {
        return A_type;
      }
    }
    return null;
  }
  List<CompilationUnitElement> get units {
    List<CompilationUnitElement> A_units = new List<CompilationUnitElement>(1 + _parts.length);
    A_units[0] = _definingCompilationUnit;
    JavaSystem.arraycopy(_parts, 0, A_units, 1, _parts.length);
    return A_units;
  }
  bool get hasExtUri => hasModifier(Modifier.HAS_EXT_URI);
  int get hashCode => _definingCompilationUnit.hashCode;
  bool get hasLoadLibraryFunction {
    if (_definingCompilationUnit.hasLoadLibraryFunction) {
      return true;
    }
    for (int i = 0; i < _parts.length; i++) {
      if (_parts[i].hasLoadLibraryFunction) {
        return true;
      }
    }
    return false;
  }
  bool get isDartCore => name == "dart.core";
  bool get isInSdk => StringUtilities.startsWith5(name, 0, 0x64, 0x61, 0x72, 0x74, 0x2E);
  void set angularHtml(bool A_isAngularHtml) {
    this._isAngularHtml = A_isAngularHtml;
  }
  void set definingCompilationUnit(CompilationUnitElement A_definingCompilationUnit) {
    (A_definingCompilationUnit as CompilationUnitElementImpl).enclosingElement = this;
    this._definingCompilationUnit = A_definingCompilationUnit;
  }
  void set exports(List<ExportElement> A_exports) {
    for (ExportElement exportElement in A_exports) {
      (exportElement as ExportElementImpl).enclosingElement = this;
    }
    this._exports = A_exports;
  }
  void set hasExtUri(bool A_hasExtUri) {
    setModifier(Modifier.HAS_EXT_URI, A_hasExtUri);
  }
  void set imports(List<ImportElement> A_imports) {
    for (ImportElement importElement in A_imports) {
      (importElement as ImportElementImpl).enclosingElement = this;
      PrefixElementImpl prefix = importElement.prefix as PrefixElementImpl;
      if (prefix != null) {
        prefix.enclosingElement = this;
      }
    }
    this._imports = A_imports;
  }
  void set parts(List<CompilationUnitElement> A_parts) {
    for (CompilationUnitElement compilationUnit in A_parts) {
      (compilationUnit as CompilationUnitElementImpl).enclosingElement = this;
    }
    this._parts = A_parts;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(_definingCompilationUnit, visitor);
    safelyVisitChildren(_exports, visitor);
    safelyVisitChildren(_imports, visitor);
    safelyVisitChildren(_parts, visitor);
  }
  String get identifier => _definingCompilationUnit.source.encoding;
  DartType get loadLibraryReturnType {
    try {
      Source asyncSource = context.sourceFactory.forUri(DartSdk.DART_ASYNC);
      if (asyncSource == null) {
        AnalysisEngine.A_instance.logger.logError("Could not create a source for dart:async");
        return VoidTypeImpl.instance;
      }
      LibraryElement asyncElement = context.computeLibraryElement(asyncSource);
      if (asyncElement == null) {
        AnalysisEngine.A_instance.logger.logError("Could not build the element model for dart:async");
        return VoidTypeImpl.instance;
      }
      ClassElement futureElement = asyncElement.getType("Future");
      if (futureElement == null) {
        AnalysisEngine.A_instance.logger.logError("Could not find type Future in dart:async");
        return VoidTypeImpl.instance;
      }
      InterfaceType futureType = futureElement.type;
      return futureType.substitute4(<DartType>[DynamicTypeImpl.instance]);
    }on AnalysisException  catch (exception, A_stackTrace) {
      AnalysisEngine.A_instance.logger.logError2("Could not build the element model for dart:async", new CaughtException(exception, A_stackTrace));
      return VoidTypeImpl.instance;
    }
  }
}
abstract class LocalElement implements A_Element {}
abstract class LocalVariableElement implements LocalElement, VariableElement {
  List<ToolkitObjectElement> get toolkitObjects;
}
class LocalVariableElementImpl extends VariableElementImpl implements LocalVariableElement {
  int _visibleRangeOffset = 0;
  int _visibleRangeLength = -1;
  static List<LocalVariableElement> B_EMPTY_ARRAY = new List<LocalVariableElement>(0);
  LocalVariableElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitLocalVariableElement(this);
  A_ElementKind get kind => A_ElementKind.B_LOCAL_VARIABLE;
  List<ToolkitObjectElement> get toolkitObjects {
    CompilationUnitElementImpl unit = getAncestor((A_element) => A_element is CompilationUnitElementImpl);
    if (unit == null) {
      return ToolkitObjectElement.B_EMPTY_ARRAY;
    }
    return unit._getToolkitObjects(this);
  }
  bool get isPotentiallyMutatedInClosure => hasModifier(Modifier.POTENTIALLY_MUTATED_IN_CONTEXT);
  bool get isPotentiallyMutatedInScope => hasModifier(Modifier.POTENTIALLY_MUTATED_IN_SCOPE);
  void markPotentiallyMutatedInClosure() {
    setModifier(Modifier.POTENTIALLY_MUTATED_IN_CONTEXT, true);
  }
  void markPotentiallyMutatedInScope() {
    setModifier(Modifier.POTENTIALLY_MUTATED_IN_SCOPE, true);
  }
  void set toolkitObjects(List<ToolkitObjectElement> A_toolkitObjects) {
    CompilationUnitElementImpl unit = getAncestor((A_element) => A_element is CompilationUnitElementImpl);
    if (unit == null) {
      return;
    }
    unit._setToolkitObjects(this, A_toolkitObjects);
  }
  void setVisibleRange(int A_offset, int A_length) {
    _visibleRangeOffset = A_offset;
    _visibleRangeLength = A_length;
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(type);
    A_builder.append(" ");
    A_builder.append(displayName);
  }
  String get identifier => "${super.identifier}@${nameOffset}";
}
abstract class Member implements A_Element {
  final A_Element _baseElement;
  final ParameterizedType _definingType;
  Member(this._baseElement, this._definingType);
  String computeDocumentationComment() => _baseElement.computeDocumentationComment();
  A_Element getAncestor(A_Predicate<A_Element> predicate) => baseElement.getAncestor(predicate);
  A_Element get baseElement => _baseElement;
  AnalysisContext get context => _baseElement.context;
  String get displayName => _baseElement.displayName;
  String getExtendedDisplayName(String shortName) => _baseElement.getExtendedDisplayName(shortName);
  A_ElementKind get kind => _baseElement.kind;
  LibraryElement get library => _baseElement.library;
  ElementLocation get location => _baseElement.location;
  List<ElementAnnotation> get metadata => _baseElement.metadata;
  String get name => _baseElement.name;
  int get nameOffset => _baseElement.nameOffset;
  AstNode get node => _baseElement.node;
  Source get source => _baseElement.source;
  CompilationUnit get unit => _baseElement.unit;
  bool isAccessibleIn(LibraryElement A_library) => _baseElement.isAccessibleIn(A_library);
  bool get isDeprecated => _baseElement.isDeprecated;
  bool get isOverride => _baseElement.isOverride;
  bool get isPrivate => _baseElement.isPrivate;
  bool get isPublic => _baseElement.isPublic;
  bool get isSynthetic => _baseElement.isSynthetic;
  void visitChildren(ElementVisitor visitor) {}
  ParameterizedType get definingType => _definingType;
  void safelyVisitChild(A_Element child, ElementVisitor visitor) {
    if (child != null) {
      child.accept(visitor);
    }
  }
  void safelyVisitChildren(List<A_Element> children, ElementVisitor visitor) {
    if (children != null) {
      for (A_Element child in children) {
        child.accept(visitor);
      }
    }
  }
  DartType substituteFor(DartType A_type) {
    if (A_type == null) {
      return null;
    }
    List<DartType> argumentTypes = _definingType.typeArguments;
    List<DartType> A_parameterTypes = TypeParameterTypeImpl.getTypes(_definingType.typeParameters);
    return A_type.substitute2(argumentTypes, A_parameterTypes);
  }
}
abstract class MethodElement implements ClassMemberElement, ExecutableElement {
  MethodDeclaration get node;
  bool get isAbstract;
}
class MethodElementImpl extends ExecutableElementImpl implements MethodElement {
  static List<MethodElement> B_EMPTY_ARRAY = new List<MethodElement>(0);
  MethodElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  MethodElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitMethodElement(this);
  String get displayName {
    String A_displayName = super.displayName;
    if ("unary-" == A_displayName) {
      return "-";
    }
    return A_displayName;
  }
  ClassElement get enclosingElement => super.enclosingElement as ClassElement;
  A_ElementKind get kind => A_ElementKind.E_METHOD;
  String get name {
    String A_name = super.name;
    if (isOperator && A_name == "-") {
      if (parameters.length == 0) {
        return "unary-";
      }
    }
    return super.name;
  }
  MethodDeclaration get node => getNodeMatching((A_node) => A_node is MethodDeclaration);
  bool get isAbstract => hasModifier(Modifier.ABSTRACT);
  bool get isOperator {
    String A_name = displayName;
    if (A_name.isEmpty) {
      return false;
    }
    int A_first = A_name.codeUnitAt(0);
    return !((0x61 <= A_first && A_first <= 0x7A) || (0x41 <= A_first && A_first <= 0x5A) || A_first == 0x5F || A_first == 0x24);
  }
  bool get isStatic => hasModifier(Modifier.STATIC);
  void set abstract(bool A_isAbstract) {
    setModifier(Modifier.ABSTRACT, A_isAbstract);
  }
  void set static(bool A_isStatic) {
    setModifier(Modifier.STATIC, A_isStatic);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(enclosingElement.displayName);
    A_builder.append(".");
    A_builder.append(displayName);
    super.appendTo(A_builder);
  }
}
class MethodMember extends ExecutableMember implements MethodElement {
  static MethodElement B_from(MethodElement baseMethod, InterfaceType definingType) {
    if (baseMethod == null || definingType.typeArguments.length == 0) {
      return baseMethod;
    }
    FunctionType baseType = baseMethod.type;
    List<DartType> argumentTypes = definingType.typeArguments;
    List<DartType> A_parameterTypes = definingType.element.type.typeArguments;
    FunctionType substitutedType = baseType.substitute2(argumentTypes, A_parameterTypes);
    if (baseType == substitutedType) {
      return baseMethod;
    }
    return new MethodMember(baseMethod, definingType);
  }
  MethodMember(MethodElement A_baseElement, InterfaceType definingType) : super(A_baseElement, definingType);
  accept(ElementVisitor visitor) => visitor.visitMethodElement(this);
  MethodElement get baseElement => super.baseElement as MethodElement;
  ClassElement get enclosingElement => baseElement.enclosingElement;
  MethodDeclaration get node => baseElement.node;
  bool get isAbstract => baseElement.isAbstract;
  String toString() {
    MethodElement A_baseElement = this.baseElement;
    List<ParameterElement> A_parameters = this.parameters;
    FunctionType A_type = this.type;
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append(A_baseElement.enclosingElement.displayName);
    A_builder.append(".");
    A_builder.append(A_baseElement.displayName);
    A_builder.append("(");
    int parameterCount = A_parameters.length;
    for (int i = 0; i < parameterCount; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      A_builder.append(A_parameters[i]).toString();
    }
    A_builder.append(")");
    if (A_type != null) {
      A_builder.append(A_Element.RIGHT_ARROW);
      A_builder.append(A_type.returnType);
    }
    return A_builder.toString();
  }
}
class Modifier extends Enum<Modifier> {
  static const Modifier ABSTRACT = const Modifier('ABSTRACT', 0);
  static const Modifier CONST = const Modifier('CONST', 1);
  static const Modifier DEFERRED = const Modifier('DEFERRED', 2);
  static const Modifier FACTORY = const Modifier('FACTORY', 3);
  static const Modifier FINAL = const Modifier('FINAL', 4);
  static const Modifier C_GETTER = const Modifier('GETTER', 5);
  static const Modifier HAS_EXT_URI = const Modifier('HAS_EXT_URI', 6);
  static const Modifier MIXIN = const Modifier('MIXIN', 7);
  static const Modifier POTENTIALLY_MUTATED_IN_CONTEXT = const Modifier('POTENTIALLY_MUTATED_IN_CONTEXT', 8);
  static const Modifier POTENTIALLY_MUTATED_IN_SCOPE = const Modifier('POTENTIALLY_MUTATED_IN_SCOPE', 9);
  static const Modifier REFERENCES_SUPER = const Modifier('REFERENCES_SUPER', 10);
  static const Modifier C_SETTER = const Modifier('SETTER', 11);
  static const Modifier STATIC = const Modifier('STATIC', 12);
  static const Modifier SYNTHETIC = const Modifier('SYNTHETIC', 13);
  static const Modifier TYPEDEF = const Modifier('TYPEDEF', 14);
  const Modifier(String A_name, int ordinal) : super(A_name, ordinal);
}
abstract class MultiplyDefinedElement implements A_Element {
  List<A_Element> get conflictingElements;
  DartType get type;
}
class MultiplyDefinedElementImpl implements MultiplyDefinedElement {
  static A_Element fromElements(AnalysisContext A_context, A_Element firstElement, A_Element secondElement) {
    List<A_Element> A_conflictingElements = _computeConflictingElements(firstElement, secondElement);
    int A_length = A_conflictingElements.length;
    if (A_length == 0) {
      return null;
    } else if (A_length == 1) {
      return A_conflictingElements[0];
    }
    return new MultiplyDefinedElementImpl(A_context, A_conflictingElements);
  }
  static void A__add(A_p.HashSet<A_Element> elements, A_Element A_element) {
    if (A_element is MultiplyDefinedElementImpl) {
      for (A_Element conflictingElement in A_element.conflictingElements) {
        elements.add(conflictingElement);
      }
    } else {
      elements.add(A_element);
    }
  }
  static List<A_Element> _computeConflictingElements(A_Element firstElement, A_Element secondElement) {
    A_p.HashSet<A_Element> elements = new A_p.HashSet<A_Element>();
    A__add(elements, firstElement);
    A__add(elements, secondElement);
    return new List.from(elements);
  }
  final AnalysisContext context;
  String B__name;
  final List<A_Element> conflictingElements;
  MultiplyDefinedElementImpl(this.context, this.conflictingElements) {
    B__name = conflictingElements[0].name;
  }
  accept(ElementVisitor visitor) => visitor.visitMultiplyDefinedElement(this);
  String computeDocumentationComment() => null;
  A_Element getAncestor(A_Predicate<A_Element> predicate) => null;
  String get displayName => B__name;
  A_Element get enclosingElement => null;
  String getExtendedDisplayName(String shortName) {
    if (shortName != null) {
      return shortName;
    }
    return displayName;
  }
  A_ElementKind get kind => A_ElementKind.B_ERROR;
  LibraryElement get library => null;
  ElementLocation get location => null;
  List<ElementAnnotation> get metadata => ElementAnnotationImpl.B_EMPTY_ARRAY;
  String get name => B__name;
  int get nameOffset => -1;
  AstNode get node => null;
  Source get source => null;
  DartType get type => DynamicTypeImpl.instance;
  CompilationUnit get unit => null;
  bool isAccessibleIn(LibraryElement A_library) {
    for (A_Element A_element in conflictingElements) {
      if (A_element.isAccessibleIn(A_library)) {
        return true;
      }
    }
    return false;
  }
  bool get isDeprecated => false;
  bool get isOverride => false;
  bool get isPrivate {
    String A_name = displayName;
    if (A_name == null) {
      return false;
    }
    return Identifier.isPrivateName(A_name);
  }
  bool get isPublic => !isPrivate;
  bool get isSynthetic => true;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("[");
    int count = conflictingElements.length;
    for (int i = 0; i < count; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      (conflictingElements[i] as ElementImpl).appendTo(A_builder);
    }
    A_builder.append("]");
    return A_builder.toString();
  }
  void visitChildren(ElementVisitor visitor) {}
}
abstract class MultiplyInheritedExecutableElement implements ExecutableElement {
  List<ExecutableElement> get inheritedElements;
}
class MultiplyInheritedMethodElementImpl extends MethodElementImpl implements MultiplyInheritedExecutableElement {
  List<ExecutableElement> B__elements = MethodElementImpl.B_EMPTY_ARRAY;
  MultiplyInheritedMethodElementImpl(Identifier A_name) : super.forNode(A_name) {
    synthetic = true;
  }
  List<ExecutableElement> get inheritedElements => B__elements;
  void set inheritedElements(List<ExecutableElement> elements) {
    this.B__elements = elements;
  }
}
class MultiplyInheritedPropertyAccessorElementImpl extends PropertyAccessorElementImpl implements MultiplyInheritedExecutableElement {
  List<ExecutableElement> B__elements = PropertyAccessorElementImpl.B_EMPTY_ARRAY;
  MultiplyInheritedPropertyAccessorElementImpl(Identifier A_name) : super.forNode(A_name) {
    synthetic = true;
  }
  List<ExecutableElement> get inheritedElements => B__elements;
  void set inheritedElements(List<ExecutableElement> elements) {
    this.B__elements = elements;
  }
}
abstract class NamespaceCombinator {
  static final List<NamespaceCombinator> B_EMPTY_ARRAY = new List<NamespaceCombinator>(0);
}
abstract class ParameterElement implements LocalElement, VariableElement {
  SourceRange get defaultValueRange;
  ParameterKind get parameterKind;
  List<ParameterElement> get parameters;
  bool get isInitializingFormal;
}
class ParameterElementImpl extends VariableElementImpl implements ParameterElement {
  List<ParameterElement> B__parameters = ParameterElementImpl.B_EMPTY_ARRAY;
  ParameterKind parameterKind;
  int _defaultValueRangeOffset = 0;
  int _defaultValueRangeLength = -1;
  int _visibleRangeOffset = 0;
  int _visibleRangeLength = -1;
  static List<ParameterElement> B_EMPTY_ARRAY = new List<ParameterElement>(0);
  ParameterElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  ParameterElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitParameterElement(this);
  ElementImpl getChild(String identifier) {
    for (ParameterElement parameter in B__parameters) {
      if ((parameter as ParameterElementImpl).identifier == identifier) {
        return parameter as ParameterElementImpl;
      }
    }
    return null;
  }
  SourceRange get defaultValueRange {
    if (_defaultValueRangeLength < 0) {
      return null;
    }
    return new SourceRange(_defaultValueRangeOffset, _defaultValueRangeLength);
  }
  A_ElementKind get kind => A_ElementKind.E_PARAMETER;
  List<ParameterElement> get parameters => B__parameters;
  bool get isInitializingFormal => false;
  bool get isPotentiallyMutatedInClosure => hasModifier(Modifier.POTENTIALLY_MUTATED_IN_CONTEXT);
  bool get isPotentiallyMutatedInScope => hasModifier(Modifier.POTENTIALLY_MUTATED_IN_SCOPE);
  void markPotentiallyMutatedInClosure() {
    setModifier(Modifier.POTENTIALLY_MUTATED_IN_CONTEXT, true);
  }
  void markPotentiallyMutatedInScope() {
    setModifier(Modifier.POTENTIALLY_MUTATED_IN_SCOPE, true);
  }
  void setDefaultValueRange(int A_offset, int A_length) {
    _defaultValueRangeOffset = A_offset;
    _defaultValueRangeLength = A_length;
  }
  void set parameters(List<ParameterElement> A_parameters) {
    for (ParameterElement parameter in A_parameters) {
      (parameter as ParameterElementImpl).enclosingElement = this;
    }
    this.B__parameters = A_parameters;
  }
  void setVisibleRange(int A_offset, int A_length) {
    _visibleRangeOffset = A_offset;
    _visibleRangeLength = A_length;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(B__parameters, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    String A_left = "";
    String A_right = "";
    while (true) {
      if (parameterKind == ParameterKind.NAMED) {
        A_left = "{";
        A_right = "}";
      } else if (parameterKind == ParameterKind.POSITIONAL) {
        A_left = "[";
        A_right = "]";
      } else if (parameterKind == ParameterKind.REQUIRED) {}
      break;
    }
    A_builder.append(A_left);
    appendToWithoutDelimiters(A_builder);
    A_builder.append(A_right);
  }
  void appendToWithoutDelimiters(JavaStringBuilder A_builder) {
    A_builder.append(type);
    A_builder.append(" ");
    A_builder.append(displayName);
  }
}
class ParameterMember extends VariableMember implements ParameterElement {
  static ParameterElement B_from(ParameterElement baseParameter, ParameterizedType definingType) {
    if (baseParameter == null || definingType.typeArguments.length == 0) {
      return baseParameter;
    }
    bool isFieldFormal = baseParameter is FieldFormalParameterElement;
    if (!isFieldFormal) {
      DartType baseType = baseParameter.type;
      List<DartType> argumentTypes = definingType.typeArguments;
      List<DartType> A_parameterTypes = TypeParameterTypeImpl.getTypes(definingType.typeParameters);
      DartType substitutedType = baseType.substitute2(argumentTypes, A_parameterTypes);
      if (baseType == substitutedType) {
        return baseParameter;
      }
    }
    if (isFieldFormal) {
      return new FieldFormalParameterMember(baseParameter as FieldFormalParameterElement, definingType);
    }
    return new ParameterMember(baseParameter, definingType);
  }
  ParameterMember(ParameterElement A_baseElement, ParameterizedType definingType) : super(A_baseElement, definingType);
  accept(ElementVisitor visitor) => visitor.visitParameterElement(this);
  A_Element getAncestor(A_Predicate<A_Element> predicate) {
    A_Element A_element = baseElement.getAncestor(predicate);
    ParameterizedType definingType = this.definingType;
    if (definingType is InterfaceType) {
      InterfaceType definingInterfaceType = definingType;
      if (A_element is ConstructorElement) {
        return ConstructorMember.B_from(A_element, definingInterfaceType);
      } else if (A_element is MethodElement) {
        return MethodMember.B_from(A_element, definingInterfaceType);
      } else if (A_element is PropertyAccessorElement) {
        return PropertyAccessorMember.B_from(A_element, definingInterfaceType);
      }
    }
    return A_element;
  }
  ParameterElement get baseElement => super.baseElement as ParameterElement;
  SourceRange get defaultValueRange => baseElement.defaultValueRange;
  A_Element get enclosingElement => baseElement.enclosingElement;
  ParameterKind get parameterKind => baseElement.parameterKind;
  List<ParameterElement> get parameters {
    List<ParameterElement> baseParameters = baseElement.parameters;
    int parameterCount = baseParameters.length;
    if (parameterCount == 0) {
      return baseParameters;
    }
    List<ParameterElement> parameterizedParameters = new List<ParameterElement>(parameterCount);
    for (int i = 0; i < parameterCount; i++) {
      parameterizedParameters[i] = ParameterMember.B_from(baseParameters[i], definingType);
    }
    return parameterizedParameters;
  }
  bool get isInitializingFormal => baseElement.isInitializingFormal;
  String toString() {
    ParameterElement A_baseElement = this.baseElement;
    String A_left = "";
    String A_right = "";
    while (true) {
      if (A_baseElement.parameterKind == ParameterKind.NAMED) {
        A_left = "{";
        A_right = "}";
      } else if (A_baseElement.parameterKind == ParameterKind.POSITIONAL) {
        A_left = "[";
        A_right = "]";
      } else if (A_baseElement.parameterKind == ParameterKind.REQUIRED) {}
      break;
    }
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append(A_left);
    A_builder.append(type);
    A_builder.append(" ");
    A_builder.append(A_baseElement.displayName);
    A_builder.append(A_right);
    return A_builder.toString();
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChildren(parameters, visitor);
  }
}
abstract class ParameterizedType implements DartType {
  List<DartType> get typeArguments;
  List<TypeParameterElement> get typeParameters;
}
abstract class PolymerAttributeElement implements PolymerElement {
  static final List<PolymerAttributeElement> B_EMPTY_ARRAY = new List<PolymerAttributeElement>(0);
  FieldElement get field;
}
class PolymerAttributeElementImpl extends PolymerElementImpl implements PolymerAttributeElement {
  FieldElement field;
  PolymerAttributeElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitPolymerAttributeElement(this);
  A_ElementKind get kind => A_ElementKind.POLYMER_ATTRIBUTE;
}
abstract class PolymerElement implements ToolkitObjectElement {}
abstract class PolymerElementImpl extends ToolkitObjectElementImpl implements PolymerElement {
  PolymerElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
}
abstract class PolymerTagDartElement implements PolymerElement {
  ClassElement get classElement;
}
class PolymerTagDartElementImpl extends PolymerElementImpl implements PolymerTagDartElement {
  final ClassElement classElement;
  PolymerTagHtmlElement htmlElement;
  PolymerTagDartElementImpl(String A_name, int nameOffset, this.classElement) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitPolymerTagDartElement(this);
  A_ElementKind get kind => A_ElementKind.POLYMER_TAG_DART;
}
abstract class PolymerTagHtmlElement implements PolymerElement {
  static final List<PolymerTagHtmlElement> B_EMPTY_ARRAY = new List<PolymerTagHtmlElement>(0);
  List<PolymerAttributeElement> get attributes;
}
class PolymerTagHtmlElementImpl extends PolymerElementImpl implements PolymerTagHtmlElement {
  PolymerTagDartElement dartElement;
  List<PolymerAttributeElement> _attributes = PolymerAttributeElement.B_EMPTY_ARRAY;
  PolymerTagHtmlElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitPolymerTagHtmlElement(this);
  List<PolymerAttributeElement> get attributes => _attributes;
  A_ElementKind get kind => A_ElementKind.POLYMER_TAG_HTML;
  void set attributes(List<PolymerAttributeElement> A_attributes) {
    for (PolymerAttributeElement property in A_attributes) {
      encloseElement(property as PolymerAttributeElementImpl);
    }
    this._attributes = A_attributes;
  }
  void visitChildren(ElementVisitor visitor) {
    safelyVisitChildren(_attributes, visitor);
    super.visitChildren(visitor);
  }
}
abstract class PrefixElement implements A_Element {
  LibraryElement get enclosingElement;
  List<LibraryElement> get importedLibraries;
}
class PrefixElementImpl extends ElementImpl implements PrefixElement {
  List<LibraryElement> _importedLibraries = LibraryElementImpl.B_EMPTY_ARRAY;
  PrefixElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitPrefixElement(this);
  LibraryElement get enclosingElement => super.enclosingElement as LibraryElement;
  List<LibraryElement> get importedLibraries => _importedLibraries;
  A_ElementKind get kind => A_ElementKind.PREFIX;
  void set importedLibraries(List<LibraryElement> A_importedLibraries) {
    for (LibraryElement library in A_importedLibraries) {
      (library as LibraryElementImpl).enclosingElement = this;
    }
    this._importedLibraries = A_importedLibraries;
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append("as ");
    super.appendTo(A_builder);
  }
  String get identifier => "_${super.identifier}";
}
abstract class PropertyAccessorElement implements ExecutableElement {
  PropertyAccessorElement get correspondingGetter;
  PropertyAccessorElement get correspondingSetter;
  PropertyInducingElement get variable;
  bool get isAbstract;
  bool get isGetter;
  bool get isSetter;
}
class PropertyAccessorElementImpl extends ExecutableElementImpl implements PropertyAccessorElement {
  PropertyInducingElement variable;
  static List<PropertyAccessorElement> B_EMPTY_ARRAY = new List<PropertyAccessorElement>(0);
  PropertyAccessorElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  PropertyAccessorElementImpl.forVariable(PropertyInducingElementImpl A_variable) : super(A_variable.name, A_variable.nameOffset) {
    this.variable = A_variable;
    synthetic = true;
  }
  accept(ElementVisitor visitor) => visitor.visitPropertyAccessorElement(this);
  bool operator==(Object object) => super == object && isGetter == (object as PropertyAccessorElement).isGetter;
  PropertyAccessorElement get correspondingGetter {
    if (isGetter || variable == null) {
      return null;
    }
    return variable.getter;
  }
  PropertyAccessorElement get correspondingSetter {
    if (isSetter || variable == null) {
      return null;
    }
    return variable.setter;
  }
  A_ElementKind get kind {
    if (isGetter) {
      return A_ElementKind.C_GETTER;
    }
    return A_ElementKind.C_SETTER;
  }
  String get name {
    if (isSetter) {
      return "${super.name}=";
    }
    return super.name;
  }
  AstNode get node {
    if (isSynthetic) {
      return null;
    }
    if (enclosingElement is ClassElement) {
      return getNodeMatching((A_node) => A_node is MethodDeclaration);
    }
    if (enclosingElement is CompilationUnitElement) {
      return getNodeMatching((A_node) => A_node is FunctionDeclaration);
    }
    return null;
  }
  int get hashCode => ObjectUtilities.combineHashCodes(super.hashCode, isGetter ? 1 : 2);
  bool get isAbstract => hasModifier(Modifier.ABSTRACT);
  bool get isGetter => hasModifier(Modifier.C_GETTER);
  bool get isSetter => hasModifier(Modifier.C_SETTER);
  bool get isStatic => hasModifier(Modifier.STATIC);
  void set abstract(bool A_isAbstract) {
    setModifier(Modifier.ABSTRACT, A_isAbstract);
  }
  void set getter(bool A_isGetter) {
    setModifier(Modifier.C_GETTER, A_isGetter);
  }
  void set setter(bool A_isSetter) {
    setModifier(Modifier.C_SETTER, A_isSetter);
  }
  void set static(bool A_isStatic) {
    setModifier(Modifier.STATIC, A_isStatic);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(isGetter ? "get " : "set ");
    A_builder.append(variable.displayName);
    super.appendTo(A_builder);
  }
  String get identifier {
    String A_name = displayName;
    String suffix = isGetter ? "?" : "=";
    return "${A_name}${suffix}";
  }
}
class PropertyAccessorMember extends ExecutableMember implements PropertyAccessorElement {
  static PropertyAccessorElement B_from(PropertyAccessorElement baseAccessor, InterfaceType A_definingType) {
    if (!_isChangedByTypeSubstitution(baseAccessor, A_definingType)) {
      return baseAccessor;
    }
    return new PropertyAccessorMember(baseAccessor, A_definingType);
  }
  static bool _isChangedByTypeSubstitution(PropertyAccessorElement baseAccessor, InterfaceType A_definingType) {
    List<DartType> argumentTypes = A_definingType.typeArguments;
    if (baseAccessor != null && argumentTypes.length != 0) {
      FunctionType baseType = baseAccessor.type;
      List<DartType> A_parameterTypes = A_definingType.element.type.typeArguments;
      FunctionType substitutedType = baseType.substitute2(argumentTypes, A_parameterTypes);
      if (baseType != substitutedType) {
        return true;
      }
      PropertyInducingElement field = baseAccessor.variable;
      if (!field.isSynthetic) {
        DartType baseFieldType = field.propagatedType;
        if (baseFieldType != null) {
          DartType substitutedFieldType = baseFieldType.substitute2(argumentTypes, A_parameterTypes);
          if (baseFieldType != substitutedFieldType) {
            return true;
          }
        }
      }
    }
    return false;
  }
  PropertyAccessorMember(PropertyAccessorElement A_baseElement, InterfaceType A_definingType) : super(A_baseElement, A_definingType);
  accept(ElementVisitor visitor) => visitor.visitPropertyAccessorElement(this);
  PropertyAccessorElement get baseElement => super.baseElement as PropertyAccessorElement;
  PropertyAccessorElement get correspondingGetter => B_from(baseElement.correspondingGetter, definingType);
  PropertyAccessorElement get correspondingSetter => B_from(baseElement.correspondingSetter, definingType);
  A_Element get enclosingElement => baseElement.enclosingElement;
  PropertyInducingElement get variable {
    PropertyInducingElement A_variable = baseElement.variable;
    if (A_variable is FieldElement) {
      return FieldMember.B_from(A_variable, definingType);
    }
    return A_variable;
  }
  bool get isAbstract => baseElement.isAbstract;
  bool get isGetter => baseElement.isGetter;
  bool get isSetter => baseElement.isSetter;
  String toString() {
    PropertyAccessorElement A_baseElement = this.baseElement;
    List<ParameterElement> A_parameters = this.parameters;
    FunctionType A_type = this.type;
    JavaStringBuilder A_builder = new JavaStringBuilder();
    if (isGetter) {
      A_builder.append("get ");
    } else {
      A_builder.append("set ");
    }
    A_builder.append(A_baseElement.enclosingElement.displayName);
    A_builder.append(".");
    A_builder.append(A_baseElement.displayName);
    A_builder.append("(");
    int parameterCount = A_parameters.length;
    for (int i = 0; i < parameterCount; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      A_builder.append(A_parameters[i]).toString();
    }
    A_builder.append(")");
    if (A_type != null) {
      A_builder.append(A_Element.RIGHT_ARROW);
      A_builder.append(A_type.returnType);
    }
    return A_builder.toString();
  }
  InterfaceType get definingType => super.definingType as InterfaceType;
}
abstract class PropertyInducingElement implements VariableElement {
  PropertyAccessorElement get getter;
  DartType get propagatedType;
  PropertyAccessorElement get setter;
  bool get isStatic;
}
abstract class PropertyInducingElementImpl extends VariableElementImpl implements PropertyInducingElement {
  PropertyAccessorElement getter;
  PropertyAccessorElement setter;
  DartType propagatedType;
  PropertyInducingElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  PropertyInducingElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
}
class RecursiveElementVisitor<A_R> implements ElementVisitor<A_R> {
  A_R visitAngularComponentElement(AngularComponentElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularControllerElement(AngularControllerElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularDirectiveElement(AngularDecoratorElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularFormatterElement(AngularFormatterElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularPropertyElement(AngularPropertyElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularScopePropertyElement(AngularScopePropertyElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularSelectorElement(AngularSelectorElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitAngularViewElement(AngularViewElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitClassElement(ClassElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitCompilationUnitElement(CompilationUnitElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitConstructorElement(ConstructorElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitEmbeddedHtmlScriptElement(EmbeddedHtmlScriptElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitExportElement(ExportElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitExternalHtmlScriptElement(ExternalHtmlScriptElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitFieldElement(FieldElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitFieldFormalParameterElement(FieldFormalParameterElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitFunctionElement(FunctionElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitFunctionTypeAliasElement(FunctionTypeAliasElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitHtmlElement(HtmlElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitImportElement(ImportElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitLabelElement(LabelElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitLibraryElement(LibraryElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitLocalVariableElement(LocalVariableElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitMethodElement(MethodElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitMultiplyDefinedElement(MultiplyDefinedElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitParameterElement(ParameterElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitPolymerAttributeElement(PolymerAttributeElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitPolymerTagDartElement(PolymerTagDartElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitPolymerTagHtmlElement(PolymerTagHtmlElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitPrefixElement(PrefixElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitPropertyAccessorElement(PropertyAccessorElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitTopLevelVariableElement(TopLevelVariableElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
  A_R visitTypeParameterElement(TypeParameterElement A_element) {
    A_element.visitChildren(this);
    return null;
  }
}
abstract class ShowElementCombinator implements NamespaceCombinator {
  int get end;
  int get offset;
  List<String> get shownNames;
}
class ShowElementCombinatorImpl implements ShowElementCombinator {
  List<String> shownNames = StringUtilities.E_EMPTY_ARRAY;
  int end = -1;
  int offset = 0;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("show ");
    int count = shownNames.length;
    for (int i = 0; i < count; i++) {
      if (i > 0) {
        A_builder.append(", ");
      }
      A_builder.append(shownNames[i]);
    }
    return A_builder.toString();
  }
}
abstract class ToolkitObjectElement implements A_Element {
  static final List<ToolkitObjectElement> B_EMPTY_ARRAY = new List<ToolkitObjectElement>(0);
}
abstract class ToolkitObjectElementImpl extends ElementImpl implements ToolkitObjectElement {
  ToolkitObjectElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
}
abstract class TopLevelVariableElement implements PropertyInducingElement {}
class TopLevelVariableElementImpl extends PropertyInducingElementImpl implements TopLevelVariableElement {
  static List<TopLevelVariableElement> B_EMPTY_ARRAY = new List<TopLevelVariableElement>(0);
  TopLevelVariableElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  TopLevelVariableElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  accept(ElementVisitor visitor) => visitor.visitTopLevelVariableElement(this);
  A_ElementKind get kind => A_ElementKind.C_TOP_LEVEL_VARIABLE;
  bool get isStatic => true;
}
abstract class A_TypeImpl implements DartType {
  static bool equalArrays(List<DartType> typeArgs1, List<DartType> typeArgs2, Set<ElementPair> visitedElementPairs) {
    if (typeArgs1.length != typeArgs2.length) {
      return false;
    }
    for (int i = 0; i < typeArgs1.length; i++) {
      if (!(typeArgs1[i] as A_TypeImpl).internalEquals(typeArgs2[i], visitedElementPairs)) {
        return false;
      }
    }
    return true;
  }
  static List<DartType> A_substitute(List<DartType> A_types, List<DartType> argumentTypes, List<DartType> A_parameterTypes) {
    int A_length = A_types.length;
    if (A_length == 0) {
      return A_types;
    }
    List<DartType> newTypes = new List<DartType>(A_length);
    for (int i = 0; i < A_length; i++) {
      newTypes[i] = A_types[i].substitute2(argumentTypes, A_parameterTypes);
    }
    return newTypes;
  }
  final A_Element E__element;
  final String name;
  static List<DartType> B_EMPTY_ARRAY = new List<DartType>(0);
  A_TypeImpl(this.E__element, this.name);
  String get displayName => name;
  A_Element get element => E__element;
  DartType getLeastUpperBound(DartType A_type) => null;
  bool isAssignableTo(DartType A_type) => isAssignableTo2(A_type, new A_p.HashSet<TypeImpl_TypePair>());
  bool isAssignableTo2(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) => isSubtypeOf2(A_type, visitedTypePairs) || (A_type as A_TypeImpl).isSubtypeOf2(this, visitedTypePairs);
  bool get isBottom => false;
  bool get isDartCoreFunction => false;
  bool get isDynamic => false;
  bool isMoreSpecificThan(DartType A_type) => isMoreSpecificThan2(A_type, false, new A_p.HashSet<TypeImpl_TypePair>());
  bool isMoreSpecificThan2(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    TypeImpl_TypePair typePair = new TypeImpl_TypePair(this, A_type);
    if (!visitedTypePairs.add(typePair)) {
      return false;
    }
    bool result = internalIsMoreSpecificThan(A_type, withDynamic, visitedTypePairs);
    visitedTypePairs.remove(typePair);
    return result;
  }
  bool get isObject => false;
  bool isSubtypeOf(DartType A_type) => isSubtypeOf2(A_type, new A_p.HashSet<TypeImpl_TypePair>());
  bool isSubtypeOf2(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) {
    TypeImpl_TypePair typePair = new TypeImpl_TypePair(this, A_type);
    if (!visitedTypePairs.add(typePair)) {
      return false;
    }
    bool result = internalIsSubtypeOf(A_type, visitedTypePairs);
    visitedTypePairs.remove(typePair);
    return result;
  }
  bool get isVoid => false;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    appendTo(A_builder);
    return A_builder.toString();
  }
  void appendTo(JavaStringBuilder A_builder) {
    if (name == null) {
      A_builder.append("<unnamed type>");
    } else {
      A_builder.append(name);
    }
  }
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs);
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs);
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs);
}
class TypeImpl_TypePair {
  final DartType _firstType;
  final DartType _secondType;
  int _cachedHashCode = 0;
  TypeImpl_TypePair(this._firstType, this._secondType);
  bool operator==(Object object) {
    if (identical(object, this)) {
      return true;
    }
    if (object is TypeImpl_TypePair) {
      TypeImpl_TypePair typePair = object;
      return _firstType == typePair._firstType && _secondType != null && _secondType == typePair._secondType;
    }
    return false;
  }
  int get hashCode {
    if (_cachedHashCode == 0) {
      int firstHashCode = 0;
      if (_firstType != null) {
        A_Element firstElement = _firstType.element;
        firstHashCode = firstElement == null ? 0 : firstElement.hashCode;
      }
      int secondHashCode = 0;
      if (_secondType != null) {
        A_Element secondElement = _secondType.element;
        secondHashCode = secondElement == null ? 0 : secondElement.hashCode;
      }
      _cachedHashCode = firstHashCode + secondHashCode;
    }
    return _cachedHashCode;
  }
}
abstract class TypeParameterElement implements A_Element {
  DartType get bound;
  TypeParameterType get type;
}
class TypeParameterElementImpl extends ElementImpl implements TypeParameterElement {
  TypeParameterType type;
  DartType bound;
  static List<TypeParameterElement> B_EMPTY_ARRAY = new List<TypeParameterElement>(0);
  TypeParameterElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  accept(ElementVisitor visitor) => visitor.visitTypeParameterElement(this);
  A_ElementKind get kind => A_ElementKind.B_TYPE_PARAMETER;
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(displayName);
    if (bound != null) {
      A_builder.append(" extends ");
      A_builder.append(bound);
    }
  }
}
abstract class TypeParameterType implements DartType {
  TypeParameterElement get element;
}
class TypeParameterTypeImpl extends A_TypeImpl implements TypeParameterType {
  static List<TypeParameterType> B_EMPTY_ARRAY = new List<TypeParameterType>(0);
  static String _TYPE_CLASS_NAME = "Type";
  static List<TypeParameterType> getTypes(List<TypeParameterElement> typeParameters) {
    int count = typeParameters.length;
    if (count == 0) {
      return B_EMPTY_ARRAY;
    }
    List<TypeParameterType> A_types = new List<TypeParameterType>(count);
    for (int i = 0; i < count; i++) {
      A_types[i] = typeParameters[i].type;
    }
    return A_types;
  }
  TypeParameterTypeImpl(TypeParameterElement A_element) : super(A_element, A_element.name);
  bool operator==(Object object) => object is TypeParameterTypeImpl && (element == object.element);
  TypeParameterElement get element => super.element as TypeParameterElement;
  int get hashCode => element.hashCode;
  DartType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) {
    int A_length = A_parameterTypes.length;
    for (int i = 0; i < A_length; i++) {
      if (A_parameterTypes[i] == this) {
        return argumentTypes[i];
      }
    }
    return this;
  }
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) => this == object;
  bool internalIsMoreSpecificThan(DartType s, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    if (this == s) {
      return true;
    }
    if (s.isDynamic) {
      return true;
    }
    return _isMoreSpecificThan(s, new A_p.HashSet<DartType>(), withDynamic, visitedTypePairs);
  }
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) => isMoreSpecificThan2(A_type, true, new A_p.HashSet<TypeImpl_TypePair>());
  bool _isMoreSpecificThan(DartType s, Set<DartType> visitedTypes, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) {
    A_Element sElement = s.element;
    LibraryElement sLibrary = sElement != null ? sElement.library : null;
    if (sLibrary != null && sLibrary.isDartCore && s.name == _TYPE_CLASS_NAME) {
      return true;
    }
    DartType A_bound = element.bound;
    if (s == A_bound) {
      return true;
    }
    if (s.isObject) {
      return true;
    }
    if (A_bound == null) {
      return false;
    }
    if (A_bound is TypeParameterTypeImpl) {
      TypeParameterTypeImpl boundTypeParameter = A_bound;
      if (visitedTypes.contains(A_bound)) {
        return false;
      }
      visitedTypes.add(A_bound);
      return boundTypeParameter._isMoreSpecificThan(s, visitedTypes, withDynamic, visitedTypePairs);
    }
    return (A_bound as A_TypeImpl).isMoreSpecificThan2(s, withDynamic, visitedTypePairs);
  }
}
abstract class UriReferencedElement implements A_Element {
  String get uri;
}
abstract class UriReferencedElementImpl extends ElementImpl implements UriReferencedElement {
  int uriOffset = -1;
  int uriEnd = -1;
  String uri;
  UriReferencedElementImpl(String A_name, int A_offset) : super(A_name, A_offset);
}
abstract class VariableElement implements A_Element {
  FunctionElement get initializer;
  VariableDeclaration get node;
  DartType get type;
  bool get isConst;
  bool get isFinal;
}
abstract class VariableElementImpl extends ElementImpl implements VariableElement {
  DartType type;
  FunctionElement A__initializer;
  VariableElementImpl.forNode(Identifier A_name) : super.forNode(A_name);
  VariableElementImpl(String A_name, int nameOffset) : super(A_name, nameOffset);
  EvaluationResultImpl get evaluationResult => null;
  FunctionElement get initializer => A__initializer;
  VariableDeclaration get node => getNodeMatching((A_node) => A_node is VariableDeclaration);
  bool get isConst => hasModifier(Modifier.CONST);
  bool get isFinal => hasModifier(Modifier.FINAL);
  bool get isPotentiallyMutatedInClosure => false;
  bool get isPotentiallyMutatedInScope => false;
  void set const3(bool A_isConst) {
    setModifier(Modifier.CONST, A_isConst);
  }
  void set evaluationResult(EvaluationResultImpl result) {
    throw new IllegalStateException("Invalid attempt to set a compile-time constant result");
  }
  void set final2(bool A_isFinal) {
    setModifier(Modifier.FINAL, A_isFinal);
  }
  void set initializer(FunctionElement A_initializer) {
    if (A_initializer != null) {
      (A_initializer as FunctionElementImpl).enclosingElement = this;
    }
    this.A__initializer = A_initializer;
  }
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(A__initializer, visitor);
  }
  void appendTo(JavaStringBuilder A_builder) {
    A_builder.append(type);
    A_builder.append(" ");
    A_builder.append(displayName);
  }
}
abstract class VariableMember extends Member implements VariableElement {
  VariableMember(VariableElement A_baseElement, ParameterizedType definingType) : super(A_baseElement, definingType);
  VariableElement get baseElement => super.baseElement as VariableElement;
  FunctionElement get initializer {
    throw new UnsupportedOperationException();
  }
  VariableDeclaration get node => baseElement.node;
  DartType get type => substituteFor(baseElement.type);
  bool get isConst => baseElement.isConst;
  bool get isFinal => baseElement.isFinal;
  void visitChildren(ElementVisitor visitor) {
    super.visitChildren(visitor);
    safelyVisitChild(baseElement.initializer, visitor);
  }
}
abstract class VoidType implements DartType {
  VoidType substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes);
}
class VoidTypeImpl extends A_TypeImpl implements VoidType {
  static VoidTypeImpl _INSTANCE = new VoidTypeImpl();
  static VoidTypeImpl get instance => _INSTANCE;
  VoidTypeImpl() : super(null, Keyword.VOID.syntax);
  bool operator==(Object object) => identical(object, this);
  int get hashCode => 2;
  bool get isVoid => true;
  VoidTypeImpl substitute2(List<DartType> argumentTypes, List<DartType> A_parameterTypes) => this;
  bool internalEquals(Object object, Set<ElementPair> visitedElementPairs) => identical(object, this);
  bool internalIsMoreSpecificThan(DartType A_type, bool withDynamic, Set<TypeImpl_TypePair> visitedTypePairs) => isSubtypeOf(A_type);
  bool internalIsSubtypeOf(DartType A_type, Set<TypeImpl_TypePair> visitedTypePairs) => identical(A_type, this) || identical(A_type, DynamicTypeImpl.instance);
}
class AnalysisCache {
  final List<CachePartition> _partitions;
  static bool _TRACE_CHANGES = false;
  AnalysisCache(this._partitions);
  void accessedAst(Source A_source) {
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        _partitions[i].accessedAst(A_source);
        return;
      }
    }
  }
  SourceEntry get(Source A_source) {
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        return _partitions[i].get(A_source);
      }
    }
    return null;
  }
  MapIterator<Source, SourceEntry> iterator() {
    int count = _partitions.length;
    List<Map<Source, SourceEntry>> maps = new List<Map>(count);
    for (int i = 0; i < count; i++) {
      maps[i] = _partitions[i].map;
    }
    return new MultipleMapIterator<Source,SourceEntry>(maps);
  }
  void put(Source A_source, SourceEntry A_entry) {
    (A_entry as SourceEntryImpl).fixExceptionState();
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        if (_TRACE_CHANGES) {
          try {
            SourceEntry oldEntry = _partitions[i].get(A_source);
            if (oldEntry == null) {
              AnalysisEngine.A_instance.logger.logInformation("Added a cache entry for '${A_source.fullName}'.");
            } else {
              AnalysisEngine.A_instance.logger.logInformation("Modified the cache entry for ${A_source.fullName}'. Diff = ${(A_entry as SourceEntryImpl).getDiff(oldEntry)}");
            }
          } catch (exception) {
            JavaSystem.currentTimeMillis();
          }
        }
        _partitions[i].put(A_source, A_entry);
        return;
      }
    }
  }
  void remove(Source A_source) {
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        if (_TRACE_CHANGES) {
          try {
            AnalysisEngine.A_instance.logger.logInformation("Removed the cache entry for ${A_source.fullName}'.");
          } catch (exception) {
            JavaSystem.currentTimeMillis();
          }
        }
        _partitions[i].remove(A_source);
        return;
      }
    }
  }
  void removedAst(Source A_source) {
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        _partitions[i].removedAst(A_source);
        return;
      }
    }
  }
  int size() {
    int A_size = 0;
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      A_size += _partitions[i].size();
    }
    return A_size;
  }
  void storedAst(Source A_source) {
    int count = _partitions.length;
    for (int i = 0; i < count; i++) {
      if (_partitions[i].contains(A_source)) {
        _partitions[i].storedAst(A_source);
        return;
      }
    }
  }
}
abstract class AnalysisContext {
  void applyChanges(ChangeSet changeSet);
  String computeDocumentationComment(A_Element A_element);
  HtmlElement computeHtmlElement(Source A_source);
  SourceKind computeKindOf(Source A_source);
  LibraryElement computeLibraryElement(Source A_source);
  LineInfo computeLineInfo(Source A_source);
  bool exists(Source A_source);
  AnalysisOptions get analysisOptions;
  TimestampedData<String> getContents(Source A_source);
  DeclaredVariables get declaredVariables;
  A_Element getElement(ElementLocation A_location);
  AnalysisErrorInfo getErrors(Source A_source);
  SourceKind getKindOf(Source A_source);
  List<Source> getLibrariesContaining(Source A_source);
  List<Source> getLibrariesDependingOn(Source librarySource);
  LibraryElement getLibraryElement(Source A_source);
  List<Source> get librarySources;
  LineInfo getLineInfo(Source A_source);
  int getModificationStamp(Source A_source);
  CompilationUnit getResolvedCompilationUnit2(Source unitSource, Source librarySource);
  SourceFactory get sourceFactory;
  bool get isDisposed;
  CompilationUnit parseCompilationUnit(Source A_source);
  AnalysisResult performAnalysisTask();
  CompilationUnit resolveCompilationUnit(Source unitSource, LibraryElement library);
  CompilationUnit resolveCompilationUnit2(Source unitSource, Source librarySource);
  void set analysisOptions(AnalysisOptions options);
  void set analysisPriorityOrder(List<Source> sources);
  void setChangedContents(Source A_source, String contents, int A_offset, int oldLength, int newLength);
  void setContents(Source A_source, String contents);
  void set sourceFactory(SourceFactory factory);
}
class AnalysisContextImpl implements InternalAnalysisContext {
  static int _PRIORITY_ORDER_SIZE_DELTA = 4;
  static bool _TRACE_PERFORM_TASK = false;
  AnalysisOptionsImpl _options = new AnalysisOptionsImpl();
  bool _generateSdkErrors = true;
  bool _disposed = false;
  ContentCache _contentCache = new ContentCache();
  SourceFactory _sourceFactory;
  DeclaredVariables A__declaredVariables = new DeclaredVariables();
  Source _coreLibrarySource;
  CachePartition _privatePartition;
  AnalysisCache _cache;
  List<Source> _priorityOrder = Source.F_EMPTY_ARRAY;
  A_p.HashSet<Source> _neededForResolution = null;
  A_p.HashMap<Source, ChangeNoticeImpl> _pendingNotices = new A_p.HashMap<Source,ChangeNoticeImpl>();
  A_p.HashSet<String> _recentTasks = new A_p.HashSet<String>();
  AnalysisContextImpl_AnalysisTaskResultRecorder _resultRecorder;
  IncrementalAnalysisCache _incrementalAnalysisCache;
  WorkManager _workManager = new WorkManager();
  Set<AngularApplication> _angularApplications = new Set();
  AnalysisContextImpl() : super() {
    _resultRecorder = new AnalysisContextImpl_AnalysisTaskResultRecorder(this);
    _privatePartition = new UniversalCachePartition(AnalysisOptionsImpl.DEFAULT_CACHE_SIZE, new AnalysisContextImpl_ContextRetentionPolicy(this));
    _cache = createCacheFromSourceFactory(null);
  }
  void applyChanges(ChangeSet changeSet) {
    if (changeSet.isEmpty) {
      return;
    }
    _recentTasks.clear();
    List<Source> removedSources = new List<Source>.from(changeSet.removedSources);
    for (SourceContainer container in changeSet.removedContainers) {
      _addSourcesInContainer(removedSources, container);
    }
    bool addedDartSource = false;
    for (Source A_source in changeSet.addedSources) {
      if (_sourceAvailable(A_source)) {
        addedDartSource = true;
      }
    }
    for (Source A_source in changeSet.changedSources) {
      if (_contentCache.getContents(A_source) != null) {
        continue;
      }
      _sourceChanged(A_source);
    }
    for (MapEntry<Source, String> A_entry in getMapEntrySet(changeSet.changedContents)) {
      setContents(A_entry.getKey(), A_entry.getValue());
    }
    for (MapEntry<Source, ChangeSet_ContentChange> A_entry in getMapEntrySet(changeSet.changedRanges)) {
      ChangeSet_ContentChange A_change = A_entry.getValue();
      setChangedContents(A_entry.getKey(), A_change.contents, A_change.offset, A_change.oldLength, A_change.newLength);
    }
    for (Source A_source in changeSet.deletedSources) {
      _sourceDeleted(A_source);
    }
    for (Source A_source in removedSources) {
      _sourceRemoved(A_source);
    }
    if (addedDartSource) {
      List<Source> sourcesToInvalidate = new List<Source>();
      MapIterator<Source, SourceEntry> A_iterator = _cache.iterator();
      while (A_iterator.moveNext()) {
        Source A_source = A_iterator.key;
        SourceEntry sourceEntry = A_iterator.value;
        if (!A_source.isInSystemLibrary && (sourceEntry is DartEntry || sourceEntry is HtmlEntry)) {
          sourcesToInvalidate.add(A_source);
        }
      }
      int count = sourcesToInvalidate.length;
      for (int i = 0; i < count; i++) {
        Source A_source = sourcesToInvalidate[i];
        SourceEntry A_entry = _getReadableSourceEntry(A_source);
        if (A_entry is DartEntry) {
          DartEntry dartEntry = A_entry;
          DartEntryImpl dartCopy = dartEntry.writableCopy;
          dartCopy.invalidateAllResolutionInformation(false);
          _cache.put(A_source, dartCopy);
          SourcePriority priority = SourcePriority.C_UNKNOWN;
          SourceKind kind = dartCopy.kind;
          if (kind == SourceKind.D_LIBRARY) {
            priority = SourcePriority.B_LIBRARY;
          } else if (kind == SourceKind.A_PART) {
            priority = SourcePriority.NORMAL_PART;
          }
          _workManager.add(A_source, priority);
        } else if (A_entry is HtmlEntry) {
          HtmlEntry htmlEntry = A_entry;
          HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
          htmlCopy.invalidateAllResolutionInformation(false);
          _cache.put(A_source, htmlCopy);
          _workManager.add(A_source, SourcePriority.B_HTML);
        }
      }
    }
  }
  String computeDocumentationComment(A_Element A_element) {
    if (A_element == null) {
      return null;
    }
    Source A_source = A_element.source;
    if (A_source == null) {
      return null;
    }
    CompilationUnit unit = parseCompilationUnit(A_source);
    if (unit == null) {
      return null;
    }
    NodeLocator locator = new NodeLocator.con1(A_element.nameOffset);
    AstNode nameNode = locator.searchWithin(unit);
    while (nameNode != null) {
      if (nameNode is AnnotatedNode) {
        Comment comment = (nameNode as AnnotatedNode).documentationComment;
        if (comment == null) {
          return null;
        }
        JavaStringBuilder A_builder = new JavaStringBuilder();
        List<A_Token> tokens = comment.tokens;
        for (int i = 0; i < tokens.length; i++) {
          if (i > 0) {
            A_builder.append("\n");
          }
          A_builder.append(tokens[i].lexeme);
        }
        return A_builder.toString();
      }
      nameNode = nameNode.parent;
    }
    return null;
  }
  List<Source> computeExportedLibraries(Source A_source) => _getDartParseData2(A_source, DartEntry.EXPORTED_LIBRARIES, Source.F_EMPTY_ARRAY);
  HtmlElement computeHtmlElement(Source A_source) => _getHtmlResolutionData(A_source, HtmlEntry.B_ELEMENT, null);
  List<Source> computeImportedLibraries(Source A_source) => _getDartParseData2(A_source, DartEntry.IMPORTED_LIBRARIES, Source.F_EMPTY_ARRAY);
  SourceKind computeKindOf(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntry(A_source);
    if (sourceEntry == null) {
      return SourceKind.D_UNKNOWN;
    } else if (sourceEntry is DartEntry) {
      try {
        return _getDartParseData(A_source, sourceEntry, DartEntry.SOURCE_KIND);
      }on AnalysisException  catch (exception) {
        return SourceKind.D_UNKNOWN;
      }
    }
    return sourceEntry.kind;
  }
  LibraryElement computeLibraryElement(Source A_source) => _getDartResolutionData2(A_source, A_source, DartEntry.B_ELEMENT, null);
  LineInfo computeLineInfo(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntry(A_source);
    try {
      if (sourceEntry is HtmlEntry) {
        return _getHtmlParseData(A_source, SourceEntry.LINE_INFO, null);
      } else if (sourceEntry is DartEntry) {
        return _getDartScanData2(A_source, SourceEntry.LINE_INFO, null);
      }
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not compute ${SourceEntry.LINE_INFO.toString()}", exception);
    }
    return null;
  }
  ResolvableCompilationUnit computeResolvableCompilationUnit(Source A_source) {
    DartEntry dartEntry = _getReadableDartEntry(A_source);
    if (dartEntry == null) {
      throw new AnalysisException("computeResolvableCompilationUnit for non-Dart: ${A_source.fullName}");
    }
    dartEntry = _cacheDartParseData(A_source, dartEntry, DartEntry.PARSED_UNIT);
    DartEntryImpl dartCopy = dartEntry.writableCopy;
    CompilationUnit unit = dartCopy.resolvableCompilationUnit;
    if (unit == null) {
      throw new AnalysisException("Internal error: computeResolvableCompilationUnit could not parse ${A_source.fullName}", new CaughtException(dartEntry.exception, null));
    }
    _cache.put(A_source, dartCopy);
    return new ResolvableCompilationUnit.C_con1(dartCopy.modificationTime, unit);
  }
  bool exists(Source A_source) {
    if (A_source == null) {
      return false;
    }
    if (_contentCache.getContents(A_source) != null) {
      return true;
    }
    return A_source.exists();
  }
  AnalysisOptions get analysisOptions => _options;
  TimestampedData<String> getContents(Source A_source) {
    String contents = _contentCache.getContents(A_source);
    if (contents != null) {
      return new TimestampedData<String>(_contentCache.getModificationStamp(A_source), contents);
    }
    return A_source.contents;
  }
  DeclaredVariables get declaredVariables => A__declaredVariables;
  A_Element getElement(ElementLocation A_location) {
    try {
      List<String> components = A_location.components;
      Source A_source = _computeSourceFromEncoding(components[0]);
      String sourceName = A_source.shortName;
      if (AnalysisEngine.isDartFileName(sourceName)) {
        ElementImpl A_element = computeLibraryElement(A_source) as ElementImpl;
        for (int i = 1; i < components.length; i++) {
          if (A_element == null) {
            return null;
          }
          A_element = A_element.getChild(components[i]);
        }
        return A_element;
      }
      if (AnalysisEngine.isHtmlFileName(sourceName)) {
        return computeHtmlElement(A_source);
      }
    }on AnalysisException  catch (exception) {}
    return null;
  }
  AnalysisErrorInfo getErrors(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(A_source);
    if (sourceEntry is DartEntry) {
      DartEntry dartEntry = sourceEntry;
      return new AnalysisErrorInfoImpl(dartEntry.allErrors, dartEntry.getValue(SourceEntry.LINE_INFO));
    } else if (sourceEntry is HtmlEntry) {
      HtmlEntry htmlEntry = sourceEntry;
      return new AnalysisErrorInfoImpl(htmlEntry.allErrors, htmlEntry.getValue(SourceEntry.LINE_INFO));
    }
    return new AnalysisErrorInfoImpl(A_AnalysisError.NO_ERRORS, null);
  }
  SourceKind getKindOf(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(A_source);
    if (sourceEntry == null) {
      return SourceKind.D_UNKNOWN;
    }
    return sourceEntry.kind;
  }
  List<Source> getLibrariesContaining(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(A_source);
    if (sourceEntry is DartEntry) {
      return sourceEntry.getValue(DartEntry.CONTAINING_LIBRARIES);
    }
    return Source.F_EMPTY_ARRAY;
  }
  List<Source> getLibrariesDependingOn(Source librarySource) {
    List<Source> dependentLibraries = new List<Source>();
    MapIterator<Source, SourceEntry> A_iterator = _cache.iterator();
    while (A_iterator.moveNext()) {
      SourceEntry sourceEntry = A_iterator.value;
      if (sourceEntry.kind == SourceKind.D_LIBRARY) {
        if (_contains((sourceEntry as DartEntry).getValue(DartEntry.EXPORTED_LIBRARIES), librarySource)) {
          dependentLibraries.add(A_iterator.key);
        }
        if (_contains((sourceEntry as DartEntry).getValue(DartEntry.IMPORTED_LIBRARIES), librarySource)) {
          dependentLibraries.add(A_iterator.key);
        }
      }
    }
    if (dependentLibraries.isEmpty) {
      return Source.F_EMPTY_ARRAY;
    }
    return new List.from(dependentLibraries);
  }
  LibraryElement getLibraryElement(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(A_source);
    if (sourceEntry is DartEntry) {
      return sourceEntry.getValue(DartEntry.B_ELEMENT);
    }
    return null;
  }
  List<Source> get librarySources => _getSources(SourceKind.D_LIBRARY);
  LineInfo getLineInfo(Source A_source) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(A_source);
    if (sourceEntry != null) {
      return sourceEntry.getValue(SourceEntry.LINE_INFO);
    }
    return null;
  }
  int getModificationStamp(Source A_source) {
    int stamp = _contentCache.getModificationStamp(A_source);
    if (stamp != null) {
      return stamp;
    }
    return A_source.modificationStamp;
  }
  Namespace getPublicNamespace(LibraryElement library) {
    Source A_source = library.definingCompilationUnit.source;
    DartEntry dartEntry = _getReadableDartEntry(A_source);
    if (dartEntry == null) {
      return null;
    }
    Namespace namespace = null;
    if (identical(dartEntry.getValue(DartEntry.B_ELEMENT), library)) {
      namespace = dartEntry.getValue(DartEntry.PUBLIC_NAMESPACE);
    }
    if (namespace == null) {
      NamespaceBuilder A_builder = new NamespaceBuilder();
      namespace = A_builder.createPublicNamespaceForLibrary(library);
      dartEntry = _getReadableDartEntry(A_source);
      if (dartEntry == null) {
        AnalysisEngine.A_instance.logger.logError2("Could not compute the public namespace for ${library.source.fullName}", new CaughtException(new AnalysisException("A Dart file became a non-Dart file: ${A_source.fullName}"), null));
        return null;
      }
      if (identical(dartEntry.getValue(DartEntry.B_ELEMENT), library)) {
        DartEntryImpl dartCopy = _getReadableDartEntry(A_source).writableCopy;
        dartCopy.setValue(DartEntry.PUBLIC_NAMESPACE, namespace);
        _cache.put(A_source, dartCopy);
      }
    }
    return namespace;
  }
  CompilationUnit getResolvedCompilationUnit2(Source unitSource, Source librarySource) {
    SourceEntry sourceEntry = _getReadableSourceEntryOrNull(unitSource);
    if (sourceEntry is DartEntry) {
      return sourceEntry.getValueInLibrary(DartEntry.RESOLVED_UNIT, librarySource);
    }
    return null;
  }
  SourceFactory get sourceFactory => _sourceFactory;
  TypeProvider get typeProvider {
    Source coreSource = sourceFactory.forUri(DartSdk.DART_CORE);
    if (coreSource == null) {
      throw new AnalysisException("Could not create a source for dart:core");
    }
    LibraryElement coreElement = computeLibraryElement(coreSource);
    if (coreElement == null) {
      throw new AnalysisException("Could not create an element for dart:core");
    }
    return new TypeProviderImpl(coreElement);
  }
  bool get isDisposed => _disposed;
  CompilationUnit parseCompilationUnit(Source A_source) => _getDartParseData2(A_source, DartEntry.PARSED_UNIT, null);
  AnalysisResult performAnalysisTask() {
    if (_TRACE_PERFORM_TASK) {
      print("----------------------------------------");
    }
    int getStart = JavaSystem.currentTimeMillis();
    AnalysisTask task = nextAnalysisTask;
    int getEnd = JavaSystem.currentTimeMillis();
    if (task == null && _validateCacheConsistency()) {
      task = nextAnalysisTask;
    }
    if (task == null) {
      return new AnalysisResult(_getChangeNotices(true), getEnd - getStart, null, -1);
    }
    String taskDescriptor = task.toString();
    if (_TRACE_PERFORM_TASK) {
      print(taskDescriptor);
    }
    int performStart = JavaSystem.currentTimeMillis();
    try {
      task.perform(_resultRecorder);
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not perform analysis task: ${taskDescriptor}", exception);
    } on AnalysisException  catch (exception) {
      if (exception.cause is! JavaIOException) {
        AnalysisEngine.A_instance.logger.logError2("Internal error while performing the task: ${task}", exception);
      }
    }
    int performEnd = JavaSystem.currentTimeMillis();
    return new AnalysisResult(_getChangeNotices(false), getEnd - getStart, task.runtimeType.toString(), performEnd - performStart);
  }
  CompilationUnit resolveCompilationUnit(Source unitSource, LibraryElement library) {
    if (library == null) {
      return null;
    }
    return resolveCompilationUnit2(unitSource, library.source);
  }
  CompilationUnit resolveCompilationUnit2(Source unitSource, Source librarySource) => _getDartResolutionData2(unitSource, librarySource, DartEntry.RESOLVED_UNIT, null);
  void set analysisOptions(AnalysisOptions options) {
    bool needsRecompute = this._options.analyzeAngular != options.analyzeAngular || this._options.analyzeFunctionBodies != options.analyzeFunctionBodies || this._options.generateSdkErrors != options.generateSdkErrors || this._options.enableAsync != options.enableAsync || this._options.enableDeferredLoading != options.enableDeferredLoading || this._options.enableEnum != options.enableEnum || this._options.dart2jsHint != options.dart2jsHint || (this._options.hint && !options.hint) || this._options.preserveComments != options.preserveComments;
    int cacheSize = options.cacheSize;
    if (this._options.cacheSize != cacheSize) {
      this._options.cacheSize = cacheSize;
      _privatePartition.maxCacheSize = cacheSize;
      int maxPriorityOrderSize = cacheSize - _PRIORITY_ORDER_SIZE_DELTA;
      if (_priorityOrder.length > maxPriorityOrderSize) {
        List<Source> newPriorityOrder = new List<Source>(maxPriorityOrderSize);
        JavaSystem.arraycopy(_priorityOrder, 0, newPriorityOrder, 0, maxPriorityOrderSize);
        _priorityOrder = newPriorityOrder;
      }
    }
    this._options.analyzeAngular = options.analyzeAngular;
    this._options.analyzeFunctionBodies = options.analyzeFunctionBodies;
    this._options.generateSdkErrors = options.generateSdkErrors;
    this._options.enableAsync = options.enableAsync;
    this._options.enableDeferredLoading = options.enableDeferredLoading;
    this._options.enableEnum = options.enableEnum;
    this._options.dart2jsHint = options.dart2jsHint;
    this._options.hint = options.hint;
    this._options.incremental = options.incremental;
    this._options.preserveComments = options.preserveComments;
    _generateSdkErrors = options.generateSdkErrors;
    if (needsRecompute) {
      _invalidateAllLocalResolutionInformation(false);
    }
  }
  void set analysisPriorityOrder(List<Source> sources) {
    if (sources == null || sources.isEmpty) {
      _priorityOrder = Source.F_EMPTY_ARRAY;
    } else {
      while (sources.remove(null)) {}
      if (sources.isEmpty) {
        _priorityOrder = Source.F_EMPTY_ARRAY;
      }
      int count = Math.A_min(sources.length, _options.cacheSize - _PRIORITY_ORDER_SIZE_DELTA);
      _priorityOrder = new List<Source>(count);
      for (int i = 0; i < count; i++) {
        _priorityOrder[i] = sources[i];
      }
    }
  }
  void setChangedContents(Source A_source, String contents, int A_offset, int oldLength, int newLength) {
    _recentTasks.clear();
    String originalContents = _contentCache.setContents(A_source, contents);
    if (contents != null) {
      if (contents != originalContents) {
        if (_options.incremental) {
          _incrementalAnalysisCache = IncrementalAnalysisCache.A_update(_incrementalAnalysisCache, A_source, originalContents, contents, A_offset, oldLength, newLength, _getReadableSourceEntry(A_source));
        }
        _sourceChanged(A_source);
        SourceEntry sourceEntry = _cache.get(A_source);
        if (sourceEntry != null) {
          SourceEntryImpl sourceCopy = sourceEntry.writableCopy;
          sourceCopy.modificationTime = _contentCache.getModificationStamp(A_source);
          sourceCopy.setValue(SourceEntry.A_CONTENT, contents);
          _cache.put(A_source, sourceCopy);
        }
      }
    } else if (originalContents != null) {
      _incrementalAnalysisCache = IncrementalAnalysisCache.A_clear(_incrementalAnalysisCache, A_source);
      _sourceChanged(A_source);
    }
  }
  void setContents(Source A_source, String contents) {
    _recentTasks.clear();
    String originalContents = _contentCache.setContents(A_source, contents);
    if (contents != null) {
      if (contents != originalContents) {
        _incrementalAnalysisCache = IncrementalAnalysisCache.A_clear(_incrementalAnalysisCache, A_source);
        _sourceChanged(A_source);
        SourceEntry sourceEntry = _cache.get(A_source);
        if (sourceEntry != null) {
          SourceEntryImpl sourceCopy = sourceEntry.writableCopy;
          sourceCopy.modificationTime = _contentCache.getModificationStamp(A_source);
          sourceCopy.setValue(SourceEntry.A_CONTENT, contents);
          _cache.put(A_source, sourceCopy);
        }
      }
    } else if (originalContents != null) {
      _incrementalAnalysisCache = IncrementalAnalysisCache.A_clear(_incrementalAnalysisCache, A_source);
      _sourceChanged(A_source);
    }
  }
  void set sourceFactory(SourceFactory factory) {
    if (identical(_sourceFactory, factory)) {
      return;
    } else if (factory.context != null) {
      throw new IllegalStateException("Source factories cannot be shared between contexts");
    }
    if (_sourceFactory != null) {
      _sourceFactory.context = null;
    }
    factory.context = this;
    _sourceFactory = factory;
    _coreLibrarySource = _sourceFactory.forUri(DartSdk.DART_CORE);
    _cache = createCacheFromSourceFactory(factory);
    _invalidateAllLocalResolutionInformation(true);
  }
  AnalysisCache createCacheFromSourceFactory(SourceFactory factory) {
    if (factory == null) {
      return new AnalysisCache(<CachePartition>[_privatePartition]);
    }
    DartSdk sdk = factory.dartSdk;
    if (sdk == null) {
      return new AnalysisCache(<CachePartition>[_privatePartition]);
    }
    return new AnalysisCache(<CachePartition>[AnalysisEngine.A_instance.partitionManager.forSdk(sdk), _privatePartition]);
  }
  DartEntry recordResolveDartLibraryCycleTaskResults(ResolveDartLibraryCycleTask task) {
    LibraryResolver2 resolver = task.libraryResolver;
    CaughtException thrownException = task.exception;
    DartEntry unitEntry = null;
    Source unitSource = task.unitSource;
    if (resolver != null) {
      List<ResolvableLibrary> resolvedLibraries = resolver.resolvedLibraries;
      if (resolvedLibraries == null) {
        unitEntry = _getReadableDartEntry(unitSource);
        if (unitEntry == null) {
          throw new AnalysisException("A Dart file became a non-Dart file: ${unitSource.fullName}");
        }
        DartEntryImpl dartCopy = unitEntry.writableCopy;
        if (thrownException == null) {
          dartCopy.recordResolutionError(new CaughtException(new AnalysisException("In recordResolveDartLibraryCycleTaskResults, resolvedLibraries was null and there was no thrown exception"), null));
        } else {
          dartCopy.recordResolutionError(thrownException);
        }
        _cache.put(unitSource, dartCopy);
        _cache.remove(unitSource);
        if (thrownException != null) {
          throw new AnalysisException('<rethrow>', thrownException);
        }
        return dartCopy;
      }
      if (_allModificationTimesMatch(resolvedLibraries)) {
        Source htmlSource = sourceFactory.forUri(DartSdk.DART_HTML);
        RecordingErrorListener errorListener = resolver.errorListener;
        for (ResolvableLibrary library in resolvedLibraries) {
          Source librarySource = library.librarySource;
          for (Source A_source in library.compilationUnitSources) {
            CompilationUnit unit = library.getAST(A_source);
            List<A_AnalysisError> B_errors = errorListener.getErrorsForSource(A_source);
            LineInfo lineInfo = getLineInfo(A_source);
            DartEntryImpl dartCopy = _cache.get(A_source).writableCopy as DartEntryImpl;
            if (thrownException == null) {
              dartCopy.setState(DartEntry.PARSED_UNIT, CacheState.FLUSHED);
              dartCopy.setValueInLibrary(DartEntry.RESOLVED_UNIT, librarySource, unit);
              dartCopy.setValueInLibrary(DartEntry.RESOLUTION_ERRORS, librarySource, B_errors);
              if (A_source == librarySource) {
                _recordElementData(dartCopy, library.libraryElement, librarySource, htmlSource);
              }
              _cache.storedAst(A_source);
            } else {
              dartCopy.recordResolutionErrorInLibrary(librarySource, thrownException);
              _cache.remove(A_source);
            }
            _cache.put(A_source, dartCopy);
            if (A_source != librarySource) {
              _workManager.add(A_source, SourcePriority.PRIORITY_PART);
            }
            if (A_source == unitSource) {
              unitEntry = dartCopy;
            }
            ChangeNoticeImpl notice = _getNotice(A_source);
            notice.compilationUnit = unit;
            notice.setErrors(dartCopy.allErrors, lineInfo);
          }
        }
      } else {
        PrintStringWriter writer = new PrintStringWriter();
        writer.println("Library resolution results discarded for");
        for (ResolvableLibrary library in resolvedLibraries) {
          for (Source A_source in library.compilationUnitSources) {
            DartEntry dartEntry = _getReadableDartEntry(A_source);
            if (dartEntry != null) {
              int resultTime = library.A_getModificationTime(A_source);
              writer.println("  ${_debuggingString(A_source)}; sourceTime = ${getModificationStamp(A_source)}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}");
              DartEntryImpl dartCopy = dartEntry.writableCopy;
              if (thrownException == null || resultTime >= 0) {
                dartCopy.recordResolutionNotInProcess();
              } else {
                dartCopy.recordResolutionError(thrownException);
                _cache.remove(A_source);
              }
              _cache.put(A_source, dartCopy);
              if (A_source == unitSource) {
                unitEntry = dartCopy;
              }
            } else {
              writer.println("  ${_debuggingString(A_source)}; sourceTime = ${getModificationStamp(A_source)}, no entry");
            }
          }
        }
        _logInformation(writer.toString());
      }
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    if (unitEntry == null) {
      unitEntry = _getReadableDartEntry(unitSource);
      if (unitEntry == null) {
        throw new AnalysisException("A Dart file became a non-Dart file: ${unitSource.fullName}");
      }
    }
    return unitEntry;
  }
  DartEntry recordResolveDartLibraryTaskResults(ResolveDartLibraryTask task) {
    LibraryResolver resolver = task.libraryResolver;
    CaughtException thrownException = task.exception;
    DartEntry unitEntry = null;
    Source unitSource = task.unitSource;
    if (resolver != null) {
      Set<Library> resolvedLibraries = resolver.resolvedLibraries;
      if (resolvedLibraries == null) {
        unitEntry = _getReadableDartEntry(unitSource);
        if (unitEntry == null) {
          throw new AnalysisException("A Dart file became a non-Dart file: ${unitSource.fullName}");
        }
        DartEntryImpl dartCopy = unitEntry.writableCopy;
        if (thrownException == null) {
          dartCopy.recordResolutionError(new CaughtException(new AnalysisException("In recordResolveDartLibraryTaskResults, resolvedLibraries was null and there was no thrown exception"), null));
        } else {
          dartCopy.recordResolutionError(thrownException);
        }
        _cache.put(unitSource, dartCopy);
        _cache.remove(unitSource);
        if (thrownException != null) {
          throw new AnalysisException('<rethrow>', thrownException);
        }
        return dartCopy;
      }
      if (_allModificationTimesMatch2(resolvedLibraries)) {
        Source htmlSource = sourceFactory.forUri(DartSdk.DART_HTML);
        RecordingErrorListener errorListener = resolver.errorListener;
        for (Library library in resolvedLibraries) {
          Source librarySource = library.librarySource;
          for (Source A_source in library.compilationUnitSources) {
            CompilationUnit unit = library.getAST(A_source);
            List<A_AnalysisError> B_errors = errorListener.getErrorsForSource(A_source);
            LineInfo lineInfo = getLineInfo(A_source);
            DartEntry dartEntry = _cache.get(A_source) as DartEntry;
            int sourceTime = getModificationStamp(A_source);
            if (dartEntry.modificationTime != sourceTime) {
              _sourceChanged(A_source);
              dartEntry = _getReadableDartEntry(A_source);
              if (dartEntry == null) {
                throw new AnalysisException("A Dart file became a non-Dart file: ${A_source.fullName}");
              }
            }
            DartEntryImpl dartCopy = dartEntry.writableCopy;
            if (thrownException == null) {
              dartCopy.setValue(SourceEntry.LINE_INFO, lineInfo);
              dartCopy.setState(DartEntry.PARSED_UNIT, CacheState.FLUSHED);
              dartCopy.setValueInLibrary(DartEntry.RESOLVED_UNIT, librarySource, unit);
              dartCopy.setValueInLibrary(DartEntry.RESOLUTION_ERRORS, librarySource, B_errors);
              if (A_source == librarySource) {
                _recordElementData(dartCopy, library.libraryElement, librarySource, htmlSource);
              }
              _cache.storedAst(A_source);
            } else {
              dartCopy.recordResolutionErrorInLibrary(librarySource, thrownException);
              _cache.remove(A_source);
            }
            _cache.put(A_source, dartCopy);
            if (A_source != librarySource) {
              _workManager.add(A_source, SourcePriority.PRIORITY_PART);
            }
            if (A_source == unitSource) {
              unitEntry = dartCopy;
            }
            ChangeNoticeImpl notice = _getNotice(A_source);
            notice.compilationUnit = unit;
            notice.setErrors(dartCopy.allErrors, lineInfo);
          }
        }
      } else {
        PrintStringWriter writer = new PrintStringWriter();
        writer.println("Library resolution results discarded for");
        for (Library library in resolvedLibraries) {
          for (Source A_source in library.compilationUnitSources) {
            DartEntry dartEntry = _getReadableDartEntry(A_source);
            if (dartEntry != null) {
              int resultTime = library.A_getModificationTime(A_source);
              writer.println("  ${_debuggingString(A_source)}; sourceTime = ${getModificationStamp(A_source)}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}");
              DartEntryImpl dartCopy = dartEntry.writableCopy;
              if (thrownException == null || resultTime >= 0) {
                dartCopy.recordResolutionNotInProcess();
              } else {
                dartCopy.recordResolutionError(thrownException);
                _cache.remove(A_source);
              }
              _cache.put(A_source, dartCopy);
              if (A_source == unitSource) {
                unitEntry = dartCopy;
              }
            } else {
              writer.println("  ${_debuggingString(A_source)}; sourceTime = ${getModificationStamp(A_source)}, no entry");
            }
          }
        }
        _logInformation(writer.toString());
      }
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    if (unitEntry == null) {
      unitEntry = _getReadableDartEntry(unitSource);
      if (unitEntry == null) {
        throw new AnalysisException("A Dart file became a non-Dart file: ${unitSource.fullName}");
      }
    }
    return unitEntry;
  }
  void _accessedAst(Source A_source) {
    _cache.accessedAst(A_source);
  }
  void _addSourcesInContainer(List<Source> sources, SourceContainer container) {
    MapIterator<Source, SourceEntry> A_iterator = _cache.iterator();
    while (A_iterator.moveNext()) {
      Source A_source = A_iterator.key;
      if (container.contains(A_source)) {
        sources.add(A_source);
      }
    }
  }
  bool _allModificationTimesMatch(List<ResolvableLibrary> resolvedLibraries) {
    bool allTimesMatch = true;
    for (ResolvableLibrary library in resolvedLibraries) {
      for (Source A_source in library.compilationUnitSources) {
        DartEntry dartEntry = _getReadableDartEntry(A_source);
        if (dartEntry == null) {
          throw new AnalysisException("Internal error: attempting to resolve non-Dart file as a Dart file: ${A_source.fullName}");
        }
        int sourceTime = getModificationStamp(A_source);
        int resultTime = library.A_getModificationTime(A_source);
        if (sourceTime != resultTime) {
          _sourceChanged(A_source);
          allTimesMatch = false;
        }
      }
    }
    return allTimesMatch;
  }
  bool _allModificationTimesMatch2(Set<Library> resolvedLibraries) {
    bool allTimesMatch = true;
    for (Library library in resolvedLibraries) {
      for (Source A_source in library.compilationUnitSources) {
        DartEntry dartEntry = _getReadableDartEntry(A_source);
        if (dartEntry == null) {
          throw new AnalysisException("Internal error: attempting to resolve non-Dart file as a Dart file: ${A_source.fullName}");
        }
        int sourceTime = getModificationStamp(A_source);
        int resultTime = library.A_getModificationTime(A_source);
        if (sourceTime != resultTime) {
          _sourceChanged(A_source);
          allTimesMatch = false;
        }
      }
    }
    return allTimesMatch;
  }
  DartEntry _cacheDartParseData(Source A_source, DartEntry dartEntry, DataDescriptor descriptor) {
    if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      if (dartEntry.hasResolvableCompilationUnit) {
        return dartEntry;
      }
    }
    CacheState state = dartEntry.getState(descriptor);
    while (state != CacheState.C_ERROR && state != CacheState.VALID) {
      dartEntry = _cacheDartScanData(A_source, dartEntry, DartEntry.TOKEN_STREAM);
      dartEntry = new ParseDartTask(this, A_source, dartEntry.modificationTime, dartEntry.getValue(DartEntry.TOKEN_STREAM), dartEntry.getValue(SourceEntry.LINE_INFO)).perform(_resultRecorder) as DartEntry;
      state = dartEntry.getState(descriptor);
    }
    return dartEntry;
  }
  DartEntry _cacheDartResolutionData(Source unitSource, Source librarySource, DartEntry dartEntry, DataDescriptor descriptor) {
    CacheState state = (identical(descriptor, DartEntry.B_ELEMENT)) ? dartEntry.getState(descriptor) : dartEntry.getStateInLibrary(descriptor, librarySource);
    while (state != CacheState.C_ERROR && state != CacheState.VALID) {
      dartEntry = new ResolveDartLibraryTask(this, unitSource, librarySource).perform(_resultRecorder) as DartEntry;
      state = (identical(descriptor, DartEntry.B_ELEMENT)) ? dartEntry.getState(descriptor) : dartEntry.getStateInLibrary(descriptor, librarySource);
    }
    return dartEntry;
  }
  DartEntry _cacheDartScanData(Source A_source, DartEntry dartEntry, DataDescriptor descriptor) {
    CacheState state = dartEntry.getState(descriptor);
    while (state != CacheState.C_ERROR && state != CacheState.VALID) {
      try {
        if (dartEntry.getState(SourceEntry.A_CONTENT) != CacheState.VALID) {
          dartEntry = new GetContentTask(this, A_source).perform(_resultRecorder) as DartEntry;
        }
        dartEntry = new ScanDartTask(this, A_source, dartEntry.modificationTime, dartEntry.getValue(SourceEntry.A_CONTENT)).perform(_resultRecorder) as DartEntry;
      }on AnalysisException  catch (exception) {
        throw exception;
      }  catch (exception, A_stackTrace) {
        throw new AnalysisException("Exception", new CaughtException(exception, A_stackTrace));
      }
      state = dartEntry.getState(descriptor);
    }
    return dartEntry;
  }
  HtmlEntry _cacheHtmlParseData(Source A_source, HtmlEntry htmlEntry, DataDescriptor descriptor) {
    if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      HtmlUnit unit = htmlEntry.anyParsedUnit;
      if (unit != null) {
        return htmlEntry;
      }
    }
    CacheState state = htmlEntry.getState(descriptor);
    while (state != CacheState.C_ERROR && state != CacheState.VALID) {
      try {
        if (htmlEntry.getState(SourceEntry.A_CONTENT) != CacheState.VALID) {
          htmlEntry = new GetContentTask(this, A_source).perform(_resultRecorder) as HtmlEntry;
        }
        htmlEntry = new ParseHtmlTask(this, A_source, htmlEntry.modificationTime, htmlEntry.getValue(SourceEntry.A_CONTENT)).perform(_resultRecorder) as HtmlEntry;
      }on AnalysisException  catch (exception) {
        throw exception;
      }  catch (exception, A_stackTrace) {
        throw new AnalysisException("Exception", new CaughtException(exception, A_stackTrace));
      }
      state = htmlEntry.getState(descriptor);
    }
    return htmlEntry;
  }
  HtmlEntry _cacheHtmlResolutionData(Source A_source, HtmlEntry htmlEntry, DataDescriptor descriptor) {
    CacheState state = htmlEntry.getState(descriptor);
    while (state != CacheState.C_ERROR && state != CacheState.VALID) {
      htmlEntry = _cacheHtmlParseData(A_source, htmlEntry, HtmlEntry.PARSED_UNIT);
      htmlEntry = new ResolveHtmlTask(this, A_source, htmlEntry.modificationTime, htmlEntry.getValue(HtmlEntry.PARSED_UNIT)).perform(_resultRecorder) as HtmlEntry;
      state = htmlEntry.getState(descriptor);
    }
    return htmlEntry;
  }
  void _computeAllLibrariesDependingOn(Source library, A_p.HashSet<Source> librariesToInvalidate) {
    if (librariesToInvalidate.add(library)) {
      for (Source dependentLibrary in getLibrariesDependingOn(library)) {
        _computeAllLibrariesDependingOn(dependentLibrary, librariesToInvalidate);
      }
    }
  }
  Source _computeSourceFromEncoding(String A_encoding) => _sourceFactory.fromEncoding(A_encoding);
  bool _contains(List<Source> sources, Source targetSource) {
    for (Source A_source in sources) {
      if (A_source == targetSource) {
        return true;
      }
    }
    return false;
  }
  AnalysisContextImpl_TaskData _createGenerateDartErrorsTask(Source unitSource, DartEntry unitEntry, Source librarySource, DartEntry libraryEntry) {
    if (unitEntry.getStateInLibrary(DartEntry.RESOLVED_UNIT, librarySource) != CacheState.VALID || libraryEntry.getState(DartEntry.B_ELEMENT) != CacheState.VALID) {
      return _createResolveDartLibraryTask(librarySource, libraryEntry);
    }
    CompilationUnit unit = unitEntry.getValueInLibrary(DartEntry.RESOLVED_UNIT, librarySource);
    if (unit == null) {
      CaughtException exception = new CaughtException(new AnalysisException("Entry has VALID state for RESOLVED_UNIT but null value for ${unitSource.fullName} in ${librarySource.fullName}"), null);
      AnalysisEngine.A_instance.logger.logInformation2(exception.toString(), exception);
      DartEntryImpl dartCopy = unitEntry.writableCopy;
      dartCopy.recordResolutionError(exception);
      _cache.put(unitSource, dartCopy);
      return new AnalysisContextImpl_TaskData(null, false);
    }
    LibraryElement libraryElement = libraryEntry.getValue(DartEntry.B_ELEMENT);
    DartEntryImpl dartCopy = unitEntry.writableCopy;
    dartCopy.setStateInLibrary(DartEntry.VERIFICATION_ERRORS, librarySource, CacheState.IN_PROCESS);
    _cache.put(unitSource, dartCopy);
    return new AnalysisContextImpl_TaskData(new GenerateDartErrorsTask(this, unitSource, dartCopy.modificationTime, unit, libraryElement), false);
  }
  AnalysisContextImpl_TaskData _createGenerateDartHintsTask(Source A_source, DartEntry dartEntry, Source librarySource, DartEntry libraryEntry) {
    if (libraryEntry.getState(DartEntry.B_ELEMENT) != CacheState.VALID) {
      return _createResolveDartLibraryTask(librarySource, libraryEntry);
    }
    LibraryElement libraryElement = libraryEntry.getValue(DartEntry.B_ELEMENT);
    CompilationUnitElement definingUnit = libraryElement.definingCompilationUnit;
    List<CompilationUnitElement> parts = libraryElement.parts;
    List<TimestampedData<CompilationUnit>> units = new List<TimestampedData>(parts.length + 1);
    units[0] = _getResolvedUnit(definingUnit, librarySource);
    if (units[0] == null) {
      return _createResolveDartLibraryTask(librarySource, libraryEntry);
    }
    for (int i = 0; i < parts.length; i++) {
      units[i + 1] = _getResolvedUnit(parts[i], librarySource);
      if (units[i + 1] == null) {
        return _createResolveDartLibraryTask(librarySource, libraryEntry);
      }
    }
    DartEntryImpl dartCopy = dartEntry.writableCopy;
    dartCopy.setStateInLibrary(DartEntry.HINTS, librarySource, CacheState.IN_PROCESS);
    _cache.put(A_source, dartCopy);
    return new AnalysisContextImpl_TaskData(new GenerateDartHintsTask(this, units, libraryElement), false);
  }
  AnalysisContextImpl_TaskData _createGetContentTask(Source A_source, SourceEntry sourceEntry) {
    SourceEntryImpl sourceCopy = sourceEntry.writableCopy;
    sourceCopy.setState(SourceEntry.A_CONTENT, CacheState.IN_PROCESS);
    _cache.put(A_source, sourceCopy);
    return new AnalysisContextImpl_TaskData(new GetContentTask(this, A_source), false);
  }
  AnalysisContextImpl_TaskData _createParseDartTask(Source A_source, DartEntry dartEntry) {
    if (dartEntry.getState(DartEntry.TOKEN_STREAM) != CacheState.VALID || dartEntry.getState(SourceEntry.LINE_INFO) != CacheState.VALID) {
      return _createScanDartTask(A_source, dartEntry);
    }
    A_Token tokenStream = dartEntry.getValue(DartEntry.TOKEN_STREAM);
    DartEntryImpl dartCopy = dartEntry.writableCopy;
    dartCopy.setState(DartEntry.TOKEN_STREAM, CacheState.FLUSHED);
    dartCopy.setState(DartEntry.PARSE_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, dartCopy);
    return new AnalysisContextImpl_TaskData(new ParseDartTask(this, A_source, dartCopy.modificationTime, tokenStream, dartEntry.getValue(SourceEntry.LINE_INFO)), false);
  }
  AnalysisContextImpl_TaskData _createParseHtmlTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(SourceEntry.A_CONTENT) != CacheState.VALID) {
      return _createGetContentTask(A_source, htmlEntry);
    }
    String content = htmlEntry.getValue(SourceEntry.A_CONTENT);
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(SourceEntry.A_CONTENT, CacheState.FLUSHED);
    htmlCopy.setState(HtmlEntry.PARSE_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new ParseHtmlTask(this, A_source, htmlCopy.modificationTime, content), false);
  }
  AnalysisContextImpl_TaskData _createPolymerBuildHtmlTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(HtmlEntry.RESOLVED_UNIT) != CacheState.VALID) {
      return _createResolveHtmlTask(A_source, htmlEntry);
    }
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(HtmlEntry.POLYMER_BUILD_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new PolymerBuildHtmlTask(this, A_source, htmlCopy.modificationTime, htmlEntry.getValue(SourceEntry.LINE_INFO), htmlCopy.getValue(HtmlEntry.RESOLVED_UNIT)), false);
  }
  AnalysisContextImpl_TaskData _createPolymerResolveHtmlTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(HtmlEntry.RESOLVED_UNIT) != CacheState.VALID) {
      return _createResolveHtmlTask(A_source, htmlEntry);
    }
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(HtmlEntry.POLYMER_RESOLUTION_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new PolymerResolveHtmlTask(this, A_source, htmlCopy.modificationTime, htmlEntry.getValue(SourceEntry.LINE_INFO), htmlCopy.getValue(HtmlEntry.RESOLVED_UNIT)), false);
  }
  AnalysisContextImpl_TaskData _createResolveAngularComponentTemplateTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(HtmlEntry.RESOLVED_UNIT) != CacheState.VALID) {
      return _createResolveHtmlTask(A_source, htmlEntry);
    }
    AngularApplication application = htmlEntry.getValue(HtmlEntry.ANGULAR_APPLICATION);
    AngularComponentElement component = htmlEntry.getValue(HtmlEntry.A_ANGULAR_COMPONENT);
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(HtmlEntry.ANGULAR_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new ResolveAngularComponentTemplateTask(this, A_source, htmlCopy.modificationTime, htmlCopy.getValue(HtmlEntry.RESOLVED_UNIT), component, application), false);
  }
  AnalysisContextImpl_TaskData _createResolveAngularEntryHtmlTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(HtmlEntry.RESOLVED_UNIT) != CacheState.VALID) {
      return _createResolveHtmlTask(A_source, htmlEntry);
    }
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(HtmlEntry.ANGULAR_ENTRY, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new ResolveAngularEntryHtmlTask(this, A_source, htmlCopy.modificationTime, htmlCopy.getValue(HtmlEntry.RESOLVED_UNIT)), false);
  }
  AnalysisContextImpl_TaskData _createResolveDartLibraryTask(Source A_source, DartEntry dartEntry) {
    try {
      AnalysisContextImpl_CycleBuilder A_builder = new AnalysisContextImpl_CycleBuilder(this);
      A_builder.computeCycleContaining(A_source);
      AnalysisContextImpl_TaskData taskData = A_builder.taskData;
      if (taskData != null) {
        return taskData;
      }
      return new AnalysisContextImpl_TaskData(new ResolveDartLibraryCycleTask(this, A_source, A_source, A_builder.librariesInCycle), false);
    }on AnalysisException  catch (exception, A_stackTrace) {
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      dartCopy.recordResolutionError(new CaughtException(exception, A_stackTrace));
      _cache.put(A_source, dartCopy);
      AnalysisEngine.A_instance.logger.logError2("Internal error trying to create a ResolveDartLibraryTask", new CaughtException(exception, A_stackTrace));
    }
    return new AnalysisContextImpl_TaskData(null, false);
  }
  AnalysisContextImpl_TaskData _createResolveHtmlTask(Source A_source, HtmlEntry htmlEntry) {
    if (htmlEntry.getState(HtmlEntry.PARSED_UNIT) != CacheState.VALID) {
      return _createParseHtmlTask(A_source, htmlEntry);
    }
    HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
    htmlCopy.setState(HtmlEntry.RESOLVED_UNIT, CacheState.IN_PROCESS);
    _cache.put(A_source, htmlCopy);
    return new AnalysisContextImpl_TaskData(new ResolveHtmlTask(this, A_source, htmlCopy.modificationTime, htmlCopy.getValue(HtmlEntry.PARSED_UNIT)), false);
  }
  AnalysisContextImpl_TaskData _createScanDartTask(Source A_source, DartEntry dartEntry) {
    if (dartEntry.getState(SourceEntry.A_CONTENT) != CacheState.VALID) {
      return _createGetContentTask(A_source, dartEntry);
    }
    String content = dartEntry.getValue(SourceEntry.A_CONTENT);
    DartEntryImpl dartCopy = dartEntry.writableCopy;
    dartCopy.setState(SourceEntry.A_CONTENT, CacheState.FLUSHED);
    dartCopy.setState(DartEntry.SCAN_ERRORS, CacheState.IN_PROCESS);
    _cache.put(A_source, dartCopy);
    return new AnalysisContextImpl_TaskData(new ScanDartTask(this, A_source, dartCopy.modificationTime, content), false);
  }
  SourceEntry _createSourceEntry(Source A_source, bool explicitlyAdded) {
    String A_name = A_source.shortName;
    if (AnalysisEngine.isHtmlFileName(A_name)) {
      HtmlEntryImpl htmlEntry = new HtmlEntryImpl();
      htmlEntry.modificationTime = getModificationStamp(A_source);
      htmlEntry.explicitlyAdded = explicitlyAdded;
      _cache.put(A_source, htmlEntry);
      return htmlEntry;
    } else {
      DartEntryImpl dartEntry = new DartEntryImpl();
      dartEntry.modificationTime = getModificationStamp(A_source);
      dartEntry.explicitlyAdded = explicitlyAdded;
      _cache.put(A_source, dartEntry);
      return dartEntry;
    }
  }
  String _debuggingString(Source A_source) => "'${A_source.fullName}' [${getModificationStamp(A_source)}]";
  List<ChangeNotice> _getChangeNotices(bool nullIfEmpty) {
    if (_pendingNotices.isEmpty) {
      if (nullIfEmpty) {
        return null;
      }
      return ChangeNoticeImpl.C_EMPTY_ARRAY;
    }
    List<ChangeNotice> notices = new List.from(_pendingNotices.values);
    _pendingNotices.clear();
    return notices;
  }
  Object _getDartParseData(Source A_source, DartEntry dartEntry, DataDescriptor descriptor) {
    dartEntry = _cacheDartParseData(A_source, dartEntry, descriptor);
    if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      _accessedAst(A_source);
      return dartEntry.anyParsedCompilationUnit;
    }
    return dartEntry.getValue(descriptor);
  }
  Object _getDartParseData2(Source A_source, DataDescriptor descriptor, Object A_defaultValue) {
    DartEntry dartEntry = _getReadableDartEntry(A_source);
    if (dartEntry == null) {
      return A_defaultValue;
    }
    try {
      return _getDartParseData(A_source, dartEntry, descriptor);
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not compute ${descriptor.toString()}", exception);
      return A_defaultValue;
    }
  }
  Object _getDartResolutionData(Source unitSource, Source librarySource, DartEntry dartEntry, DataDescriptor descriptor) {
    dartEntry = _cacheDartResolutionData(unitSource, librarySource, dartEntry, descriptor);
    if (identical(descriptor, DartEntry.B_ELEMENT)) {
      return dartEntry.getValue(descriptor);
    } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
      _accessedAst(unitSource);
    }
    return dartEntry.getValueInLibrary(descriptor, librarySource);
  }
  Object _getDartResolutionData2(Source unitSource, Source librarySource, DataDescriptor descriptor, Object A_defaultValue) {
    DartEntry dartEntry = _getReadableDartEntry(unitSource);
    if (dartEntry == null) {
      return A_defaultValue;
    }
    try {
      return _getDartResolutionData(unitSource, librarySource, dartEntry, descriptor);
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not compute ${descriptor.toString()}", exception);
      return A_defaultValue;
    }
  }
  Object _getDartScanData(Source A_source, DartEntry dartEntry, DataDescriptor descriptor) {
    dartEntry = _cacheDartScanData(A_source, dartEntry, descriptor);
    return dartEntry.getValue(descriptor);
  }
  Object _getDartScanData2(Source A_source, DataDescriptor descriptor, Object A_defaultValue) {
    DartEntry dartEntry = _getReadableDartEntry(A_source);
    if (dartEntry == null) {
      return A_defaultValue;
    }
    try {
      return _getDartScanData(A_source, dartEntry, descriptor);
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not compute ${descriptor.toString()}", exception);
      return A_defaultValue;
    }
  }
  Object _getHtmlParseData(Source A_source, DataDescriptor descriptor, Object A_defaultValue) {
    HtmlEntry htmlEntry = _getReadableHtmlEntry(A_source);
    if (htmlEntry == null) {
      return A_defaultValue;
    }
    htmlEntry = _cacheHtmlParseData(A_source, htmlEntry, descriptor);
    if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      _accessedAst(A_source);
      return htmlEntry.anyParsedUnit;
    }
    return htmlEntry.getValue(descriptor);
  }
  Object _getHtmlResolutionData(Source A_source, DataDescriptor descriptor, Object A_defaultValue) {
    HtmlEntry htmlEntry = _getReadableHtmlEntry(A_source);
    if (htmlEntry == null) {
      return A_defaultValue;
    }
    try {
      return _getHtmlResolutionData2(A_source, htmlEntry, descriptor);
    }on ObsoleteSourceAnalysisException  catch (exception) {
      AnalysisEngine.A_instance.logger.logInformation2("Could not compute ${descriptor.toString()}", exception);
      return A_defaultValue;
    }
  }
  Object _getHtmlResolutionData2(Source A_source, HtmlEntry htmlEntry, DataDescriptor descriptor) {
    htmlEntry = _cacheHtmlResolutionData(A_source, htmlEntry, descriptor);
    if (identical(descriptor, HtmlEntry.RESOLVED_UNIT)) {
      _accessedAst(A_source);
    }
    return htmlEntry.getValue(descriptor);
  }
  AnalysisTask get nextAnalysisTask {
    bool hintsEnabled = _options.hint;
    bool hasBlockedTask = false;
    if (_incrementalAnalysisCache != null && _incrementalAnalysisCache.hasWork) {
      AnalysisTask task = new IncrementalAnalysisTask(this, _incrementalAnalysisCache);
      _incrementalAnalysisCache = null;
      return task;
    }
    int priorityCount = _priorityOrder.length;
    for (int i = 0; i < priorityCount; i++) {
      Source A_source = _priorityOrder[i];
      AnalysisContextImpl_TaskData taskData = _getNextAnalysisTaskForSource(A_source, _cache.get(A_source), true, hintsEnabled);
      AnalysisTask task = taskData.task;
      if (task != null) {
        return task;
      } else if (taskData.isBlocked) {
        hasBlockedTask = true;
      }
    }
    if (_neededForResolution != null) {
      List<Source> sourcesToRemove = new List<Source>();
      for (Source A_source in _neededForResolution) {
        SourceEntry sourceEntry = _cache.get(A_source);
        if (sourceEntry is DartEntry) {
          DartEntry dartEntry = sourceEntry;
          if (!dartEntry.hasResolvableCompilationUnit) {
            if (dartEntry.getState(DartEntry.PARSED_UNIT) == CacheState.C_ERROR) {
              sourcesToRemove.add(A_source);
            } else {
              AnalysisContextImpl_TaskData taskData = _createParseDartTask(A_source, dartEntry);
              AnalysisTask task = taskData.task;
              if (task != null) {
                return task;
              } else if (taskData.isBlocked) {
                hasBlockedTask = true;
              }
            }
          }
        }
      }
      int count = sourcesToRemove.length;
      for (int i = 0; i < count; i++) {
        _neededForResolution.remove(sourcesToRemove[i]);
      }
    }
    List<Source> sourcesToRemove = new List<Source>();
    WorkManager_WorkIterator sources = _workManager.iterator();
    while (sources.hasNext) {
      Source A_source = sources.next();
      AnalysisContextImpl_TaskData taskData = _getNextAnalysisTaskForSource(A_source, _cache.get(A_source), false, hintsEnabled);
      AnalysisTask task = taskData.task;
      if (task != null) {
        int count = sourcesToRemove.length;
        for (int i = 0; i < count; i++) {
          _workManager.remove(sourcesToRemove[i]);
        }
        return task;
      } else if (taskData.isBlocked) {
        hasBlockedTask = true;
      } else {
        sourcesToRemove.add(A_source);
      }
    }
    int count = sourcesToRemove.length;
    for (int i = 0; i < count; i++) {
      _workManager.remove(sourcesToRemove[i]);
    }
    if (hasBlockedTask) {
      return WaitForAsyncTask.A_instance;
    }
    return null;
  }
  AnalysisContextImpl_TaskData _getNextAnalysisTaskForSource(Source A_source, SourceEntry sourceEntry, bool isPriority, bool hintsEnabled) {
    if (sourceEntry == null) {
      return new AnalysisContextImpl_TaskData(null, false);
    }
    CacheState contentState = sourceEntry.getState(SourceEntry.A_CONTENT);
    if (contentState == CacheState.INVALID) {
      return _createGetContentTask(A_source, sourceEntry);
    } else if (contentState == CacheState.IN_PROCESS) {
      return new AnalysisContextImpl_TaskData(null, true);
    } else if (contentState == CacheState.C_ERROR) {
      return new AnalysisContextImpl_TaskData(null, false);
    }
    if (sourceEntry is DartEntry) {
      DartEntry dartEntry = sourceEntry;
      CacheState scanErrorsState = dartEntry.getState(DartEntry.SCAN_ERRORS);
      if (scanErrorsState == CacheState.INVALID || (isPriority && scanErrorsState == CacheState.FLUSHED)) {
        return _createScanDartTask(A_source, dartEntry);
      }
      CacheState parseErrorsState = dartEntry.getState(DartEntry.PARSE_ERRORS);
      if (parseErrorsState == CacheState.INVALID || (isPriority && parseErrorsState == CacheState.FLUSHED)) {
        return _createParseDartTask(A_source, dartEntry);
      }
      if (isPriority && parseErrorsState != CacheState.C_ERROR) {
        if (!dartEntry.hasResolvableCompilationUnit) {
          return _createParseDartTask(A_source, dartEntry);
        }
      }
      SourceKind kind = dartEntry.getValue(DartEntry.SOURCE_KIND);
      if (kind == SourceKind.D_UNKNOWN) {
        return _createParseDartTask(A_source, dartEntry);
      } else if (kind == SourceKind.D_LIBRARY) {
        CacheState elementState = dartEntry.getState(DartEntry.B_ELEMENT);
        if (elementState == CacheState.INVALID) {
          return _createResolveDartLibraryTask(A_source, dartEntry);
        }
      }
      List<Source> librariesContaining = dartEntry.getValue(DartEntry.CONTAINING_LIBRARIES);
      for (Source librarySource in librariesContaining) {
        SourceEntry librarySourceEntry = _cache.get(librarySource);
        if (librarySourceEntry is DartEntry) {
          DartEntry libraryEntry = librarySourceEntry;
          CacheState elementState = libraryEntry.getState(DartEntry.B_ELEMENT);
          if (elementState == CacheState.INVALID || (isPriority && elementState == CacheState.FLUSHED)) {
            DartEntryImpl libraryCopy = libraryEntry.writableCopy;
            libraryCopy.setState(DartEntry.B_ELEMENT, CacheState.IN_PROCESS);
            _cache.put(librarySource, libraryCopy);
            return new AnalysisContextImpl_TaskData(new ResolveDartLibraryTask(this, A_source, librarySource), false);
          }
          CacheState resolvedUnitState = dartEntry.getStateInLibrary(DartEntry.RESOLVED_UNIT, librarySource);
          if (resolvedUnitState == CacheState.INVALID || (isPriority && resolvedUnitState == CacheState.FLUSHED)) {
            DartEntryImpl dartCopy = dartEntry.writableCopy;
            dartCopy.setStateInLibrary(DartEntry.RESOLVED_UNIT, librarySource, CacheState.IN_PROCESS);
            _cache.put(A_source, dartCopy);
            return new AnalysisContextImpl_TaskData(new ResolveDartLibraryTask(this, A_source, librarySource), false);
          }
          if (_generateSdkErrors || !A_source.isInSystemLibrary) {
            CacheState verificationErrorsState = dartEntry.getStateInLibrary(DartEntry.VERIFICATION_ERRORS, librarySource);
            if (verificationErrorsState == CacheState.INVALID || (isPriority && verificationErrorsState == CacheState.FLUSHED)) {
              return _createGenerateDartErrorsTask(A_source, dartEntry, librarySource, libraryEntry);
            }
            if (hintsEnabled) {
              CacheState hintsState = dartEntry.getStateInLibrary(DartEntry.HINTS, librarySource);
              if (hintsState == CacheState.INVALID || (isPriority && hintsState == CacheState.FLUSHED)) {
                return _createGenerateDartHintsTask(A_source, dartEntry, librarySource, libraryEntry);
              }
            }
          }
        }
      }
    } else if (sourceEntry is HtmlEntry) {
      HtmlEntry htmlEntry = sourceEntry;
      CacheState parseErrorsState = htmlEntry.getState(HtmlEntry.PARSE_ERRORS);
      if (parseErrorsState == CacheState.INVALID || (isPriority && parseErrorsState == CacheState.FLUSHED)) {
        return _createParseHtmlTask(A_source, htmlEntry);
      }
      if (isPriority && parseErrorsState != CacheState.C_ERROR) {
        HtmlUnit parsedUnit = htmlEntry.anyParsedUnit;
        if (parsedUnit == null) {
          return _createParseHtmlTask(A_source, htmlEntry);
        }
      }
      CacheState resolvedUnitState = htmlEntry.getState(HtmlEntry.RESOLVED_UNIT);
      if (resolvedUnitState == CacheState.INVALID || (isPriority && resolvedUnitState == CacheState.FLUSHED)) {
        return _createResolveHtmlTask(A_source, htmlEntry);
      }
      if (_options.analyzeAngular) {
        CacheState angularEntryState = htmlEntry.getState(HtmlEntry.ANGULAR_ENTRY);
        if (angularEntryState == CacheState.INVALID || (isPriority && angularEntryState == CacheState.FLUSHED)) {
          return _createResolveAngularEntryHtmlTask(A_source, htmlEntry);
        }
        CacheState angularErrorsState = htmlEntry.getState(HtmlEntry.ANGULAR_ERRORS);
        if (angularErrorsState == CacheState.INVALID || (isPriority && angularErrorsState == CacheState.FLUSHED)) {
          return _createResolveAngularComponentTemplateTask(A_source, htmlEntry);
        }
      }
      if (_options.analyzePolymer) {
        CacheState polymerBuildErrorsState = htmlEntry.getState(HtmlEntry.POLYMER_BUILD_ERRORS);
        if (polymerBuildErrorsState == CacheState.INVALID || (isPriority && polymerBuildErrorsState == CacheState.FLUSHED)) {
          return _createPolymerBuildHtmlTask(A_source, htmlEntry);
        }
        CacheState polymerResolutionErrorsState = htmlEntry.getState(HtmlEntry.POLYMER_RESOLUTION_ERRORS);
        if (polymerResolutionErrorsState == CacheState.INVALID || (isPriority && polymerResolutionErrorsState == CacheState.FLUSHED)) {
          return _createPolymerResolveHtmlTask(A_source, htmlEntry);
        }
      }
    }
    return new AnalysisContextImpl_TaskData(null, false);
  }
  ChangeNoticeImpl _getNotice(Source A_source) {
    ChangeNoticeImpl notice = _pendingNotices[A_source];
    if (notice == null) {
      notice = new ChangeNoticeImpl(A_source);
      _pendingNotices[A_source] = notice;
    }
    return notice;
  }
  DartEntry _getReadableDartEntry(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      sourceEntry = _createSourceEntry(A_source, false);
    }
    if (sourceEntry is DartEntry) {
      return sourceEntry as DartEntry;
    }
    return null;
  }
  HtmlEntry _getReadableHtmlEntry(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      sourceEntry = _createSourceEntry(A_source, false);
    }
    if (sourceEntry is HtmlEntry) {
      return sourceEntry as HtmlEntry;
    }
    return null;
  }
  SourceEntry _getReadableSourceEntry(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      sourceEntry = _createSourceEntry(A_source, false);
    }
    return sourceEntry;
  }
  SourceEntry _getReadableSourceEntryOrNull(Source A_source) => _cache.get(A_source);
  TimestampedData<CompilationUnit> _getResolvedUnit(CompilationUnitElement A_element, Source librarySource) {
    SourceEntry sourceEntry = _cache.get(A_element.source);
    if (sourceEntry is DartEntry) {
      DartEntry dartEntry = sourceEntry;
      if (dartEntry.getStateInLibrary(DartEntry.RESOLVED_UNIT, librarySource) == CacheState.VALID) {
        return new TimestampedData<CompilationUnit>(dartEntry.modificationTime, dartEntry.getValueInLibrary(DartEntry.RESOLVED_UNIT, librarySource));
      }
    }
    return null;
  }
  List<Source> _getSources(SourceKind kind) {
    List<Source> sources = new List<Source>();
    MapIterator<Source, SourceEntry> A_iterator = _cache.iterator();
    while (A_iterator.moveNext()) {
      if (A_iterator.value.kind == kind) {
        sources.add(A_iterator.key);
      }
    }
    return new List.from(sources);
  }
  void _invalidateAllLocalResolutionInformation(bool invalidateUris) {
    A_p.HashMap<Source, List<Source>> oldPartMap = new A_p.HashMap<Source,List<Source>>();
    MapIterator<Source, SourceEntry> A_iterator = _privatePartition.iterator();
    while (A_iterator.moveNext()) {
      Source A_source = A_iterator.key;
      SourceEntry sourceEntry = A_iterator.value;
      if (sourceEntry is HtmlEntry) {
        HtmlEntryImpl htmlCopy = sourceEntry.writableCopy;
        htmlCopy.invalidateAllResolutionInformation(invalidateUris);
        A_iterator.value = htmlCopy;
      } else if (sourceEntry is DartEntry) {
        DartEntry dartEntry = sourceEntry;
        oldPartMap[A_source] = dartEntry.getValue(DartEntry.INCLUDED_PARTS);
        DartEntryImpl dartCopy = dartEntry.writableCopy;
        dartCopy.invalidateAllResolutionInformation(invalidateUris);
        A_iterator.value = dartCopy;
        _workManager.add(A_source, SourcePriority.C_UNKNOWN);
      }
    }
    _removeFromPartsUsingMap(oldPartMap);
  }
  void _invalidateAngularResolution(HtmlEntryImpl entryCopy) {
    AngularApplication application = entryCopy.getValue(HtmlEntry.ANGULAR_ENTRY);
    if (application == null) {
      return;
    }
    _angularApplications.remove(application);
    entryCopy.setState(HtmlEntry.ANGULAR_ENTRY, CacheState.INVALID);
    List<AngularElement> oldAngularElements = application.elements;
    for (AngularElement angularElement in oldAngularElements) {
      if (angularElement is AngularHasTemplateElement) {
        AngularHasTemplateElement hasTemplate = angularElement;
        Source templateSource = hasTemplate.templateSource;
        if (templateSource != null) {
          HtmlEntry htmlEntry = _getReadableHtmlEntry(templateSource);
          HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
          htmlCopy.setValue(HtmlEntry.ANGULAR_APPLICATION, null);
          htmlCopy.setValue(HtmlEntry.A_ANGULAR_COMPONENT, null);
          htmlCopy.setState(HtmlEntry.ANGULAR_ERRORS, CacheState.INVALID);
          _cache.put(templateSource, htmlCopy);
          _workManager.add(templateSource, SourcePriority.B_HTML);
        }
      }
    }
    List<Source> oldElementSources = application.elementSources;
    for (Source elementSource in oldElementSources) {
      DartEntry dartEntry = _getReadableDartEntry(elementSource);
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      dartCopy.setValue(DartEntry.ANGULAR_ERRORS, A_AnalysisError.NO_ERRORS);
      _cache.put(elementSource, dartCopy);
      ChangeNoticeImpl notice = _getNotice(elementSource);
      notice.setErrors(dartCopy.allErrors, dartEntry.getValue(SourceEntry.LINE_INFO));
    }
  }
  void _invalidateLibraryResolution(Source librarySource) {
    DartEntry libraryEntry = _getReadableDartEntry(librarySource);
    if (libraryEntry != null) {
      List<Source> includedParts = libraryEntry.getValue(DartEntry.INCLUDED_PARTS);
      DartEntryImpl libraryCopy = libraryEntry.writableCopy;
      libraryCopy.invalidateAllResolutionInformation(false);
      _cache.put(librarySource, libraryCopy);
      _workManager.add(librarySource, SourcePriority.B_LIBRARY);
      for (Source partSource in includedParts) {
        SourceEntry partEntry = _cache.get(partSource);
        if (partEntry is DartEntry) {
          DartEntryImpl partCopy = partEntry.writableCopy;
          partCopy.invalidateAllResolutionInformation(false);
          _cache.put(partSource, partCopy);
        }
      }
    }
    List<AngularApplication> angularApplicationsCopy = [];
    for (AngularApplication application in angularApplicationsCopy) {
      if (application.dependsOn(librarySource)) {
        Source entryPointSource = application.entryPoint;
        HtmlEntry A_entry = _getReadableHtmlEntry(entryPointSource);
        HtmlEntryImpl entryCopy = A_entry.writableCopy;
        _invalidateAngularResolution(entryCopy);
        _cache.put(entryPointSource, entryCopy);
        _workManager.add(entryPointSource, SourcePriority.B_HTML);
      }
    }
  }
  bool _isClient(LibraryElement library, Source htmlSource, A_p.HashSet<LibraryElement> visitedLibraries) {
    if (visitedLibraries.contains(library)) {
      return false;
    }
    if (library.source == htmlSource) {
      return true;
    }
    visitedLibraries.add(library);
    for (LibraryElement imported in library.importedLibraries) {
      if (_isClient(imported, htmlSource, visitedLibraries)) {
        return true;
      }
    }
    for (LibraryElement exported in library.exportedLibraries) {
      if (_isClient(exported, htmlSource, visitedLibraries)) {
        return true;
      }
    }
    return false;
  }
  void _logInformation(String A_message) {
    AnalysisEngine.A_instance.logger.logInformation(A_message);
  }
  void _logInformation2(String A_message, Exception exception) {
    if (exception == null) {
      AnalysisEngine.A_instance.logger.logInformation(A_message);
    } else {
      AnalysisEngine.A_instance.logger.logInformation2(A_message, exception);
    }
  }
  void _recordAngularEntryPoint(HtmlEntryImpl A_entry, ResolveAngularEntryHtmlTask task) {
    AngularApplication application = task.application;
    if (application != null) {
      _angularApplications.add(application);
      A_entry.setValue(HtmlEntry.ANGULAR_ERRORS, task.entryErrors);
      List<AngularElement> newAngularElements = application.elements;
      for (AngularElement angularElement in newAngularElements) {
        if (angularElement is AngularHasTemplateElement) {
          AngularHasTemplateElement hasTemplate = angularElement;
          Source templateSource = hasTemplate.templateSource;
          if (templateSource != null) {
            HtmlEntry htmlEntry = _getReadableHtmlEntry(templateSource);
            HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
            htmlCopy.setValue(HtmlEntry.ANGULAR_APPLICATION, application);
            if (hasTemplate is AngularComponentElement) {
              AngularComponentElement component = hasTemplate;
              htmlCopy.setValue(HtmlEntry.A_ANGULAR_COMPONENT, component);
            }
            htmlCopy.setState(HtmlEntry.ANGULAR_ERRORS, CacheState.INVALID);
            _cache.put(templateSource, htmlCopy);
            _workManager.add(templateSource, SourcePriority.B_HTML);
          }
        }
      }
      List<Source> newElementSources = application.elementSources;
      for (Source elementSource in newElementSources) {
        DartEntry dartEntry = _getReadableDartEntry(elementSource);
        DartEntryImpl dartCopy = dartEntry.writableCopy;
        dartCopy.setValue(DartEntry.ANGULAR_ERRORS, task.getErrors(elementSource));
        _cache.put(elementSource, dartCopy);
        ChangeNoticeImpl notice = _getNotice(elementSource);
        notice.setErrors(dartCopy.allErrors, computeLineInfo(elementSource));
      }
    }
    A_entry.setValue(HtmlEntry.ANGULAR_ENTRY, application);
  }
  void _recordElementData(DartEntryImpl dartCopy, LibraryElement library, Source librarySource, Source htmlSource) {
    dartCopy.setValue(DartEntry.B_ELEMENT, library);
    dartCopy.setValue(DartEntry.IS_LAUNCHABLE, library.entryPoint != null);
    dartCopy.setValue(DartEntry.IS_CLIENT, _isClient(library, htmlSource, new A_p.HashSet<LibraryElement>()));
  }
  DartEntry _recordGenerateDartErrorsTask(GenerateDartErrorsTask task) {
    Source A_source = task.source;
    Source librarySource = task.libraryElement.source;
    CaughtException thrownException = task.exception;
    DartEntry dartEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! DartEntry) {
      throw new AnalysisException("Internal error: attempting to verify non-Dart file as a Dart file: ${A_source.fullName}");
    }
    dartEntry = sourceEntry as DartEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (dartEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        dartEntry = _getReadableDartEntry(A_source);
        if (dartEntry == null) {
          throw new AnalysisException("A Dart file became a non-Dart file: ${A_source.fullName}");
        }
      }
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null) {
        dartCopy.setValueInLibrary(DartEntry.VERIFICATION_ERRORS, librarySource, task.errors);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(dartCopy.allErrors, dartCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        dartCopy.recordVerificationErrorInLibrary(librarySource, thrownException);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    } else {
      _logInformation2("Generated errors discarded for ${_debuggingString(A_source)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}", thrownException);
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        _removeFromParts(A_source, dartEntry);
        dartCopy.invalidateAllInformation();
        dartCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
        _workManager.add(A_source, SourcePriority.C_UNKNOWN);
      } else {
        dartCopy.recordVerificationErrorInLibrary(librarySource, thrownException);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return dartEntry;
  }
  DartEntry _recordGenerateDartHintsTask(GenerateDartHintsTask task) {
    Source librarySource = task.libraryElement.source;
    CaughtException thrownException = task.exception;
    DartEntry libraryEntry = null;
    A_p.HashMap<Source, TimestampedData<List<A_AnalysisError>>> hintMap = task.hintMap;
    if (hintMap == null) {
      SourceEntry sourceEntry = _cache.get(librarySource);
      if (sourceEntry == null) {
        throw new ObsoleteSourceAnalysisException(librarySource);
      } else if (sourceEntry is! DartEntry) {
        throw new AnalysisException("Internal error: attempting to generate hints for non-Dart file as a Dart file: ${librarySource.fullName}");
      }
      if (thrownException == null) {
        thrownException = new CaughtException(new AnalysisException("GenerateDartHintsTask returned a null hint map without throwing an exception: ${librarySource.fullName}"), null);
      }
      DartEntryImpl dartCopy = (sourceEntry as DartEntry).writableCopy;
      dartCopy.recordHintErrorInLibrary(librarySource, thrownException);
      _cache.put(librarySource, dartCopy);
      throw new AnalysisException('<rethrow>', thrownException);
    }
    for (MapEntry<Source, TimestampedData<List<A_AnalysisError>>> A_entry in getMapEntrySet(hintMap)) {
      Source unitSource = A_entry.getKey();
      TimestampedData<List<A_AnalysisError>> results = A_entry.getValue();
      SourceEntry sourceEntry = _cache.get(unitSource);
      if (sourceEntry is! DartEntry) {
        throw new AnalysisException("Internal error: attempting to parse non-Dart file as a Dart file: ${unitSource.fullName}");
      }
      DartEntry dartEntry = sourceEntry as DartEntry;
      if (unitSource == librarySource) {
        libraryEntry = dartEntry;
      }
      int sourceTime = getModificationStamp(unitSource);
      int resultTime = results.modificationTime;
      if (sourceTime == resultTime) {
        if (dartEntry.modificationTime != sourceTime) {
          _sourceChanged(unitSource);
          dartEntry = _getReadableDartEntry(unitSource);
          if (dartEntry == null) {
            throw new AnalysisException("A Dart file became a non-Dart file: ${unitSource.fullName}");
          }
        }
        DartEntryImpl dartCopy = dartEntry.writableCopy;
        if (thrownException == null) {
          dartCopy.setValueInLibrary(DartEntry.HINTS, librarySource, results.data);
          ChangeNoticeImpl notice = _getNotice(unitSource);
          notice.setErrors(dartCopy.allErrors, dartCopy.getValue(SourceEntry.LINE_INFO));
        } else {
          dartCopy.recordHintErrorInLibrary(librarySource, thrownException);
        }
        _cache.put(unitSource, dartCopy);
        dartEntry = dartCopy;
      } else {
        _logInformation2("Generated hints discarded for ${_debuggingString(unitSource)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}", thrownException);
        if (dartEntry.getStateInLibrary(DartEntry.HINTS, librarySource) == CacheState.IN_PROCESS) {
          DartEntryImpl dartCopy = dartEntry.writableCopy;
          if (thrownException == null || resultTime >= 0) {
            _removeFromParts(unitSource, dartEntry);
            dartCopy.invalidateAllInformation();
            dartCopy.modificationTime = sourceTime;
            _cache.removedAst(unitSource);
            _workManager.add(unitSource, SourcePriority.C_UNKNOWN);
          } else {
            dartCopy.recordHintErrorInLibrary(librarySource, thrownException);
          }
          _cache.put(unitSource, dartCopy);
          dartEntry = dartCopy;
        }
      }
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return libraryEntry;
  }
  SourceEntry _recordGetContentsTask(GetContentTask task) {
    if (!task.isComplete) {
      return null;
    }
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    SourceEntry sourceEntry = null;
    sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    }
    SourceEntryImpl sourceCopy = sourceEntry.writableCopy;
    if (thrownException == null) {
      sourceCopy.modificationTime = task.modificationTime;
      sourceCopy.setValue(SourceEntry.A_CONTENT, task.content);
    } else {
      sourceCopy.recordContentError(thrownException);
      _workManager.remove(A_source);
    }
    _cache.put(A_source, sourceCopy);
    sourceEntry = sourceCopy;
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return sourceEntry;
  }
  DartEntry _recordIncrementalAnalysisTaskResults(IncrementalAnalysisTask task) {
    CompilationUnit unit = task.compilationUnit;
    if (unit != null) {
      ChangeNoticeImpl notice = _getNotice(task.source);
      notice.compilationUnit = unit;
      _incrementalAnalysisCache = IncrementalAnalysisCache.cacheResult(task.cache, unit);
    }
    return null;
  }
  DartEntry _recordParseDartTaskResults(ParseDartTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    DartEntry dartEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! DartEntry) {
      throw new AnalysisException("Internal error: attempting to parse non-Dart file as a Dart file: ${A_source.fullName}");
    }
    dartEntry = sourceEntry as DartEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (dartEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        dartEntry = _getReadableDartEntry(A_source);
        if (dartEntry == null) {
          throw new AnalysisException("A Dart file became a non-Dart file: ${A_source.fullName}");
        }
      }
      _removeFromParts(A_source, dartEntry);
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null) {
        if (task.hasNonPartOfDirective) {
          dartCopy.setValue(DartEntry.SOURCE_KIND, SourceKind.D_LIBRARY);
          dartCopy.containingLibrary = A_source;
          _workManager.add(A_source, SourcePriority.B_LIBRARY);
        } else if (task.hasPartOfDirective) {
          dartCopy.setValue(DartEntry.SOURCE_KIND, SourceKind.A_PART);
          dartCopy.removeContainingLibrary(A_source);
          _workManager.add(A_source, SourcePriority.NORMAL_PART);
        } else {
          List<Source> containingLibraries = dartCopy.containingLibraries;
          if (containingLibraries.length > 1 || (containingLibraries.length == 1 && containingLibraries[0] != A_source)) {
            dartCopy.setValue(DartEntry.SOURCE_KIND, SourceKind.A_PART);
            dartCopy.removeContainingLibrary(A_source);
            _workManager.add(A_source, SourcePriority.NORMAL_PART);
          } else {
            dartCopy.setValue(DartEntry.SOURCE_KIND, SourceKind.D_LIBRARY);
            dartCopy.containingLibrary = A_source;
            _workManager.add(A_source, SourcePriority.B_LIBRARY);
          }
        }
        List<Source> newParts = task.includedSources;
        for (int i = 0; i < newParts.length; i++) {
          Source partSource = newParts[i];
          DartEntry partEntry = _getReadableDartEntry(partSource);
          if (partEntry != null && !identical(partEntry, dartEntry)) {
            DartEntryImpl partCopy = partEntry.writableCopy;
            partCopy.addContainingLibrary(A_source);
            _cache.put(partSource, partCopy);
          }
        }
        dartCopy.setValue(DartEntry.PARSED_UNIT, task.compilationUnit);
        dartCopy.setValue(DartEntry.PARSE_ERRORS, task.errors);
        dartCopy.setValue(DartEntry.EXPORTED_LIBRARIES, task.exportedSources);
        dartCopy.setValue(DartEntry.IMPORTED_LIBRARIES, task.importedSources);
        dartCopy.setValue(DartEntry.INCLUDED_PARTS, newParts);
        _cache.storedAst(A_source);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(dartCopy.allErrors, task.lineInfo);
        _incrementalAnalysisCache = IncrementalAnalysisCache.verifyStructure(_incrementalAnalysisCache, A_source, task.compilationUnit);
      } else {
        _removeFromParts(A_source, dartEntry);
        dartCopy.recordParseError(thrownException);
        _cache.removedAst(A_source);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    } else {
      _logInformation2("Parse results discarded for ${_debuggingString(A_source)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}", thrownException);
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        _removeFromParts(A_source, dartEntry);
        dartCopy.invalidateAllInformation();
        dartCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
        _workManager.add(A_source, SourcePriority.C_UNKNOWN);
      } else {
        dartCopy.recordParseError(thrownException);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return dartEntry;
  }
  HtmlEntry _recordParseHtmlTaskResults(ParseHtmlTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to parse non-HTML file as a HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = (sourceEntry as HtmlEntry).writableCopy;
      if (thrownException == null) {
        LineInfo lineInfo = task.lineInfo;
        HtmlUnit unit = task.htmlUnit;
        htmlCopy.setValue(SourceEntry.LINE_INFO, lineInfo);
        htmlCopy.setValue(HtmlEntry.PARSED_UNIT, unit);
        htmlCopy.setValue(HtmlEntry.PARSE_ERRORS, task.errors);
        htmlCopy.setValue(HtmlEntry.REFERENCED_LIBRARIES, task.referencedLibraries);
        _cache.storedAst(A_source);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(htmlCopy.allErrors, lineInfo);
      } else {
        htmlCopy.recordParseError(thrownException);
        _cache.removedAst(A_source);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      _logInformation2("Parse results discarded for ${_debuggingString(A_source)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${htmlEntry.modificationTime}", thrownException);
      HtmlEntryImpl htmlCopy = (sourceEntry as HtmlEntry).writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordParseError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  HtmlEntry _recordPolymerBuildHtmlTaskResults(PolymerBuildHtmlTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to resolve non-HTML file as an HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null) {
        htmlCopy.setValue(HtmlEntry.POLYMER_BUILD_ERRORS, task.errors);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(htmlCopy.allErrors, htmlCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  HtmlEntry _recordPolymerResolveHtmlTaskResults(PolymerResolveHtmlTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to resolve non-HTML file as an HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null) {
        htmlCopy.setValue(HtmlEntry.POLYMER_RESOLUTION_ERRORS, task.errors);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(htmlCopy.allErrors, htmlCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  HtmlEntry _recordResolveAngularComponentTemplateTaskResults(ResolveAngularComponentTemplateTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to resolve non-HTML file as an HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null) {
        htmlCopy.setValue(HtmlEntry.ANGULAR_ERRORS, task.resolutionErrors);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.htmlUnit = task.resolvedUnit;
        notice.setErrors(htmlCopy.allErrors, htmlCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  HtmlEntry _recordResolveAngularEntryHtmlTaskResults(ResolveAngularEntryHtmlTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to resolve non-HTML file as an HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null) {
        htmlCopy.setValue(HtmlEntry.RESOLVED_UNIT, task.resolvedUnit);
        _recordAngularEntryPoint(htmlCopy, task);
        _cache.storedAst(A_source);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.htmlUnit = task.resolvedUnit;
        notice.setErrors(htmlCopy.allErrors, htmlCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  HtmlEntry _recordResolveHtmlTaskResults(ResolveHtmlTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    HtmlEntry htmlEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! HtmlEntry) {
      throw new AnalysisException("Internal error: attempting to resolve non-HTML file as an HTML file: ${A_source.fullName}");
    }
    htmlEntry = sourceEntry as HtmlEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (htmlEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        htmlEntry = _getReadableHtmlEntry(A_source);
        if (htmlEntry == null) {
          throw new AnalysisException("An HTML file became a non-HTML file: ${A_source.fullName}");
        }
      }
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null) {
        htmlCopy.setState(HtmlEntry.PARSED_UNIT, CacheState.FLUSHED);
        htmlCopy.setValue(HtmlEntry.RESOLVED_UNIT, task.resolvedUnit);
        htmlCopy.setValue(HtmlEntry.B_ELEMENT, task.element);
        htmlCopy.setValue(HtmlEntry.RESOLUTION_ERRORS, task.resolutionErrors);
        _cache.storedAst(A_source);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.htmlUnit = task.resolvedUnit;
        notice.setErrors(htmlCopy.allErrors, htmlCopy.getValue(SourceEntry.LINE_INFO));
      } else {
        htmlCopy.recordResolutionError(thrownException);
        _cache.removedAst(A_source);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    } else {
      _logInformation2("Resolution results discarded for ${_debuggingString(A_source)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${htmlEntry.modificationTime}", thrownException);
      HtmlEntryImpl htmlCopy = htmlEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        htmlCopy.invalidateAllInformation();
        htmlCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
      } else {
        htmlCopy.recordResolutionError(thrownException);
      }
      _cache.put(A_source, htmlCopy);
      htmlEntry = htmlCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return htmlEntry;
  }
  DartEntry _recordScanDartTaskResults(ScanDartTask task) {
    Source A_source = task.source;
    CaughtException thrownException = task.exception;
    DartEntry dartEntry = null;
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      throw new ObsoleteSourceAnalysisException(A_source);
    } else if (sourceEntry is! DartEntry) {
      throw new AnalysisException("Internal error: attempting to parse non-Dart file as a Dart file: ${A_source.fullName}");
    }
    dartEntry = sourceEntry as DartEntry;
    int sourceTime = getModificationStamp(A_source);
    int resultTime = task.modificationTime;
    if (sourceTime == resultTime) {
      if (dartEntry.modificationTime != sourceTime) {
        _sourceChanged(A_source);
        dartEntry = _getReadableDartEntry(A_source);
        if (dartEntry == null) {
          throw new AnalysisException("A Dart file became a non-Dart file: ${A_source.fullName}");
        }
      }
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null) {
        LineInfo lineInfo = task.lineInfo;
        dartCopy.setValue(SourceEntry.LINE_INFO, lineInfo);
        dartCopy.setValue(DartEntry.TOKEN_STREAM, task.tokenStream);
        dartCopy.setValue(DartEntry.SCAN_ERRORS, task.errors);
        _cache.storedAst(A_source);
        _workManager.add(A_source, SourcePriority.NORMAL_PART);
        ChangeNoticeImpl notice = _getNotice(A_source);
        notice.setErrors(dartEntry.allErrors, lineInfo);
      } else {
        _removeFromParts(A_source, dartEntry);
        dartCopy.recordScanError(thrownException);
        _cache.removedAst(A_source);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    } else {
      _logInformation2("Scan results discarded for ${_debuggingString(A_source)}; sourceTime = ${sourceTime}, resultTime = ${resultTime}, cacheTime = ${dartEntry.modificationTime}", thrownException);
      DartEntryImpl dartCopy = dartEntry.writableCopy;
      if (thrownException == null || resultTime >= 0) {
        _removeFromParts(A_source, dartEntry);
        dartCopy.invalidateAllInformation();
        dartCopy.modificationTime = sourceTime;
        _cache.removedAst(A_source);
        _workManager.add(A_source, SourcePriority.C_UNKNOWN);
      } else {
        dartCopy.recordScanError(thrownException);
      }
      _cache.put(A_source, dartCopy);
      dartEntry = dartCopy;
    }
    if (thrownException != null) {
      throw new AnalysisException('<rethrow>', thrownException);
    }
    return dartEntry;
  }
  void _removeFromParts(Source librarySource, DartEntry dartEntry) {
    List<Source> oldParts = dartEntry.getValue(DartEntry.INCLUDED_PARTS);
    for (int i = 0; i < oldParts.length; i++) {
      Source partSource = oldParts[i];
      DartEntry partEntry = _getReadableDartEntry(partSource);
      if (partEntry != null && !identical(partEntry, dartEntry)) {
        DartEntryImpl partCopy = partEntry.writableCopy;
        partCopy.removeContainingLibrary(librarySource);
        if (partCopy.containingLibraries.length == 0 && !exists(partSource)) {
          _cache.remove(partSource);
        } else {
          _cache.put(partSource, partCopy);
        }
      }
    }
  }
  void _removeFromPartsUsingMap(A_p.HashMap<Source, List<Source>> oldPartMap) {
    for (MapEntry<Source, List<Source>> A_entry in getMapEntrySet(oldPartMap)) {
      Source librarySource = A_entry.getKey();
      List<Source> oldParts = A_entry.getValue();
      for (int i = 0; i < oldParts.length; i++) {
        Source partSource = oldParts[i];
        if (partSource != librarySource) {
          DartEntry partEntry = _getReadableDartEntry(partSource);
          if (partEntry != null) {
            DartEntryImpl partCopy = partEntry.writableCopy;
            partCopy.removeContainingLibrary(librarySource);
            if (partCopy.containingLibraries.length == 0 && !exists(partSource)) {
              _cache.remove(partSource);
            } else {
              _cache.put(partSource, partCopy);
            }
          }
        }
      }
    }
  }
  void _removeFromPriorityOrder(Source A_source) {
    int count = _priorityOrder.length;
    List<Source> newOrder = new List<Source>();
    for (int i = 0; i < count; i++) {
      if (_priorityOrder[i] != A_source) {
        newOrder.add(_priorityOrder[i]);
      }
    }
    if (newOrder.length < count) {
      analysisPriorityOrder = newOrder;
    }
  }
  bool _sourceAvailable(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null) {
      sourceEntry = _createSourceEntry(A_source, true);
    } else {
      _sourceChanged(A_source);
      sourceEntry = _cache.get(A_source);
    }
    if (sourceEntry is HtmlEntry) {
      _workManager.add(A_source, SourcePriority.B_HTML);
    } else {
      _workManager.add(A_source, SourcePriority.C_UNKNOWN);
    }
    return sourceEntry is DartEntry;
  }
  void _sourceChanged(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry == null || sourceEntry.modificationTime == getModificationStamp(A_source)) {
      return;
    }
    if (sourceEntry is HtmlEntry) {
      HtmlEntryImpl htmlCopy = sourceEntry.writableCopy;
      htmlCopy.modificationTime = getModificationStamp(A_source);
      _invalidateAngularResolution(htmlCopy);
      htmlCopy.invalidateAllInformation();
      _cache.put(A_source, htmlCopy);
      _cache.removedAst(A_source);
      _workManager.add(A_source, SourcePriority.B_HTML);
    } else if (sourceEntry is DartEntry) {
      List<Source> containingLibraries = getLibrariesContaining(A_source);
      A_p.HashSet<Source> librariesToInvalidate = new A_p.HashSet<Source>();
      for (Source containingLibrary in containingLibraries) {
        _computeAllLibrariesDependingOn(containingLibrary, librariesToInvalidate);
      }
      for (Source library in librariesToInvalidate) {
        _invalidateLibraryResolution(library);
      }
      _removeFromParts(A_source, _cache.get(A_source) as DartEntry);
      DartEntryImpl dartCopy = (_cache.get(A_source) as DartEntry).writableCopy;
      dartCopy.modificationTime = getModificationStamp(A_source);
      dartCopy.invalidateAllInformation();
      _cache.put(A_source, dartCopy);
      _cache.removedAst(A_source);
      _workManager.add(A_source, SourcePriority.C_UNKNOWN);
    }
  }
  void _sourceDeleted(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry is HtmlEntry) {
      HtmlEntryImpl htmlCopy = sourceEntry.writableCopy;
      _invalidateAngularResolution(htmlCopy);
      htmlCopy.recordContentError(new CaughtException(new AnalysisException("This source was marked as being deleted"), null));
      _cache.put(A_source, htmlCopy);
    } else if (sourceEntry is DartEntry) {
      A_p.HashSet<Source> libraries = new A_p.HashSet<Source>();
      for (Source librarySource in getLibrariesContaining(A_source)) {
        libraries.add(librarySource);
        for (Source dependentLibrary in getLibrariesDependingOn(librarySource)) {
          libraries.add(dependentLibrary);
        }
      }
      for (Source librarySource in libraries) {
        _invalidateLibraryResolution(librarySource);
      }
      DartEntryImpl dartCopy = sourceEntry.writableCopy;
      dartCopy.recordContentError(new CaughtException(new AnalysisException("This source was marked as being deleted"), null));
      _cache.put(A_source, dartCopy);
    }
    _workManager.remove(A_source);
    _removeFromPriorityOrder(A_source);
  }
  void _sourceRemoved(Source A_source) {
    SourceEntry sourceEntry = _cache.get(A_source);
    if (sourceEntry is HtmlEntry) {
      HtmlEntryImpl htmlCopy = sourceEntry.writableCopy;
      _invalidateAngularResolution(htmlCopy);
    } else if (sourceEntry is DartEntry) {
      A_p.HashSet<Source> libraries = new A_p.HashSet<Source>();
      for (Source librarySource in getLibrariesContaining(A_source)) {
        libraries.add(librarySource);
        for (Source dependentLibrary in getLibrariesDependingOn(librarySource)) {
          libraries.add(dependentLibrary);
        }
      }
      for (Source librarySource in libraries) {
        _invalidateLibraryResolution(librarySource);
      }
    }
    _cache.remove(A_source);
    _workManager.remove(A_source);
    _removeFromPriorityOrder(A_source);
  }
  bool _validateCacheConsistency() {
    int consistencyCheckStart = JavaSystem.nanoTime();
    List<Source> changedSources = new List<Source>();
    List<Source> missingSources = new List<Source>();
    MapIterator<Source, SourceEntry> A_iterator = _cache.iterator();
    while (A_iterator.moveNext()) {
      Source A_source = A_iterator.key;
      SourceEntry sourceEntry = A_iterator.value;
      int sourceTime = getModificationStamp(A_source);
      if (sourceTime != sourceEntry.modificationTime) {
        changedSources.add(A_source);
      }
      if (sourceEntry.exception != null) {
        if (!exists(A_source)) {
          missingSources.add(A_source);
        }
      }
    }
    int count = changedSources.length;
    for (int i = 0; i < count; i++) {
      _sourceChanged(changedSources[i]);
    }
    int consistencyCheckEnd = JavaSystem.nanoTime();
    if (changedSources.length > 0 || missingSources.length > 0) {
      PrintStringWriter writer = new PrintStringWriter();
      writer.print("Consistency check took ");
      writer.print((consistencyCheckEnd - consistencyCheckStart) / 1000000.0);
      writer.println(" ms and found");
      writer.print("  ");
      writer.print(changedSources.length);
      writer.println(" inconsistent entries");
      writer.print("  ");
      writer.print(missingSources.length);
      writer.println(" missing sources");
      for (Source A_source in missingSources) {
        writer.print("    ");
        writer.println(A_source.fullName);
      }
      _logInformation(writer.toString());
    }
    return changedSources.length > 0;
  }
}
class AnalysisContextImpl_AnalysisTaskResultRecorder implements AnalysisTaskVisitor<SourceEntry> {
  final AnalysisContextImpl AnalysisContextImpl_this;
  AnalysisContextImpl_AnalysisTaskResultRecorder(this.AnalysisContextImpl_this);
  DartEntry visitGenerateDartErrorsTask(GenerateDartErrorsTask task) => AnalysisContextImpl_this._recordGenerateDartErrorsTask(task);
  DartEntry visitGenerateDartHintsTask(GenerateDartHintsTask task) => AnalysisContextImpl_this._recordGenerateDartHintsTask(task);
  SourceEntry visitGetContentTask(GetContentTask task) => AnalysisContextImpl_this._recordGetContentsTask(task);
  DartEntry visitIncrementalAnalysisTask(IncrementalAnalysisTask task) => AnalysisContextImpl_this._recordIncrementalAnalysisTaskResults(task);
  DartEntry visitParseDartTask(ParseDartTask task) => AnalysisContextImpl_this._recordParseDartTaskResults(task);
  HtmlEntry visitParseHtmlTask(ParseHtmlTask task) => AnalysisContextImpl_this._recordParseHtmlTaskResults(task);
  HtmlEntry visitPolymerBuildHtmlTask(PolymerBuildHtmlTask task) => AnalysisContextImpl_this._recordPolymerBuildHtmlTaskResults(task);
  HtmlEntry visitPolymerResolveHtmlTask(PolymerResolveHtmlTask task) => AnalysisContextImpl_this._recordPolymerResolveHtmlTaskResults(task);
  HtmlEntry visitResolveAngularComponentTemplateTask(ResolveAngularComponentTemplateTask task) => AnalysisContextImpl_this._recordResolveAngularComponentTemplateTaskResults(task);
  HtmlEntry visitResolveAngularEntryHtmlTask(ResolveAngularEntryHtmlTask task) => AnalysisContextImpl_this._recordResolveAngularEntryHtmlTaskResults(task);
  DartEntry visitResolveDartLibraryCycleTask(ResolveDartLibraryCycleTask task) => AnalysisContextImpl_this.recordResolveDartLibraryCycleTaskResults(task);
  DartEntry visitResolveDartLibraryTask(ResolveDartLibraryTask task) => AnalysisContextImpl_this.recordResolveDartLibraryTaskResults(task);
  HtmlEntry visitResolveHtmlTask(ResolveHtmlTask task) => AnalysisContextImpl_this._recordResolveHtmlTaskResults(task);
  DartEntry visitScanDartTask(ScanDartTask task) => AnalysisContextImpl_this._recordScanDartTaskResults(task);
}
class AnalysisContextImpl_ContextRetentionPolicy implements CacheRetentionPolicy {
  final AnalysisContextImpl AnalysisContextImpl_this;
  AnalysisContextImpl_ContextRetentionPolicy(this.AnalysisContextImpl_this);
  RetentionPriority getAstPriority(Source A_source, SourceEntry sourceEntry) {
    int priorityCount = AnalysisContextImpl_this._priorityOrder.length;
    for (int i = 0; i < priorityCount; i++) {
      if (A_source == AnalysisContextImpl_this._priorityOrder[i]) {
        return RetentionPriority.HIGH;
      }
    }
    if (AnalysisContextImpl_this._neededForResolution != null && AnalysisContextImpl_this._neededForResolution.contains(A_source)) {
      return RetentionPriority.HIGH;
    }
    if (sourceEntry is DartEntry) {
      DartEntry dartEntry = sourceEntry;
      if (_astIsNeeded(dartEntry)) {
        return RetentionPriority.MEDIUM;
      }
    }
    return RetentionPriority.A_LOW;
  }
  bool _astIsNeeded(DartEntry dartEntry) => dartEntry.hasInvalidData(DartEntry.HINTS) || dartEntry.hasInvalidData(DartEntry.VERIFICATION_ERRORS) || dartEntry.hasInvalidData(DartEntry.RESOLUTION_ERRORS);
}
class AnalysisContextImpl_CycleBuilder {
  final AnalysisContextImpl AnalysisContextImpl_this;
  A_p.HashMap<Source, ResolvableLibrary> _libraryMap = new A_p.HashMap<Source,ResolvableLibrary>();
  DirectedGraph<ResolvableLibrary> _dependencyGraph;
  List<ResolvableLibrary> _librariesInCycle;
  AnalysisContextImpl_TaskData _taskData;
  AnalysisContextImpl_CycleBuilder(this.AnalysisContextImpl_this) : super();
  void computeCycleContaining(Source librarySource) {
    ResolvableLibrary targetLibrary = _createLibrary(librarySource);
    _dependencyGraph = new DirectedGraph<ResolvableLibrary>();
    _computeLibraryDependencies(targetLibrary);
    if (_taskData != null) {
      return;
    }
    _librariesInCycle = _dependencyGraph.findCycleContaining(targetLibrary);
    _ensureImportsAndExports();
    if (_taskData != null) {
      AnalysisTask task = _taskData.task;
      if (task is ResolveDartLibraryTask) {
        AnalysisContextImpl_this._workManager.addFirst(task.librarySource, SourcePriority.B_LIBRARY);
      }
      return;
    }
    _computePartsInCycle(librarySource);
    if (_taskData != null) {
      return;
    }
    AnalysisContextImpl_this._neededForResolution = null;
  }
  List<ResolvableLibrary> get librariesInCycle => _librariesInCycle;
  AnalysisContextImpl_TaskData get taskData => _taskData;
  void _computeLibraryDependencies(ResolvableLibrary library) {
    Source librarySource = library.librarySource;
    DartEntry dartEntry = AnalysisContextImpl_this._getReadableDartEntry(librarySource);
    List<Source> importedSources = _getSources(librarySource, dartEntry, DartEntry.IMPORTED_LIBRARIES);
    if (_taskData != null) {
      return;
    }
    List<Source> exportedSources = _getSources(librarySource, dartEntry, DartEntry.EXPORTED_LIBRARIES);
    if (_taskData != null) {
      return;
    }
    _computeLibraryDependenciesFromDirectives(library, importedSources, exportedSources);
  }
  void _computeLibraryDependenciesFromDirectives(ResolvableLibrary library, List<Source> importedSources, List<Source> exportedSources) {
    int importCount = importedSources.length;
    if (importCount > 0) {
      List<ResolvableLibrary> importedLibraries = new List<ResolvableLibrary>();
      bool explicitlyImportsCore = false;
      for (int i = 0; i < importCount; i++) {
        Source importedSource = importedSources[i];
        if (importedSource == AnalysisContextImpl_this._coreLibrarySource) {
          explicitlyImportsCore = true;
        }
        ResolvableLibrary importedLibrary = _libraryMap[importedSource];
        if (importedLibrary == null) {
          importedLibrary = _createLibraryOrNull(importedSource);
          if (importedLibrary != null) {
            _computeLibraryDependencies(importedLibrary);
            if (_taskData != null) {
              return;
            }
          }
        }
        if (importedLibrary != null) {
          importedLibraries.add(importedLibrary);
          _dependencyGraph.addEdge(library, importedLibrary);
        }
      }
      library.explicitlyImportsCore = explicitlyImportsCore;
      if (!explicitlyImportsCore && AnalysisContextImpl_this._coreLibrarySource != library.librarySource) {
        ResolvableLibrary importedLibrary = _libraryMap[AnalysisContextImpl_this._coreLibrarySource];
        if (importedLibrary == null) {
          importedLibrary = _createLibraryOrNull(AnalysisContextImpl_this._coreLibrarySource);
          if (importedLibrary != null) {
            _computeLibraryDependencies(importedLibrary);
            if (_taskData != null) {
              return;
            }
          }
        }
        if (importedLibrary != null) {
          importedLibraries.add(importedLibrary);
          _dependencyGraph.addEdge(library, importedLibrary);
        }
      }
      library.importedLibraries = new List.from(importedLibraries);
    } else {
      library.explicitlyImportsCore = false;
      ResolvableLibrary importedLibrary = _libraryMap[AnalysisContextImpl_this._coreLibrarySource];
      if (importedLibrary == null) {
        importedLibrary = _createLibraryOrNull(AnalysisContextImpl_this._coreLibrarySource);
        if (importedLibrary != null) {
          _computeLibraryDependencies(importedLibrary);
          if (_taskData != null) {
            return;
          }
        }
      }
      if (importedLibrary != null) {
        _dependencyGraph.addEdge(library, importedLibrary);
        library.importedLibraries = <ResolvableLibrary>[importedLibrary];
      }
    }
    int exportCount = exportedSources.length;
    if (exportCount > 0) {
      List<ResolvableLibrary> exportedLibraries = new List<ResolvableLibrary>();
      for (int i = 0; i < exportCount; i++) {
        Source exportedSource = exportedSources[i];
        ResolvableLibrary exportedLibrary = _libraryMap[exportedSource];
        if (exportedLibrary == null) {
          exportedLibrary = _createLibraryOrNull(exportedSource);
          if (exportedLibrary != null) {
            _computeLibraryDependencies(exportedLibrary);
            if (_taskData != null) {
              return;
            }
          }
        }
        if (exportedLibrary != null) {
          exportedLibraries.add(exportedLibrary);
          _dependencyGraph.addEdge(library, exportedLibrary);
        }
      }
      library.exportedLibraries = new List.from(exportedLibraries);
    }
  }
  void _computePartsInCycle(Source librarySource) {
    int count = _librariesInCycle.length;
    List<CycleBuilder_LibraryPair> libraryData = new List<CycleBuilder_LibraryPair>();
    for (int i = 0; i < count; i++) {
      ResolvableLibrary library = _librariesInCycle[i];
      libraryData.add(new CycleBuilder_LibraryPair(library, _ensurePartsInLibrary(library)));
    }
    AnalysisContextImpl_this._neededForResolution = _gatherSources(libraryData);
    if (AnalysisContextImpl._TRACE_PERFORM_TASK) {
      print("  preserve resolution data for ${AnalysisContextImpl_this._neededForResolution.length} sources while resolving ${librarySource.fullName}");
    }
    if (_taskData != null) {
      return;
    }
    for (int i = 0; i < count; i++) {
      _computePartsInLibrary(libraryData[i]);
    }
  }
  void _computePartsInLibrary(CycleBuilder_LibraryPair libraryPair) {
    ResolvableLibrary library = libraryPair.library;
    List<CycleBuilder_SourceEntryPair> entryPairs = libraryPair.entryPairs;
    int count = entryPairs.length;
    List<ResolvableCompilationUnit> units = new List<ResolvableCompilationUnit>(count);
    for (int i = 0; i < count; i++) {
      CycleBuilder_SourceEntryPair entryPair = entryPairs[i];
      Source A_source = entryPair.source;
      DartEntryImpl dartCopy = entryPair.entry.writableCopy;
      units[i] = new ResolvableCompilationUnit.C_con2(dartCopy.modificationTime, dartCopy.resolvableCompilationUnit, A_source);
      AnalysisContextImpl_this._cache.put(A_source, dartCopy);
    }
    library.resolvableCompilationUnits = units;
  }
  ResolvableLibrary _createLibrary(Source librarySource) {
    ResolvableLibrary library = new ResolvableLibrary(librarySource);
    SourceEntry sourceEntry = AnalysisContextImpl_this._cache.get(librarySource);
    if (sourceEntry is DartEntry) {
      LibraryElementImpl libraryElement = sourceEntry.getValue(DartEntry.B_ELEMENT) as LibraryElementImpl;
      if (libraryElement != null) {
        library.libraryElement = libraryElement;
      }
    }
    _libraryMap[librarySource] = library;
    return library;
  }
  ResolvableLibrary _createLibraryOrNull(Source librarySource) {
    if (!AnalysisContextImpl_this.exists(librarySource)) {
      return null;
    }
    ResolvableLibrary library = new ResolvableLibrary(librarySource);
    SourceEntry sourceEntry = AnalysisContextImpl_this._cache.get(librarySource);
    if (sourceEntry is DartEntry) {
      LibraryElementImpl libraryElement = sourceEntry.getValue(DartEntry.B_ELEMENT) as LibraryElementImpl;
      if (libraryElement != null) {
        library.libraryElement = libraryElement;
      }
    }
    _libraryMap[librarySource] = library;
    return library;
  }
  void _ensureElementModel(ResolvableLibrary library) {
    Source librarySource = library.librarySource;
    DartEntry libraryEntry = AnalysisContextImpl_this._getReadableDartEntry(librarySource);
    if (libraryEntry != null && libraryEntry.getState(DartEntry.PARSED_UNIT) != CacheState.C_ERROR) {
      AnalysisContextImpl_this._workManager.addFirst(librarySource, SourcePriority.B_LIBRARY);
      if (_taskData == null) {
        _taskData = AnalysisContextImpl_this._createResolveDartLibraryTask(librarySource, libraryEntry);
      }
    }
  }
  void _ensureExports(ResolvableLibrary library, A_p.HashSet<Source> visitedLibraries) {
    List<ResolvableLibrary> dependencies = library.exports;
    int dependencyCount = dependencies.length;
    for (int i = 0; i < dependencyCount; i++) {
      ResolvableLibrary dependency = dependencies[i];
      if (!_librariesInCycle.contains(dependency) && visitedLibraries.add(dependency.librarySource)) {
        if (dependency.libraryElement == null) {
          _ensureElementModel(dependency);
        } else {
          _ensureExports(dependency, visitedLibraries);
        }
        if (_taskData != null) {
          return;
        }
      }
    }
  }
  void _ensureImports(ResolvableLibrary library) {
    List<ResolvableLibrary> dependencies = library.imports;
    int dependencyCount = dependencies.length;
    for (int i = 0; i < dependencyCount; i++) {
      ResolvableLibrary dependency = dependencies[i];
      if (!_librariesInCycle.contains(dependency) && dependency.libraryElement == null) {
        _ensureElementModel(dependency);
        if (_taskData != null) {
          return;
        }
      }
    }
  }
  void _ensureImportsAndExports() {
    A_p.HashSet<Source> visitedLibraries = new A_p.HashSet<Source>();
    int libraryCount = _librariesInCycle.length;
    for (int i = 0; i < libraryCount; i++) {
      ResolvableLibrary library = _librariesInCycle[i];
      _ensureImports(library);
      if (_taskData != null) {
        return;
      }
      _ensureExports(library, visitedLibraries);
      if (_taskData != null) {
        return;
      }
    }
  }
  List<CycleBuilder_SourceEntryPair> _ensurePartsInLibrary(ResolvableLibrary library) {
    List<CycleBuilder_SourceEntryPair> pairs = new List<CycleBuilder_SourceEntryPair>();
    Source librarySource = library.librarySource;
    DartEntry libraryEntry = AnalysisContextImpl_this._getReadableDartEntry(librarySource);
    if (libraryEntry == null) {
      throw new AnalysisException("Cannot find entry for ${librarySource.fullName}");
    } else if (libraryEntry.getState(DartEntry.PARSED_UNIT) == CacheState.C_ERROR) {
      throw new AnalysisException("Cannot compute parsed unit for ${librarySource.fullName}");
    }
    _ensureResolvableCompilationUnit(librarySource, libraryEntry);
    pairs.add(new CycleBuilder_SourceEntryPair(librarySource, libraryEntry));
    List<Source> partSources = _getSources(librarySource, libraryEntry, DartEntry.INCLUDED_PARTS);
    int count = partSources.length;
    for (int i = 0; i < count; i++) {
      Source partSource = partSources[i];
      DartEntry partEntry = AnalysisContextImpl_this._getReadableDartEntry(partSource);
      if (partEntry != null && partEntry.getState(DartEntry.PARSED_UNIT) != CacheState.C_ERROR) {
        _ensureResolvableCompilationUnit(partSource, partEntry);
        pairs.add(new CycleBuilder_SourceEntryPair(partSource, partEntry));
      }
    }
    return pairs;
  }
  void _ensureResolvableCompilationUnit(Source A_source, DartEntry dartEntry) {
    if (dartEntry != null && !dartEntry.hasResolvableCompilationUnit) {
      if (_taskData == null) {
        _taskData = AnalysisContextImpl_this._createParseDartTask(A_source, dartEntry);
      }
    }
  }
  A_p.HashSet<Source> _gatherSources(List<CycleBuilder_LibraryPair> libraryData) {
    int libraryCount = libraryData.length;
    A_p.HashSet<Source> sources = new A_p.HashSet<Source>();
    for (int i = 0; i < libraryCount; i++) {
      List<CycleBuilder_SourceEntryPair> entryPairs = libraryData[i].entryPairs;
      int entryCount = entryPairs.length;
      for (int j = 0; j < entryCount; j++) {
        sources.add(entryPairs[j].source);
      }
    }
    return sources;
  }
  List<Source> _getSources(Source A_source, DartEntry dartEntry, DataDescriptor<List<Source>> descriptor) {
    if (dartEntry == null) {
      return Source.F_EMPTY_ARRAY;
    }
    CacheState exportState = dartEntry.getState(descriptor);
    if (exportState == CacheState.C_ERROR) {
      return Source.F_EMPTY_ARRAY;
    } else if (exportState != CacheState.VALID) {
      if (_taskData == null) {
        _taskData = AnalysisContextImpl_this._createParseDartTask(A_source, dartEntry);
      }
      return Source.F_EMPTY_ARRAY;
    }
    return dartEntry.getValue(descriptor);
  }
}
class AnalysisContextImpl_TaskData {
  final AnalysisTask task;
  final bool _blocked;
  AnalysisContextImpl_TaskData(this.task, this._blocked);
  bool get isBlocked => _blocked;
  String toString() {
    if (task == null) {
      return "blocked: ${_blocked}";
    }
    return task.toString();
  }
}
class AnalysisEngine {
  static String SUFFIX_DART = "dart";
  static String SUFFIX_HTM = "htm";
  static String SUFFIX_HTML = "html";
  static AnalysisEngine _UniqueInstance = new AnalysisEngine();
  static AnalysisEngine get A_instance => _UniqueInstance;
  static bool isDartFileName(String fileName) {
    if (fileName == null) {
      return false;
    }
    return javaStringEqualsIgnoreCase(FileNameUtilities.getExtension(fileName), SUFFIX_DART);
  }
  static bool isHtmlFileName(String fileName) {
    if (fileName == null) {
      return false;
    }
    String extension = FileNameUtilities.getExtension(fileName);
    return javaStringEqualsIgnoreCase(extension, SUFFIX_HTML) || javaStringEqualsIgnoreCase(extension, SUFFIX_HTM);
  }
  Logger A__logger = Logger.NULL;
  final PartitionManager partitionManager = new PartitionManager();
  AnalysisContext createAnalysisContext() {
    if (Instrumentation.isNullLogger) {
      return new AnalysisContextImpl();
    }
    return new InstrumentedAnalysisContextImpl.C_con1(new AnalysisContextImpl());
  }
  Logger get logger => A__logger;
  void set logger(Logger A_logger) {
    this.A__logger = A_logger == null ? Logger.NULL : A_logger;
  }
}
abstract class AnalysisErrorInfo {
  List<A_AnalysisError> get errors;
  LineInfo get lineInfo;
}
class AnalysisErrorInfoImpl implements AnalysisErrorInfo {
  final List<A_AnalysisError> errors;
  final LineInfo lineInfo;
  AnalysisErrorInfoImpl(this.errors, this.lineInfo);
}
abstract class AnalysisOptions {
  bool get analyzeAngular;
  bool get analyzeFunctionBodies;
  bool get analyzePolymer;
  int get cacheSize;
  bool get dart2jsHint;
  bool get enableAsync;
  bool get enableDeferredLoading;
  bool get enableEnum;
  bool get generateSdkErrors;
  bool get hint;
  bool get incremental;
  bool get preserveComments;
}
class AnalysisOptionsImpl implements AnalysisOptions {
  static int DEFAULT_CACHE_SIZE = 64;
  static bool DEFAULT_ENABLE_ASYNC = false;
  static bool DEFAULT_ENABLE_DEFERRED_LOADING = true;
  static bool DEFAULT_ENABLE_ENUM = false;
  bool analyzeAngular = true;
  bool analyzeFunctionBodies = true;
  bool analyzePolymer = true;
  int cacheSize = DEFAULT_CACHE_SIZE;
  bool dart2jsHint = true;
  bool enableAsync = DEFAULT_ENABLE_ASYNC;
  bool enableDeferredLoading = DEFAULT_ENABLE_DEFERRED_LOADING;
  bool enableEnum = DEFAULT_ENABLE_ENUM;
  bool _generateSdkErrors = false;
  bool hint = true;
  bool incremental = false;
  bool preserveComments = true;
  AnalysisOptionsImpl();
  AnalysisOptionsImpl.C_con1(AnalysisOptions options) {
    analyzeAngular = options.analyzeAngular;
    analyzeFunctionBodies = options.analyzeFunctionBodies;
    analyzePolymer = options.analyzePolymer;
    cacheSize = options.cacheSize;
    dart2jsHint = options.dart2jsHint;
    enableAsync = options.enableAsync;
    enableDeferredLoading = options.enableDeferredLoading;
    enableEnum = options.enableEnum;
    _generateSdkErrors = options.generateSdkErrors;
    hint = options.hint;
    incremental = options.incremental;
    preserveComments = options.preserveComments;
  }
  bool get generateSdkErrors => _generateSdkErrors;
  void set generateSdkErrors(bool A_generate) {
    _generateSdkErrors = A_generate;
  }
}
class AnalysisResult {
  final List<ChangeNotice> _notices;
  final int getTime;
  final String taskClassName;
  final int performTime;
  AnalysisResult(this._notices, this.getTime, this.taskClassName, this.performTime);
  List<ChangeNotice> get changeNotices => _notices;
}
abstract class AnalysisTask {
  final InternalAnalysisContext context;
  CaughtException _thrownException;
  AnalysisTask(this.context);
  accept(AnalysisTaskVisitor visitor);
  CaughtException get exception => _thrownException;
  Object perform(AnalysisTaskVisitor visitor) {
    try {
      _safelyPerform();
    }on AnalysisException  catch (A_exception, A_stackTrace) {
      _thrownException = new CaughtException(A_exception, A_stackTrace);
      AnalysisEngine.A_instance.logger.logInformation2("Task failed: ${taskDescription}", new CaughtException(A_exception, A_stackTrace));
    }
    return accept(visitor);
  }
  String toString() => taskDescription;
  String get taskDescription;
  void internalPerform();
  void _safelyPerform() {
    try {
      internalPerform();
    }on AnalysisException  catch (A_exception) {
      throw A_exception;
    }  catch (A_exception, A_stackTrace) {
      throw new AnalysisException("Exception", new CaughtException(A_exception, A_stackTrace));
    }
  }
}
abstract class AnalysisTaskVisitor<E_E> {
  E_E visitGenerateDartErrorsTask(GenerateDartErrorsTask task);
  E_E visitGenerateDartHintsTask(GenerateDartHintsTask task);
  E_E visitGetContentTask(GetContentTask task);
  E_E visitIncrementalAnalysisTask(IncrementalAnalysisTask incrementalAnalysisTask);
  E_E visitParseDartTask(ParseDartTask task);
  E_E visitParseHtmlTask(ParseHtmlTask task);
  E_E visitPolymerBuildHtmlTask(PolymerBuildHtmlTask task);
  E_E visitPolymerResolveHtmlTask(PolymerResolveHtmlTask task);
  E_E visitResolveAngularComponentTemplateTask(ResolveAngularComponentTemplateTask task);
  E_E visitResolveAngularEntryHtmlTask(ResolveAngularEntryHtmlTask task);
  E_E visitResolveDartLibraryCycleTask(ResolveDartLibraryCycleTask task);
  E_E visitResolveDartLibraryTask(ResolveDartLibraryTask task);
  E_E visitResolveHtmlTask(ResolveHtmlTask task);
  E_E visitScanDartTask(ScanDartTask task);
}
class AngularExpression {
  final Expression expression;
  final List<AngularFormatterNode> formatters;
  AngularExpression(this.expression, this.formatters);
  int get end {
    if (formatters.isEmpty) {
      return expression.end;
    }
    AngularFormatterNode lastFormatter = formatters[formatters.length - 1];
    List<AngularFormatterArgument> formatterArguments = lastFormatter.arguments;
    if (formatterArguments.isEmpty) {
      return lastFormatter.name.end;
    }
    return formatterArguments[formatterArguments.length - 1].expression.end;
  }
  List<Expression> get expressions {
    List<Expression> A_expressions = [];
    A_expressions.add(expression);
    for (AngularFormatterNode formatter in formatters) {
      A_expressions.add(formatter.name);
      for (AngularFormatterArgument formatterArgument in formatter.arguments) {
        A_expressions.addAll(formatterArgument.subExpressions);
        A_expressions.add(formatterArgument.expression);
      }
    }
    return A_expressions;
  }
  int get length => end - offset;
  int get offset => expression.offset;
}
class AngularFormatterArgument {
  final A_Token token;
  final Expression expression;
  List<Expression> subExpressions = Expression.A_EMPTY_ARRAY;
  AngularFormatterArgument(this.token, this.expression);
}
class AngularFormatterNode {
  final A_Token token;
  final SimpleIdentifier name;
  final List<AngularFormatterArgument> arguments;
  AngularFormatterNode(this.token, this.name, this.arguments);
}
class AngularHtmlUnitResolver extends RecursiveXmlVisitor<Object> {
  static String _NG_APP = "ng-app";
  static AngularElement getAngularElement(A_Element A_element) {
    if (A_element is LocalVariableElement) {
      LocalVariableElement local = A_element;
      List<ToolkitObjectElement> toolkitObjects = local.toolkitObjects;
      if (toolkitObjects.length == 1 && toolkitObjects[0] is AngularElement) {
        return toolkitObjects[0] as AngularElement;
      }
    }
    return null;
  }
  static bool hasAngularAnnotation(HtmlUnit htmlUnit) {
    try {
      htmlUnit.accept(new RecursiveXmlVisitor_AngularHtmlUnitResolver_hasAngularAnnotation());
    }on AngularHtmlUnitResolver_FoundAppError  catch (e) {
      return true;
    }
    return false;
  }
  static SimpleIdentifier _createIdentifier(String A_name, int A_offset) {
    StringToken token = _createStringToken(A_name, A_offset);
    return new SimpleIdentifier(token);
  }
  static void _addAngularElementsFromClass(Set<AngularElement> angularElements, ClassElement classElement) {
    for (ToolkitObjectElement toolkitObject in classElement.toolkitObjects) {
      if (toolkitObject is AngularElement) {
        angularElements.add(toolkitObject);
      }
    }
  }
  static void _addAngularElementsFromLibrary(Set<AngularElement> angularElements, LibraryElement library, Set<LibraryElement> visited) {
    if (library == null) {
      return;
    }
    if (!visited.add(library)) {
      return;
    }
    for (CompilationUnitElement unit in library.units) {
      angularElements.addAll(unit.angularViews);
      for (ClassElement A_type in unit.types) {
        _addAngularElementsFromClass(angularElements, A_type);
      }
    }
    for (ImportElement importElement in library.imports) {
      LibraryElement importedLibrary = importElement.importedLibrary;
      _addAngularElementsFromLibrary(angularElements, importedLibrary, visited);
    }
  }
  static StringToken _createStringToken(String A_name, int A_offset) => new StringToken(A_TokenType.IDENTIFIER, A_name, A_offset);
  static List<AngularElement> _getAngularElements(Set<LibraryElement> libraries, LibraryElement libraryElement) {
    Set<AngularElement> angularElements = new Set();
    _addAngularElementsFromLibrary(angularElements, libraryElement, libraries);
    return new List.from(angularElements);
  }
  static CompilationUnit _getDartUnit(AnalysisContext context, HtmlUnit unit) {
    for (HtmlScriptElement A_script in unit.element.scripts) {
      if (A_script is ExternalHtmlScriptElement) {
        Source scriptSource = A_script.scriptSource;
        if (scriptSource != null) {
          return context.resolveCompilationUnit2(scriptSource, scriptSource);
        }
      }
    }
    return null;
  }
  static Set<Source> _getLibrarySources(Set<LibraryElement> libraries) {
    Set<Source> sources = new Set();
    for (LibraryElement library in libraries) {
      sources.add(library.source);
    }
    return sources;
  }
  final InternalAnalysisContext A__context;
  TypeProvider A__typeProvider;
  AngularHtmlUnitResolver_FilteringAnalysisErrorListener _errorListener;
  final Source B__source;
  final LineInfo _lineInfo;
  final HtmlUnit F__unit;
  List<AngularElement> _angularElements;
  List<NgProcessor> _processors = [];
  LibraryElementImpl A__libraryElement;
  CompilationUnitElementImpl _unitElement;
  FunctionElementImpl _functionElement;
  ResolverVisitor _resolver;
  bool _isAngular = false;
  List<LocalVariableElementImpl> _definedVariables = [];
  Set<LibraryElement> _injectedLibraries = new Set();
  Scope _topNameScope;
  Scope _nameScope;
  AngularHtmlUnitResolver(this.A__context, AnalysisErrorListener errorListener, this.B__source, this._lineInfo, this.F__unit) {
    this.A__typeProvider = A__context.typeProvider;
    this._errorListener = new AngularHtmlUnitResolver_FilteringAnalysisErrorListener(errorListener);
  }
  AngularApplication calculateAngularApplication() {
    if (!hasAngularAnnotation(F__unit)) {
      return null;
    }
    CompilationUnit dartUnit = _getDartUnit(A__context, F__unit);
    if (dartUnit == null) {
      return null;
    }
    LibraryElement libraryElement = dartUnit.element.library;
    Set<LibraryElement> libraries = new Set();
    List<AngularElement> angularElements = _getAngularElements(libraries, libraryElement);
    Set<Source> angularElementsSources = new Set();
    for (AngularElement angularElement in angularElements) {
      if (angularElement is AngularHasTemplateElement) {
        AngularHasTemplateElement hasTemplate = angularElement;
        angularElementsSources.add(angularElement.source);
        String templateUri = hasTemplate.templateUri;
        if (templateUri == null) {
          continue;
        }
        try {
          Source templateSource = A__context.sourceFactory.forUri2(B__source.resolveRelativeUri(parseUriWithException(templateUri)));
          if (!A__context.exists(templateSource)) {
            templateSource = A__context.sourceFactory.resolveUri(B__source, "package:${templateUri}");
            if (!A__context.exists(templateSource)) {
              _errorListener.onError(new A_AnalysisError.D_con2(angularElement.source, hasTemplate.templateUriOffset, templateUri.length, AngularCode.URI_DOES_NOT_EXIST, [templateUri]));
              continue;
            }
          }
          if (!AnalysisEngine.isHtmlFileName(templateUri)) {
            continue;
          }
          if (hasTemplate is AngularComponentElementImpl) {
            hasTemplate.templateSource = templateSource;
          }
          if (hasTemplate is AngularViewElementImpl) {
            hasTemplate.templateSource = templateSource;
          }
        }on URISyntaxException  catch (exception) {
          _errorListener.onError(new A_AnalysisError.D_con2(angularElement.source, hasTemplate.templateUriOffset, templateUri.length, AngularCode.A_INVALID_URI, [templateUri]));
        }
      }
    }
    AngularApplication application = new AngularApplication(B__source, _getLibrarySources(libraries), angularElements, new List.from(angularElementsSources));
    for (AngularElement angularElement in angularElements) {
      (angularElement as AngularElementImpl).application = application;
    }
    return application;
  }
  void resolveComponentTemplate(AngularApplication application, AngularComponentElement component) {
    _isAngular = true;
    _resolveInternal(application.elements, component);
  }
  void resolveEntryPoint(AngularApplication application) {
    _resolveInternal(application.elements, null);
  }
  Object visitXmlAttributeNode(XmlAttributeNode node) {
    _parseEmbeddedExpressionsInAttribute(node);
    _resolveExpressions(node.expressions);
    return super.visitXmlAttributeNode(node);
  }
  Object visitXmlTagNode(XmlTagNode node) {
    bool wasAngular = _isAngular;
    try {
      if (node.getAttribute(_NG_APP) != null) {
        _isAngular = true;
        _visitModelDirectives(node);
      }
      if (!_isAngular) {
        return super.visitXmlTagNode(node);
      }
      _pushNameScope();
      try {
        _parseEmbeddedExpressionsInTag(node);
        for (NgProcessor processor in _processors) {
          if (processor.canApply(node)) {
            processor.apply(this, node);
          }
        }
        _resolveExpressions(node.expressions);
        return super.visitXmlTagNode(node);
      } finally {
        _popNameScope();
      }
    } finally {
      _isAngular = wasAngular;
    }
  }
  LocalVariableElementImpl _createLocalVariableFromIdentifier(DartType A_type, SimpleIdentifier identifier) {
    LocalVariableElementImpl variable = new LocalVariableElementImpl.forNode(identifier);
    _definedVariables.add(variable);
    variable.type = A_type;
    return variable;
  }
  LocalVariableElementImpl _createLocalVariableWithName(DartType A_type, String A_name) {
    SimpleIdentifier identifier = _createIdentifier(A_name, 0);
    return _createLocalVariableFromIdentifier(A_type, identifier);
  }
  void _defineTopVariable(LocalVariableElementImpl variable) {
    _recordDefinedVariable(variable);
    _topNameScope.define(variable);
    _recordTypeLibraryInjected(variable);
  }
  void _defineVariable(LocalVariableElementImpl variable) {
    _recordDefinedVariable(variable);
    _nameScope.define(variable);
    _recordTypeLibraryInjected(variable);
  }
  TypeProvider get typeProvider => A__typeProvider;
  AngularExpression _parseAngularExpression(String contents, int startIndex, int endIndex, int A_offset) {
    A_Token token = _scanDart(contents, startIndex, endIndex, A_offset);
    return _parseAngularExpressionInToken(token);
  }
  AngularExpression _parseAngularExpressionInToken(A_Token token) {
    List<A_Token> tokens = _splitAtBar(token);
    Expression mainExpression = _parseDartExpressionInToken(tokens[0]);
    List<AngularFormatterNode> formatters = [];
    for (int i = 1; i < tokens.length; i++) {
      A_Token formatterToken = tokens[i];
      A_Token barToken = formatterToken;
      formatterToken = formatterToken.next;
      Expression nameExpression = _parseDartExpressionInToken(formatterToken);
      if (nameExpression is! SimpleIdentifier) {
        _reportErrorForNode(AngularCode.INVALID_FORMATTER_NAME, nameExpression, []);
        continue;
      }
      SimpleIdentifier A_name = nameExpression as SimpleIdentifier;
      formatterToken = A_name.endToken.next;
      List<AngularFormatterArgument> A_arguments = [];
      while (formatterToken.type != A_TokenType.A_EOF) {
        A_Token colonToken = formatterToken;
        if (colonToken.type == A_TokenType.A_COLON) {
          formatterToken = formatterToken.next;
        } else {
          _reportErrorForToken(AngularCode.MISSING_FORMATTER_COLON, colonToken, []);
        }
        Expression argument = _parseDartExpressionInToken(formatterToken);
        A_arguments.add(new AngularFormatterArgument(colonToken, argument));
        formatterToken = argument.endToken.next;
      }
      formatters.add(new AngularFormatterNode(barToken, A_name, A_arguments));
    }
    return new AngularExpression(mainExpression, formatters);
  }
  Expression _parseDartExpressionInToken(A_Token token) {
    Parser parser = new Parser(B__source, _errorListener);
    return parser.parseExpression(token);
  }
  void _popNameScope() {
    _nameScope = _resolver.popNameScope();
  }
  void _pushNameScope() {
    _nameScope = _resolver.pushNameScope();
  }
  void _reportErrorForNode(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    _reportErrorForOffset(A_errorCode, node.offset, node.length, A_arguments);
  }
  void _reportErrorForOffset(ErrorCode A_errorCode, int A_offset, int A_length, List<Object> A_arguments) {
    _errorListener.onError(new A_AnalysisError.D_con2(B__source, A_offset, A_length, A_errorCode, A_arguments));
  }
  void _reportErrorForToken(ErrorCode A_errorCode, A_Token token, List<Object> A_arguments) {
    _reportErrorForOffset(A_errorCode, token.offset, token.length, A_arguments);
  }
  void _resolveExpression(AngularExpression angularExpression) {
    List<Expression> dartExpressions = angularExpression.expressions;
    for (Expression dartExpression in dartExpressions) {
      _resolveNode(dartExpression);
    }
  }
  void _resolveNode(AstNode node) {
    node.accept(_resolver);
  }
  A_Token _scanDart(String contents, int startIndex, int endIndex, int A_offset) => HtmlParser.scanDartSource(B__source, _lineInfo, contents.substring(startIndex, endIndex), A_offset + startIndex, _errorListener);
  void _createLibraryElement() {
    String unitName = B__source.shortName;
    _unitElement = new CompilationUnitElementImpl(unitName);
    _unitElement.source = B__source;
    A__libraryElement = new LibraryElementImpl.forNode(A__context, null);
    A__libraryElement.definingCompilationUnit = _unitElement;
    A__libraryElement.angularHtml = true;
    _injectedLibraries.add(A__libraryElement);
    _functionElement = new FunctionElementImpl.forOffset(0);
    _unitElement.functions = <FunctionElement>[_functionElement];
  }
  NgProcessor _createProcessor(AngularElement A_element) {
    if (A_element is AngularComponentElement) {
      AngularComponentElement component = A_element;
      return new NgComponentElementProcessor(component);
    }
    if (A_element is AngularControllerElement) {
      AngularControllerElement A_controller = A_element;
      return new NgControllerElementProcessor(A_controller);
    }
    if (A_element is AngularDecoratorElement) {
      AngularDecoratorElement directive = A_element;
      return new NgDecoratorElementProcessor(directive);
    }
    return null;
  }
  void _createResolver() {
    InheritanceManager inheritanceManager = new InheritanceManager(A__libraryElement);
    _resolver = new ResolverVisitor.G_con2(A__libraryElement, B__source, A__typeProvider, inheritanceManager, _errorListener);
    _topNameScope = _resolver.pushNameScope();
    {
      DartType A_type = A__typeProvider.dynamicType;
      _topNameScope.define(_createLocalVariableWithName(A_type, "\$id"));
      _topNameScope.define(_createLocalVariableWithName(A_type, "\$parent"));
      _topNameScope.define(_createLocalVariableWithName(A_type, "\$root"));
    }
  }
  void _defineTopVariable_forClassElement(AngularElement A_element) {
    ClassElement classElement = A_element.enclosingElement as ClassElement;
    InterfaceType A_type = classElement.type;
    LocalVariableElementImpl variable = _createLocalVariableWithName(A_type, A_element.name);
    _defineTopVariable(variable);
    variable.toolkitObjects = <AngularElement>[A_element];
  }
  void _defineTopVariable_forScopeProperty(AngularScopePropertyElement A_element) {
    DartType A_type = A_element.type;
    LocalVariableElementImpl variable = _createLocalVariableWithName(A_type, A_element.name);
    _defineTopVariable(variable);
    variable.toolkitObjects = <AngularElement>[A_element];
  }
  void _parseEmbeddedExpressions(List<AngularMoustacheXmlExpression> expressions, Token token) {
    String lexeme = token.lexeme;
    int A_offset = token.offset;
    int startIndex = StringUtilities.indexOf2(lexeme, 0, AngularMoustacheXmlExpression.OPENING_DELIMITER_CHAR, AngularMoustacheXmlExpression.OPENING_DELIMITER_CHAR);
    while (startIndex >= 0) {
      int endIndex = StringUtilities.indexOf2(lexeme, startIndex + AngularMoustacheXmlExpression.OPENING_DELIMITER_LENGTH, AngularMoustacheXmlExpression.CLOSING_DELIMITER_CHAR, AngularMoustacheXmlExpression.CLOSING_DELIMITER_CHAR);
      if (endIndex < 0) {
        return;
      } else if (startIndex + AngularMoustacheXmlExpression.OPENING_DELIMITER_LENGTH < endIndex) {
        startIndex += AngularMoustacheXmlExpression.OPENING_DELIMITER_LENGTH;
        AngularExpression expression = _parseAngularExpression(lexeme, startIndex, endIndex, A_offset);
        expressions.add(new AngularMoustacheXmlExpression(startIndex, endIndex, expression));
      }
      startIndex = StringUtilities.indexOf2(lexeme, endIndex + AngularMoustacheXmlExpression.CLOSING_DELIMITER_LENGTH, AngularMoustacheXmlExpression.OPENING_DELIMITER_CHAR, AngularMoustacheXmlExpression.OPENING_DELIMITER_CHAR);
    }
  }
  void _parseEmbeddedExpressionsInAttribute(XmlAttributeNode node) {
    List<AngularMoustacheXmlExpression> expressions = [];
    _parseEmbeddedExpressions(expressions, node.valueToken);
    if (!expressions.isEmpty) {
      node.expressions = new List.from(expressions);
    }
  }
  void _parseEmbeddedExpressionsInTag(XmlTagNode node) {
    List<AngularMoustacheXmlExpression> expressions = [];
    Token token = node.attributeEnd;
    Token endToken = node.endToken;
    bool inChild = false;
    while (!identical(token, endToken)) {
      for (XmlTagNode child in node.tagNodes) {
        if (identical(token, child.beginToken)) {
          inChild = true;
          break;
        }
        if (identical(token, child.endToken)) {
          inChild = false;
          break;
        }
      }
      if (!inChild && token.type == TokenType.A_TEXT) {
        _parseEmbeddedExpressions(expressions, token);
      }
      token = token.next;
    }
    node.expressions = new List.from(expressions);
  }
  void _recordDefinedVariable(LocalVariableElementImpl variable) {
    _definedVariables.add(variable);
    _functionElement.localVariables = new List.from(_definedVariables);
  }
  void _recordTypeLibraryInjected(LocalVariableElementImpl variable) {
    LibraryElement typeLibrary = variable.type.element.library;
    _injectedLibraries.add(typeLibrary);
  }
  void _resolveExpressions(List<XmlExpression> expressions) {
    for (XmlExpression xmlExpression in expressions) {
      if (xmlExpression is AngularXmlExpression) {
        AngularXmlExpression angularXmlExpression = xmlExpression;
        _resolveXmlExpression(angularXmlExpression);
      }
    }
  }
  void _resolveInternal(List<AngularElement> angularElements, AngularComponentElement component) {
    this._angularElements = angularElements;
    _processors.add(NgModelProcessor.B_INSTANCE);
    for (AngularElement angularElement in angularElements) {
      _injectedLibraries.add(angularElement.library);
    }
    _createLibraryElement();
    (F__unit.element as HtmlElementImpl).angularCompilationUnit = _unitElement;
    _createResolver();
    if (component != null) {
      _defineTopVariable_forClassElement(component);
      for (AngularScopePropertyElement scopeProperty in component.scopeProperties) {
        _defineTopVariable_forScopeProperty(scopeProperty);
      }
    }
    for (AngularElement angularElement in angularElements) {
      NgProcessor processor = _createProcessor(angularElement);
      if (processor != null) {
        _processors.add(processor);
      }
    }
    for (AngularElement angularElement in angularElements) {
      if (angularElement is AngularFormatterElement) {
        _defineTopVariable_forClassElement(angularElement);
      }
    }
    F__unit.accept(this);
    {
      List<ImportElement> imports = [];
      for (LibraryElement injectedLibrary in _injectedLibraries) {
        ImportElementImpl importElement = new ImportElementImpl(-1);
        importElement.importedLibrary = injectedLibrary;
        imports.add(importElement);
      }
      A__libraryElement.imports = new List.from(imports);
    }
  }
  void _resolveXmlExpression(AngularXmlExpression angularXmlExpression) {
    AngularExpression angularExpression = angularXmlExpression.expression;
    _resolveExpression(angularExpression);
  }
  List<A_Token> _splitAtBar(A_Token token) {
    List<A_Token> tokens = [];
    tokens.add(token);
    while (token.type != A_TokenType.A_EOF) {
      if (token.type == A_TokenType.BAR) {
        tokens.add(token);
        A_Token eofToken = new A_Token(A_TokenType.A_EOF, 0);
        token.previous.setNext(eofToken);
      }
      token = token.next;
    }
    return tokens;
  }
  void _visitModelDirectives(XmlTagNode appNode) {
    appNode.accept(new RecursiveXmlVisitor_AngularHtmlUnitResolver_visitModelDirectives(this));
  }
}
class AngularHtmlUnitResolver_FilteringAnalysisErrorListener implements AnalysisErrorListener {
  final AnalysisErrorListener _listener;
  AngularHtmlUnitResolver_FilteringAnalysisErrorListener(this._listener);
  void onError(A_AnalysisError A_error) {
    ErrorCode A_errorCode = A_error.errorCode;
    if (identical(A_errorCode, StaticWarningCode.UNDEFINED_GETTER) || identical(A_errorCode, StaticWarningCode.UNDEFINED_IDENTIFIER) || identical(A_errorCode, StaticTypeWarningCode.UNDEFINED_GETTER)) {
      return;
    }
    _listener.onError(A_error);
  }
}
class AngularHtmlUnitResolver_FoundAppError extends Error {}
class AngularMoustacheXmlExpression extends AngularXmlExpression {
  static int OPENING_DELIMITER_CHAR = 0x7B;
  static int CLOSING_DELIMITER_CHAR = 0x7D;
  static String OPENING_DELIMITER = "{{";
  static String CLOSING_DELIMITER = "}}";
  static int OPENING_DELIMITER_LENGTH = OPENING_DELIMITER.length;
  static int CLOSING_DELIMITER_LENGTH = CLOSING_DELIMITER.length;
  final int _openingOffset;
  final int _closingOffset;
  AngularMoustacheXmlExpression(this._openingOffset, this._closingOffset, AngularExpression expression) : super(expression);
  int get end => _closingOffset + CLOSING_DELIMITER_LENGTH;
  int get length => _closingOffset + CLOSING_DELIMITER_LENGTH - _openingOffset;
  int get offset => _openingOffset;
}
class AngularRawXmlExpression extends AngularXmlExpression {
  AngularRawXmlExpression(AngularExpression expression) : super(expression);
  int get end => expression.end;
  int get length => expression.length;
  int get offset => expression.offset;
}
abstract class AngularXmlExpression extends XmlExpression {
  final AngularExpression expression;
  AngularXmlExpression(this.expression);
}
abstract class CachePartition {
  A_p.HashMap<Source, SourceEntry> _sourceMap = new A_p.HashMap<Source,SourceEntry>();
  int _maxCacheSize = 0;
  final CacheRetentionPolicy _retentionPolicy;
  List<Source> _recentlyUsed;
  CachePartition(int A_maxCacheSize, this._retentionPolicy) {
    this._maxCacheSize = A_maxCacheSize;
    _recentlyUsed = new List<Source>();
  }
  void accessedAst(Source A_source) {
    if (_recentlyUsed.remove(A_source)) {
      _recentlyUsed.add(A_source);
      return;
    }
    while (_recentlyUsed.length >= _maxCacheSize) {
      if (!_flushAstFromCache()) {
        break;
      }
    }
    _recentlyUsed.add(A_source);
  }
  bool contains(Source A_source);
  SourceEntry get(Source A_source) => _sourceMap[A_source];
  Map<Source, SourceEntry> get map => _sourceMap;
  MapIterator<Source, SourceEntry> iterator() => new SingleMapIterator<Source,SourceEntry>(_sourceMap);
  void put(Source A_source, SourceEntry A_entry) {
    (A_entry as SourceEntryImpl).fixExceptionState();
    _sourceMap[A_source] = A_entry;
  }
  void remove(Source A_source) {
    _recentlyUsed.remove(A_source);
    _sourceMap.remove(A_source);
  }
  void removedAst(Source A_source) {
    _recentlyUsed.remove(A_source);
  }
  void set maxCacheSize(int A_size) {
    _maxCacheSize = A_size;
    while (_recentlyUsed.length > _maxCacheSize) {
      if (!_flushAstFromCache()) {
        break;
      }
    }
  }
  int size() => _sourceMap.length;
  void storedAst(Source A_source) {
    if (_recentlyUsed.contains(A_source)) {
      return;
    }
    while (_recentlyUsed.length >= _maxCacheSize) {
      if (!_flushAstFromCache()) {
        break;
      }
    }
    _recentlyUsed.add(A_source);
  }
  bool _flushAstFromCache() {
    Source removedSource = _removeAstToFlush();
    if (removedSource == null) {
      return false;
    }
    SourceEntry sourceEntry = _sourceMap[removedSource];
    if (sourceEntry is HtmlEntry) {
      HtmlEntryImpl htmlCopy = sourceEntry.writableCopy;
      htmlCopy.flushAstStructures();
      _sourceMap[removedSource] = htmlCopy;
    } else if (sourceEntry is DartEntry) {
      DartEntryImpl dartCopy = sourceEntry.writableCopy;
      dartCopy.flushAstStructures();
      _sourceMap[removedSource] = dartCopy;
    }
    return true;
  }
  Source _removeAstToFlush() {
    int sourceToRemove = -1;
    for (int i = 0; i < _recentlyUsed.length; i++) {
      Source A_source = _recentlyUsed[i];
      RetentionPriority priority = _retentionPolicy.getAstPriority(A_source, _sourceMap[A_source]);
      if (priority == RetentionPriority.A_LOW) {
        return _recentlyUsed.removeAt(i);
      } else if (priority == RetentionPriority.MEDIUM && sourceToRemove < 0) {
        sourceToRemove = i;
      }
    }
    if (sourceToRemove < 0) {
      return null;
    }
    return _recentlyUsed.removeAt(sourceToRemove);
  }
}
abstract class CacheRetentionPolicy {
  RetentionPriority getAstPriority(Source A_source, SourceEntry sourceEntry);
}
class CacheState extends Enum<CacheState> {
  static const CacheState C_ERROR = const CacheState('ERROR', 0);
  static const CacheState FLUSHED = const CacheState('FLUSHED', 1);
  static const CacheState IN_PROCESS = const CacheState('IN_PROCESS', 2);
  static const CacheState INVALID = const CacheState('INVALID', 3);
  static const CacheState VALID = const CacheState('VALID', 4);
  const CacheState(String A_name, int ordinal) : super(A_name, ordinal);
}
abstract class ChangeNotice implements AnalysisErrorInfo {
  CompilationUnit get compilationUnit;
  HtmlUnit get htmlUnit;
  Source get source;
}
class ChangeNoticeImpl implements ChangeNotice {
  final Source source;
  CompilationUnit compilationUnit;
  HtmlUnit htmlUnit;
  List<A_AnalysisError> A__errors;
  LineInfo _lineInfo;
  static List<ChangeNoticeImpl> C_EMPTY_ARRAY = new List<ChangeNoticeImpl>(0);
  ChangeNoticeImpl(this.source);
  List<A_AnalysisError> get errors => A__errors;
  LineInfo get lineInfo => _lineInfo;
  void setErrors(List<A_AnalysisError> B_errors, LineInfo A_lineInfo) {
    this.A__errors = B_errors;
    this._lineInfo = A_lineInfo;
    if (A_lineInfo == null) {
      AnalysisEngine.A_instance.logger.logInformation2("No line info: ${source}", new JavaException());
    }
  }
  String toString() => "Changes for ${source.fullName}";
}
class ChangeSet {
  final List<Source> addedSources = new List<Source>();
  final List<Source> changedSources = new List<Source>();
  A_p.HashMap<Source, String> _changedContent = new A_p.HashMap<Source,String>();
  final A_p.HashMap<Source, ChangeSet_ContentChange> changedRanges = new A_p.HashMap<Source,ChangeSet_ContentChange>();
  final List<Source> removedSources = new List<Source>();
  final List<SourceContainer> removedContainers = new List<SourceContainer>();
  final List<Source> deletedSources = new List<Source>();
  void addedSource(Source A_source) {
    addedSources.add(A_source);
  }
  void changedSource(Source A_source) {
    changedSources.add(A_source);
  }
  Map<Source, String> get changedContents => _changedContent;
  bool get isEmpty => addedSources.isEmpty && changedSources.isEmpty && _changedContent.isEmpty && changedRanges.isEmpty && removedSources.isEmpty && removedContainers.isEmpty && deletedSources.isEmpty;
  void removedSource(Source A_source) {
    if (A_source != null) {
      removedSources.add(A_source);
    }
  }
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    bool needsSeparator = _appendSources(A_builder, addedSources, false, "addedSources");
    needsSeparator = _appendSources(A_builder, changedSources, needsSeparator, "changedSources");
    needsSeparator = _appendSources2(A_builder, _changedContent, needsSeparator, "changedContent");
    needsSeparator = _appendSources2(A_builder, changedRanges, needsSeparator, "changedRanges");
    needsSeparator = _appendSources(A_builder, deletedSources, needsSeparator, "deletedSources");
    needsSeparator = _appendSources(A_builder, removedSources, needsSeparator, "removedSources");
    int count = removedContainers.length;
    if (count > 0) {
      if (removedSources.isEmpty) {
        if (needsSeparator) {
          A_builder.append("; ");
        }
        A_builder.append("removed: from ");
        A_builder.append(count);
        A_builder.append(" containers");
      } else {
        A_builder.append(", and more from ");
        A_builder.append(count);
        A_builder.append(" containers");
      }
    }
    return A_builder.toString();
  }
  bool _appendSources(JavaStringBuilder A_builder, List<Source> sources, bool needsSeparator, String label) {
    if (sources.isEmpty) {
      return needsSeparator;
    }
    if (needsSeparator) {
      A_builder.append("; ");
    }
    A_builder.append(label);
    String prefix = " ";
    for (Source A_source in sources) {
      A_builder.append(prefix);
      A_builder.append(A_source.fullName);
      prefix = ", ";
    }
    return true;
  }
  bool _appendSources2(JavaStringBuilder A_builder, A_p.HashMap<Source, dynamic> sources, bool needsSeparator, String label) {
    if (sources.isEmpty) {
      return needsSeparator;
    }
    if (needsSeparator) {
      A_builder.append("; ");
    }
    A_builder.append(label);
    String prefix = " ";
    for (Source A_source in sources.keys.toSet()) {
      A_builder.append(prefix);
      A_builder.append(A_source.fullName);
      prefix = ", ";
    }
    return true;
  }
}
class ChangeSet_ContentChange {}
class CycleBuilder_LibraryPair {
  ResolvableLibrary library;
  List<CycleBuilder_SourceEntryPair> entryPairs;
  CycleBuilder_LibraryPair(ResolvableLibrary A_library, List<CycleBuilder_SourceEntryPair> A_entryPairs) {
    this.library = A_library;
    this.entryPairs = A_entryPairs;
  }
}
class CycleBuilder_SourceEntryPair {
  Source source;
  DartEntry entry;
  CycleBuilder_SourceEntryPair(Source A_source, DartEntry A_entry) {
    this.source = A_source;
    this.entry = A_entry;
  }
}
abstract class DartEntry implements SourceEntry {
  static final DataDescriptor<List<A_AnalysisError>> ANGULAR_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.ANGULAR_ERRORS");
  static final DataDescriptor<List<A_AnalysisError>> BUILD_ELEMENT_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.BUILD_ELEMENT_ERRORS");
  static final DataDescriptor<CompilationUnit> BUILT_UNIT = new DataDescriptor<CompilationUnit>("DartEntry.BUILT_UNIT");
  static final DataDescriptor<List<Source>> CONTAINING_LIBRARIES = new DataDescriptor<List<Source>>("DartEntry.CONTAINING_LIBRARIES");
  static final DataDescriptor<LibraryElement> B_ELEMENT = new DataDescriptor<LibraryElement>("DartEntry.ELEMENT");
  static final DataDescriptor<List<Source>> EXPORTED_LIBRARIES = new DataDescriptor<List<Source>>("DartEntry.EXPORTED_LIBRARIES");
  static final DataDescriptor<List<A_AnalysisError>> HINTS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.HINTS");
  static final DataDescriptor<List<Source>> IMPORTED_LIBRARIES = new DataDescriptor<List<Source>>("DartEntry.IMPORTED_LIBRARIES");
  static final DataDescriptor<List<Source>> INCLUDED_PARTS = new DataDescriptor<List<Source>>("DartEntry.INCLUDED_PARTS");
  static final DataDescriptor<bool> IS_CLIENT = new DataDescriptor<bool>("DartEntry.IS_CLIENT");
  static final DataDescriptor<bool> IS_LAUNCHABLE = new DataDescriptor<bool>("DartEntry.IS_LAUNCHABLE");
  static final DataDescriptor<List<A_AnalysisError>> PARSE_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.PARSE_ERRORS");
  static final DataDescriptor<CompilationUnit> PARSED_UNIT = new DataDescriptor<CompilationUnit>("DartEntry.PARSED_UNIT");
  static final DataDescriptor<Namespace> PUBLIC_NAMESPACE = new DataDescriptor<Namespace>("DartEntry.PUBLIC_NAMESPACE");
  static final DataDescriptor<List<A_AnalysisError>> RESOLUTION_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.RESOLUTION_ERRORS");
  static final DataDescriptor<CompilationUnit> RESOLVED_UNIT = new DataDescriptor<CompilationUnit>("DartEntry.RESOLVED_UNIT");
  static final DataDescriptor<List<A_AnalysisError>> SCAN_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.SCAN_ERRORS");
  static final DataDescriptor<SourceKind> SOURCE_KIND = new DataDescriptor<SourceKind>("DartEntry.SOURCE_KIND");
  static final DataDescriptor<A_Token> TOKEN_STREAM = new DataDescriptor<A_Token>("DartEntry.TOKEN_STREAM");
  static final DataDescriptor<List<A_AnalysisError>> VERIFICATION_ERRORS = new DataDescriptor<List<A_AnalysisError>>("DartEntry.VERIFICATION_ERRORS");
  List<A_AnalysisError> get allErrors;
  CompilationUnit get anyParsedCompilationUnit;
  CompilationUnit get anyResolvedCompilationUnit;
  CacheState getStateInLibrary(DataDescriptor descriptor, Source librarySource);
  Object getValueInLibrary(DataDescriptor descriptor, Source librarySource);
  DartEntryImpl get writableCopy;
  bool hasInvalidData(DataDescriptor descriptor);
  bool get hasResolvableCompilationUnit;
}
class DartEntryImpl extends SourceEntryImpl implements DartEntry {
  CacheState _tokenStreamState = CacheState.INVALID;
  A_Token _tokenStream;
  CacheState _scanErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _scanErrors = A_AnalysisError.NO_ERRORS;
  CacheState _sourceKindState = CacheState.INVALID;
  SourceKind _sourceKind = SourceKind.D_UNKNOWN;
  CacheState _parsedUnitState = CacheState.INVALID;
  bool _parsedUnitAccessed = false;
  CompilationUnit _parsedUnit;
  CacheState _parseErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _parseErrors = A_AnalysisError.NO_ERRORS;
  CacheState _importedLibrariesState = CacheState.INVALID;
  List<Source> A__importedLibraries = Source.F_EMPTY_ARRAY;
  CacheState _exportedLibrariesState = CacheState.INVALID;
  List<Source> _exportedLibraries = Source.F_EMPTY_ARRAY;
  CacheState _includedPartsState = CacheState.INVALID;
  List<Source> _includedParts = Source.F_EMPTY_ARRAY;
  List<Source> _containingLibraries = new List<Source>();
  DartEntryImpl_ResolutionState _resolutionState = new DartEntryImpl_ResolutionState();
  CacheState _elementState = CacheState.INVALID;
  LibraryElement F__element;
  CacheState _publicNamespaceState = CacheState.INVALID;
  Namespace _publicNamespace;
  CacheState _clientServerState = CacheState.INVALID;
  CacheState _launchableState = CacheState.INVALID;
  List<A_AnalysisError> _angularErrors = A_AnalysisError.NO_ERRORS;
  static int _LAUNCHABLE_INDEX = 1;
  static int _CLIENT_CODE_INDEX = 2;
  void addContainingLibrary(Source librarySource) {
    _containingLibraries.add(librarySource);
  }
  void flushAstStructures() {
    if (_tokenStreamState == CacheState.VALID) {
      _tokenStreamState = CacheState.FLUSHED;
      _tokenStream = null;
    }
    if (_parsedUnitState == CacheState.VALID) {
      _parsedUnitState = CacheState.FLUSHED;
      _parsedUnitAccessed = false;
      _parsedUnit = null;
    }
    _resolutionState.flushAstStructures();
  }
  List<A_AnalysisError> get allErrors {
    List<A_AnalysisError> B_errors = new List<A_AnalysisError>();
    ListUtilities.A_addAll(B_errors, _scanErrors);
    ListUtilities.A_addAll(B_errors, _parseErrors);
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      ListUtilities.A_addAll(B_errors, state._buildElementErrors);
      ListUtilities.A_addAll(B_errors, state._resolutionErrors);
      ListUtilities.A_addAll(B_errors, state._verificationErrors);
      ListUtilities.A_addAll(B_errors, state._hints);
      state = state._nextState;
    }
    ListUtilities.A_addAll(B_errors, _angularErrors);
    if (B_errors.length == 0) {
      return A_AnalysisError.NO_ERRORS;
    }
    return new List.from(B_errors);
  }
  CompilationUnit get anyParsedCompilationUnit {
    if (_parsedUnitState == CacheState.VALID) {
      _parsedUnitAccessed = true;
      return _parsedUnit;
    }
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (state._builtUnitState == CacheState.VALID) {
        return state._builtUnit;
      }
      state = state._nextState;
    }
    ;
    return anyResolvedCompilationUnit;
  }
  CompilationUnit get anyResolvedCompilationUnit {
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (state._resolvedUnitState == CacheState.VALID) {
        return state._resolvedUnit;
      }
      state = state._nextState;
    }
    ;
    return null;
  }
  List<Source> get containingLibraries => _containingLibraries;
  SourceKind get kind => _sourceKind;
  List<Source> get librariesContaining {
    DartEntryImpl_ResolutionState state = _resolutionState;
    List<Source> result = new List<Source>();
    while (state != null) {
      if (state._librarySource != null) {
        result.add(state._librarySource);
      }
      state = state._nextState;
    }
    return new List.from(result);
  }
  CompilationUnit get resolvableCompilationUnit {
    if (_parsedUnitState == CacheState.VALID) {
      if (_parsedUnitAccessed) {
        return _parsedUnit.accept(new AstCloner()) as CompilationUnit;
      }
      CompilationUnit unit = _parsedUnit;
      _parsedUnitState = CacheState.FLUSHED;
      _parsedUnitAccessed = false;
      _parsedUnit = null;
      return unit;
    }
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (state._builtUnitState == CacheState.VALID) {
        return state._builtUnit.accept(new AstCloner()) as CompilationUnit;
      }
      if (state._resolvedUnitState == CacheState.VALID) {
        return state._resolvedUnit.accept(new AstCloner()) as CompilationUnit;
      }
      state = state._nextState;
    }
    ;
    return null;
  }
  CacheState getState(DataDescriptor descriptor) {
    if (identical(descriptor, DartEntry.B_ELEMENT)) {
      return _elementState;
    } else if (identical(descriptor, DartEntry.EXPORTED_LIBRARIES)) {
      return _exportedLibrariesState;
    } else if (identical(descriptor, DartEntry.IMPORTED_LIBRARIES)) {
      return _importedLibrariesState;
    } else if (identical(descriptor, DartEntry.INCLUDED_PARTS)) {
      return _includedPartsState;
    } else if (identical(descriptor, DartEntry.IS_CLIENT)) {
      return _clientServerState;
    } else if (identical(descriptor, DartEntry.IS_LAUNCHABLE)) {
      return _launchableState;
    } else if (identical(descriptor, DartEntry.PARSE_ERRORS)) {
      return _parseErrorsState;
    } else if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      return _parsedUnitState;
    } else if (identical(descriptor, DartEntry.PUBLIC_NAMESPACE)) {
      return _publicNamespaceState;
    } else if (identical(descriptor, DartEntry.SCAN_ERRORS)) {
      return _scanErrorsState;
    } else if (identical(descriptor, DartEntry.SOURCE_KIND)) {
      return _sourceKindState;
    } else if (identical(descriptor, DartEntry.TOKEN_STREAM)) {
      return _tokenStreamState;
    } else {
      return super.getState(descriptor);
    }
  }
  CacheState getStateInLibrary(DataDescriptor descriptor, Source librarySource) {
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (librarySource == state._librarySource) {
        if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS)) {
          return state._buildElementErrorsState;
        } else if (identical(descriptor, DartEntry.BUILT_UNIT)) {
          return state._builtUnitState;
        } else if (identical(descriptor, DartEntry.RESOLUTION_ERRORS)) {
          return state._resolutionErrorsState;
        } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
          return state._resolvedUnitState;
        } else if (identical(descriptor, DartEntry.VERIFICATION_ERRORS)) {
          return state._verificationErrorsState;
        } else if (identical(descriptor, DartEntry.HINTS)) {
          return state._hintsState;
        } else {
          throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
        }
      }
      state = state._nextState;
    }
    ;
    if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS) || identical(descriptor, DartEntry.BUILT_UNIT) || identical(descriptor, DartEntry.RESOLUTION_ERRORS) || identical(descriptor, DartEntry.RESOLVED_UNIT) || identical(descriptor, DartEntry.VERIFICATION_ERRORS) || identical(descriptor, DartEntry.HINTS)) {
      return CacheState.INVALID;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  Object getValue(DataDescriptor descriptor) {
    if (identical(descriptor, DartEntry.ANGULAR_ERRORS)) {
      return _angularErrors;
    } else if (identical(descriptor, DartEntry.CONTAINING_LIBRARIES)) {
      return new List.from(_containingLibraries);
    } else if (identical(descriptor, DartEntry.B_ELEMENT)) {
      return F__element;
    } else if (identical(descriptor, DartEntry.EXPORTED_LIBRARIES)) {
      return _exportedLibraries;
    } else if (identical(descriptor, DartEntry.IMPORTED_LIBRARIES)) {
      return A__importedLibraries;
    } else if (identical(descriptor, DartEntry.INCLUDED_PARTS)) {
      return _includedParts;
    } else if (identical(descriptor, DartEntry.IS_CLIENT)) {
      return getFlag(_CLIENT_CODE_INDEX);
    } else if (identical(descriptor, DartEntry.IS_LAUNCHABLE)) {
      return getFlag(_LAUNCHABLE_INDEX);
    } else if (identical(descriptor, DartEntry.PARSE_ERRORS)) {
      return _parseErrors;
    } else if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      _parsedUnitAccessed = true;
      return _parsedUnit;
    } else if (identical(descriptor, DartEntry.PUBLIC_NAMESPACE)) {
      return _publicNamespace;
    } else if (identical(descriptor, DartEntry.SCAN_ERRORS)) {
      return _scanErrors;
    } else if (identical(descriptor, DartEntry.SOURCE_KIND)) {
      return _sourceKind;
    } else if (identical(descriptor, DartEntry.TOKEN_STREAM)) {
      return _tokenStream;
    }
    return super.getValue(descriptor);
  }
  Object getValueInLibrary(DataDescriptor descriptor, Source librarySource) {
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (librarySource == state._librarySource) {
        if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS)) {
          return state._buildElementErrors;
        } else if (identical(descriptor, DartEntry.BUILT_UNIT)) {
          return state._builtUnit;
        } else if (identical(descriptor, DartEntry.RESOLUTION_ERRORS)) {
          return state._resolutionErrors;
        } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
          return state._resolvedUnit;
        } else if (identical(descriptor, DartEntry.VERIFICATION_ERRORS)) {
          return state._verificationErrors;
        } else if (identical(descriptor, DartEntry.HINTS)) {
          return state._hints;
        } else {
          throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
        }
      }
      state = state._nextState;
    }
    ;
    if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS) || identical(descriptor, DartEntry.RESOLUTION_ERRORS) || identical(descriptor, DartEntry.VERIFICATION_ERRORS) || identical(descriptor, DartEntry.HINTS)) {
      return A_AnalysisError.NO_ERRORS;
    } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
      return null;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  DartEntryImpl get writableCopy {
    DartEntryImpl A_copy = new DartEntryImpl();
    A_copy.copyFrom(this);
    return A_copy;
  }
  bool hasInvalidData(DataDescriptor descriptor) {
    if (identical(descriptor, DartEntry.B_ELEMENT)) {
      return _elementState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.EXPORTED_LIBRARIES)) {
      return _exportedLibrariesState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.IMPORTED_LIBRARIES)) {
      return _importedLibrariesState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.INCLUDED_PARTS)) {
      return _includedPartsState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.IS_CLIENT)) {
      return _clientServerState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.IS_LAUNCHABLE)) {
      return _launchableState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.PARSE_ERRORS)) {
      return _parseErrorsState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      return _parsedUnitState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.PUBLIC_NAMESPACE)) {
      return _publicNamespaceState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.SCAN_ERRORS)) {
      return _scanErrorsState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.SOURCE_KIND)) {
      return _sourceKindState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.TOKEN_STREAM)) {
      return _tokenStreamState == CacheState.INVALID;
    } else if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS) || identical(descriptor, DartEntry.BUILT_UNIT) || identical(descriptor, DartEntry.RESOLUTION_ERRORS) || identical(descriptor, DartEntry.RESOLVED_UNIT) || identical(descriptor, DartEntry.VERIFICATION_ERRORS) || identical(descriptor, DartEntry.HINTS)) {
      DartEntryImpl_ResolutionState state = _resolutionState;
      while (state != null) {
        if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS)) {
          return state._buildElementErrorsState == CacheState.INVALID;
        } else if (identical(descriptor, DartEntry.BUILT_UNIT)) {
          return state._builtUnitState == CacheState.INVALID;
        } else if (identical(descriptor, DartEntry.RESOLUTION_ERRORS)) {
          return state._resolutionErrorsState == CacheState.INVALID;
        } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
          return state._resolvedUnitState == CacheState.INVALID;
        } else if (identical(descriptor, DartEntry.VERIFICATION_ERRORS)) {
          return state._verificationErrorsState == CacheState.INVALID;
        } else if (identical(descriptor, DartEntry.HINTS)) {
          return state._hintsState == CacheState.INVALID;
        }
      }
      return false;
    } else {
      return super.getState(descriptor) == CacheState.INVALID;
    }
  }
  bool get hasResolvableCompilationUnit {
    if (_parsedUnitState == CacheState.VALID) {
      return true;
    }
    DartEntryImpl_ResolutionState state = _resolutionState;
    while (state != null) {
      if (state._builtUnitState == CacheState.VALID || state._resolvedUnitState == CacheState.VALID) {
        return true;
      }
      state = state._nextState;
    }
    ;
    return false;
  }
  void invalidateAllInformation() {
    super.invalidateAllInformation();
    _scanErrors = A_AnalysisError.NO_ERRORS;
    _scanErrorsState = CacheState.INVALID;
    _tokenStream = null;
    _tokenStreamState = CacheState.INVALID;
    _sourceKind = SourceKind.D_UNKNOWN;
    _sourceKindState = CacheState.INVALID;
    _parseErrors = A_AnalysisError.NO_ERRORS;
    _parseErrorsState = CacheState.INVALID;
    _parsedUnit = null;
    _parsedUnitAccessed = false;
    _parsedUnitState = CacheState.INVALID;
    _discardCachedResolutionInformation(true);
  }
  void invalidateAllResolutionInformation(bool invalidateUris) {
    if (_parsedUnitState == CacheState.FLUSHED) {
      DartEntryImpl_ResolutionState state = _resolutionState;
      while (state != null) {
        if (state._builtUnitState == CacheState.VALID) {
          _parsedUnit = state._builtUnit;
          _parsedUnitAccessed = true;
          _parsedUnitState = CacheState.VALID;
          break;
        } else if (state._resolvedUnitState == CacheState.VALID) {
          _parsedUnit = state._resolvedUnit;
          _parsedUnitAccessed = true;
          _parsedUnitState = CacheState.VALID;
          break;
        }
        state = state._nextState;
      }
    }
    _discardCachedResolutionInformation(invalidateUris);
  }
  void recordContentError(CaughtException exception) {
    super.recordContentError(exception);
    recordScanError(exception);
  }
  void recordHintErrorInLibrary(Source librarySource, CaughtException exception) {
    this.exception = exception;
    DartEntryImpl_ResolutionState state = _getOrCreateResolutionState(librarySource);
    state.recordHintError();
  }
  void recordParseError(CaughtException exception) {
    _sourceKind = SourceKind.D_UNKNOWN;
    _sourceKindState = CacheState.C_ERROR;
    _parseErrors = A_AnalysisError.NO_ERRORS;
    _parseErrorsState = CacheState.C_ERROR;
    _parsedUnit = null;
    _parsedUnitAccessed = false;
    _parsedUnitState = CacheState.C_ERROR;
    _exportedLibraries = Source.F_EMPTY_ARRAY;
    _exportedLibrariesState = CacheState.C_ERROR;
    A__importedLibraries = Source.F_EMPTY_ARRAY;
    _importedLibrariesState = CacheState.C_ERROR;
    _includedParts = Source.F_EMPTY_ARRAY;
    _includedPartsState = CacheState.C_ERROR;
    recordResolutionError(exception);
  }
  void recordResolutionError(CaughtException exception) {
    this.exception = exception;
    F__element = null;
    _elementState = CacheState.C_ERROR;
    clearFlags([_LAUNCHABLE_INDEX, _CLIENT_CODE_INDEX]);
    _clientServerState = CacheState.C_ERROR;
    _launchableState = CacheState.C_ERROR;
    _publicNamespace = null;
    _publicNamespaceState = CacheState.C_ERROR;
    _resolutionState.recordResolutionErrorsInAllLibraries();
  }
  void recordResolutionErrorInLibrary(Source librarySource, CaughtException exception) {
    this.exception = exception;
    F__element = null;
    _elementState = CacheState.C_ERROR;
    clearFlags([_LAUNCHABLE_INDEX, _CLIENT_CODE_INDEX]);
    _clientServerState = CacheState.C_ERROR;
    _launchableState = CacheState.C_ERROR;
    _publicNamespace = null;
    _publicNamespaceState = CacheState.C_ERROR;
    DartEntryImpl_ResolutionState state = _getOrCreateResolutionState(librarySource);
    state.recordResolutionError();
  }
  void recordResolutionNotInProcess() {
    if (_elementState == CacheState.IN_PROCESS) {
      _elementState = CacheState.INVALID;
    }
    if (_clientServerState == CacheState.IN_PROCESS) {
      _clientServerState = CacheState.INVALID;
    }
    if (_launchableState == CacheState.IN_PROCESS) {
      _launchableState = CacheState.INVALID;
    }
    if (_publicNamespaceState == CacheState.IN_PROCESS) {
      _publicNamespaceState = CacheState.INVALID;
    }
    _resolutionState.recordResolutionNotInProcess();
  }
  void recordScanError(CaughtException exception) {
    super.recordScanError(exception);
    _scanErrors = A_AnalysisError.NO_ERRORS;
    _scanErrorsState = CacheState.C_ERROR;
    _tokenStream = null;
    _tokenStreamState = CacheState.C_ERROR;
    recordParseError(exception);
  }
  void recordVerificationErrorInLibrary(Source librarySource, CaughtException exception) {
    this.exception = exception;
    DartEntryImpl_ResolutionState state = _getOrCreateResolutionState(librarySource);
    state.recordVerificationError();
  }
  void removeContainingLibrary(Source librarySource) {
    _containingLibraries.remove(librarySource);
  }
  void set containingLibrary(Source librarySource) {
    _containingLibraries.clear();
    _containingLibraries.add(librarySource);
  }
  void setState(DataDescriptor descriptor, CacheState state) {
    if (identical(descriptor, DartEntry.B_ELEMENT)) {
      F__element = updatedValue(state, F__element, null);
      _elementState = state;
    } else if (identical(descriptor, DartEntry.EXPORTED_LIBRARIES)) {
      _exportedLibraries = updatedValue(state, _exportedLibraries, Source.F_EMPTY_ARRAY);
      _exportedLibrariesState = state;
    } else if (identical(descriptor, DartEntry.IMPORTED_LIBRARIES)) {
      A__importedLibraries = updatedValue(state, A__importedLibraries, Source.F_EMPTY_ARRAY);
      _importedLibrariesState = state;
    } else if (identical(descriptor, DartEntry.INCLUDED_PARTS)) {
      _includedParts = updatedValue(state, _includedParts, Source.F_EMPTY_ARRAY);
      _includedPartsState = state;
    } else if (identical(descriptor, DartEntry.IS_CLIENT)) {
      _updateValueOfFlag(_CLIENT_CODE_INDEX, state);
      _clientServerState = state;
    } else if (identical(descriptor, DartEntry.IS_LAUNCHABLE)) {
      _updateValueOfFlag(_LAUNCHABLE_INDEX, state);
      _launchableState = state;
    } else if (identical(descriptor, DartEntry.PARSE_ERRORS)) {
      _parseErrors = updatedValue(state, _parseErrors, A_AnalysisError.NO_ERRORS);
      _parseErrorsState = state;
    } else if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      CompilationUnit newUnit = updatedValue(state, _parsedUnit, null);
      if (!identical(newUnit, _parsedUnit)) {
        _parsedUnitAccessed = false;
      }
      _parsedUnit = newUnit;
      _parsedUnitState = state;
    } else if (identical(descriptor, DartEntry.PUBLIC_NAMESPACE)) {
      _publicNamespace = updatedValue(state, _publicNamespace, null);
      _publicNamespaceState = state;
    } else if (identical(descriptor, DartEntry.SCAN_ERRORS)) {
      _scanErrors = updatedValue(state, _scanErrors, A_AnalysisError.NO_ERRORS);
      _scanErrorsState = state;
    } else if (identical(descriptor, DartEntry.SOURCE_KIND)) {
      _sourceKind = updatedValue(state, _sourceKind, SourceKind.D_UNKNOWN);
      _sourceKindState = state;
    } else if (identical(descriptor, DartEntry.TOKEN_STREAM)) {
      _tokenStream = updatedValue(state, _tokenStream, null);
      _tokenStreamState = state;
    } else {
      super.setState(descriptor, state);
    }
  }
  void setStateInLibrary(DataDescriptor descriptor, Source librarySource, CacheState cacheState) {
    DartEntryImpl_ResolutionState state = _getOrCreateResolutionState(librarySource);
    if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS)) {
      state._buildElementErrors = updatedValue(cacheState, state._buildElementErrors, A_AnalysisError.NO_ERRORS);
      state._buildElementErrorsState = cacheState;
    } else if (identical(descriptor, DartEntry.BUILT_UNIT)) {
      state._builtUnit = updatedValue(cacheState, state._builtUnit, null);
      state._builtUnitState = cacheState;
    } else if (identical(descriptor, DartEntry.RESOLUTION_ERRORS)) {
      state._resolutionErrors = updatedValue(cacheState, state._resolutionErrors, A_AnalysisError.NO_ERRORS);
      state._resolutionErrorsState = cacheState;
    } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
      state._resolvedUnit = updatedValue(cacheState, state._resolvedUnit, null);
      state._resolvedUnitState = cacheState;
    } else if (identical(descriptor, DartEntry.VERIFICATION_ERRORS)) {
      state._verificationErrors = updatedValue(cacheState, state._verificationErrors, A_AnalysisError.NO_ERRORS);
      state._verificationErrorsState = cacheState;
    } else if (identical(descriptor, DartEntry.HINTS)) {
      state._hints = updatedValue(cacheState, state._hints, A_AnalysisError.NO_ERRORS);
      state._hintsState = cacheState;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  void setValue(DataDescriptor descriptor, Object A_value) {
    if (identical(descriptor, DartEntry.ANGULAR_ERRORS)) {
      _angularErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
    } else if (identical(descriptor, DartEntry.B_ELEMENT)) {
      F__element = A_value as LibraryElement;
      _elementState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.EXPORTED_LIBRARIES)) {
      _exportedLibraries = A_value == null ? Source.F_EMPTY_ARRAY : (A_value as List<Source>);
      _exportedLibrariesState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.IMPORTED_LIBRARIES)) {
      A__importedLibraries = A_value == null ? Source.F_EMPTY_ARRAY : (A_value as List<Source>);
      _importedLibrariesState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.INCLUDED_PARTS)) {
      _includedParts = A_value == null ? Source.F_EMPTY_ARRAY : (A_value as List<Source>);
      _includedPartsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.IS_CLIENT)) {
      setFlag(_CLIENT_CODE_INDEX, A_value as bool);
      _clientServerState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.IS_LAUNCHABLE)) {
      setFlag(_LAUNCHABLE_INDEX, A_value as bool);
      _launchableState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.PARSE_ERRORS)) {
      _parseErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      _parseErrorsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.PARSED_UNIT)) {
      _parsedUnit = A_value as CompilationUnit;
      _parsedUnitAccessed = false;
      _parsedUnitState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.PUBLIC_NAMESPACE)) {
      _publicNamespace = A_value as Namespace;
      _publicNamespaceState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.SCAN_ERRORS)) {
      _scanErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      _scanErrorsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.SOURCE_KIND)) {
      _sourceKind = A_value as SourceKind;
      _sourceKindState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.TOKEN_STREAM)) {
      _tokenStream = A_value as A_Token;
      _tokenStreamState = CacheState.VALID;
    } else {
      super.setValue(descriptor, A_value);
    }
  }
  void setValueInLibrary(DataDescriptor descriptor, Source librarySource, Object A_value) {
    DartEntryImpl_ResolutionState state = _getOrCreateResolutionState(librarySource);
    if (identical(descriptor, DartEntry.BUILD_ELEMENT_ERRORS)) {
      state._buildElementErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      state._buildElementErrorsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.BUILT_UNIT)) {
      state._builtUnit = A_value as CompilationUnit;
      state._builtUnitState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.RESOLUTION_ERRORS)) {
      state._resolutionErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      state._resolutionErrorsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.RESOLVED_UNIT)) {
      state._resolvedUnit = A_value as CompilationUnit;
      state._resolvedUnitState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.VERIFICATION_ERRORS)) {
      state._verificationErrors = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      state._verificationErrorsState = CacheState.VALID;
    } else if (identical(descriptor, DartEntry.HINTS)) {
      state._hints = A_value == null ? A_AnalysisError.NO_ERRORS : (A_value as List<A_AnalysisError>);
      state._hintsState = CacheState.VALID;
    }
  }
  void copyFrom(SourceEntryImpl A_entry) {
    super.copyFrom(A_entry);
    DartEntryImpl other = A_entry as DartEntryImpl;
    _scanErrorsState = other._scanErrorsState;
    _scanErrors = other._scanErrors;
    _tokenStreamState = other._tokenStreamState;
    _tokenStream = other._tokenStream;
    _sourceKindState = other._sourceKindState;
    _sourceKind = other._sourceKind;
    _parsedUnitState = other._parsedUnitState;
    _parsedUnit = other._parsedUnit;
    _parsedUnitAccessed = other._parsedUnitAccessed;
    _parseErrorsState = other._parseErrorsState;
    _parseErrors = other._parseErrors;
    _includedPartsState = other._includedPartsState;
    _includedParts = other._includedParts;
    _exportedLibrariesState = other._exportedLibrariesState;
    _exportedLibraries = other._exportedLibraries;
    _importedLibrariesState = other._importedLibrariesState;
    A__importedLibraries = other.A__importedLibraries;
    _containingLibraries = new List<Source>.from(other._containingLibraries);
    _resolutionState.copyFrom(other._resolutionState);
    _elementState = other._elementState;
    F__element = other.F__element;
    _publicNamespaceState = other._publicNamespaceState;
    _publicNamespace = other._publicNamespace;
    _clientServerState = other._clientServerState;
    _launchableState = other._launchableState;
    _angularErrors = other._angularErrors;
  }
  bool get hasErrorState => super.hasErrorState || _scanErrorsState == CacheState.C_ERROR || _tokenStreamState == CacheState.C_ERROR || _sourceKindState == CacheState.C_ERROR || _parsedUnitState == CacheState.C_ERROR || _parseErrorsState == CacheState.C_ERROR || _importedLibrariesState == CacheState.C_ERROR || _exportedLibrariesState == CacheState.C_ERROR || _includedPartsState == CacheState.C_ERROR || _elementState == CacheState.C_ERROR || _publicNamespaceState == CacheState.C_ERROR || _clientServerState == CacheState.C_ERROR || _launchableState == CacheState.C_ERROR || _resolutionState.hasErrorState;
  bool writeDiffOn(JavaStringBuilder A_builder, SourceEntry oldEntry) {
    bool needsSeparator = super.writeDiffOn(A_builder, oldEntry);
    if (oldEntry is! DartEntryImpl) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append("entry type changed; was ${oldEntry.runtimeType.toString()}");
      return true;
    }
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.TOKEN_STREAM, "tokenStream");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.SCAN_ERRORS, "scanErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.SOURCE_KIND, "sourceKind");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.PARSED_UNIT, "parsedUnit");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.PARSE_ERRORS, "parseErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.IMPORTED_LIBRARIES, "importedLibraries");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.EXPORTED_LIBRARIES, "exportedLibraries");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.INCLUDED_PARTS, "includedParts");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.B_ELEMENT, "element");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.PUBLIC_NAMESPACE, "publicNamespace");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.IS_CLIENT, "clientServer");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.IS_LAUNCHABLE, "launchable");
    int oldLibraryCount = (oldEntry as DartEntryImpl)._containingLibraries.length;
    int libraryCount = _containingLibraries.length;
    if (oldLibraryCount != libraryCount) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append("containingLibraryCount = ");
      A_builder.append(oldLibraryCount);
      A_builder.append(" -> ");
      A_builder.append(libraryCount);
      needsSeparator = true;
    }
    A_p.HashMap<Source, DartEntryImpl_ResolutionState> oldStateMap = new A_p.HashMap<Source,DartEntryImpl_ResolutionState>();
    DartEntryImpl_ResolutionState state = (oldEntry as DartEntryImpl)._resolutionState;
    while (state != null) {
      Source librarySource = state._librarySource;
      if (librarySource != null) {
        oldStateMap[librarySource] = state;
      }
      state = state._nextState;
    }
    state = _resolutionState;
    while (state != null) {
      Source librarySource = state._librarySource;
      if (librarySource != null) {
        DartEntryImpl_ResolutionState oldState = oldStateMap.remove(librarySource);
        if (oldState == null) {
          if (needsSeparator) {
            A_builder.append("; ");
          }
          A_builder.append("added resolution for ");
          A_builder.append(librarySource.fullName);
          needsSeparator = true;
        } else {
          needsSeparator = oldState.writeDiffOn(A_builder, needsSeparator, oldEntry as DartEntry);
        }
      }
      state = state._nextState;
    }
    for (Source librarySource in oldStateMap.keys.toSet()) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append("removed resolution for ");
      A_builder.append(librarySource.fullName);
      needsSeparator = true;
    }
    return needsSeparator;
  }
  void writeOn(JavaStringBuilder A_builder) {
    A_builder.append("Dart: ");
    super.writeOn(A_builder);
    A_builder.append("; tokenStream = ");
    A_builder.append(_tokenStreamState);
    A_builder.append("; scanErrors = ");
    A_builder.append(_scanErrorsState);
    A_builder.append("; sourceKind = ");
    A_builder.append(_sourceKindState);
    A_builder.append("; parsedUnit = ");
    A_builder.append(_parsedUnitState);
    A_builder.append(" (");
    A_builder.append(_parsedUnitAccessed ? "T" : "F");
    A_builder.append("); parseErrors = ");
    A_builder.append(_parseErrorsState);
    A_builder.append("; exportedLibraries = ");
    A_builder.append(_exportedLibrariesState);
    A_builder.append("; importedLibraries = ");
    A_builder.append(_importedLibrariesState);
    A_builder.append("; includedParts = ");
    A_builder.append(_includedPartsState);
    A_builder.append("; element = ");
    A_builder.append(_elementState);
    A_builder.append("; publicNamespace = ");
    A_builder.append(_publicNamespaceState);
    A_builder.append("; clientServer = ");
    A_builder.append(_clientServerState);
    A_builder.append("; launchable = ");
    A_builder.append(_launchableState);
    _resolutionState.writeOn(A_builder);
  }
  void _discardCachedResolutionInformation(bool invalidateUris) {
    F__element = null;
    _elementState = CacheState.INVALID;
    clearFlags([_LAUNCHABLE_INDEX, _CLIENT_CODE_INDEX]);
    _clientServerState = CacheState.INVALID;
    _launchableState = CacheState.INVALID;
    _publicNamespace = null;
    _publicNamespaceState = CacheState.INVALID;
    _resolutionState.invalidateAllResolutionInformation();
    if (invalidateUris) {
      A__importedLibraries = Source.F_EMPTY_ARRAY;
      _importedLibrariesState = CacheState.INVALID;
      _exportedLibraries = Source.F_EMPTY_ARRAY;
      _exportedLibrariesState = CacheState.INVALID;
      _includedParts = Source.F_EMPTY_ARRAY;
      _includedPartsState = CacheState.INVALID;
    }
  }
  DartEntryImpl_ResolutionState _getOrCreateResolutionState(Source librarySource) {
    DartEntryImpl_ResolutionState state = _resolutionState;
    if (state._librarySource == null) {
      state._librarySource = librarySource;
      return state;
    }
    while (state._librarySource != librarySource) {
      if (state._nextState == null) {
        DartEntryImpl_ResolutionState newState = new DartEntryImpl_ResolutionState();
        newState._librarySource = librarySource;
        state._nextState = newState;
        return newState;
      }
      state = state._nextState;
    }
    return state;
  }
  void _updateValueOfFlag(int A_index, CacheState state) {
    if (state == CacheState.VALID) {
      throw new IllegalArgumentException("Use setValue() to set the state to VALID");
    } else if (state != CacheState.IN_PROCESS) {
      setFlag(A_index, false);
    }
  }
}
class DartEntryImpl_ResolutionState {
  DartEntryImpl_ResolutionState _nextState;
  Source _librarySource;
  CacheState _builtUnitState = CacheState.INVALID;
  CompilationUnit _builtUnit;
  CacheState _buildElementErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _buildElementErrors = A_AnalysisError.NO_ERRORS;
  CacheState _resolvedUnitState = CacheState.INVALID;
  CompilationUnit _resolvedUnit;
  CacheState _resolutionErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _resolutionErrors = A_AnalysisError.NO_ERRORS;
  CacheState _verificationErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _verificationErrors = A_AnalysisError.NO_ERRORS;
  CacheState _hintsState = CacheState.INVALID;
  List<A_AnalysisError> _hints = A_AnalysisError.NO_ERRORS;
  void copyFrom(DartEntryImpl_ResolutionState other) {
    _librarySource = other._librarySource;
    _builtUnitState = other._builtUnitState;
    _builtUnit = other._builtUnit;
    _buildElementErrorsState = other._buildElementErrorsState;
    _buildElementErrors = other._buildElementErrors;
    _resolvedUnitState = other._resolvedUnitState;
    _resolvedUnit = other._resolvedUnit;
    _resolutionErrorsState = other._resolutionErrorsState;
    _resolutionErrors = other._resolutionErrors;
    _verificationErrorsState = other._verificationErrorsState;
    _verificationErrors = other._verificationErrors;
    _hintsState = other._hintsState;
    _hints = other._hints;
    if (other._nextState != null) {
      _nextState = new DartEntryImpl_ResolutionState();
      _nextState.copyFrom(other._nextState);
    }
  }
  void flushAstStructures() {
    if (_builtUnitState == CacheState.VALID) {
      _builtUnitState = CacheState.FLUSHED;
      _builtUnit = null;
    }
    if (_resolvedUnitState == CacheState.VALID) {
      _resolvedUnitState = CacheState.FLUSHED;
      _resolvedUnit = null;
    }
    if (_nextState != null) {
      _nextState.flushAstStructures();
    }
  }
  bool get hasErrorState => _builtUnitState == CacheState.C_ERROR || _buildElementErrorsState == CacheState.C_ERROR || _resolvedUnitState == CacheState.C_ERROR || _resolutionErrorsState == CacheState.C_ERROR || _verificationErrorsState == CacheState.C_ERROR || _hintsState == CacheState.C_ERROR || (_nextState != null && _nextState.hasErrorState);
  void invalidateAllResolutionInformation() {
    _nextState = null;
    _librarySource = null;
    _builtUnitState = CacheState.INVALID;
    _builtUnit = null;
    _buildElementErrorsState = CacheState.INVALID;
    _buildElementErrors = A_AnalysisError.NO_ERRORS;
    _resolvedUnitState = CacheState.INVALID;
    _resolvedUnit = null;
    _resolutionErrorsState = CacheState.INVALID;
    _resolutionErrors = A_AnalysisError.NO_ERRORS;
    _verificationErrorsState = CacheState.INVALID;
    _verificationErrors = A_AnalysisError.NO_ERRORS;
    _hintsState = CacheState.INVALID;
    _hints = A_AnalysisError.NO_ERRORS;
  }
  void recordHintError() {
    _hints = A_AnalysisError.NO_ERRORS;
    _hintsState = CacheState.C_ERROR;
  }
  void recordResolutionError() {
    _resolvedUnitState = CacheState.C_ERROR;
    _resolvedUnit = null;
    _resolutionErrorsState = CacheState.C_ERROR;
    _resolutionErrors = A_AnalysisError.NO_ERRORS;
    recordVerificationError();
  }
  void recordResolutionErrorsInAllLibraries() {
    _builtUnitState = CacheState.C_ERROR;
    _builtUnit = null;
    _buildElementErrorsState = CacheState.C_ERROR;
    _buildElementErrors = A_AnalysisError.NO_ERRORS;
    _resolvedUnitState = CacheState.C_ERROR;
    _resolvedUnit = null;
    _resolutionErrorsState = CacheState.C_ERROR;
    _resolutionErrors = A_AnalysisError.NO_ERRORS;
    recordVerificationError();
    if (_nextState != null) {
      _nextState.recordResolutionErrorsInAllLibraries();
    }
  }
  void recordResolutionNotInProcess() {
    if (_resolvedUnitState == CacheState.IN_PROCESS) {
      _resolvedUnitState = CacheState.INVALID;
    }
    if (_resolutionErrorsState == CacheState.IN_PROCESS) {
      _resolutionErrorsState = CacheState.INVALID;
    }
    if (_verificationErrorsState == CacheState.IN_PROCESS) {
      _verificationErrorsState = CacheState.INVALID;
    }
    if (_hintsState == CacheState.IN_PROCESS) {
      _hintsState = CacheState.INVALID;
    }
    if (_nextState != null) {
      _nextState.recordResolutionNotInProcess();
    }
  }
  void recordVerificationError() {
    _verificationErrors = A_AnalysisError.NO_ERRORS;
    _verificationErrorsState = CacheState.C_ERROR;
    recordHintError();
  }
  bool writeDiffOn(JavaStringBuilder A_builder, bool needsSeparator, DartEntry oldEntry) {
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.BUILT_UNIT, _builtUnitState, "builtUnit");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.BUILD_ELEMENT_ERRORS, _buildElementErrorsState, "buildElementErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.RESOLVED_UNIT, _resolvedUnitState, "resolvedUnit");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.RESOLUTION_ERRORS, _resolutionErrorsState, "resolutionErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.VERIFICATION_ERRORS, _verificationErrorsState, "verificationErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, DartEntry.HINTS, _hintsState, "hints");
    return needsSeparator;
  }
  void writeOn(JavaStringBuilder A_builder) {
    if (_librarySource != null) {
      A_builder.append("; builtUnit = ");
      A_builder.append(_builtUnitState);
      A_builder.append("; buildElementErrors = ");
      A_builder.append(_buildElementErrorsState);
      A_builder.append("; resolvedUnit = ");
      A_builder.append(_resolvedUnitState);
      A_builder.append("; resolutionErrors = ");
      A_builder.append(_resolutionErrorsState);
      A_builder.append("; verificationErrors = ");
      A_builder.append(_verificationErrorsState);
      A_builder.append("; hints = ");
      A_builder.append(_hintsState);
      if (_nextState != null) {
        _nextState.writeOn(A_builder);
      }
    }
  }
  bool writeStateDiffOn(JavaStringBuilder A_builder, bool needsSeparator, SourceEntry oldEntry, DataDescriptor descriptor, CacheState newState, String label) {
    CacheState oldState = (oldEntry as DartEntryImpl).getStateInLibrary(descriptor, _librarySource);
    if (oldState != newState) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append(label);
      A_builder.append(" = ");
      A_builder.append(oldState);
      A_builder.append(" -> ");
      A_builder.append(newState);
      return true;
    }
    return needsSeparator;
  }
}
class DataDescriptor<E_E> {
  final String C__name;
  DataDescriptor(this.C__name);
  String toString() => C__name;
}
class DefaultRetentionPolicy implements CacheRetentionPolicy {
  static DefaultRetentionPolicy POLICY = new DefaultRetentionPolicy();
  RetentionPriority getAstPriority(Source A_source, SourceEntry sourceEntry) {
    if (sourceEntry is DartEntry) {
      DartEntry dartEntry = sourceEntry;
      if (astIsNeeded(dartEntry)) {
        return RetentionPriority.MEDIUM;
      }
    }
    return RetentionPriority.A_LOW;
  }
  bool astIsNeeded(DartEntry dartEntry) => dartEntry.hasInvalidData(DartEntry.HINTS) || dartEntry.hasInvalidData(DartEntry.VERIFICATION_ERRORS) || dartEntry.hasInvalidData(DartEntry.RESOLUTION_ERRORS);
}
class GenerateDartErrorsTask extends AnalysisTask {
  static void validateDirectives(AnalysisContext context, Source librarySource, CompilationUnit unit, AnalysisErrorListener errorListener) {
    for (Directive directive in unit.directives) {
      if (directive is UriBasedDirective) {
        validateReferencedSource(context, librarySource, directive, errorListener);
      }
    }
  }
  static void validateReferencedSource(AnalysisContext context, Source librarySource, UriBasedDirective directive, AnalysisErrorListener errorListener) {
    Source A_source = directive.source;
    if (A_source != null) {
      if (context.exists(A_source)) {
        return;
      }
    } else {
      if (directive.validate() != null) {
        return;
      }
    }
    StringLiteral uriLiteral = directive.uri;
    errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.URI_DOES_NOT_EXIST, [directive.uriContent]));
  }
  final Source source;
  final int modificationTime;
  final CompilationUnit F__unit;
  final LibraryElement libraryElement;
  List<A_AnalysisError> A__errors;
  GenerateDartErrorsTask(InternalAnalysisContext context, this.source, this.modificationTime, this.F__unit, this.libraryElement) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitGenerateDartErrorsTask(this);
  List<A_AnalysisError> get errors => A__errors;
  String get taskDescription => "generate errors and warnings for ${source.fullName}";
  void internalPerform() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_errors.start();
    try {
      RecordingErrorListener errorListener = new RecordingErrorListener();
      ErrorReporter errorReporter = new ErrorReporter(errorListener, source);
      TypeProvider typeProvider = context.typeProvider;
      validateDirectives(context, source, F__unit, errorListener);
      ConstantVerifier constantVerifier = new ConstantVerifier(errorReporter, libraryElement, typeProvider);
      F__unit.accept(constantVerifier);
      ErrorVerifier errorVerifier = new ErrorVerifier(errorReporter, libraryElement, typeProvider, new InheritanceManager(libraryElement));
      F__unit.accept(errorVerifier);
      A__errors = errorListener.getErrorsForSource(source);
    } finally {
      timeCounter.stop();
    }
  }
}
class GenerateDartHintsTask extends AnalysisTask {
  final List<TimestampedData<CompilationUnit>> _units;
  final LibraryElement libraryElement;
  A_p.HashMap<Source, TimestampedData<List<A_AnalysisError>>> _hintMap;
  GenerateDartHintsTask(InternalAnalysisContext context, this._units, this.libraryElement) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitGenerateDartHintsTask(this);
  A_p.HashMap<Source, TimestampedData<List<A_AnalysisError>>> get hintMap => _hintMap;
  String get taskDescription {
    Source librarySource = libraryElement.source;
    if (librarySource == null) {
      return "generate Dart hints for library without source";
    }
    return "generate Dart hints for ${librarySource.fullName}";
  }
  void internalPerform() {
    int unitCount = _units.length;
    List<CompilationUnit> compilationUnits = new List<CompilationUnit>(unitCount);
    for (int i = 0; i < unitCount; i++) {
      compilationUnits[i] = _units[i].data;
    }
    RecordingErrorListener errorListener = new RecordingErrorListener();
    HintGenerator hintGenerator = new HintGenerator(compilationUnits, context, errorListener);
    hintGenerator.generateForLibrary();
    _hintMap = new A_p.HashMap<Source,TimestampedData<List<A_AnalysisError>>>();
    for (int i = 0; i < unitCount; i++) {
      int modificationTime = _units[i].modificationTime;
      Source A_source = _units[i].data.element.source;
      List<A_AnalysisError> B_errors = errorListener.getErrorsForSource(A_source);
      _hintMap[A_source] = new TimestampedData<List<A_AnalysisError>>(modificationTime, B_errors);
    }
  }
}
class GetContentTask extends AnalysisTask {
  final Source source;
  bool A__complete = false;
  String _content;
  int _modificationTime = -1;
  GetContentTask(InternalAnalysisContext context, this.source) : super(context) {
    if (source == null) {
      throw new IllegalArgumentException("Cannot get contents of null source");
    }
  }
  accept(AnalysisTaskVisitor visitor) => visitor.visitGetContentTask(this);
  String get content => _content;
  int get modificationTime => _modificationTime;
  bool get isComplete => A__complete;
  String get taskDescription => "get contents of ${source.fullName}";
  void internalPerform() {
    A__complete = true;
    try {
      TimestampedData<String> A_data = context.getContents(source);
      _content = A_data.data;
      _modificationTime = A_data.modificationTime;
    } catch (exception, A_stackTrace) {
      throw new AnalysisException("Could not get contents of ${source}", new CaughtException(exception, A_stackTrace));
    }
  }
}
abstract class HtmlEntry implements SourceEntry {
  static final DataDescriptor<AngularApplication> ANGULAR_APPLICATION = new DataDescriptor<AngularApplication>("HtmlEntry.ANGULAR_APPLICATION");
  static final DataDescriptor<AngularComponentElement> A_ANGULAR_COMPONENT = new DataDescriptor<AngularComponentElement>("HtmlEntry.ANGULAR_COMPONENT");
  static final DataDescriptor<AngularApplication> ANGULAR_ENTRY = new DataDescriptor<AngularApplication>("HtmlEntry.ANGULAR_ENTRY");
  static final DataDescriptor<List<A_AnalysisError>> ANGULAR_ERRORS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.ANGULAR_ERRORS");
  static final DataDescriptor<HtmlElement> B_ELEMENT = new DataDescriptor<HtmlElement>("HtmlEntry.ELEMENT");
  static final DataDescriptor<List<A_AnalysisError>> HINTS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.HINTS");
  static final DataDescriptor<List<A_AnalysisError>> PARSE_ERRORS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.PARSE_ERRORS");
  static final DataDescriptor<HtmlUnit> PARSED_UNIT = new DataDescriptor<HtmlUnit>("HtmlEntry.PARSED_UNIT");
  static final DataDescriptor<HtmlUnit> RESOLVED_UNIT = new DataDescriptor<HtmlUnit>("HtmlEntry.RESOLVED_UNIT");
  static final DataDescriptor<List<Source>> REFERENCED_LIBRARIES = new DataDescriptor<List<Source>>("HtmlEntry.REFERENCED_LIBRARIES");
  static final DataDescriptor<List<A_AnalysisError>> RESOLUTION_ERRORS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.RESOLUTION_ERRORS");
  static final DataDescriptor<List<A_AnalysisError>> POLYMER_BUILD_ERRORS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.POLYMER_BUILD_ERRORS");
  static final DataDescriptor<List<A_AnalysisError>> POLYMER_RESOLUTION_ERRORS = new DataDescriptor<List<A_AnalysisError>>("HtmlEntry.POLYMER_RESOLUTION_ERRORS");
  List<A_AnalysisError> get allErrors;
  HtmlUnit get anyParsedUnit;
  HtmlEntryImpl get writableCopy;
}
class HtmlEntryImpl extends SourceEntryImpl implements HtmlEntry {
  CacheState _parsedUnitState = CacheState.INVALID;
  HtmlUnit _parsedUnit;
  CacheState _resolvedUnitState = CacheState.INVALID;
  HtmlUnit _resolvedUnit;
  CacheState _parseErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _parseErrors = A_AnalysisError.NO_ERRORS;
  CacheState _resolutionErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _resolutionErrors = A_AnalysisError.NO_ERRORS;
  CacheState _referencedLibrariesState = CacheState.INVALID;
  List<Source> _referencedLibraries = Source.F_EMPTY_ARRAY;
  CacheState _elementState = CacheState.INVALID;
  HtmlElement F__element;
  CacheState _angularApplicationState = CacheState.VALID;
  AngularApplication _angularApplication;
  CacheState _angularEntryState = CacheState.INVALID;
  AngularApplication _angularEntry = null;
  CacheState _angularComponentState = CacheState.VALID;
  AngularComponentElement _angularComponent = null;
  CacheState _angularErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _angularErrors = A_AnalysisError.NO_ERRORS;
  CacheState _hintsState = CacheState.INVALID;
  List<A_AnalysisError> _hints = A_AnalysisError.NO_ERRORS;
  CacheState _polymerBuildErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _polymerBuildErrors = A_AnalysisError.NO_ERRORS;
  CacheState _polymerResolutionErrorsState = CacheState.INVALID;
  List<A_AnalysisError> _polymerResolutionErrors = A_AnalysisError.NO_ERRORS;
  void flushAstStructures() {
    if (_parsedUnitState == CacheState.VALID) {
      _parsedUnitState = CacheState.FLUSHED;
      _parsedUnit = null;
    }
    if (_resolvedUnitState == CacheState.VALID) {
      _resolvedUnitState = CacheState.FLUSHED;
      _resolvedUnit = null;
    }
    if (_angularEntryState == CacheState.VALID) {
      _angularEntryState = CacheState.FLUSHED;
    }
    if (_angularErrorsState == CacheState.VALID) {
      _angularErrorsState = CacheState.FLUSHED;
    }
  }
  List<A_AnalysisError> get allErrors {
    List<A_AnalysisError> B_errors = new List<A_AnalysisError>();
    if (_parseErrors != null) {
      for (A_AnalysisError A_error in _parseErrors) {
        B_errors.add(A_error);
      }
    }
    if (_resolutionErrors != null) {
      for (A_AnalysisError A_error in _resolutionErrors) {
        B_errors.add(A_error);
      }
    }
    if (_angularErrors != null) {
      for (A_AnalysisError A_error in _angularErrors) {
        B_errors.add(A_error);
      }
    }
    if (_hints != null) {
      for (A_AnalysisError A_error in _hints) {
        B_errors.add(A_error);
      }
    }
    if (_polymerBuildErrors != null) {
      for (A_AnalysisError A_error in _polymerBuildErrors) {
        B_errors.add(A_error);
      }
    }
    if (_polymerResolutionErrors != null) {
      for (A_AnalysisError A_error in _polymerResolutionErrors) {
        B_errors.add(A_error);
      }
    }
    if (B_errors.length == 0) {
      return A_AnalysisError.NO_ERRORS;
    }
    return new List.from(B_errors);
  }
  HtmlUnit get anyParsedUnit {
    if (_parsedUnitState == CacheState.VALID) {
      return _parsedUnit;
    }
    if (_resolvedUnitState == CacheState.VALID) {
      return _resolvedUnit;
    }
    return null;
  }
  SourceKind get kind => SourceKind.C_HTML;
  CacheState getState(DataDescriptor descriptor) {
    if (identical(descriptor, HtmlEntry.ANGULAR_APPLICATION)) {
      return _angularApplicationState;
    } else if (identical(descriptor, HtmlEntry.A_ANGULAR_COMPONENT)) {
      return _angularComponentState;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ENTRY)) {
      return _angularEntryState;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ERRORS)) {
      return _angularErrorsState;
    } else if (identical(descriptor, HtmlEntry.B_ELEMENT)) {
      return _elementState;
    } else if (identical(descriptor, HtmlEntry.PARSE_ERRORS)) {
      return _parseErrorsState;
    } else if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      return _parsedUnitState;
    } else if (identical(descriptor, HtmlEntry.RESOLVED_UNIT)) {
      return _resolvedUnitState;
    } else if (identical(descriptor, HtmlEntry.REFERENCED_LIBRARIES)) {
      return _referencedLibrariesState;
    } else if (identical(descriptor, HtmlEntry.RESOLUTION_ERRORS)) {
      return _resolutionErrorsState;
    } else if (identical(descriptor, HtmlEntry.HINTS)) {
      return _hintsState;
    } else if (identical(descriptor, HtmlEntry.POLYMER_BUILD_ERRORS)) {
      return _polymerBuildErrorsState;
    } else if (identical(descriptor, HtmlEntry.POLYMER_RESOLUTION_ERRORS)) {
      return _polymerResolutionErrorsState;
    }
    return super.getState(descriptor);
  }
  Object getValue(DataDescriptor descriptor) {
    if (identical(descriptor, HtmlEntry.ANGULAR_APPLICATION)) {
      return _angularApplication;
    } else if (identical(descriptor, HtmlEntry.A_ANGULAR_COMPONENT)) {
      return _angularComponent;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ENTRY)) {
      return _angularEntry;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ERRORS)) {
      return _angularErrors;
    } else if (identical(descriptor, HtmlEntry.B_ELEMENT)) {
      return F__element;
    } else if (identical(descriptor, HtmlEntry.PARSE_ERRORS)) {
      return _parseErrors;
    } else if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      return _parsedUnit;
    } else if (identical(descriptor, HtmlEntry.RESOLVED_UNIT)) {
      return _resolvedUnit;
    } else if (identical(descriptor, HtmlEntry.REFERENCED_LIBRARIES)) {
      return _referencedLibraries;
    } else if (identical(descriptor, HtmlEntry.RESOLUTION_ERRORS)) {
      return _resolutionErrors;
    } else if (identical(descriptor, HtmlEntry.HINTS)) {
      return _hints;
    } else if (identical(descriptor, HtmlEntry.POLYMER_BUILD_ERRORS)) {
      return _polymerBuildErrors;
    } else if (identical(descriptor, HtmlEntry.POLYMER_RESOLUTION_ERRORS)) {
      return _polymerResolutionErrors;
    }
    return super.getValue(descriptor);
  }
  HtmlEntryImpl get writableCopy {
    HtmlEntryImpl A_copy = new HtmlEntryImpl();
    A_copy.copyFrom(this);
    return A_copy;
  }
  void invalidateAllInformation() {
    super.invalidateAllInformation();
    _parseErrors = A_AnalysisError.NO_ERRORS;
    _parseErrorsState = CacheState.INVALID;
    _parsedUnit = null;
    _parsedUnitState = CacheState.INVALID;
    _resolvedUnit = null;
    _resolvedUnitState = CacheState.INVALID;
    invalidateAllResolutionInformation(true);
  }
  void invalidateAllResolutionInformation(bool invalidateUris) {
    _angularEntry = null;
    _angularEntryState = CacheState.INVALID;
    _angularErrors = A_AnalysisError.NO_ERRORS;
    _angularErrorsState = CacheState.INVALID;
    _polymerBuildErrors = A_AnalysisError.NO_ERRORS;
    _polymerBuildErrorsState = CacheState.INVALID;
    _polymerResolutionErrors = A_AnalysisError.NO_ERRORS;
    _polymerResolutionErrorsState = CacheState.INVALID;
    F__element = null;
    _elementState = CacheState.INVALID;
    _resolutionErrors = A_AnalysisError.NO_ERRORS;
    _resolutionErrorsState = CacheState.INVALID;
    _hints = A_AnalysisError.NO_ERRORS;
    _hintsState = CacheState.INVALID;
    if (invalidateUris) {
      _referencedLibraries = Source.F_EMPTY_ARRAY;
      _referencedLibrariesState = CacheState.INVALID;
    }
  }
  void recordContentError(CaughtException exception) {
    super.recordContentError(exception);
    recordParseError(exception);
  }
  void recordParseError(CaughtException exception) {
    recordScanError(exception);
    _parseErrors = A_AnalysisError.NO_ERRORS;
    _parseErrorsState = CacheState.C_ERROR;
    _parsedUnit = null;
    _parsedUnitState = CacheState.C_ERROR;
    _referencedLibraries = Source.F_EMPTY_ARRAY;
    _referencedLibrariesState = CacheState.C_ERROR;
    recordResolutionError(exception);
  }
  void recordResolutionError(CaughtException exception) {
    this.exception = exception;
    _angularErrors = A_AnalysisError.NO_ERRORS;
    _angularErrorsState = CacheState.C_ERROR;
    _resolvedUnit = null;
    _resolvedUnitState = CacheState.C_ERROR;
    F__element = null;
    _elementState = CacheState.C_ERROR;
    _resolutionErrors = A_AnalysisError.NO_ERRORS;
    _resolutionErrorsState = CacheState.C_ERROR;
    _hints = A_AnalysisError.NO_ERRORS;
    _hintsState = CacheState.C_ERROR;
    _polymerBuildErrors = A_AnalysisError.NO_ERRORS;
    _polymerBuildErrorsState = CacheState.C_ERROR;
    _polymerResolutionErrors = A_AnalysisError.NO_ERRORS;
    _polymerResolutionErrorsState = CacheState.C_ERROR;
  }
  void setState(DataDescriptor descriptor, CacheState state) {
    if (identical(descriptor, HtmlEntry.ANGULAR_APPLICATION)) {
      _angularApplication = updatedValue(state, _angularApplication, null);
      _angularApplicationState = state;
    } else if (identical(descriptor, HtmlEntry.A_ANGULAR_COMPONENT)) {
      _angularComponent = updatedValue(state, _angularComponent, null);
      _angularComponentState = state;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ENTRY)) {
      _angularEntry = updatedValue(state, _angularEntry, null);
      _angularEntryState = state;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ERRORS)) {
      _angularErrors = updatedValue(state, _angularErrors, null);
      _angularErrorsState = state;
    } else if (identical(descriptor, HtmlEntry.B_ELEMENT)) {
      F__element = updatedValue(state, F__element, null);
      _elementState = state;
    } else if (identical(descriptor, HtmlEntry.PARSE_ERRORS)) {
      _parseErrors = updatedValue(state, _parseErrors, null);
      _parseErrorsState = state;
    } else if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      _parsedUnit = updatedValue(state, _parsedUnit, null);
      _parsedUnitState = state;
    } else if (identical(descriptor, HtmlEntry.RESOLVED_UNIT)) {
      _resolvedUnit = updatedValue(state, _resolvedUnit, null);
      _resolvedUnitState = state;
    } else if (identical(descriptor, HtmlEntry.REFERENCED_LIBRARIES)) {
      _referencedLibraries = updatedValue(state, _referencedLibraries, Source.F_EMPTY_ARRAY);
      _referencedLibrariesState = state;
    } else if (identical(descriptor, HtmlEntry.RESOLUTION_ERRORS)) {
      _resolutionErrors = updatedValue(state, _resolutionErrors, A_AnalysisError.NO_ERRORS);
      _resolutionErrorsState = state;
    } else if (identical(descriptor, HtmlEntry.HINTS)) {
      _hints = updatedValue(state, _hints, A_AnalysisError.NO_ERRORS);
      _hintsState = state;
    } else if (identical(descriptor, HtmlEntry.POLYMER_BUILD_ERRORS)) {
      _polymerBuildErrors = updatedValue(state, _polymerBuildErrors, null);
      _polymerBuildErrorsState = state;
    } else if (identical(descriptor, HtmlEntry.POLYMER_RESOLUTION_ERRORS)) {
      _polymerResolutionErrors = updatedValue(state, _polymerResolutionErrors, null);
      _polymerResolutionErrorsState = state;
    } else {
      super.setState(descriptor, state);
    }
  }
  void setValue(DataDescriptor descriptor, Object A_value) {
    if (identical(descriptor, HtmlEntry.ANGULAR_APPLICATION)) {
      _angularApplication = A_value as AngularApplication;
      _angularApplicationState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.A_ANGULAR_COMPONENT)) {
      _angularComponent = A_value as AngularComponentElement;
      _angularComponentState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ENTRY)) {
      _angularEntry = A_value as AngularApplication;
      _angularEntryState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.ANGULAR_ERRORS)) {
      _angularErrors = A_value as List<A_AnalysisError>;
      _angularErrorsState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.B_ELEMENT)) {
      F__element = A_value as HtmlElement;
      _elementState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.PARSE_ERRORS)) {
      _parseErrors = A_value as List<A_AnalysisError>;
      _parseErrorsState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.PARSED_UNIT)) {
      _parsedUnit = A_value as HtmlUnit;
      _parsedUnitState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.RESOLVED_UNIT)) {
      _resolvedUnit = A_value as HtmlUnit;
      _resolvedUnitState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.REFERENCED_LIBRARIES)) {
      _referencedLibraries = A_value == null ? Source.F_EMPTY_ARRAY : (A_value as List<Source>);
      _referencedLibrariesState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.RESOLUTION_ERRORS)) {
      _resolutionErrors = A_value as List<A_AnalysisError>;
      _resolutionErrorsState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.HINTS)) {
      _hints = A_value as List<A_AnalysisError>;
      _hintsState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.POLYMER_BUILD_ERRORS)) {
      _polymerBuildErrors = A_value as List<A_AnalysisError>;
      _polymerBuildErrorsState = CacheState.VALID;
    } else if (identical(descriptor, HtmlEntry.POLYMER_RESOLUTION_ERRORS)) {
      _polymerResolutionErrors = A_value as List<A_AnalysisError>;
      _polymerResolutionErrorsState = CacheState.VALID;
    } else {
      super.setValue(descriptor, A_value);
    }
  }
  void copyFrom(SourceEntryImpl A_entry) {
    super.copyFrom(A_entry);
    HtmlEntryImpl other = A_entry as HtmlEntryImpl;
    _angularApplicationState = other._angularApplicationState;
    _angularApplication = other._angularApplication;
    _angularComponentState = other._angularComponentState;
    _angularComponent = other._angularComponent;
    _angularEntryState = other._angularEntryState;
    _angularEntry = other._angularEntry;
    _angularErrorsState = other._angularErrorsState;
    _angularErrors = other._angularErrors;
    _parseErrorsState = other._parseErrorsState;
    _parseErrors = other._parseErrors;
    _parsedUnitState = other._parsedUnitState;
    _parsedUnit = other._parsedUnit;
    _resolvedUnitState = other._resolvedUnitState;
    _resolvedUnit = other._resolvedUnit;
    _referencedLibrariesState = other._referencedLibrariesState;
    _referencedLibraries = other._referencedLibraries;
    _resolutionErrorsState = other._resolutionErrorsState;
    _resolutionErrors = other._resolutionErrors;
    _elementState = other._elementState;
    F__element = other.F__element;
    _hintsState = other._hintsState;
    _hints = other._hints;
    _polymerBuildErrorsState = other._polymerBuildErrorsState;
    _polymerBuildErrors = other._polymerBuildErrors;
    _polymerResolutionErrorsState = other._polymerResolutionErrorsState;
    _polymerResolutionErrors = other._polymerResolutionErrors;
  }
  bool get hasErrorState => super.hasErrorState || _parsedUnitState == CacheState.C_ERROR || _resolvedUnitState == CacheState.C_ERROR || _parseErrorsState == CacheState.C_ERROR || _resolutionErrorsState == CacheState.C_ERROR || _referencedLibrariesState == CacheState.C_ERROR || _elementState == CacheState.C_ERROR || _angularErrorsState == CacheState.C_ERROR || _hintsState == CacheState.C_ERROR || _polymerBuildErrorsState == CacheState.C_ERROR || _polymerResolutionErrorsState == CacheState.C_ERROR;
  bool writeDiffOn(JavaStringBuilder A_builder, SourceEntry oldEntry) {
    bool needsSeparator = super.writeDiffOn(A_builder, oldEntry);
    if (oldEntry is! HtmlEntryImpl) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append("entry type changed; was ${oldEntry.runtimeType.toString()}");
      return true;
    }
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.PARSE_ERRORS, "parseErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.PARSED_UNIT, "parsedUnit");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.RESOLVED_UNIT, "resolvedUnit");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.RESOLUTION_ERRORS, "resolutionErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.REFERENCED_LIBRARIES, "referencedLibraries");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.B_ELEMENT, "element");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.ANGULAR_APPLICATION, "angularApplicationState");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.A_ANGULAR_COMPONENT, "angularComponent");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.ANGULAR_ENTRY, "angularEntry");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.ANGULAR_ERRORS, "angularErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.POLYMER_BUILD_ERRORS, "polymerBuildErrors");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, HtmlEntry.POLYMER_RESOLUTION_ERRORS, "polymerResolutionErrors");
    return needsSeparator;
  }
  void writeOn(JavaStringBuilder A_builder) {
    A_builder.append("Html: ");
    super.writeOn(A_builder);
    A_builder.append("; parseErrors = ");
    A_builder.append(_parseErrorsState);
    A_builder.append("; parsedUnit = ");
    A_builder.append(_parsedUnitState);
    A_builder.append("; resolvedUnit = ");
    A_builder.append(_resolvedUnitState);
    A_builder.append("; resolutionErrors = ");
    A_builder.append(_resolutionErrorsState);
    A_builder.append("; referencedLibraries = ");
    A_builder.append(_referencedLibrariesState);
    A_builder.append("; element = ");
    A_builder.append(_elementState);
    A_builder.append("; angularApplication = ");
    A_builder.append(_angularApplicationState);
    A_builder.append("; angularComponent = ");
    A_builder.append(_angularComponentState);
    A_builder.append("; angularEntry = ");
    A_builder.append(_angularEntryState);
    A_builder.append("; angularErrors = ");
    A_builder.append(_angularErrorsState);
    A_builder.append("; polymerBuildErrors = ");
    A_builder.append(_polymerBuildErrorsState);
    A_builder.append("; polymerResolutionErrors = ");
    A_builder.append(_polymerResolutionErrorsState);
  }
}
class IncrementalAnalysisCache {
  static IncrementalAnalysisCache cacheResult(IncrementalAnalysisCache cache, CompilationUnit unit) {
    if (cache != null && unit != null) {
      return new IncrementalAnalysisCache(cache.librarySource, cache.source, unit, cache._newContents, cache._newContents, 0, 0, 0);
    }
    return null;
  }
  static IncrementalAnalysisCache A_clear(IncrementalAnalysisCache cache, Source A_source) {
    if (cache == null || cache.source == A_source) {
      return null;
    }
    return cache;
  }
  static IncrementalAnalysisCache A_update(IncrementalAnalysisCache cache, Source A_source, String A_oldContents, String A_newContents, int A_offset, int A_oldLength, int A_newLength, SourceEntry sourceEntry) {
    Source A_librarySource = null;
    CompilationUnit unit = null;
    if (sourceEntry is DartEntryImpl) {
      DartEntryImpl dartEntry = sourceEntry;
      List<Source> librarySources = dartEntry.librariesContaining;
      if (librarySources.length == 1) {
        A_librarySource = librarySources[0];
        if (A_librarySource != null) {
          unit = dartEntry.getValueInLibrary(DartEntry.RESOLVED_UNIT, A_librarySource);
        }
      }
    }
    if (cache == null || cache.source != A_source || unit != null) {
      if (unit == null) {
        return null;
      }
      if (A_oldContents == null) {
        if (A_oldLength != 0) {
          return null;
        }
        A_oldContents = "${A_newContents.substring(0, A_offset)}${A_newContents.substring(A_offset + A_newLength)}";
      }
      return new IncrementalAnalysisCache(A_librarySource, A_source, unit, A_oldContents, A_newContents, A_offset, A_oldLength, A_newLength);
    }
    if (cache._oldLength == 0 && cache._newLength == 0) {
      cache.C__offset = A_offset;
      cache._oldLength = A_oldLength;
      cache._newLength = A_newLength;
    } else {
      if (cache.C__offset > A_offset || A_offset > cache.C__offset + cache._newLength) {
        return null;
      }
      cache._newLength += A_newLength - A_oldLength;
    }
    cache._newContents = A_newContents;
    return cache;
  }
  static IncrementalAnalysisCache verifyStructure(IncrementalAnalysisCache cache, Source A_source, CompilationUnit unit) {
    if (cache != null && unit != null && cache.source == A_source) {
      if (!AstComparator.equalNodes(cache.resolvedUnit, unit)) {
        return null;
      }
    }
    return cache;
  }
  final Source librarySource;
  final Source source;
  final String oldContents;
  final CompilationUnit resolvedUnit;
  String _newContents;
  int C__offset = 0;
  int _oldLength = 0;
  int _newLength = 0;
  IncrementalAnalysisCache(this.librarySource, this.source, this.resolvedUnit, this.oldContents, String A_newContents, int A_offset, int A_oldLength, int A_newLength) {
    this._newContents = A_newContents;
    this.C__offset = A_offset;
    this._oldLength = A_oldLength;
    this._newLength = A_newLength;
  }
  String get newContents => _newContents;
  int get newLength => _newLength;
  int get offset => C__offset;
  int get oldLength => _oldLength;
  bool get hasWork => _oldLength > 0 || _newLength > 0;
}
class IncrementalAnalysisTask extends AnalysisTask {
  final IncrementalAnalysisCache cache;
  CompilationUnit _updatedUnit;
  IncrementalAnalysisTask(InternalAnalysisContext context, this.cache) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitIncrementalAnalysisTask(this);
  CompilationUnit get compilationUnit => _updatedUnit;
  Source get source => cache != null ? cache.source : null;
  String get taskDescription => "incremental analysis ${(cache != null ? cache.source : "null")}";
  void internalPerform() {
    if (cache == null) {
      return;
    }
    if (cache.oldLength > 0 || cache.newLength > 30) {
      return;
    }
    CharacterReader reader = new CharSequenceReader(cache.newContents);
    BooleanErrorListener errorListener = new BooleanErrorListener();
    IncrementalScanner scanner = new IncrementalScanner(cache.source, reader, errorListener);
    scanner.rescan(cache.resolvedUnit.beginToken, cache.offset, cache.oldLength, cache.newLength);
    if (errorListener.errorReported) {
      return;
    }
    IncrementalParser parser = new IncrementalParser(cache.source, scanner.tokenMap, AnalysisErrorListener.NULL_LISTENER);
    _updatedUnit = parser.reparse(cache.resolvedUnit, scanner.leftToken, scanner.rightToken, cache.offset, cache.offset + cache.oldLength);
    TypeProvider A_typeProvider = this.typeProvider;
    if (_updatedUnit != null && A_typeProvider != null) {
      CompilationUnitElement A_element = _updatedUnit.element;
      if (A_element != null) {
        LibraryElement library = A_element.library;
        if (library != null) {
          IncrementalResolver resolver = new IncrementalResolver(library, cache.source, A_typeProvider, errorListener);
          resolver.resolve(parser.updatedNode);
        }
      }
    }
  }
  TypeProvider get typeProvider {
    try {
      return context.typeProvider;
    }on AnalysisException  catch (exception) {
      return null;
    }
  }
}
class InstrumentedAnalysisContextImpl implements InternalAnalysisContext {
  static void _checkThread(InstrumentationBuilder instrumentation) {}
  static void _recordAnalysisException(InstrumentationBuilder instrumentation, CaughtException exception) {
    instrumentation.record(exception);
  }
  String _contextId = UUID.randomUUID().toString();
  InternalAnalysisContext _basis;
  InstrumentedAnalysisContextImpl.C_con1(InternalAnalysisContext context) {
    _basis = context;
  }
  void applyChanges(ChangeSet changeSet) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-applyChanges");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.applyChanges(changeSet);
    } finally {
      instrumentation.log();
    }
  }
  String computeDocumentationComment(A_Element A_element) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-computeDocumentationComment");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.computeDocumentationComment(A_element);
    } finally {
      instrumentation.log();
    }
  }
  List<Source> computeExportedLibraries(Source A_source) => _basis.computeExportedLibraries(A_source);
  HtmlElement computeHtmlElement(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-computeHtmlElement");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.computeHtmlElement(A_source);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  List<Source> computeImportedLibraries(Source A_source) => _basis.computeImportedLibraries(A_source);
  SourceKind computeKindOf(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-computeKindOf");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.computeKindOf(A_source);
    } finally {
      instrumentation.log();
    }
  }
  LibraryElement computeLibraryElement(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-computeLibraryElement");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.computeLibraryElement(A_source);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  LineInfo computeLineInfo(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-computeLineInfo");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.computeLineInfo(A_source);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  ResolvableCompilationUnit computeResolvableCompilationUnit(Source A_source) => _basis.computeResolvableCompilationUnit(A_source);
  bool exists(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-exists");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.exists(A_source);
    } finally {
      instrumentation.log();
    }
  }
  AnalysisOptions get analysisOptions {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getAnalysisOptions");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.analysisOptions;
    } finally {
      instrumentation.log();
    }
  }
  AnalysisContext get basis => _basis;
  TimestampedData<String> getContents(Source A_source) => _basis.getContents(A_source);
  DeclaredVariables get declaredVariables => _basis.declaredVariables;
  A_Element getElement(ElementLocation A_location) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getElement");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getElement(A_location);
    } finally {
      instrumentation.log();
    }
  }
  AnalysisErrorInfo getErrors(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getErrors");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      AnalysisErrorInfo ret = _basis.getErrors(A_source);
      if (ret != null) {
        instrumentation.metric2("Errors-count", ret.errors.length);
      }
      return ret;
    } finally {
      instrumentation.log();
    }
  }
  SourceKind getKindOf(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getKindOf");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getKindOf(A_source);
    } finally {
      instrumentation.log();
    }
  }
  List<Source> getLibrariesContaining(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getLibrariesContaining");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      List<Source> ret = _basis.getLibrariesContaining(A_source);
      if (ret != null) {
        instrumentation.metric2("Source-count", ret.length);
      }
      return ret;
    } finally {
      instrumentation.log2(2);
    }
  }
  List<Source> getLibrariesDependingOn(Source librarySource) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getLibrariesDependingOn");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      List<Source> ret = _basis.getLibrariesDependingOn(librarySource);
      if (ret != null) {
        instrumentation.metric2("Source-count", ret.length);
      }
      return ret;
    } finally {
      instrumentation.log();
    }
  }
  LibraryElement getLibraryElement(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getLibraryElement");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getLibraryElement(A_source);
    } finally {
      instrumentation.log();
    }
  }
  List<Source> get librarySources {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getLibrarySources");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      List<Source> ret = _basis.librarySources;
      if (ret != null) {
        instrumentation.metric2("Source-count", ret.length);
      }
      return ret;
    } finally {
      instrumentation.log();
    }
  }
  LineInfo getLineInfo(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getLineInfo");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getLineInfo(A_source);
    } finally {
      instrumentation.log();
    }
  }
  int getModificationStamp(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getModificationStamp");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getModificationStamp(A_source);
    } finally {
      instrumentation.log();
    }
  }
  Namespace getPublicNamespace(LibraryElement library) => _basis.getPublicNamespace(library);
  CompilationUnit getResolvedCompilationUnit2(Source unitSource, Source librarySource) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getResolvedCompilationUnit");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.getResolvedCompilationUnit2(unitSource, librarySource);
    } finally {
      instrumentation.log2(2);
    }
  }
  SourceFactory get sourceFactory {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-getSourceFactory");
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.sourceFactory;
    } finally {
      instrumentation.log2(2);
    }
  }
  TypeProvider get typeProvider => _basis.typeProvider;
  bool get isDisposed {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-isDisposed");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.isDisposed;
    } finally {
      instrumentation.log();
    }
  }
  CompilationUnit parseCompilationUnit(Source A_source) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-parseCompilationUnit");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.parseCompilationUnit(A_source);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  AnalysisResult performAnalysisTask() {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-performAnalysisTask");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      AnalysisResult result = _basis.performAnalysisTask();
      if (result.changeNotices != null) {
        instrumentation.metric2("ChangeNotice-count", result.changeNotices.length);
      }
      return result;
    } finally {
      instrumentation.log2(2);
    }
  }
  CompilationUnit resolveCompilationUnit(Source unitSource, LibraryElement library) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-resolveCompilationUnit");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.resolveCompilationUnit(unitSource, library);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  CompilationUnit resolveCompilationUnit2(Source unitSource, Source librarySource) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-resolveCompilationUnit");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      return _basis.resolveCompilationUnit2(unitSource, librarySource);
    }on AnalysisException  catch (e, A_stackTrace) {
      _recordAnalysisException(instrumentation, new CaughtException(e, A_stackTrace));
      throw e;
    } finally {
      instrumentation.log();
    }
  }
  void set analysisOptions(AnalysisOptions options) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-setAnalysisOptions");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.analysisOptions = options;
    } finally {
      instrumentation.log();
    }
  }
  void set analysisPriorityOrder(List<Source> sources) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-setAnalysisPriorityOrder");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.analysisPriorityOrder = sources;
    } finally {
      instrumentation.log();
    }
  }
  void setChangedContents(Source A_source, String contents, int A_offset, int oldLength, int newLength) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-setChangedContents");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.setChangedContents(A_source, contents, A_offset, oldLength, newLength);
    } finally {
      instrumentation.log();
    }
  }
  void setContents(Source A_source, String contents) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-setContents");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.setContents(A_source, contents);
    } finally {
      instrumentation.log();
    }
  }
  void set sourceFactory(SourceFactory factory) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("Analysis-setSourceFactory");
    _checkThread(instrumentation);
    try {
      instrumentation.metric3("contextId", _contextId);
      _basis.sourceFactory = factory;
    } finally {
      instrumentation.log();
    }
  }
}
abstract class InternalAnalysisContext implements AnalysisContext {
  List<Source> computeExportedLibraries(Source A_source);
  List<Source> computeImportedLibraries(Source A_source);
  ResolvableCompilationUnit computeResolvableCompilationUnit(Source A_source);
  Namespace getPublicNamespace(LibraryElement library);
  TypeProvider get typeProvider;
}
abstract class Logger {
  static final Logger NULL = new Logger_NullLogger();
  void logError(String A_message);
  void logError2(String A_message, exception);
  void logInformation(String A_message);
  void logInformation2(String A_message, Exception exception);
}
class Logger_NullLogger implements Logger {
  void logError(String A_message) {}
  void logError2(String A_message, exception) {}
  void logInformation(String A_message) {}
  void logInformation2(String A_message, exception) {}
}
class NgComponentElementProcessor extends NgDirectiveProcessor {
  final AngularComponentElement F__element;
  NgComponentElementProcessor(this.F__element);
  void apply(AngularHtmlUnitResolver resolver, XmlTagNode node) {
    node.element = F__element.selector;
    for (AngularPropertyElement property in F__element.properties) {
      String A_name = property.name;
      XmlAttributeNode attribute = node.getAttribute(A_name);
      if (attribute != null) {
        attribute.element = property;
        if (property.propertyKind != AngularPropertyKind.ATTR) {
          AngularExpression expression = parseAngularExpression(resolver, attribute);
          resolver._resolveExpression(expression);
          setAngularExpression(attribute, expression);
        }
      }
    }
  }
  bool canApply(XmlTagNode node) => F__element.selector.apply(node);
}
class NgControllerElementProcessor extends NgProcessor {
  final AngularControllerElement F__element;
  NgControllerElementProcessor(this.F__element);
  void apply(AngularHtmlUnitResolver resolver, XmlTagNode node) {
    InterfaceType A_type = (F__element.enclosingElement as ClassElement).type;
    String A_name = F__element.name;
    LocalVariableElementImpl variable = resolver._createLocalVariableWithName(A_type, A_name);
    resolver._defineVariable(variable);
    variable.toolkitObjects = <AngularElement>[F__element];
  }
  bool canApply(XmlTagNode node) => F__element.selector.apply(node);
}
class NgDecoratorElementProcessor extends NgDirectiveProcessor {
  final AngularDecoratorElement F__element;
  NgDecoratorElementProcessor(this.F__element);
  void apply(AngularHtmlUnitResolver resolver, XmlTagNode node) {
    String selectorAttributeName = null;
    {
      AngularSelectorElement selector = F__element.selector;
      if (selector is HasAttributeSelectorElementImpl) {
        selectorAttributeName = selector.name;
        XmlAttributeNode attribute = node.getAttribute(selectorAttributeName);
        if (attribute != null) {
          attribute.element = selector;
        }
      }
    }
    for (AngularPropertyElement property in F__element.properties) {
      String A_name = property.name;
      if (A_name == ".") {
        A_name = selectorAttributeName;
      }
      XmlAttributeNode attribute = node.getAttribute(A_name);
      if (attribute == null) {
        continue;
      }
      if (A_name != selectorAttributeName) {
        attribute.element = property;
      }
      if (!NgDirectiveProcessor.hasValue(attribute)) {
        continue;
      }
      if (property.propertyKind != AngularPropertyKind.ATTR) {
        resolver._pushNameScope();
        try {
          _onNgEventDirective(resolver);
          AngularExpression expression = parseAngularExpression(resolver, attribute);
          resolver._resolveExpression(expression);
          setAngularExpression(attribute, expression);
        } finally {
          resolver._popNameScope();
        }
      }
    }
  }
  bool canApply(XmlTagNode node) => F__element.selector.apply(node);
  void _onNgEventDirective(AngularHtmlUnitResolver resolver) {
    if (F__element.isClass("NgEventDirective")) {
      DartType dynamicType = resolver.typeProvider.dynamicType;
      resolver._defineVariable(resolver._createLocalVariableWithName(dynamicType, "\$event"));
    }
  }
}
abstract class NgDirectiveProcessor extends NgProcessor {
  static bool hasValue(XmlAttributeNode attribute) {
    Token valueToken = attribute.valueToken;
    return valueToken != null && !valueToken.isSynthetic;
  }
  static AngularRawXmlExpression newAngularRawXmlExpression(AngularExpression e) => new AngularRawXmlExpression(e);
  static RawXmlExpression newRawXmlExpression(Expression e) => new RawXmlExpression(e);
  AngularExpression parseAngularExpression(AngularHtmlUnitResolver resolver, XmlAttributeNode attribute) {
    A_Token token = _scanAttribute(resolver, attribute);
    return resolver._parseAngularExpressionInToken(token);
  }
  Expression parseDartExpression(AngularHtmlUnitResolver resolver, XmlAttributeNode attribute) {
    A_Token token = _scanAttribute(resolver, attribute);
    return resolver._parseDartExpressionInToken(token);
  }
  void setAngularExpression(XmlAttributeNode attribute, AngularExpression expression) {
    _setExpression(attribute, newAngularRawXmlExpression(expression));
  }
  void setExpression(XmlAttributeNode attribute, Expression expression) {
    _setExpression(attribute, newRawXmlExpression(expression));
  }
  A_Token _scanAttribute(AngularHtmlUnitResolver resolver, XmlAttributeNode attribute) {
    int A_offset = attribute.valueToken.offset + 1;
    String A_value = attribute.text;
    return resolver._scanDart(A_value, 0, A_value.length, A_offset);
  }
  void _setExpression(XmlAttributeNode attribute, XmlExpression xmlExpression) {
    attribute.expressions = <XmlExpression>[xmlExpression];
  }
}
class NgModelProcessor extends NgDirectiveProcessor {
  static String _NG_MODEL = "ng-model";
  static NgModelProcessor B_INSTANCE = new NgModelProcessor();
  void apply(AngularHtmlUnitResolver resolver, XmlTagNode node) {
    XmlAttributeNode attribute = node.getAttribute(_NG_MODEL);
    Expression expression = parseDartExpression(resolver, attribute);
    if (expression is SimpleIdentifier) {
      return;
    }
    resolver._resolveNode(expression);
    setExpression(attribute, expression);
  }
  bool canApply(XmlTagNode node) => node.getAttribute(_NG_MODEL) != null;
  void _applyTopDeclarations(AngularHtmlUnitResolver resolver, XmlTagNode node) {
    XmlAttributeNode attribute = node.getAttribute(_NG_MODEL);
    Expression expression = parseDartExpression(resolver, attribute);
    if (expression is! SimpleIdentifier) {
      return;
    }
    SimpleIdentifier identifier = expression as SimpleIdentifier;
    InterfaceType A_type = resolver.typeProvider.stringType;
    LocalVariableElementImpl A_element = resolver._createLocalVariableFromIdentifier(A_type, identifier);
    resolver._defineTopVariable(A_element);
    identifier.staticElement = A_element;
    identifier.staticType = A_type;
    setExpression(attribute, identifier);
  }
}
abstract class NgProcessor {
  void apply(AngularHtmlUnitResolver resolver, XmlTagNode node);
  bool canApply(XmlTagNode node);
}
class ObsoleteSourceAnalysisException extends AnalysisException {
  Source B__source;
  ObsoleteSourceAnalysisException(Source A_source) : super("The source '${A_source.fullName}' was removed while it was being analyzed") {
    this.B__source = A_source;
  }
  Source get source => B__source;
}
class ParseDartTask extends AnalysisTask {
  static Source resolveDirective(AnalysisContext context, Source librarySource, UriBasedDirective directive, AnalysisErrorListener errorListener) {
    StringLiteral uriLiteral = directive.uri;
    String uriContent = uriLiteral.stringValue;
    if (uriContent != null) {
      uriContent = uriContent.trim();
      directive.uriContent = uriContent;
    }
    UriValidationCode A_code = directive.validate();
    if (A_code == null) {
      String encodedUriContent = Uri.encodeFull(uriContent);
      Source A_source = context.sourceFactory.resolveUri(librarySource, encodedUriContent);
      directive.source = A_source;
      return A_source;
    }
    if (A_code == UriValidationCode.URI_WITH_DART_EXT_SCHEME) {
      return null;
    }
    if (A_code == UriValidationCode.URI_WITH_INTERPOLATION) {
      errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.A_URI_WITH_INTERPOLATION, []));
      return null;
    }
    if (A_code == UriValidationCode.INVALID_URI) {
      errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.A_INVALID_URI, [uriContent]));
      return null;
    }
    throw new RuntimeException(message: "Failed to handle validation code: ${A_code}");
  }
  final Source source;
  final int modificationTime;
  final A_Token _tokenStream;
  final LineInfo lineInfo;
  CompilationUnit F__unit;
  bool _containsPartOfDirective = false;
  bool _containsNonPartOfDirective = false;
  A_p.HashSet<Source> _exportedSources = new A_p.HashSet<Source>();
  A_p.HashSet<Source> _importedSources = new A_p.HashSet<Source>();
  A_p.HashSet<Source> _includedSources = new A_p.HashSet<Source>();
  List<A_AnalysisError> A__errors = A_AnalysisError.NO_ERRORS;
  ParseDartTask(InternalAnalysisContext context, this.source, this.modificationTime, this._tokenStream, this.lineInfo) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitParseDartTask(this);
  CompilationUnit get compilationUnit => F__unit;
  List<A_AnalysisError> get errors => A__errors;
  List<Source> get exportedSources => _toArray(_exportedSources);
  List<Source> get importedSources => _toArray(_importedSources);
  List<Source> get includedSources => _toArray(_includedSources);
  bool get hasNonPartOfDirective => _containsNonPartOfDirective;
  bool get hasPartOfDirective => _containsPartOfDirective;
  String get taskDescription {
    if (source == null) {
      return "parse as dart null source";
    }
    return "parse as dart ${source.fullName}";
  }
  void internalPerform() {
    TimeCounter_TimeCounterHandle timeCounterParse = PerformanceStatistics.A_parse.start();
    try {
      RecordingErrorListener errorListener = new RecordingErrorListener();
      Parser parser = new Parser(source, errorListener);
      AnalysisOptions options = context.analysisOptions;
      parser.parseFunctionBodies = options.analyzeFunctionBodies;
      parser.parseAsync = options.enableAsync;
      parser.parseDeferredLibraries = options.enableDeferredLoading;
      parser.parseEnum = options.enableEnum;
      F__unit = parser.parseCompilationUnit(_tokenStream);
      F__unit.lineInfo = lineInfo;
      AnalysisContext analysisContext = context;
      for (Directive directive in F__unit.directives) {
        if (directive is PartOfDirective) {
          _containsPartOfDirective = true;
        } else {
          _containsNonPartOfDirective = true;
          if (directive is UriBasedDirective) {
            Source referencedSource = resolveDirective(analysisContext, source, directive, errorListener);
            if (referencedSource != null) {
              if (directive is ExportDirective) {
                _exportedSources.add(referencedSource);
              } else if (directive is ImportDirective) {
                _importedSources.add(referencedSource);
              } else if (directive is PartDirective) {
                if (referencedSource != source) {
                  _includedSources.add(referencedSource);
                }
              } else {
                throw new AnalysisException("${runtimeType.toString()} failed to handle a ${directive.runtimeType.toString()}");
              }
            }
          }
        }
      }
      A__errors = errorListener.getErrorsForSource(source);
    } finally {
      timeCounterParse.stop();
    }
  }
  List<Source> _toArray(A_p.HashSet<Source> sources) {
    int A_size = sources.length;
    if (A_size == 0) {
      return Source.F_EMPTY_ARRAY;
    }
    return new List.from(sources);
  }
}
class ParseHtmlTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final String _content;
  LineInfo _lineInfo;
  HtmlUnit F__unit;
  List<A_AnalysisError> A__errors = A_AnalysisError.NO_ERRORS;
  List<Source> _referencedLibraries = Source.F_EMPTY_ARRAY;
  static String _ATTRIBUTE_SRC = "src";
  static String _TAG_SCRIPT = "script";
  ParseHtmlTask(InternalAnalysisContext context, this.source, this.modificationTime, this._content) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitParseHtmlTask(this);
  List<A_AnalysisError> get errors => A__errors;
  HtmlUnit get htmlUnit => F__unit;
  LineInfo get lineInfo => _lineInfo;
  List<Source> get referencedLibraries => _referencedLibraries;
  String get taskDescription {
    if (source == null) {
      return "parse as html null source";
    }
    return "parse as html ${source.fullName}";
  }
  void internalPerform() {
    try {
      AbstractScanner scanner = new StringScanner(source, _content);
      scanner.passThroughElements = <String>[_TAG_SCRIPT];
      Token token = scanner.tokenize();
      _lineInfo = new LineInfo(scanner.lineStarts);
      RecordingErrorListener errorListener = new RecordingErrorListener();
      F__unit = new HtmlParser(source, errorListener).parse(token, _lineInfo);
      F__unit.accept(new RecursiveXmlVisitor_ParseHtmlTask_internalPerform(this, errorListener));
      A__errors = errorListener.getErrorsForSource(source);
      _referencedLibraries = librarySources;
    } catch (exception, A_stackTrace) {
      throw new AnalysisException("Exception", new CaughtException(exception, A_stackTrace));
    }
  }
  List<Source> get librarySources {
    List<Source> libraries = new List<Source>();
    F__unit.accept(new RecursiveXmlVisitor_ParseHtmlTask_getLibrarySources(this, libraries));
    if (libraries.isEmpty) {
      return Source.F_EMPTY_ARRAY;
    }
    return new List.from(libraries);
  }
  void _resolveScriptDirectives(CompilationUnit A_script, AnalysisErrorListener errorListener) {
    if (A_script == null) {
      return;
    }
    AnalysisContext analysisContext = context;
    for (Directive directive in A_script.directives) {
      if (directive is UriBasedDirective) {
        ParseDartTask.resolveDirective(analysisContext, source, directive, errorListener);
      }
    }
  }
}
class PartitionManager {
  A_p.HashMap<DartSdk, SdkCachePartition> _sdkPartitions = new A_p.HashMap<DartSdk,SdkCachePartition>();
  static int _DEFAULT_SDK_CACHE_SIZE = 256;
  SdkCachePartition forSdk(DartSdk sdk) {
    SdkCachePartition partition = _sdkPartitions[sdk];
    if (partition == null) {
      partition = new SdkCachePartition(_DEFAULT_SDK_CACHE_SIZE);
      _sdkPartitions[sdk] = partition;
    }
    return partition;
  }
}
class PerformanceStatistics {
  static TimeCounter io = new TimeCounter();
  static TimeCounter scan = new TimeCounter();
  static TimeCounter A_parse = new TimeCounter();
  static TimeCounter A_resolve = new TimeCounter();
  static TimeCounter angular = new TimeCounter();
  static TimeCounter polymer = new TimeCounter();
  static TimeCounter A_errors = new TimeCounter();
  static TimeCounter hints = new TimeCounter();
}
class PolymerBuildHtmlTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final LineInfo _lineInfo;
  final HtmlUnit F__unit;
  List<A_AnalysisError> A__errors = A_AnalysisError.NO_ERRORS;
  PolymerBuildHtmlTask(InternalAnalysisContext context, this.source, this.modificationTime, this._lineInfo, this.F__unit) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitPolymerBuildHtmlTask(this);
  List<A_AnalysisError> get errors => A__errors;
  String get taskDescription => "build Polymer elements ${source.fullName}";
  void internalPerform() {
    RecordingErrorListener errorListener = new RecordingErrorListener();
    PolymerHtmlUnitBuilder resolver = new PolymerHtmlUnitBuilder(context, errorListener, source, _lineInfo, F__unit);
    resolver.build();
    A__errors = errorListener.getErrorsForSource(source);
  }
}
class PolymerHtmlUnitBuilder extends RecursiveXmlVisitor<Object> {
  static Set<String> _FORBIDDEN_TAG_NAMES = new Set();
  static bool isValidAttributeName(String A_name) {
    if (A_name.isEmpty) {
      return false;
    }
    int A_length = A_name.length;
    for (int i = 0; i < A_length; i++) {
      int c = A_name.codeUnitAt(i);
      if (i == 0) {
        if (!Character.isLetter(c)) {
          return false;
        }
      } else {
        if (!(Character.isLetterOrDigit(c) || c == 0x5F)) {
          return false;
        }
      }
    }
    return true;
  }
  static bool isValidTagName(String A_name) {
    if (A_name.isEmpty) {
      return false;
    }
    if (_FORBIDDEN_TAG_NAMES.contains(A_name)) {
      return false;
    }
    int A_length = A_name.length;
    bool hasDash = false;
    for (int i = 0; i < A_length; i++) {
      int c = A_name.codeUnitAt(i);
      if (c == 0x2D) {
        hasDash = true;
      }
      if (i == 0) {
        if (hasDash) {
          return false;
        }
        if (!Character.isLetter(c)) {
          return false;
        }
      } else {
        if (!(Character.isLetterOrDigit(c) || c == 0x2D || c == 0x5F)) {
          return false;
        }
      }
    }
    if (!hasDash) {
      return false;
    }
    return true;
  }
  final InternalAnalysisContext A__context;
  TypeProvider A__typeProvider;
  final AnalysisErrorListener _errorListener;
  final Source B__source;
  final LineInfo _lineInfo;
  final HtmlUnit F__unit;
  List<PolymerTagHtmlElement> _tagHtmlElements = [];
  XmlTagNode _elementNode;
  String _elementName;
  PolymerTagHtmlElementImpl _htmlElement;
  PolymerTagDartElementImpl _dartElement;
  PolymerHtmlUnitBuilder(this.A__context, this._errorListener, this.B__source, this._lineInfo, this.F__unit) {
    this.A__typeProvider = A__context.typeProvider;
  }
  void build() {
    F__unit.accept(this);
    HtmlElementImpl unitElement = F__unit.element as HtmlElementImpl;
    unitElement.polymerTags = new List.from(_tagHtmlElements);
  }
  Object visitXmlTagNode(XmlTagNode node) {
    if (node.tag == "polymer-element") {
      _createTagHtmlElement(node);
    }
    return super.visitXmlTagNode(node);
  }
  void _createAttributeElements() {
    XmlAttributeNode attributesAttribute = _elementNode.getAttribute("attributes");
    if (attributesAttribute == null) {
      return;
    }
    if (_dartElement == null) {
      return;
    }
    String attributesText = attributesAttribute.text;
    if (attributesText.trim().isEmpty) {
      _reportErrorForAttribute(attributesAttribute, PolymerCode.EMPTY_ATTRIBUTES, []);
      return;
    }
    List<PolymerHtmlUnitBuilder_NameToken> nameTokens = [];
    {
      int A_index = 0;
      int textOffset = attributesAttribute.textOffset;
      int nameOffset = -1;
      JavaStringBuilder nameBuilder = new JavaStringBuilder();
      while (A_index < attributesText.length) {
        int c = attributesText.codeUnitAt(A_index++);
        if (Character.A_isWhitespace(c)) {
          if (nameOffset != -1) {
            nameTokens.add(new PolymerHtmlUnitBuilder_NameToken(nameOffset, nameBuilder.toString()));
            nameBuilder = new JavaStringBuilder();
            nameOffset = -1;
          }
          continue;
        }
        if (nameOffset == -1) {
          nameOffset = textOffset + A_index - 1;
        }
        nameBuilder.appendChar(c);
      }
      if (nameOffset != -1) {
        nameTokens.add(new PolymerHtmlUnitBuilder_NameToken(nameOffset, nameBuilder.toString()));
        nameBuilder = new JavaStringBuilder();
      }
    }
    List<PolymerAttributeElement> attributes = [];
    Set<String> definedNames = new Set();
    ClassElement classElement = _dartElement.classElement;
    for (PolymerHtmlUnitBuilder_NameToken nameToken in nameTokens) {
      int A_offset = nameToken.C__offset;
      String A_name = nameToken.B__value;
      if (!isValidAttributeName(A_name)) {
        _reportErrorForNameToken(nameToken, PolymerCode.INVALID_ATTRIBUTE_NAME, [A_name]);
        continue;
      }
      if (!definedNames.add(A_name)) {
        _reportErrorForNameToken(nameToken, PolymerCode.DUPLICATE_ATTRIBUTE_DEFINITION, [A_name]);
        continue;
      }
      PolymerAttributeElementImpl attribute = new PolymerAttributeElementImpl(A_name, A_offset);
      attributes.add(attribute);
      FieldElement field = classElement.getField(A_name);
      if (field == null) {
        _reportErrorForNameToken(nameToken, PolymerCode.UNDEFINED_ATTRIBUTE_FIELD, [A_name, classElement.displayName]);
        continue;
      }
      if (!_isPublishedField(field)) {
        _reportErrorForNameToken(nameToken, PolymerCode.ATTRIBUTE_FIELD_NOT_PUBLISHED, [A_name, classElement.displayName]);
      }
      attribute.field = field;
    }
    _htmlElement.attributes = new List.from(attributes);
  }
  void _createTagHtmlElement(XmlTagNode node) {
    this._elementNode = node;
    this._elementName = null;
    this._htmlElement = null;
    this._dartElement = null;
    XmlAttributeNode nameAttribute = node.getAttribute("name");
    if (nameAttribute == null) {
      _reportErrorForToken(node.tagToken, PolymerCode.MISSING_TAG_NAME, []);
      return;
    }
    _elementName = nameAttribute.text;
    if (!isValidTagName(_elementName)) {
      _reportErrorForAttributeValue(nameAttribute, PolymerCode.INVALID_TAG_NAME, [_elementName]);
      return;
    }
    int nameOffset = nameAttribute.textOffset;
    _htmlElement = new PolymerTagHtmlElementImpl(_elementName, nameOffset);
    _dartElement = _findTagDartElement();
    if (_dartElement != null) {
      _htmlElement.dartElement = _dartElement;
      _dartElement.htmlElement = _htmlElement;
    }
    _createAttributeElements();
    _tagHtmlElements.add(_htmlElement);
  }
  PolymerTagDartElementImpl _findTagDartElement() {
    LibraryElement dartLibraryElement = dartUnitElement;
    if (dartLibraryElement == null) {
      return null;
    }
    return _findTagDartElement_inLibrary(dartLibraryElement);
  }
  PolymerTagDartElementImpl _findTagDartElement_inLibrary(LibraryElement library) {
    try {
      library.accept(new RecursiveElementVisitor_PolymerHtmlUnitBuilder_findTagDartElement_inLibrary(this));
    }on PolymerHtmlUnitBuilder_FoundTagDartElementError  catch (e) {
      return e.B__result;
    }
    return null;
  }
  LibraryElement get dartUnitElement {
    for (XmlTagNode child in _elementNode.tagNodes) {
      if (child is HtmlScriptTagNode) {
        HtmlScriptElement scriptElement = child.scriptElement;
        if (scriptElement is ExternalHtmlScriptElement) {
          Source scriptSource = scriptElement.scriptSource;
          if (scriptSource != null) {
            return A__context.getLibraryElement(scriptSource);
          }
        }
      }
    }
    return null;
  }
  bool _isPublishedAnnotation(ElementAnnotation annotation) {
    A_Element A_element = annotation.element;
    if (A_element != null && A_element.name == "published") {
      return true;
    }
    return false;
  }
  bool _isPublishedField(FieldElement field) {
    List<ElementAnnotation> annotations = field.metadata;
    for (ElementAnnotation annotation in annotations) {
      if (_isPublishedAnnotation(annotation)) {
        return true;
      }
    }
    return false;
  }
  void _reportErrorForAttribute(XmlAttributeNode node, ErrorCode A_errorCode, List<Object> A_arguments) {
    _reportErrorForOffset(node.offset, node.length, A_errorCode, A_arguments);
  }
  void _reportErrorForAttributeValue(XmlAttributeNode node, ErrorCode A_errorCode, List<Object> A_arguments) {
    Token valueToken = node.valueToken;
    if (valueToken == null || valueToken.isSynthetic) {
      _reportErrorForAttribute(node, A_errorCode, A_arguments);
    } else {
      _reportErrorForToken(valueToken, A_errorCode, A_arguments);
    }
  }
  void _reportErrorForNameToken(PolymerHtmlUnitBuilder_NameToken token, ErrorCode A_errorCode, List<Object> A_arguments) {
    int A_offset = token.C__offset;
    int A_length = token.B__value.length;
    _reportErrorForOffset(A_offset, A_length, A_errorCode, A_arguments);
  }
  void _reportErrorForOffset(int A_offset, int A_length, ErrorCode A_errorCode, List<Object> A_arguments) {
    _errorListener.onError(new A_AnalysisError.D_con2(B__source, A_offset, A_length, A_errorCode, A_arguments));
  }
  void _reportErrorForToken(Token token, ErrorCode A_errorCode, List<Object> A_arguments) {
    int A_offset = token.offset;
    int A_length = token.length;
    _reportErrorForOffset(A_offset, A_length, A_errorCode, A_arguments);
  }
}
class PolymerHtmlUnitBuilder_FoundTagDartElementError extends Error {
  final PolymerTagDartElementImpl B__result;
  PolymerHtmlUnitBuilder_FoundTagDartElementError(this.B__result);
}
class PolymerHtmlUnitBuilder_NameToken {
  final int C__offset;
  final String B__value;
  PolymerHtmlUnitBuilder_NameToken(this.C__offset, this.B__value);
}
class PolymerHtmlUnitResolver extends RecursiveXmlVisitor<Object> {
  final InternalAnalysisContext A__context;
  TypeProvider A__typeProvider;
  final AnalysisErrorListener _errorListener;
  final Source B__source;
  final LineInfo _lineInfo;
  final HtmlUnit F__unit;
  PolymerHtmlUnitResolver(this.A__context, this._errorListener, this.B__source, this._lineInfo, this.F__unit) {
    this.A__typeProvider = A__context.typeProvider;
  }
  void resolveUnit() {}
  Object visitXmlAttributeNode(XmlAttributeNode node) => super.visitXmlAttributeNode(node);
  Object visitXmlTagNode(XmlTagNode node) => super.visitXmlTagNode(node);
}
class PolymerResolveHtmlTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final LineInfo _lineInfo;
  final HtmlUnit F__unit;
  List<A_AnalysisError> A__errors = A_AnalysisError.NO_ERRORS;
  PolymerResolveHtmlTask(InternalAnalysisContext context, this.source, this.modificationTime, this._lineInfo, this.F__unit) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitPolymerResolveHtmlTask(this);
  List<A_AnalysisError> get errors => A__errors;
  String get taskDescription => "resolve as Polymer ${source.fullName}";
  void internalPerform() {
    RecordingErrorListener errorListener = new RecordingErrorListener();
    PolymerHtmlUnitResolver resolver = new PolymerHtmlUnitResolver(context, errorListener, source, _lineInfo, F__unit);
    resolver.resolveUnit();
    A__errors = errorListener.getErrorsForSource(source);
  }
}
class RecordingErrorListener implements AnalysisErrorListener {
  Map<Source, A_p.HashSet<A_AnalysisError>> A__errors = new A_p.HashMap<Source,A_p.HashSet<A_AnalysisError>>();
  void addAll(RecordingErrorListener listener) {
    for (A_AnalysisError A_error in listener.errors) {
      onError(A_error);
    }
  }
  List<A_AnalysisError> get errors {
    Iterable<MapEntry<Source, A_p.HashSet<A_AnalysisError>>> entrySet = getMapEntrySet(A__errors);
    int numEntries = entrySet.length;
    if (numEntries == 0) {
      return A_AnalysisError.NO_ERRORS;
    }
    List<A_AnalysisError> resultList = new List<A_AnalysisError>();
    for (MapEntry<Source, A_p.HashSet<A_AnalysisError>> A_entry in entrySet) {
      resultList.addAll(A_entry.getValue());
    }
    return new List.from(resultList);
  }
  List<A_AnalysisError> getErrorsForSource(Source A_source) {
    A_p.HashSet<A_AnalysisError> errorsForSource = A__errors[A_source];
    if (errorsForSource == null) {
      return A_AnalysisError.NO_ERRORS;
    } else {
      return new List.from(errorsForSource);
    }
  }
  void onError(A_AnalysisError A_error) {
    Source A_source = A_error.source;
    A_p.HashSet<A_AnalysisError> errorsForSource = A__errors[A_source];
    if (A__errors[A_source] == null) {
      errorsForSource = new A_p.HashSet<A_AnalysisError>();
      A__errors[A_source] = errorsForSource;
    }
    errorsForSource.add(A_error);
  }
}
class RecursiveElementVisitor_PolymerHtmlUnitBuilder_findTagDartElement_inLibrary extends RecursiveElementVisitor<Object> {
  final PolymerHtmlUnitBuilder PolymerHtmlUnitBuilder_this;
  RecursiveElementVisitor_PolymerHtmlUnitBuilder_findTagDartElement_inLibrary(this.PolymerHtmlUnitBuilder_this) : super();
  Object visitPolymerTagDartElement(PolymerTagDartElement A_element) {
    if (A_element.name == PolymerHtmlUnitBuilder_this._elementName) {
      throw new PolymerHtmlUnitBuilder_FoundTagDartElementError(A_element as PolymerTagDartElementImpl);
    }
    return null;
  }
}
class RecursiveXmlVisitor_AngularHtmlUnitResolver_hasAngularAnnotation extends RecursiveXmlVisitor<Object> {
  Object visitXmlTagNode(XmlTagNode node) {
    if (node.getAttribute(AngularHtmlUnitResolver._NG_APP) != null) {
      throw new AngularHtmlUnitResolver_FoundAppError();
    }
    return super.visitXmlTagNode(node);
  }
}
class RecursiveXmlVisitor_AngularHtmlUnitResolver_visitModelDirectives extends RecursiveXmlVisitor<Object> {
  final AngularHtmlUnitResolver AngularHtmlUnitResolver_this;
  RecursiveXmlVisitor_AngularHtmlUnitResolver_visitModelDirectives(this.AngularHtmlUnitResolver_this) : super();
  Object visitXmlTagNode(XmlTagNode node) {
    NgModelProcessor directive = NgModelProcessor.B_INSTANCE;
    if (directive.canApply(node)) {
      directive._applyTopDeclarations(AngularHtmlUnitResolver_this, node);
    }
    return super.visitXmlTagNode(node);
  }
}
class RecursiveXmlVisitor_ParseHtmlTask_getLibrarySources extends RecursiveXmlVisitor<Object> {
  final ParseHtmlTask ParseHtmlTask_this;
  List<Source> libraries;
  RecursiveXmlVisitor_ParseHtmlTask_getLibrarySources(this.ParseHtmlTask_this, this.libraries) : super();
  Object visitHtmlScriptTagNode(HtmlScriptTagNode node) {
    XmlAttributeNode scriptAttribute = null;
    for (XmlAttributeNode attribute in node.attributes) {
      if (javaStringEqualsIgnoreCase(attribute.name, ParseHtmlTask._ATTRIBUTE_SRC)) {
        scriptAttribute = attribute;
      }
    }
    if (scriptAttribute != null) {
      try {
        Uri A_uri = new Uri(path: scriptAttribute.text);
        String fileName = A_uri.path;
        Source librarySource = ParseHtmlTask_this.context.sourceFactory.resolveUri(ParseHtmlTask_this.source, fileName);
        if (ParseHtmlTask_this.context.exists(librarySource)) {
          libraries.add(librarySource);
        }
      }on URISyntaxException  catch (e) {}
    }
    return super.visitHtmlScriptTagNode(node);
  }
}
class RecursiveXmlVisitor_ParseHtmlTask_internalPerform extends RecursiveXmlVisitor<Object> {
  final ParseHtmlTask ParseHtmlTask_this;
  RecordingErrorListener errorListener;
  RecursiveXmlVisitor_ParseHtmlTask_internalPerform(this.ParseHtmlTask_this, this.errorListener) : super();
  Object visitHtmlScriptTagNode(HtmlScriptTagNode node) {
    ParseHtmlTask_this._resolveScriptDirectives(node.script, errorListener);
    return null;
  }
}
class RecursiveXmlVisitor_ResolveHtmlTask_internalPerform extends RecursiveXmlVisitor<Object> {
  final ResolveHtmlTask ResolveHtmlTask_this;
  RecordingErrorListener errorListener;
  RecursiveXmlVisitor_ResolveHtmlTask_internalPerform(this.ResolveHtmlTask_this, this.errorListener) : super();
  Object visitHtmlScriptTagNode(HtmlScriptTagNode node) {
    CompilationUnit A_script = node.script;
    if (A_script != null) {
      GenerateDartErrorsTask.validateDirectives(ResolveHtmlTask_this.context, ResolveHtmlTask_this.source, A_script, errorListener);
    }
    return null;
  }
}
class ResolvableCompilationUnit extends TimestampedData<CompilationUnit> {
  final Source source;
  ResolvableCompilationUnit.C_con1(int modificationTime, CompilationUnit unit) : this.C_con2(modificationTime, unit, null);
  ResolvableCompilationUnit.C_con2(int modificationTime, CompilationUnit unit, this.source) : super(modificationTime, unit);
  CompilationUnit get compilationUnit => data;
}
class ResolveAngularComponentTemplateTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final HtmlUnit F__unit;
  final AngularComponentElement _component;
  final AngularApplication A__application;
  HtmlUnit _resolvedUnit;
  List<A_AnalysisError> _resolutionErrors = A_AnalysisError.NO_ERRORS;
  ResolveAngularComponentTemplateTask(InternalAnalysisContext context, this.source, this.modificationTime, this.F__unit, this._component, this.A__application) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitResolveAngularComponentTemplateTask(this);
  List<A_AnalysisError> get resolutionErrors => _resolutionErrors;
  HtmlUnit get resolvedUnit => _resolvedUnit;
  String get taskDescription => "resolve as Angular template ${source}";
  void internalPerform() {
    RecordingErrorListener errorListener = new RecordingErrorListener();
    LineInfo lineInfo = context.getLineInfo(source);
    if (A__application != null) {
      AngularHtmlUnitResolver resolver = new AngularHtmlUnitResolver(context, errorListener, source, lineInfo, F__unit);
      resolver.resolveComponentTemplate(A__application, _component);
      _resolvedUnit = F__unit;
    }
    _resolutionErrors = errorListener.getErrorsForSource(source);
  }
}
class ResolveAngularEntryHtmlTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final HtmlUnit F__unit;
  RecordingErrorListener _errorListener = new RecordingErrorListener();
  HtmlUnit _resolvedUnit;
  HtmlElement F__element = null;
  AngularApplication A__application;
  ResolveAngularEntryHtmlTask(InternalAnalysisContext context, this.source, this.modificationTime, this.F__unit) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitResolveAngularEntryHtmlTask(this);
  AngularApplication get application => A__application;
  HtmlElement get element => F__element;
  List<A_AnalysisError> get entryErrors => _errorListener.getErrorsForSource(source);
  List<A_AnalysisError> getErrors(Source A_source) => _errorListener.getErrorsForSource(A_source);
  HtmlUnit get resolvedUnit => _resolvedUnit;
  String get taskDescription {
    if (source == null) {
      return "resolve as Angular entry point null source";
    }
    return "resolve as Angular entry point ${source.fullName}";
  }
  void internalPerform() {
    LineInfo lineInfo = context.getLineInfo(source);
    A__application = new AngularHtmlUnitResolver(context, _errorListener, source, lineInfo, F__unit).calculateAngularApplication();
    if (A__application != null) {
      new AngularHtmlUnitResolver(context, _errorListener, source, lineInfo, F__unit).resolveEntryPoint(A__application);
    }
    _resolvedUnit = F__unit;
  }
}
class ResolveDartLibraryCycleTask extends AnalysisTask {
  final Source unitSource;
  final Source librarySource;
  final List<ResolvableLibrary> _librariesInCycle;
  LibraryResolver2 _resolver;
  ResolveDartLibraryCycleTask(InternalAnalysisContext context, this.unitSource, this.librarySource, this._librariesInCycle) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitResolveDartLibraryCycleTask(this);
  LibraryResolver2 get libraryResolver => _resolver;
  String get taskDescription {
    if (librarySource == null) {
      return "resolve library null source";
    }
    return "resolve library ${librarySource.fullName}";
  }
  void internalPerform() {
    _resolver = new LibraryResolver2(context);
    _resolver.resolveLibrary(librarySource, _librariesInCycle);
  }
}
class ResolveDartLibraryTask extends AnalysisTask {
  final Source unitSource;
  final Source librarySource;
  LibraryResolver _resolver;
  ResolveDartLibraryTask(InternalAnalysisContext context, this.unitSource, this.librarySource) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitResolveDartLibraryTask(this);
  LibraryResolver get libraryResolver => _resolver;
  String get taskDescription {
    if (librarySource == null) {
      return "resolve library null source";
    }
    return "resolve library ${librarySource.fullName}";
  }
  void internalPerform() {
    _resolver = new LibraryResolver(context);
    _resolver.resolveLibrary(librarySource, true);
  }
}
class ResolveHtmlTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final HtmlUnit F__unit;
  HtmlUnit _resolvedUnit;
  HtmlElement F__element = null;
  List<A_AnalysisError> _resolutionErrors = A_AnalysisError.NO_ERRORS;
  ResolveHtmlTask(InternalAnalysisContext context, this.source, this.modificationTime, this.F__unit) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitResolveHtmlTask(this);
  HtmlElement get element => F__element;
  List<A_AnalysisError> get resolutionErrors => _resolutionErrors;
  HtmlUnit get resolvedUnit => _resolvedUnit;
  String get taskDescription {
    if (source == null) {
      return "resolve as html null source";
    }
    return "resolve as html ${source.fullName}";
  }
  void internalPerform() {
    HtmlUnitBuilder A_builder = new HtmlUnitBuilder(context);
    F__element = A_builder.buildHtmlElement(source, modificationTime, F__unit);
    RecordingErrorListener errorListener = A_builder.errorListener;
    F__unit.accept(new RecursiveXmlVisitor_ResolveHtmlTask_internalPerform(this, errorListener));
    _resolutionErrors = errorListener.getErrorsForSource(source);
    _resolvedUnit = F__unit;
  }
}
class RetentionPriority extends Enum<RetentionPriority> {
  static const RetentionPriority A_LOW = const RetentionPriority('LOW', 0);
  static const RetentionPriority MEDIUM = const RetentionPriority('MEDIUM', 1);
  static const RetentionPriority HIGH = const RetentionPriority('HIGH', 2);
  const RetentionPriority(String A_name, int ordinal) : super(A_name, ordinal);
}
class ScanDartTask extends AnalysisTask {
  final Source source;
  final int modificationTime;
  final String _content;
  A_Token _tokenStream;
  LineInfo _lineInfo;
  List<A_AnalysisError> A__errors = A_AnalysisError.NO_ERRORS;
  ScanDartTask(InternalAnalysisContext context, this.source, this.modificationTime, this._content) : super(context);
  accept(AnalysisTaskVisitor visitor) => visitor.visitScanDartTask(this);
  List<A_AnalysisError> get errors => A__errors;
  LineInfo get lineInfo => _lineInfo;
  A_Token get tokenStream => _tokenStream;
  String get taskDescription {
    if (source == null) {
      return "scan as dart null source";
    }
    return "scan as dart ${source.fullName}";
  }
  void internalPerform() {
    RecordingErrorListener errorListener = new RecordingErrorListener();
    TimeCounter_TimeCounterHandle timeCounterScan = PerformanceStatistics.scan.start();
    try {
      Scanner scanner = new Scanner(source, new CharSequenceReader(_content), errorListener);
      scanner.preserveComments = context.analysisOptions.preserveComments;
      _tokenStream = scanner.tokenize();
      _lineInfo = new LineInfo(scanner.lineStarts);
      A__errors = errorListener.getErrorsForSource(source);
    } catch (exception, A_stackTrace) {
      throw new AnalysisException("Exception", new CaughtException(exception, A_stackTrace));
    } finally {
      timeCounterScan.stop();
    }
  }
}
class SdkAnalysisContext extends AnalysisContextImpl {
  AnalysisCache createCacheFromSourceFactory(SourceFactory factory) {
    if (factory == null) {
      return super.createCacheFromSourceFactory(factory);
    }
    DartSdk sdk = factory.dartSdk;
    if (sdk == null) {
      throw new IllegalArgumentException("The source factory for an SDK analysis context must have a DartUriResolver");
    }
    return new AnalysisCache(<CachePartition>[AnalysisEngine.A_instance.partitionManager.forSdk(sdk)]);
  }
}
class SdkCachePartition extends CachePartition {
  SdkCachePartition(int maxCacheSize) : super(maxCacheSize, DefaultRetentionPolicy.POLICY);
  bool contains(Source A_source) => A_source.isInSystemLibrary;
}
abstract class SourceEntry {
  static final DataDescriptor<String> A_CONTENT = new DataDescriptor<String>("DartEntry.CONTENT");
  static final DataDescriptor<LineInfo> LINE_INFO = new DataDescriptor<LineInfo>("SourceEntry.LINE_INFO");
  CaughtException get exception;
  SourceKind get kind;
  int get modificationTime;
  CacheState getState(DataDescriptor descriptor);
  Object getValue(DataDescriptor descriptor);
  SourceEntryImpl get writableCopy;
}
abstract class SourceEntryImpl implements SourceEntry {
  int _modificationTime = 0;
  int A__flags = 0;
  CaughtException A__exception;
  CacheState _contentState = CacheState.INVALID;
  String _content;
  CacheState _lineInfoState = CacheState.INVALID;
  LineInfo _lineInfo;
  static int _EXPLICITLY_ADDED_FLAG = 0;
  void fixExceptionState() {
    if (hasErrorState) {
      if (A__exception == null) {
        A__exception = new CaughtException(new AnalysisException("State set to ERROR without setting an exception"), null);
      }
    } else {
      A__exception = null;
    }
  }
  String getDiff(SourceEntry oldEntry) {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    writeDiffOn(A_builder, oldEntry);
    return A_builder.toString();
  }
  CaughtException get exception => A__exception;
  int get modificationTime => _modificationTime;
  CacheState getState(DataDescriptor descriptor) {
    if (identical(descriptor, SourceEntry.A_CONTENT)) {
      return _contentState;
    } else if (identical(descriptor, SourceEntry.LINE_INFO)) {
      return _lineInfoState;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  Object getValue(DataDescriptor descriptor) {
    if (identical(descriptor, SourceEntry.A_CONTENT)) {
      return _content;
    } else if (identical(descriptor, SourceEntry.LINE_INFO)) {
      return _lineInfo;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  void invalidateAllInformation() {
    _content = null;
    _contentState = _checkContentState(CacheState.INVALID);
    _lineInfo = null;
    _lineInfoState = CacheState.INVALID;
  }
  void recordContentError(CaughtException A_exception) {
    _content = null;
    _contentState = CacheState.C_ERROR;
    recordScanError(A_exception);
  }
  void recordScanError(CaughtException A_exception) {
    this.exception = A_exception;
    _lineInfo = null;
    _lineInfoState = CacheState.C_ERROR;
  }
  void set explicitlyAdded(bool A_explicitlyAdded) {
    setFlag(_EXPLICITLY_ADDED_FLAG, A_explicitlyAdded);
  }
  void set modificationTime(int time) {
    _modificationTime = time;
  }
  void setState(DataDescriptor descriptor, CacheState state) {
    if (identical(descriptor, SourceEntry.A_CONTENT)) {
      _content = updatedValue(state, _content, null);
      _contentState = _checkContentState(state);
    } else if (identical(descriptor, SourceEntry.LINE_INFO)) {
      _lineInfo = updatedValue(state, _lineInfo, null);
      _lineInfoState = state;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  void setValue(DataDescriptor descriptor, Object A_value) {
    if (identical(descriptor, SourceEntry.A_CONTENT)) {
      _content = A_value as String;
      _contentState = _checkContentState(CacheState.VALID);
    } else if (identical(descriptor, SourceEntry.LINE_INFO)) {
      _lineInfo = A_value as LineInfo;
      _lineInfoState = CacheState.VALID;
    } else {
      throw new IllegalArgumentException("Invalid descriptor: ${descriptor}");
    }
  }
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    writeOn(A_builder);
    return A_builder.toString();
  }
  void clearFlags(List<int> indexes) {
    for (int i = 0; i < indexes.length; i++) {
      A__flags = BooleanArray.A_set(A__flags, indexes[i], false);
    }
  }
  void copyFrom(SourceEntryImpl A_entry) {
    _modificationTime = A_entry._modificationTime;
    A__flags = A_entry.A__flags;
    A__exception = A_entry.A__exception;
    _contentState = A_entry._contentState;
    _content = A_entry._content;
    _lineInfoState = A_entry._lineInfoState;
    _lineInfo = A_entry._lineInfo;
  }
  bool getFlag(int A_index) => BooleanArray.A_get(A__flags, A_index);
  bool get hasErrorState => _contentState == CacheState.C_ERROR || _lineInfoState == CacheState.C_ERROR;
  void set exception(CaughtException A_exception) {
    if (A_exception == null) {
      throw new IllegalArgumentException("exception cannot be null");
    }
    this.A__exception = A_exception;
  }
  void setFlag(int A_index, bool A_value) {
    A__flags = BooleanArray.A_set(A__flags, A_index, A_value);
  }
  Object updatedValue(CacheState state, Object currentValue, Object A_defaultValue) {
    if (state == CacheState.VALID) {
      throw new IllegalArgumentException("Use setValue() to set the state to VALID");
    } else if (state == CacheState.IN_PROCESS) {
      return currentValue;
    }
    return A_defaultValue;
  }
  bool writeDiffOn(JavaStringBuilder A_builder, SourceEntry oldEntry) {
    bool needsSeparator = false;
    CaughtException oldException = oldEntry.exception;
    if (!identical(oldException, A__exception)) {
      A_builder.append("exception = ");
      A_builder.append(oldException.runtimeType);
      A_builder.append(" -> ");
      A_builder.append(A__exception.runtimeType);
      needsSeparator = true;
    }
    int oldModificationTime = oldEntry.modificationTime;
    if (oldModificationTime != _modificationTime) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append("time = ");
      A_builder.append(oldModificationTime);
      A_builder.append(" -> ");
      A_builder.append(_modificationTime);
      needsSeparator = true;
    }
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, SourceEntry.A_CONTENT, "content");
    needsSeparator = writeStateDiffOn(A_builder, needsSeparator, oldEntry, SourceEntry.LINE_INFO, "lineInfo");
    return needsSeparator;
  }
  void writeOn(JavaStringBuilder A_builder) {
    A_builder.append("time = ");
    A_builder.append(_modificationTime);
    A_builder.append("; content = ");
    A_builder.append(_contentState);
    A_builder.append("; lineInfo = ");
    A_builder.append(_lineInfoState);
  }
  bool writeStateDiffOn(JavaStringBuilder A_builder, bool needsSeparator, SourceEntry oldEntry, DataDescriptor descriptor, String label) {
    CacheState oldState = oldEntry.getState(descriptor);
    CacheState newState = getState(descriptor);
    if (oldState != newState) {
      if (needsSeparator) {
        A_builder.append("; ");
      }
      A_builder.append(label);
      A_builder.append(" = ");
      A_builder.append(oldState);
      A_builder.append(" -> ");
      A_builder.append(newState);
      return true;
    }
    return needsSeparator;
  }
  CacheState _checkContentState(CacheState newState) {
    if (_contentState == CacheState.C_ERROR) {
      InstrumentationBuilder A_builder = Instrumentation.builder2("SourceEntryImpl-checkContentState");
      A_builder.data3("message", "contentState changing from ${_contentState} to ${newState}");
      A_builder.record(new AnalysisException());
      A_builder.log();
    }
    return newState;
  }
}
class SourcePriority extends Enum<SourcePriority> {
  static const SourcePriority PRIORITY_PART = const SourcePriority('PRIORITY_PART', 0);
  static const SourcePriority B_LIBRARY = const SourcePriority('LIBRARY', 1);
  static const SourcePriority C_UNKNOWN = const SourcePriority('UNKNOWN', 2);
  static const SourcePriority NORMAL_PART = const SourcePriority('NORMAL_PART', 3);
  static const SourcePriority B_HTML = const SourcePriority('HTML', 4);
  static const List<SourcePriority> A_values = const[PRIORITY_PART, B_LIBRARY, C_UNKNOWN, NORMAL_PART, B_HTML];
  const SourcePriority(String A_name, int ordinal) : super(A_name, ordinal);
}
class TimestampedData<E_E> {
  final int modificationTime;
  final E_E data;
  TimestampedData(this.modificationTime, this.data);
}
class UniversalCachePartition extends CachePartition {
  UniversalCachePartition(int maxCacheSize, CacheRetentionPolicy retentionPolicy) : super(maxCacheSize, retentionPolicy);
  bool contains(Source A_source) => true;
}
class WaitForAsyncTask extends AnalysisTask {
  static WaitForAsyncTask _UniqueInstance = new WaitForAsyncTask();
  static WaitForAsyncTask get A_instance => _UniqueInstance;
  WaitForAsyncTask() : super(null);
  accept(AnalysisTaskVisitor visitor) => null;
  String get taskDescription => "Waiting for async analysis";
  void internalPerform() {}
}
class WorkManager {
  List<List<Source>> _workQueues;
  WorkManager() {
    int queueCount = SourcePriority.A_values.length;
    _workQueues = new List<List>(queueCount);
    for (int i = 0; i < queueCount; i++) {
      _workQueues[i] = new List<Source>();
    }
  }
  void add(Source A_source, SourcePriority priority) {
    int queueCount = _workQueues.length;
    int ordinal = priority.ordinal;
    for (int i = 0; i < queueCount; i++) {
      List<Source> queue = _workQueues[i];
      if (i == ordinal) {
        if (!queue.contains(A_source)) {
          queue.add(A_source);
        }
      } else {
        queue.remove(A_source);
      }
    }
  }
  void addFirst(Source A_source, SourcePriority priority) {
    int queueCount = _workQueues.length;
    int ordinal = priority.ordinal;
    for (int i = 0; i < queueCount; i++) {
      List<Source> queue = _workQueues[i];
      if (i == ordinal) {
        queue.remove(A_source);
        queue.insert(0, A_source);
      } else {
        queue.remove(A_source);
      }
    }
  }
  WorkManager_WorkIterator iterator() => new WorkManager_WorkIterator(this);
  void remove(Source A_source) {
    int queueCount = _workQueues.length;
    for (int i = 0; i < queueCount; i++) {
      _workQueues[i].remove(A_source);
    }
  }
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    List<SourcePriority> priorities = SourcePriority.A_values;
    bool needsSeparator = false;
    int queueCount = _workQueues.length;
    for (int i = 0; i < queueCount; i++) {
      List<Source> queue = _workQueues[i];
      if (!queue.isEmpty) {
        if (needsSeparator) {
          A_builder.append("; ");
        }
        A_builder.append(priorities[i]);
        A_builder.append(": ");
        int queueSize = queue.length;
        for (int j = 0; j < queueSize; j++) {
          if (j > 0) {
            A_builder.append(", ");
          }
          A_builder.append(queue[j].fullName);
        }
        needsSeparator = true;
      }
    }
    return A_builder.toString();
  }
}
class WorkManager_WorkIterator {
  final WorkManager WorkManager_this;
  int _queueIndex = 0;
  int C__index = -1;
  WorkManager_WorkIterator(this.WorkManager_this) {
    _advance();
  }
  bool get hasNext => _queueIndex < WorkManager_this._workQueues.length;
  Source next() {
    if (!hasNext) {
      throw new NoSuchElementException();
    }
    Source A_source = WorkManager_this._workQueues[_queueIndex][C__index];
    _advance();
    return A_source;
  }
  void _advance() {
    C__index++;
    if (C__index >= WorkManager_this._workQueues[_queueIndex].length) {
      C__index = 0;
      _queueIndex++;
      while (_queueIndex < WorkManager_this._workQueues.length && WorkManager_this._workQueues[_queueIndex].isEmpty) {
        _queueIndex++;
      }
    }
  }
}
class A_AnalysisError {
  static List<A_AnalysisError> NO_ERRORS = new List<A_AnalysisError>(0);
  final ErrorCode errorCode;
  String A__message;
  String _correction;
  Source source;
  int D__offset = 0;
  int A__length = 0;
  bool isStaticOnly = false;
  A_AnalysisError.D_con1(this.source, this.errorCode, List<Object> A_arguments) {
    this.A__message = JavaString.A_format(errorCode.message, A_arguments);
  }
  A_AnalysisError.D_con2(this.source, int A_offset, int A_length, this.errorCode, List<Object> A_arguments) {
    this.D__offset = A_offset;
    this.A__length = A_length;
    this.A__message = JavaString.A_format(errorCode.message, A_arguments);
    String correctionTemplate = errorCode.correction;
    if (correctionTemplate != null) {
      this._correction = JavaString.A_format(correctionTemplate, A_arguments);
    }
  }
  bool operator==(Object obj) {
    if (identical(obj, this)) {
      return true;
    }
    if (obj is! A_AnalysisError) {
      return false;
    }
    A_AnalysisError other = obj as A_AnalysisError;
    if (!identical(errorCode, other.errorCode)) {
      return false;
    }
    if (D__offset != other.D__offset || A__length != other.A__length) {
      return false;
    }
    if (isStaticOnly != other.isStaticOnly) {
      return false;
    }
    if (A__message != other.A__message) {
      return false;
    }
    if (source != other.source) {
      return false;
    }
    return true;
  }
  String get correction => _correction;
  int get length => A__length;
  String get message => A__message;
  int get offset => D__offset;
  Object getProperty(ErrorProperty property) => null;
  int get hashCode {
    int A_hashCode = D__offset;
    A_hashCode ^= (A__message != null) ? A__message.hashCode : 0;
    A_hashCode ^= (source != null) ? source.hashCode : 0;
    return A_hashCode;
  }
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append((source != null) ? source.fullName : "<unknown source>");
    A_builder.append("(");
    A_builder.append(D__offset);
    A_builder.append("..");
    A_builder.append(D__offset + A__length - 1);
    A_builder.append("): ");
    A_builder.append(A__message);
    return A_builder.toString();
  }
}
abstract class AnalysisErrorListener {
  static final AnalysisErrorListener NULL_LISTENER = new AnalysisErrorListener_NULL_LISTENER();
  void onError(A_AnalysisError A_error);
}
class AnalysisErrorListener_NULL_LISTENER implements AnalysisErrorListener {
  void onError(A_AnalysisError event) {}
}
class AnalysisErrorWithProperties extends A_AnalysisError {
  A_p.HashMap<ErrorProperty, Object> A__propertyMap = new A_p.HashMap<ErrorProperty,Object>();
  AnalysisErrorWithProperties.D_con2(Source A_source, int A_offset, int A_length, ErrorCode A_errorCode, List<Object> A_arguments) : super.D_con2(A_source, A_offset, A_length, A_errorCode, A_arguments);
  Object getProperty(ErrorProperty property) => A__propertyMap[property];
  void setProperty(ErrorProperty property, Object A_value) {
    A__propertyMap[property] = A_value;
  }
}
class AngularCode extends Enum<AngularCode> implements ErrorCode {
  static const AngularCode CANNOT_PARSE_SELECTOR = const AngularCode('CANNOT_PARSE_SELECTOR', 0, "The selector '%s' cannot be parsed");
  static const AngularCode INVALID_FORMATTER_NAME = const AngularCode('INVALID_FORMATTER_NAME', 1, "Formatter name must be a simple identifier");
  static const AngularCode INVALID_PROPERTY_KIND = const AngularCode('INVALID_PROPERTY_KIND', 2, "Unknown property binding kind '%s', use one of the '@', '=>', '=>!' or '<=>'");
  static const AngularCode INVALID_PROPERTY_FIELD = const AngularCode('INVALID_PROPERTY_FIELD', 3, "Unknown property field '%s'");
  static const AngularCode INVALID_PROPERTY_MAP = const AngularCode('INVALID_PROPERTY_MAP', 4, "Argument 'map' must be a constant map literal");
  static const AngularCode INVALID_PROPERTY_NAME = const AngularCode('INVALID_PROPERTY_NAME', 5, "Property name must be a string literal");
  static const AngularCode INVALID_PROPERTY_SPEC = const AngularCode('INVALID_PROPERTY_SPEC', 6, "Property binding specification must be a string literal");
  static const AngularCode A_INVALID_URI = const AngularCode('INVALID_URI', 9, "Invalid URI syntax: '%s'");
  static const AngularCode MISSING_FORMATTER_COLON = const AngularCode('MISSING_FORMATTER_COLON', 10, "Missing ':' before formatter argument");
  static const AngularCode MISSING_NAME = const AngularCode('MISSING_NAME', 11, "Argument 'name' must be provided");
  static const AngularCode MISSING_PUBLISH_AS = const AngularCode('MISSING_PUBLISH_AS', 12, "Argument 'publishAs' must be provided");
  static const AngularCode MISSING_SELECTOR = const AngularCode('MISSING_SELECTOR', 13, "Argument 'selector' must be provided");
  static const AngularCode URI_DOES_NOT_EXIST = const AngularCode('URI_DOES_NOT_EXIST', 14, "Target of URI does not exist: '%s'");
  final String message;
  const AngularCode(String A_name, int ordinal, this.message) : super(A_name, ordinal);
  String get correction => null;
  ErrorSeverity get errorSeverity => ErrorSeverity.INFO;
  ErrorType get type => ErrorType.ANGULAR;
}
class BooleanErrorListener implements AnalysisErrorListener {
  bool _errorReported = false;
  bool get errorReported => _errorReported;
  void onError(A_AnalysisError A_error) {
    _errorReported = true;
  }
}
class CompileTimeErrorCode extends Enum<CompileTimeErrorCode> implements ErrorCode {
  static const CompileTimeErrorCode AMBIGUOUS_EXPORT = const CompileTimeErrorCode.D_con1('AMBIGUOUS_EXPORT', 1, "The name '%s' is defined in the libraries '%s' and '%s'");
  static const CompileTimeErrorCode BUILT_IN_IDENTIFIER_AS_TYPE = const CompileTimeErrorCode.D_con1('BUILT_IN_IDENTIFIER_AS_TYPE', 3, "The built-in identifier '%s' cannot be as a type");
  static const CompileTimeErrorCode BUILT_IN_IDENTIFIER_AS_TYPE_NAME = const CompileTimeErrorCode.D_con1('BUILT_IN_IDENTIFIER_AS_TYPE_NAME', 4, "The built-in identifier '%s' cannot be used as a type name");
  static const CompileTimeErrorCode BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME = const CompileTimeErrorCode.D_con1('BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME', 5, "The built-in identifier '%s' cannot be used as a type alias name");
  static const CompileTimeErrorCode BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME = const CompileTimeErrorCode.D_con1('BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME', 6, "The built-in identifier '%s' cannot be used as a type parameter name");
  static const CompileTimeErrorCode CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS = const CompileTimeErrorCode.D_con1('CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS', 7, "The switch case expression type '%s' cannot override the == operator");
  static const CompileTimeErrorCode CONFLICTING_GETTER_AND_METHOD = const CompileTimeErrorCode.D_con1('CONFLICTING_GETTER_AND_METHOD', 9, "Class '%s' cannot have both getter '%s.%s' and method with the same name");
  static const CompileTimeErrorCode CONFLICTING_METHOD_AND_GETTER = const CompileTimeErrorCode.D_con1('CONFLICTING_METHOD_AND_GETTER', 10, "Class '%s' cannot have both method '%s.%s' and getter with the same name");
  static const CompileTimeErrorCode CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD = const CompileTimeErrorCode.D_con1('CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD', 11, "'%s' cannot be used to name a constructor and a field in this class");
  static const CompileTimeErrorCode CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD = const CompileTimeErrorCode.D_con1('CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD', 12, "'%s' cannot be used to name a constructor and a method in this class");
  static const CompileTimeErrorCode CONFLICTING_TYPE_VARIABLE_AND_CLASS = const CompileTimeErrorCode.D_con1('CONFLICTING_TYPE_VARIABLE_AND_CLASS', 13, "'%s' cannot be used to name a type varaible in a class with the same name");
  static const CompileTimeErrorCode CONFLICTING_TYPE_VARIABLE_AND_MEMBER = const CompileTimeErrorCode.D_con1('CONFLICTING_TYPE_VARIABLE_AND_MEMBER', 14, "'%s' cannot be used to name a type varaible and member in this class");
  static const CompileTimeErrorCode CONST_CONSTRUCTOR_THROWS_EXCEPTION = const CompileTimeErrorCode.D_con1('CONST_CONSTRUCTOR_THROWS_EXCEPTION', 15, "'const' constructors cannot throw exceptions");
  static const CompileTimeErrorCode CONST_CONSTRUCTOR_WITH_FIELD_INITIALIZED_BY_NON_CONST = const CompileTimeErrorCode.D_con1('CONST_CONSTRUCTOR_WITH_FIELD_INITIALIZED_BY_NON_CONST', 16, "Can't define the 'const' constructor because the field '%s' is initialized with a non-constant value");
  static const CompileTimeErrorCode CONST_CONSTRUCTOR_WITH_MIXIN = const CompileTimeErrorCode.D_con1('CONST_CONSTRUCTOR_WITH_MIXIN', 17, "Constant constructor cannot be declared for a class with a mixin");
  static const CompileTimeErrorCode CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER = const CompileTimeErrorCode.D_con1('CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER', 18, "Constant constructor cannot call non-constant super constructor of '%s'");
  static const CompileTimeErrorCode CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD = const CompileTimeErrorCode.D_con1('CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD', 19, "Cannot define the 'const' constructor for a class with non-final fields");
  static const CompileTimeErrorCode CONST_DEFERRED_CLASS = const CompileTimeErrorCode.D_con1('CONST_DEFERRED_CLASS', 20, "Deferred classes cannot be created with 'const'");
  static const CompileTimeErrorCode CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE = const CompileTimeErrorCode.D_con1('CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE', 21, "The initializer type '%s' cannot be assigned to the field type '%s'");
  static const CompileTimeErrorCode CONST_FORMAL_PARAMETER = const CompileTimeErrorCode.D_con1('CONST_FORMAL_PARAMETER', 22, "Parameters cannot be 'const'");
  static const CompileTimeErrorCode CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE = const CompileTimeErrorCode.D_con1('CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE', 23, "'const' variables must be constant value");
  static const CompileTimeErrorCode CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY', 24, "Constant values from a deferred library cannot be used to initialized a 'const' variable");
  static const CompileTimeErrorCode CONST_INSTANCE_FIELD = const CompileTimeErrorCode.D_con1('CONST_INSTANCE_FIELD', 25, "Only static fields can be declared as 'const'");
  static const CompileTimeErrorCode CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS = const CompileTimeErrorCode.D_con1('CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS', 26, "The constant map entry key expression type '%s' cannot override the == operator");
  static const CompileTimeErrorCode CONST_NOT_INITIALIZED = const CompileTimeErrorCode.D_con1('CONST_NOT_INITIALIZED', 27, "The const variable '%s' must be initialized");
  static const CompileTimeErrorCode CONST_EVAL_TYPE_BOOL = const CompileTimeErrorCode.D_con1('CONST_EVAL_TYPE_BOOL', 28, "An expression of type 'bool' was expected");
  static const CompileTimeErrorCode CONST_EVAL_TYPE_BOOL_NUM_STRING = const CompileTimeErrorCode.D_con1('CONST_EVAL_TYPE_BOOL_NUM_STRING', 29, "An expression of type 'bool', 'num', 'String' or 'null' was expected");
  static const CompileTimeErrorCode CONST_EVAL_TYPE_INT = const CompileTimeErrorCode.D_con1('CONST_EVAL_TYPE_INT', 30, "An expression of type 'int' was expected");
  static const CompileTimeErrorCode CONST_EVAL_TYPE_NUM = const CompileTimeErrorCode.D_con1('CONST_EVAL_TYPE_NUM', 31, "An expression of type 'num' was expected");
  static const CompileTimeErrorCode CONST_EVAL_THROWS_EXCEPTION = const CompileTimeErrorCode.D_con1('CONST_EVAL_THROWS_EXCEPTION', 32, "Evaluation of this constant expression causes exception");
  static const CompileTimeErrorCode CONST_EVAL_THROWS_IDBZE = const CompileTimeErrorCode.D_con1('CONST_EVAL_THROWS_IDBZE', 33, "Evaluation of this constant expression throws IntegerDivisionByZeroException");
  static const CompileTimeErrorCode CONST_WITH_INVALID_TYPE_PARAMETERS = const CompileTimeErrorCode.D_con1('CONST_WITH_INVALID_TYPE_PARAMETERS', 34, "The type '%s' is declared with %d type parameters, but %d type arguments were given");
  static const CompileTimeErrorCode CONST_WITH_NON_CONST = const CompileTimeErrorCode.D_con1('CONST_WITH_NON_CONST', 35, "The constructor being called is not a 'const' constructor");
  static const CompileTimeErrorCode CONST_WITH_NON_CONSTANT_ARGUMENT = const CompileTimeErrorCode.D_con1('CONST_WITH_NON_CONSTANT_ARGUMENT', 36, "Arguments of a constant creation must be constant expressions");
  static const CompileTimeErrorCode CONST_WITH_NON_TYPE = const CompileTimeErrorCode.D_con1('CONST_WITH_NON_TYPE', 37, "The name '%s' is not a class");
  static const CompileTimeErrorCode CONST_WITH_TYPE_PARAMETERS = const CompileTimeErrorCode.D_con1('CONST_WITH_TYPE_PARAMETERS', 38, "The constant creation cannot use a type parameter");
  static const CompileTimeErrorCode CONST_WITH_UNDEFINED_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('CONST_WITH_UNDEFINED_CONSTRUCTOR', 39, "The class '%s' does not have a constant constructor '%s'");
  static const CompileTimeErrorCode CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT = const CompileTimeErrorCode.D_con1('CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT', 40, "The class '%s' does not have a default constant constructor");
  static const CompileTimeErrorCode DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS = const CompileTimeErrorCode.D_con1('DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS', 41, "Default values aren't allowed in typedefs");
  static const CompileTimeErrorCode DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER = const CompileTimeErrorCode.D_con1('DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER', 42, "Default values aren't allowed in function type parameters");
  static const CompileTimeErrorCode DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR', 43, "Default values aren't allowed in factory constructors that redirect to another constructor");
  static const CompileTimeErrorCode DUPLICATE_CONSTRUCTOR_DEFAULT = const CompileTimeErrorCode.D_con1('DUPLICATE_CONSTRUCTOR_DEFAULT', 44, "The default constructor is already defined");
  static const CompileTimeErrorCode DUPLICATE_CONSTRUCTOR_NAME = const CompileTimeErrorCode.D_con1('DUPLICATE_CONSTRUCTOR_NAME', 45, "The constructor with name '%s' is already defined");
  static const CompileTimeErrorCode DUPLICATE_DEFINITION = const CompileTimeErrorCode.D_con1('DUPLICATE_DEFINITION', 46, "The name '%s' is already defined");
  static const CompileTimeErrorCode DUPLICATE_DEFINITION_INHERITANCE = const CompileTimeErrorCode.D_con1('DUPLICATE_DEFINITION_INHERITANCE', 47, "The name '%s' is already defined in '%s'");
  static const CompileTimeErrorCode DUPLICATE_NAMED_ARGUMENT = const CompileTimeErrorCode.D_con1('DUPLICATE_NAMED_ARGUMENT', 48, "The argument for the named parameter '%s' was already specified");
  static const CompileTimeErrorCode EXPORT_INTERNAL_LIBRARY = const CompileTimeErrorCode.D_con1('EXPORT_INTERNAL_LIBRARY', 49, "The library '%s' is internal and cannot be exported");
  static const CompileTimeErrorCode EXPORT_OF_NON_LIBRARY = const CompileTimeErrorCode.D_con1('EXPORT_OF_NON_LIBRARY', 50, "The exported library '%s' must not have a part-of directive");
  static const CompileTimeErrorCode EXTENDS_NON_CLASS = const CompileTimeErrorCode.D_con1('EXTENDS_NON_CLASS', 52, "Classes can only extend other classes");
  static const CompileTimeErrorCode EXTENDS_DISALLOWED_CLASS = const CompileTimeErrorCode.D_con1('EXTENDS_DISALLOWED_CLASS', 53, "Classes cannot extend '%s'");
  static const CompileTimeErrorCode EXTENDS_DEFERRED_CLASS = const CompileTimeErrorCode.D_con1('EXTENDS_DEFERRED_CLASS', 54, "This class cannot extend the deferred class '%s'");
  static const CompileTimeErrorCode EXTRA_POSITIONAL_ARGUMENTS = const CompileTimeErrorCode.D_con1('EXTRA_POSITIONAL_ARGUMENTS', 55, "%d positional arguments expected, but %d found");
  static const CompileTimeErrorCode FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS = const CompileTimeErrorCode.D_con1('FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS', 56, "The field '%s' cannot be initialized twice in the same constructor");
  static const CompileTimeErrorCode FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER = const CompileTimeErrorCode.D_con1('FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER', 57, "Fields cannot be initialized in both the parameter list and the initializers");
  static const CompileTimeErrorCode FINAL_INITIALIZED_MULTIPLE_TIMES = const CompileTimeErrorCode.D_con1('FINAL_INITIALIZED_MULTIPLE_TIMES', 58, "'%s' is a final field and so can only be set once");
  static const CompileTimeErrorCode FIELD_INITIALIZER_FACTORY_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('FIELD_INITIALIZER_FACTORY_CONSTRUCTOR', 59, "Initializing formal fields cannot be used in factory constructors");
  static const CompileTimeErrorCode FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR', 60, "Initializing formal fields can only be used in constructors");
  static const CompileTimeErrorCode FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR', 61, "The redirecting constructor cannot have a field initializer");
  static const CompileTimeErrorCode GETTER_AND_METHOD_WITH_SAME_NAME = const CompileTimeErrorCode.D_con1('GETTER_AND_METHOD_WITH_SAME_NAME', 62, "'%s' cannot be used to name a getter, there is already a method with the same name");
  static const CompileTimeErrorCode IMPLEMENTS_DEFERRED_CLASS = const CompileTimeErrorCode.D_con1('IMPLEMENTS_DEFERRED_CLASS', 63, "This class cannot implement the deferred class '%s'");
  static const CompileTimeErrorCode IMPLEMENTS_DISALLOWED_CLASS = const CompileTimeErrorCode.D_con1('IMPLEMENTS_DISALLOWED_CLASS', 64, "Classes cannot implement '%s'");
  static const CompileTimeErrorCode IMPLEMENTS_DYNAMIC = const CompileTimeErrorCode.D_con1('IMPLEMENTS_DYNAMIC', 65, "Classes cannot implement 'dynamic'");
  static const CompileTimeErrorCode IMPLEMENTS_NON_CLASS = const CompileTimeErrorCode.D_con1('IMPLEMENTS_NON_CLASS', 67, "Classes can only implement other classes");
  static const CompileTimeErrorCode IMPLEMENTS_REPEATED = const CompileTimeErrorCode.D_con1('IMPLEMENTS_REPEATED', 68, "'%s' can only be implemented once");
  static const CompileTimeErrorCode IMPLEMENTS_SUPER_CLASS = const CompileTimeErrorCode.D_con1('IMPLEMENTS_SUPER_CLASS', 69, "'%s' cannot be used in both 'extends' and 'implements' clauses");
  static const CompileTimeErrorCode IMPLICIT_THIS_REFERENCE_IN_INITIALIZER = const CompileTimeErrorCode.D_con1('IMPLICIT_THIS_REFERENCE_IN_INITIALIZER', 70, "Only static members can be accessed in initializers");
  static const CompileTimeErrorCode IMPORT_INTERNAL_LIBRARY = const CompileTimeErrorCode.D_con1('IMPORT_INTERNAL_LIBRARY', 71, "The library '%s' is internal and cannot be imported");
  static const CompileTimeErrorCode IMPORT_OF_NON_LIBRARY = const CompileTimeErrorCode.D_con1('IMPORT_OF_NON_LIBRARY', 72, "The imported library '%s' must not have a part-of directive");
  static const CompileTimeErrorCode INCONSISTENT_CASE_EXPRESSION_TYPES = const CompileTimeErrorCode.D_con1('INCONSISTENT_CASE_EXPRESSION_TYPES', 73, "Case expressions must have the same types, '%s' is not a '%s'");
  static const CompileTimeErrorCode INITIALIZER_FOR_NON_EXISTANT_FIELD = const CompileTimeErrorCode.D_con1('INITIALIZER_FOR_NON_EXISTANT_FIELD', 74, "'%s' is not a variable in the enclosing class");
  static const CompileTimeErrorCode INITIALIZER_FOR_STATIC_FIELD = const CompileTimeErrorCode.D_con1('INITIALIZER_FOR_STATIC_FIELD', 75, "'%s' is a static variable in the enclosing class, variables initialized in a constructor cannot be static");
  static const CompileTimeErrorCode INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD = const CompileTimeErrorCode.D_con1('INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD', 76, "'%s' is not a variable in the enclosing class");
  static const CompileTimeErrorCode INITIALIZING_FORMAL_FOR_STATIC_FIELD = const CompileTimeErrorCode.D_con1('INITIALIZING_FORMAL_FOR_STATIC_FIELD', 77, "'%s' is a static field in the enclosing class, fields initialized in a constructor cannot be static");
  static const CompileTimeErrorCode INSTANCE_MEMBER_ACCESS_FROM_FACTORY = const CompileTimeErrorCode.D_con1('INSTANCE_MEMBER_ACCESS_FROM_FACTORY', 78, "Instance members cannot be accessed from a factory constructor");
  static const CompileTimeErrorCode INSTANCE_MEMBER_ACCESS_FROM_STATIC = const CompileTimeErrorCode.D_con1('INSTANCE_MEMBER_ACCESS_FROM_STATIC', 79, "Instance members cannot be accessed from a static method");
  static const CompileTimeErrorCode INVALID_ANNOTATION = const CompileTimeErrorCode.D_con1('INVALID_ANNOTATION', 81, "Annotation can be only constant variable or constant constructor invocation");
  static const CompileTimeErrorCode INVALID_ANNOTATION_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('INVALID_ANNOTATION_FROM_DEFERRED_LIBRARY', 82, "Constant values from a deferred library cannot be used as annotations");
  static const CompileTimeErrorCode INVALID_CONSTANT = const CompileTimeErrorCode.D_con1('INVALID_CONSTANT', 83, "Invalid constant value");
  static const CompileTimeErrorCode INVALID_CONSTRUCTOR_NAME = const CompileTimeErrorCode.D_con1('INVALID_CONSTRUCTOR_NAME', 84, "Invalid constructor name");
  static const CompileTimeErrorCode INVALID_FACTORY_NAME_NOT_A_CLASS = const CompileTimeErrorCode.D_con1('INVALID_FACTORY_NAME_NOT_A_CLASS', 85, "The name of the immediately enclosing class expected");
  static const CompileTimeErrorCode INVALID_REFERENCE_TO_THIS = const CompileTimeErrorCode.D_con1('INVALID_REFERENCE_TO_THIS', 86, "Invalid reference to 'this' expression");
  static const CompileTimeErrorCode INVALID_TYPE_ARGUMENT_IN_CONST_LIST = const CompileTimeErrorCode.D_con1('INVALID_TYPE_ARGUMENT_IN_CONST_LIST', 87, "Constant list literals cannot include a type parameter as a type argument, such as '%s'");
  static const CompileTimeErrorCode INVALID_TYPE_ARGUMENT_IN_CONST_MAP = const CompileTimeErrorCode.D_con1('INVALID_TYPE_ARGUMENT_IN_CONST_MAP', 88, "Constant map literals cannot include a type parameter as a type argument, such as '%s'");
  static const CompileTimeErrorCode A_INVALID_URI = const CompileTimeErrorCode.D_con1('INVALID_URI', 89, "Invalid URI syntax: '%s'");
  static const CompileTimeErrorCode LABEL_IN_OUTER_SCOPE = const CompileTimeErrorCode.D_con1('LABEL_IN_OUTER_SCOPE', 90, "Cannot reference label '%s' declared in an outer method");
  static const CompileTimeErrorCode LABEL_UNDEFINED = const CompileTimeErrorCode.D_con1('LABEL_UNDEFINED', 91, "Cannot reference undefined label '%s'");
  static const CompileTimeErrorCode LIST_ELEMENT_TYPE_NOT_ASSIGNABLE = const CompileTimeErrorCode.D_con1('LIST_ELEMENT_TYPE_NOT_ASSIGNABLE', 92, "The element type '%s' cannot be assigned to the list type '%s'");
  static const CompileTimeErrorCode MAP_KEY_TYPE_NOT_ASSIGNABLE = const CompileTimeErrorCode.D_con1('MAP_KEY_TYPE_NOT_ASSIGNABLE', 93, "The element type '%s' cannot be assigned to the map key type '%s'");
  static const CompileTimeErrorCode MAP_VALUE_TYPE_NOT_ASSIGNABLE = const CompileTimeErrorCode.D_con1('MAP_VALUE_TYPE_NOT_ASSIGNABLE', 94, "The element type '%s' cannot be assigned to the map value type '%s'");
  static const CompileTimeErrorCode MEMBER_WITH_CLASS_NAME = const CompileTimeErrorCode.D_con1('MEMBER_WITH_CLASS_NAME', 95, "Class members cannot have the same name as the enclosing class");
  static const CompileTimeErrorCode METHOD_AND_GETTER_WITH_SAME_NAME = const CompileTimeErrorCode.D_con1('METHOD_AND_GETTER_WITH_SAME_NAME', 96, "'%s' cannot be used to name a method, there is already a getter with the same name");
  static const CompileTimeErrorCode MISSING_CONST_IN_LIST_LITERAL = const CompileTimeErrorCode.D_con1('MISSING_CONST_IN_LIST_LITERAL', 97, "List literals must be prefixed with 'const' when used as a constant expression");
  static const CompileTimeErrorCode MISSING_CONST_IN_MAP_LITERAL = const CompileTimeErrorCode.D_con1('MISSING_CONST_IN_MAP_LITERAL', 98, "Map literals must be prefixed with 'const' when used as a constant expression");
  static const CompileTimeErrorCode MIXIN_DECLARES_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('MIXIN_DECLARES_CONSTRUCTOR', 100, "The class '%s' cannot be used as a mixin because it declares a constructor");
  static const CompileTimeErrorCode MIXIN_DEFERRED_CLASS = const CompileTimeErrorCode.D_con1('MIXIN_DEFERRED_CLASS', 101, "This class cannot mixin the deferred class '%s'");
  static const CompileTimeErrorCode MIXIN_INHERITS_FROM_NOT_OBJECT = const CompileTimeErrorCode.D_con1('MIXIN_INHERITS_FROM_NOT_OBJECT', 102, "The class '%s' cannot be used as a mixin because it extends a class other than Object");
  static const CompileTimeErrorCode MIXIN_OF_DISALLOWED_CLASS = const CompileTimeErrorCode.D_con1('MIXIN_OF_DISALLOWED_CLASS', 103, "Classes cannot mixin '%s'");
  static const CompileTimeErrorCode MIXIN_OF_NON_CLASS = const CompileTimeErrorCode.D_con1('MIXIN_OF_NON_CLASS', 105, "Classes can only mixin other classes");
  static const CompileTimeErrorCode MIXIN_REFERENCES_SUPER = const CompileTimeErrorCode.D_con1('MIXIN_REFERENCES_SUPER', 106, "The class '%s' cannot be used as a mixin because it references 'super'");
  static const CompileTimeErrorCode MIXIN_WITH_NON_CLASS_SUPERCLASS = const CompileTimeErrorCode.D_con1('MIXIN_WITH_NON_CLASS_SUPERCLASS', 107, "Mixin can only be applied to class");
  static const CompileTimeErrorCode MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS = const CompileTimeErrorCode.D_con1('MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS', 108, "Constructor may have at most one 'this' redirection");
  static const CompileTimeErrorCode MULTIPLE_SUPER_INITIALIZERS = const CompileTimeErrorCode.D_con1('MULTIPLE_SUPER_INITIALIZERS', 109, "Constructor may have at most one 'super' initializer");
  static const CompileTimeErrorCode NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS = const CompileTimeErrorCode.D_con1('NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS', 110, "Annotation creation must have arguments");
  static const CompileTimeErrorCode NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT = const CompileTimeErrorCode.D_con1('NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT', 111, "The class '%s' does not have a default constructor");
  static const CompileTimeErrorCode NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT = const CompileTimeErrorCode.D_con1('NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT', 112, "The class '%s' does not have a default constructor");
  static const CompileTimeErrorCode NON_CONST_MAP_AS_EXPRESSION_STATEMENT = const CompileTimeErrorCode.D_con1('NON_CONST_MAP_AS_EXPRESSION_STATEMENT', 113, "A non-constant map literal without type arguments cannot be used as an expression statement");
  static const CompileTimeErrorCode NON_CONSTANT_CASE_EXPRESSION = const CompileTimeErrorCode.D_con1('NON_CONSTANT_CASE_EXPRESSION', 114, "Case expressions must be constant");
  static const CompileTimeErrorCode NON_CONSTANT_CASE_EXPRESSION_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_CASE_EXPRESSION_FROM_DEFERRED_LIBRARY', 115, "Constant values from a deferred library cannot be used as a case expression");
  static const CompileTimeErrorCode NON_CONSTANT_DEFAULT_VALUE = const CompileTimeErrorCode.D_con1('NON_CONSTANT_DEFAULT_VALUE', 116, "Default values of an optional parameter must be constant");
  static const CompileTimeErrorCode NON_CONSTANT_DEFAULT_VALUE_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_DEFAULT_VALUE_FROM_DEFERRED_LIBRARY', 117, "Constant values from a deferred library cannot be used as a default parameter value");
  static const CompileTimeErrorCode NON_CONSTANT_LIST_ELEMENT = const CompileTimeErrorCode.D_con1('NON_CONSTANT_LIST_ELEMENT', 118, "'const' lists must have all constant values");
  static const CompileTimeErrorCode NON_CONSTANT_LIST_ELEMENT_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_LIST_ELEMENT_FROM_DEFERRED_LIBRARY', 119, "Constant values from a deferred library cannot be used as values in a 'const' list");
  static const CompileTimeErrorCode NON_CONSTANT_MAP_KEY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_MAP_KEY', 120, "The keys in a map must be constant");
  static const CompileTimeErrorCode NON_CONSTANT_MAP_KEY_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_MAP_KEY_FROM_DEFERRED_LIBRARY', 121, "Constant values from a deferred library cannot be used as keys in a map");
  static const CompileTimeErrorCode NON_CONSTANT_MAP_VALUE = const CompileTimeErrorCode.D_con1('NON_CONSTANT_MAP_VALUE', 122, "The values in a 'const' map must be constant");
  static const CompileTimeErrorCode NON_CONSTANT_MAP_VALUE_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_MAP_VALUE_FROM_DEFERRED_LIBRARY', 123, "Constant values from a deferred library cannot be used as values in a 'const' map");
  static const CompileTimeErrorCode NON_CONSTANT_ANNOTATION_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('NON_CONSTANT_ANNOTATION_CONSTRUCTOR', 124, "Annotation creation can use only 'const' constructor");
  static const CompileTimeErrorCode NON_CONSTANT_VALUE_IN_INITIALIZER = const CompileTimeErrorCode.D_con1('NON_CONSTANT_VALUE_IN_INITIALIZER', 125, "Initializer expressions in constant constructors must be constants");
  static const CompileTimeErrorCode NON_CONSTANT_VALUE_IN_INITIALIZER_FROM_DEFERRED_LIBRARY = const CompileTimeErrorCode.D_con1('NON_CONSTANT_VALUE_IN_INITIALIZER_FROM_DEFERRED_LIBRARY', 126, "Constant values from a deferred library cannot be used as constant initializers");
  static const CompileTimeErrorCode NOT_ENOUGH_REQUIRED_ARGUMENTS = const CompileTimeErrorCode.D_con1('NOT_ENOUGH_REQUIRED_ARGUMENTS', 127, "%d required argument(s) expected, but %d found");
  static const CompileTimeErrorCode NON_GENERATIVE_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('NON_GENERATIVE_CONSTRUCTOR', 128, "The generative constructor '%s' expected, but factory found");
  static const CompileTimeErrorCode OPTIONAL_PARAMETER_IN_OPERATOR = const CompileTimeErrorCode.D_con1('OPTIONAL_PARAMETER_IN_OPERATOR', 130, "Optional parameters are not allowed when defining an operator");
  static const CompileTimeErrorCode PART_OF_NON_PART = const CompileTimeErrorCode.D_con1('PART_OF_NON_PART', 131, "The included part '%s' must have a part-of directive");
  static const CompileTimeErrorCode PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER = const CompileTimeErrorCode.D_con1('PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER', 132, "The name '%s' is already used as an import prefix and cannot be used to name a top-level element");
  static const CompileTimeErrorCode PRIVATE_OPTIONAL_PARAMETER = const CompileTimeErrorCode.D_con1('PRIVATE_OPTIONAL_PARAMETER', 133, "Named optional parameters cannot start with an underscore");
  static const CompileTimeErrorCode RECURSIVE_CONSTRUCTOR_REDIRECT = const CompileTimeErrorCode.D_con1('RECURSIVE_CONSTRUCTOR_REDIRECT', 135, "Cycle in redirecting generative constructors");
  static const CompileTimeErrorCode RECURSIVE_FACTORY_REDIRECT = const CompileTimeErrorCode.D_con1('RECURSIVE_FACTORY_REDIRECT', 136, "Cycle in redirecting factory constructors");
  static const CompileTimeErrorCode RECURSIVE_INTERFACE_INHERITANCE = const CompileTimeErrorCode.D_con1('RECURSIVE_INTERFACE_INHERITANCE', 137, "'%s' cannot be a superinterface of itself: %s");
  static const CompileTimeErrorCode RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS = const CompileTimeErrorCode.D_con1('RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS', 138, "'%s' cannot extend itself");
  static const CompileTimeErrorCode RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS = const CompileTimeErrorCode.D_con1('RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS', 139, "'%s' cannot implement itself");
  static const CompileTimeErrorCode RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_WITH = const CompileTimeErrorCode.D_con1('RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_WITH', 140, "'%s' cannot use itself as a mixin");
  static const CompileTimeErrorCode REDIRECT_TO_MISSING_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('REDIRECT_TO_MISSING_CONSTRUCTOR', 141, "The constructor '%s' could not be found in '%s'");
  static const CompileTimeErrorCode REDIRECT_TO_NON_CLASS = const CompileTimeErrorCode.D_con1('REDIRECT_TO_NON_CLASS', 142, "The name '%s' is not a type and cannot be used in a redirected constructor");
  static const CompileTimeErrorCode REDIRECT_TO_NON_CONST_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('REDIRECT_TO_NON_CONST_CONSTRUCTOR', 143, "Constant factory constructor cannot delegate to a non-constant constructor");
  static const CompileTimeErrorCode REDIRECT_GENERATIVE_TO_MISSING_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('REDIRECT_GENERATIVE_TO_MISSING_CONSTRUCTOR', 144, "The constructor '%s' could not be found in '%s'");
  static const CompileTimeErrorCode REDIRECT_GENERATIVE_TO_NON_GENERATIVE_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('REDIRECT_GENERATIVE_TO_NON_GENERATIVE_CONSTRUCTOR', 145, "Generative constructor cannot redirect to a factory constructor");
  static const CompileTimeErrorCode REFERENCED_BEFORE_DECLARATION = const CompileTimeErrorCode.D_con1('REFERENCED_BEFORE_DECLARATION', 146, "Local variables cannot be referenced before they are declared");
  static const CompileTimeErrorCode RETHROW_OUTSIDE_CATCH = const CompileTimeErrorCode.D_con1('RETHROW_OUTSIDE_CATCH', 147, "rethrow must be inside of a catch clause");
  static const CompileTimeErrorCode RETURN_IN_GENERATIVE_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('RETURN_IN_GENERATIVE_CONSTRUCTOR', 148, "Constructors cannot return a value");
  static const CompileTimeErrorCode SHARED_DEFERRED_PREFIX = const CompileTimeErrorCode.D_con1('SHARED_DEFERRED_PREFIX', 149, "The prefix of a deferred import cannot be used in other import directives");
  static const CompileTimeErrorCode SUPER_IN_INVALID_CONTEXT = const CompileTimeErrorCode.D_con1('SUPER_IN_INVALID_CONTEXT', 150, "Invalid context for 'super' invocation");
  static const CompileTimeErrorCode SUPER_IN_REDIRECTING_CONSTRUCTOR = const CompileTimeErrorCode.D_con1('SUPER_IN_REDIRECTING_CONSTRUCTOR', 151, "The redirecting constructor cannot have a 'super' initializer");
  static const CompileTimeErrorCode TYPE_ARGUMENT_NOT_MATCHING_BOUNDS = const CompileTimeErrorCode.D_con1('TYPE_ARGUMENT_NOT_MATCHING_BOUNDS', 153, "'%s' does not extend '%s'");
  static const CompileTimeErrorCode TYPE_ALIAS_CANNOT_REFERENCE_ITSELF = const CompileTimeErrorCode.D_con1('TYPE_ALIAS_CANNOT_REFERENCE_ITSELF', 154, "Type alias cannot reference itself directly or recursively via another typedef");
  static const CompileTimeErrorCode UNDEFINED_CLASS = const CompileTimeErrorCode.D_con1('UNDEFINED_CLASS', 155, "Undefined class '%s'");
  static const CompileTimeErrorCode UNDEFINED_CONSTRUCTOR_IN_INITIALIZER = const CompileTimeErrorCode.D_con1('UNDEFINED_CONSTRUCTOR_IN_INITIALIZER', 156, "The class '%s' does not have a generative constructor '%s'");
  static const CompileTimeErrorCode UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT = const CompileTimeErrorCode.D_con1('UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT', 157, "The class '%s' does not have a default generative constructor");
  static const CompileTimeErrorCode UNDEFINED_NAMED_PARAMETER = const CompileTimeErrorCode.D_con1('UNDEFINED_NAMED_PARAMETER', 158, "The named parameter '%s' is not defined");
  static const CompileTimeErrorCode URI_DOES_NOT_EXIST = const CompileTimeErrorCode.D_con1('URI_DOES_NOT_EXIST', 159, "Target of URI does not exist: '%s'");
  static const CompileTimeErrorCode A_URI_WITH_INTERPOLATION = const CompileTimeErrorCode.D_con1('URI_WITH_INTERPOLATION', 160, "URIs cannot use string interpolation");
  static const CompileTimeErrorCode WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR = const CompileTimeErrorCode.D_con1('WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR', 161, "Operator '%s' should declare exactly %d parameter(s), but %d found");
  static const CompileTimeErrorCode WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS = const CompileTimeErrorCode.D_con1('WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS', 162, "Operator '-' should declare 0 or 1 parameter, but %d found");
  static const CompileTimeErrorCode WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER = const CompileTimeErrorCode.D_con1('WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER', 163, "Setters should declare exactly one required parameter");
  final String message;
  final String correction;
  const CompileTimeErrorCode.D_con1(String A_name, int ordinal, String A_message) : this.D_con2(A_name, ordinal, A_message, null);
  const CompileTimeErrorCode.D_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorType.COMPILE_TIME_ERROR.severity;
  ErrorType get type => ErrorType.COMPILE_TIME_ERROR;
}
abstract class ErrorCode {
  String get correction;
  ErrorSeverity get errorSeverity;
  String get message;
  ErrorType get type;
}
class ErrorProperty extends Enum<ErrorProperty> {
  static const ErrorProperty UNIMPLEMENTED_METHODS = const ErrorProperty('UNIMPLEMENTED_METHODS', 0);
  const ErrorProperty(String A_name, int ordinal) : super(A_name, ordinal);
}
class ErrorReporter {
  final AnalysisErrorListener A__errorListener;
  final Source _defaultSource;
  Source C__source;
  ErrorReporter(this.A__errorListener, this._defaultSource) {
    if (A__errorListener == null) {
      throw new IllegalArgumentException("An error listener must be provided");
    } else if (_defaultSource == null) {
      throw new IllegalArgumentException("A default source must be provided");
    }
    this.C__source = _defaultSource;
  }
  AnalysisErrorWithProperties newErrorWithProperties(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) => new AnalysisErrorWithProperties.D_con2(C__source, node.offset, node.length, A_errorCode, A_arguments);
  void reportError(A_AnalysisError A_error) {
    A__errorListener.onError(A_error);
  }
  void reportErrorForElement(ErrorCode A_errorCode, A_Element A_element, List<Object> A_arguments) {
    reportErrorForOffset(A_errorCode, A_element.nameOffset, A_element.displayName.length, A_arguments);
  }
  void reportErrorForNode(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    reportErrorForOffset(A_errorCode, node.offset, node.length, A_arguments);
  }
  void reportErrorForOffset(ErrorCode A_errorCode, int A_offset, int A_length, List<Object> A_arguments) {
    A__errorListener.onError(new A_AnalysisError.D_con2(C__source, A_offset, A_length, A_errorCode, A_arguments));
  }
  void reportErrorForToken(ErrorCode A_errorCode, A_Token token, List<Object> A_arguments) {
    reportErrorForOffset(A_errorCode, token.offset, token.length, A_arguments);
  }
  void reportTypeErrorForNode(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    _convertTypeNames(A_arguments);
    reportErrorForOffset(A_errorCode, node.offset, node.length, A_arguments);
  }
  void set source(Source A_source) {
    this.C__source = A_source == null ? _defaultSource : A_source;
  }
  void _convertTypeNames(List<Object> A_arguments) {
    if (_hasEqualTypeNames(A_arguments)) {
      int count = A_arguments.length;
      for (int i = 0; i < count; i++) {
        Object argument = A_arguments[i];
        if (argument is DartType) {
          DartType A_type = argument;
          A_Element A_element = A_type.element;
          if (A_element == null) {
            A_arguments[i] = A_type.displayName;
          } else {
            A_arguments[i] = A_element.getExtendedDisplayName(A_type.displayName);
          }
        }
      }
    } else {
      int count = A_arguments.length;
      for (int i = 0; i < count; i++) {
        Object argument = A_arguments[i];
        if (argument is DartType) {
          A_arguments[i] = argument.displayName;
        }
      }
    }
  }
  bool _hasEqualTypeNames(List<Object> A_arguments) {
    int count = A_arguments.length;
    A_p.HashSet<String> typeNames = new A_p.HashSet<String>();
    for (int i = 0; i < count; i++) {
      if (A_arguments[i] is DartType && !typeNames.add((A_arguments[i] as DartType).displayName)) {
        return true;
      }
    }
    return false;
  }
}
class ErrorSeverity extends Enum<ErrorSeverity> {
  static const ErrorSeverity INFO = const ErrorSeverity('INFO', 1, "I", "info");
  static const ErrorSeverity A_WARNING = const ErrorSeverity('WARNING', 2, "W", "warning");
  static const ErrorSeverity D_ERROR = const ErrorSeverity('ERROR', 3, "E", "error");
  final String machineCode;
  final String displayName;
  const ErrorSeverity(String A_name, int ordinal, this.machineCode, this.displayName) : super(A_name, ordinal);
}
class ErrorType extends Enum<ErrorType> {
  static const ErrorType TODO = const ErrorType('TODO', 0, ErrorSeverity.INFO);
  static const ErrorType HINT = const ErrorType('HINT', 1, ErrorSeverity.INFO);
  static const ErrorType COMPILE_TIME_ERROR = const ErrorType('COMPILE_TIME_ERROR', 2, ErrorSeverity.D_ERROR);
  static const ErrorType STATIC_WARNING = const ErrorType('STATIC_WARNING', 4, ErrorSeverity.A_WARNING);
  static const ErrorType STATIC_TYPE_WARNING = const ErrorType('STATIC_TYPE_WARNING', 5, ErrorSeverity.A_WARNING);
  static const ErrorType SYNTACTIC_ERROR = const ErrorType('SYNTACTIC_ERROR', 6, ErrorSeverity.D_ERROR);
  static const ErrorType ANGULAR = const ErrorType('ANGULAR', 7, ErrorSeverity.INFO);
  static const ErrorType POLYMER = const ErrorType('POLYMER', 8, ErrorSeverity.INFO);
  final ErrorSeverity severity;
  const ErrorType(String A_name, int ordinal, this.severity) : super(A_name, ordinal);
  String get displayName => name.toLowerCase().replaceAll('_', ' ');
}
class HintCode extends Enum<HintCode> implements ErrorCode {
  static const HintCode ARGUMENT_TYPE_NOT_ASSIGNABLE = const HintCode.D_con1('ARGUMENT_TYPE_NOT_ASSIGNABLE', 0, "The argument type '%s' cannot be assigned to the parameter type '%s'");
  static const HintCode DEAD_CODE = const HintCode.D_con1('DEAD_CODE', 1, "Dead code");
  static const HintCode DEAD_CODE_CATCH_FOLLOWING_CATCH = const HintCode.D_con1('DEAD_CODE_CATCH_FOLLOWING_CATCH', 2, "Dead code, catch clauses after a 'catch (e)' or an 'on Object catch (e)' are never reached");
  static const HintCode DEAD_CODE_ON_CATCH_SUBTYPE = const HintCode.D_con1('DEAD_CODE_ON_CATCH_SUBTYPE', 3, "Dead code, this on-catch block will never be executed since '%s' is a subtype of '%s'");
  static const HintCode DEPRECATED_MEMBER_USE = const HintCode.D_con1('DEPRECATED_MEMBER_USE', 4, "'%s' is deprecated");
  static const HintCode DUPLICATE_IMPORT = const HintCode.D_con1('DUPLICATE_IMPORT', 5, "Duplicate import");
  static const HintCode DIVISION_OPTIMIZATION = const HintCode.D_con1('DIVISION_OPTIMIZATION', 6, "The operator x ~/ y is more efficient than (x / y).toInt()");
  static const HintCode IS_DOUBLE = const HintCode.D_con1('IS_DOUBLE', 7, "When compiled to JS, this test might return true when the left hand side is an int");
  static const HintCode IS_NOT_DOUBLE = const HintCode.D_con1('IS_NOT_DOUBLE', 9, "When compiled to JS, this test might return false when the left hand side is an int");
  static const HintCode IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION = const HintCode.D_con1('IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION', 11, "The library '%s' defines a top-level function named 'loadLibrary' which is hidden by deferring this library");
  static const HintCode INVALID_ASSIGNMENT = const HintCode.D_con1('INVALID_ASSIGNMENT', 12, "A value of type '%s' cannot be assigned to a variable of type '%s'");
  static const HintCode MISSING_RETURN = const HintCode.D_con2('MISSING_RETURN', 13, "This function declares a return type of '%s', but does not end with a return statement", "Either add a return statement or change the return type to 'void'");
  static const HintCode OVERRIDE_ON_NON_OVERRIDING_GETTER = const HintCode.D_con1('OVERRIDE_ON_NON_OVERRIDING_GETTER', 14, "Getter does not override an inherited getter");
  static const HintCode OVERRIDE_ON_NON_OVERRIDING_METHOD = const HintCode.D_con1('OVERRIDE_ON_NON_OVERRIDING_METHOD', 15, "Method does not override an inherited method");
  static const HintCode OVERRIDE_ON_NON_OVERRIDING_SETTER = const HintCode.D_con1('OVERRIDE_ON_NON_OVERRIDING_SETTER', 16, "Setter does not override an inherited setter");
  static const HintCode TYPE_CHECK_IS_NOT_NULL = const HintCode.D_con1('TYPE_CHECK_IS_NOT_NULL', 18, "Tests for non-null should be done with '!= null'");
  static const HintCode TYPE_CHECK_IS_NULL = const HintCode.D_con1('TYPE_CHECK_IS_NULL', 19, "Tests for null should be done with '== null'");
  static const HintCode UNDEFINED_GETTER = const HintCode.D_con1('UNDEFINED_GETTER', 20, "There is no such getter '%s' in '%s'");
  static const HintCode UNDEFINED_METHOD = const HintCode.D_con1('UNDEFINED_METHOD', 21, "The method '%s' is not defined for the class '%s'");
  static const HintCode UNDEFINED_OPERATOR = const HintCode.D_con1('UNDEFINED_OPERATOR', 22, "There is no such operator '%s' in '%s'");
  static const HintCode UNDEFINED_SETTER = const HintCode.D_con1('UNDEFINED_SETTER', 23, "There is no such setter '%s' in '%s'");
  static const HintCode UNNECESSARY_CAST = const HintCode.D_con1('UNNECESSARY_CAST', 24, "Unnecessary cast");
  static const HintCode UNNECESSARY_TYPE_CHECK_FALSE = const HintCode.D_con1('UNNECESSARY_TYPE_CHECK_FALSE', 25, "Unnecessary type check, the result is always false");
  static const HintCode UNNECESSARY_TYPE_CHECK_TRUE = const HintCode.D_con1('UNNECESSARY_TYPE_CHECK_TRUE', 26, "Unnecessary type check, the result is always true");
  static const HintCode UNUSED_IMPORT = const HintCode.D_con1('UNUSED_IMPORT', 27, "Unused import");
  static const HintCode USE_OF_VOID_RESULT = const HintCode.D_con1('USE_OF_VOID_RESULT', 28, "The result of '%s' is being used, even though it is declared to be 'void'");
  final String message;
  final String correction;
  const HintCode.D_con1(String A_name, int ordinal, String A_message) : this.D_con2(A_name, ordinal, A_message, null);
  const HintCode.D_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorType.HINT.severity;
  ErrorType get type => ErrorType.HINT;
}
class HtmlWarningCode extends Enum<HtmlWarningCode> implements ErrorCode {
  static const HtmlWarningCode A_INVALID_URI = const HtmlWarningCode.D_con1('INVALID_URI', 0, "Invalid URI syntax: '%s'");
  static const HtmlWarningCode URI_DOES_NOT_EXIST = const HtmlWarningCode.D_con1('URI_DOES_NOT_EXIST', 1, "Target of URI does not exist: '%s'");
  final String message;
  final String correction;
  const HtmlWarningCode.D_con1(String A_name, int ordinal, String A_message) : this.D_con2(A_name, ordinal, A_message, null);
  const HtmlWarningCode.D_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorSeverity.A_WARNING;
  ErrorType get type => ErrorType.STATIC_WARNING;
}
class PolymerCode extends Enum<PolymerCode> implements ErrorCode {
  static const PolymerCode ATTRIBUTE_FIELD_NOT_PUBLISHED = const PolymerCode('ATTRIBUTE_FIELD_NOT_PUBLISHED', 0, "Field '%s' in '%s' must be @published");
  static const PolymerCode DUPLICATE_ATTRIBUTE_DEFINITION = const PolymerCode('DUPLICATE_ATTRIBUTE_DEFINITION', 1, "The attribute '%s' is already defined");
  static const PolymerCode EMPTY_ATTRIBUTES = const PolymerCode('EMPTY_ATTRIBUTES', 2, "Empty 'attributes' attribute is useless");
  static const PolymerCode INVALID_ATTRIBUTE_NAME = const PolymerCode('INVALID_ATTRIBUTE_NAME', 3, "'%s' is not a valid name for a custom element attribute");
  static const PolymerCode INVALID_TAG_NAME = const PolymerCode('INVALID_TAG_NAME', 4, "'%s' is not a valid name for a custom element");
  static const PolymerCode MISSING_TAG_NAME = const PolymerCode('MISSING_TAG_NAME', 5, "Missing tag name of the custom element. Please include an attribute like name='your-tag-name'");
  static const PolymerCode UNDEFINED_ATTRIBUTE_FIELD = const PolymerCode('UNDEFINED_ATTRIBUTE_FIELD', 6, "There is no such field '%s' in '%s'");
  final String message;
  const PolymerCode(String A_name, int ordinal, this.message) : super(A_name, ordinal);
  String get correction => null;
  ErrorSeverity get errorSeverity => ErrorSeverity.INFO;
  ErrorType get type => ErrorType.POLYMER;
}
class StaticTypeWarningCode extends Enum<StaticTypeWarningCode> implements ErrorCode {
  static const StaticTypeWarningCode EXPECTED_ONE_LIST_TYPE_ARGUMENTS = const StaticTypeWarningCode.D_con1('EXPECTED_ONE_LIST_TYPE_ARGUMENTS', 0, "List literal requires exactly one type arguments or none, but %d found");
  static const StaticTypeWarningCode EXPECTED_TWO_MAP_TYPE_ARGUMENTS = const StaticTypeWarningCode.D_con1('EXPECTED_TWO_MAP_TYPE_ARGUMENTS', 1, "Map literal requires exactly two type arguments or none, but %d found");
  static const StaticTypeWarningCode INCONSISTENT_METHOD_INHERITANCE = const StaticTypeWarningCode.D_con1('INCONSISTENT_METHOD_INHERITANCE', 3, "'%s' is inherited by at least two interfaces inconsistently, from %s");
  static const StaticTypeWarningCode INSTANCE_ACCESS_TO_STATIC_MEMBER = const StaticTypeWarningCode.D_con1('INSTANCE_ACCESS_TO_STATIC_MEMBER', 4, "Static member '%s' cannot be accessed using instance access");
  static const StaticTypeWarningCode INVALID_ASSIGNMENT = const StaticTypeWarningCode.D_con1('INVALID_ASSIGNMENT', 5, "A value of type '%s' cannot be assigned to a variable of type '%s'");
  static const StaticTypeWarningCode INVOCATION_OF_NON_FUNCTION = const StaticTypeWarningCode.D_con1('INVOCATION_OF_NON_FUNCTION', 6, "'%s' is not a method");
  static const StaticTypeWarningCode INVOCATION_OF_NON_FUNCTION_EXPRESSION = const StaticTypeWarningCode.D_con1('INVOCATION_OF_NON_FUNCTION_EXPRESSION', 7, "Cannot invoke a non-function");
  static const StaticTypeWarningCode NON_BOOL_CONDITION = const StaticTypeWarningCode.D_con1('NON_BOOL_CONDITION', 8, "Conditions must have a static type of 'bool'");
  static const StaticTypeWarningCode NON_BOOL_EXPRESSION = const StaticTypeWarningCode.D_con1('NON_BOOL_EXPRESSION', 9, "Assertions must be on either a 'bool' or '() -> bool'");
  static const StaticTypeWarningCode NON_BOOL_NEGATION_EXPRESSION = const StaticTypeWarningCode.D_con1('NON_BOOL_NEGATION_EXPRESSION', 10, "Negation argument must have a static type of 'bool'");
  static const StaticTypeWarningCode NON_BOOL_OPERAND = const StaticTypeWarningCode.D_con1('NON_BOOL_OPERAND', 11, "The operands of the '%s' operator must be assignable to 'bool'");
  static const StaticTypeWarningCode NON_TYPE_AS_TYPE_ARGUMENT = const StaticTypeWarningCode.D_con1('NON_TYPE_AS_TYPE_ARGUMENT', 12, "The name '%s' is not a type and cannot be used as a parameterized type");
  static const StaticTypeWarningCode RETURN_OF_INVALID_TYPE = const StaticTypeWarningCode.D_con1('RETURN_OF_INVALID_TYPE', 13, "The return type '%s' is not a '%s', as defined by the method '%s'");
  static const StaticTypeWarningCode TYPE_ARGUMENT_NOT_MATCHING_BOUNDS = const StaticTypeWarningCode.D_con1('TYPE_ARGUMENT_NOT_MATCHING_BOUNDS', 14, "'%s' does not extend '%s'");
  static const StaticTypeWarningCode TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND = const StaticTypeWarningCode.D_con1('TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND', 15, "'%s' cannot be a supertype of its upper bound");
  static const StaticTypeWarningCode UNDEFINED_FUNCTION = const StaticTypeWarningCode.D_con1('UNDEFINED_FUNCTION', 17, "The function '%s' is not defined");
  static const StaticTypeWarningCode UNDEFINED_GETTER = const StaticTypeWarningCode.D_con1('UNDEFINED_GETTER', 18, "There is no such getter '%s' in '%s'");
  static const StaticTypeWarningCode UNDEFINED_METHOD = const StaticTypeWarningCode.D_con1('UNDEFINED_METHOD', 19, "The method '%s' is not defined for the class '%s'");
  static const StaticTypeWarningCode UNDEFINED_OPERATOR = const StaticTypeWarningCode.D_con1('UNDEFINED_OPERATOR', 20, "There is no such operator '%s' in '%s'");
  static const StaticTypeWarningCode UNDEFINED_SETTER = const StaticTypeWarningCode.D_con1('UNDEFINED_SETTER', 21, "There is no such setter '%s' in '%s'");
  static const StaticTypeWarningCode UNDEFINED_SUPER_METHOD = const StaticTypeWarningCode.D_con1('UNDEFINED_SUPER_METHOD', 22, "There is no such method '%s' in '%s'");
  static const StaticTypeWarningCode UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER = const StaticTypeWarningCode.D_con1('UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER', 23, "Static members from supertypes must be qualified by the name of the defining type");
  static const StaticTypeWarningCode WRONG_NUMBER_OF_TYPE_ARGUMENTS = const StaticTypeWarningCode.D_con1('WRONG_NUMBER_OF_TYPE_ARGUMENTS', 24, "The type '%s' is declared with %d type parameters, but %d type arguments were given");
  final String message;
  final String correction;
  const StaticTypeWarningCode.D_con1(String A_name, int ordinal, String A_message) : this.D_con2(A_name, ordinal, A_message, null);
  const StaticTypeWarningCode.D_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorType.STATIC_TYPE_WARNING.severity;
  ErrorType get type => ErrorType.STATIC_TYPE_WARNING;
}
class StaticWarningCode extends Enum<StaticWarningCode> implements ErrorCode {
  static const StaticWarningCode AMBIGUOUS_IMPORT = const StaticWarningCode.D_con1('AMBIGUOUS_IMPORT', 0, "The name '%s' is defined in the libraries %s");
  static const StaticWarningCode ARGUMENT_TYPE_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('ARGUMENT_TYPE_NOT_ASSIGNABLE', 1, "The argument type '%s' cannot be assigned to the parameter type '%s'");
  static const StaticWarningCode ASSIGNMENT_TO_CONST = const StaticWarningCode.D_con1('ASSIGNMENT_TO_CONST', 2, "Constant variables cannot be assigned a value");
  static const StaticWarningCode ASSIGNMENT_TO_FINAL = const StaticWarningCode.D_con1('ASSIGNMENT_TO_FINAL', 3, "'%s' cannot be used as a setter, it is final");
  static const StaticWarningCode ASSIGNMENT_TO_FINAL_NO_SETTER = const StaticWarningCode.D_con1('ASSIGNMENT_TO_FINAL_NO_SETTER', 4, "No setter named '%s' in class '%s'");
  static const StaticWarningCode ASSIGNMENT_TO_FUNCTION = const StaticWarningCode.D_con1('ASSIGNMENT_TO_FUNCTION', 5, "Functions cannot be assigned a value");
  static const StaticWarningCode ASSIGNMENT_TO_METHOD = const StaticWarningCode.D_con1('ASSIGNMENT_TO_METHOD', 6, "Methods cannot be assigned a value");
  static const StaticWarningCode CASE_BLOCK_NOT_TERMINATED = const StaticWarningCode.D_con1('CASE_BLOCK_NOT_TERMINATED', 7, "The last statement of the 'case' should be 'break', 'continue', 'return' or 'throw'");
  static const StaticWarningCode CAST_TO_NON_TYPE = const StaticWarningCode.D_con1('CAST_TO_NON_TYPE', 8, "The name '%s' is not a type and cannot be used in an 'as' expression");
  static const StaticWarningCode CONCRETE_CLASS_WITH_ABSTRACT_MEMBER = const StaticWarningCode.D_con1('CONCRETE_CLASS_WITH_ABSTRACT_MEMBER', 9, "'%s' must have a method body because '%s' is not abstract");
  static const StaticWarningCode CONFLICTING_DART_IMPORT = const StaticWarningCode.D_con1('CONFLICTING_DART_IMPORT', 10, "Element '%s' from SDK library '%s' is implicitly hidden by '%s'");
  static const StaticWarningCode CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER = const StaticWarningCode.D_con1('CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER', 11, "Superclass '%s' declares static member with the same name");
  static const StaticWarningCode CONFLICTING_INSTANCE_METHOD_SETTER = const StaticWarningCode.D_con1('CONFLICTING_INSTANCE_METHOD_SETTER', 12, "Class '%s' declares instance method '%s', but also has a setter with the same name from '%s'");
  static const StaticWarningCode CONFLICTING_INSTANCE_METHOD_SETTER2 = const StaticWarningCode.D_con1('CONFLICTING_INSTANCE_METHOD_SETTER2', 13, "Class '%s' declares the setter '%s', but also has an instance method in the same class");
  static const StaticWarningCode CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER = const StaticWarningCode.D_con1('CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER', 14, "Superclass '%s' declares static member with the same name");
  static const StaticWarningCode CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER = const StaticWarningCode.D_con1('CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER', 15, "Class '%s' declares non-static setter with the same name");
  static const StaticWarningCode CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER = const StaticWarningCode.D_con1('CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER', 16, "Class '%s' declares non-static member with the same name");
  static const StaticWarningCode CONST_WITH_ABSTRACT_CLASS = const StaticWarningCode.D_con1('CONST_WITH_ABSTRACT_CLASS', 17, "Abstract classes cannot be created with a 'const' expression");
  static const StaticWarningCode EQUAL_KEYS_IN_MAP = const StaticWarningCode.D_con1('EQUAL_KEYS_IN_MAP', 18, "Keys in a map cannot be equal");
  static const StaticWarningCode EXPORT_DUPLICATED_LIBRARY_NAME = const StaticWarningCode.D_con1('EXPORT_DUPLICATED_LIBRARY_NAME', 19, "The exported libraries '%s' and '%s' should not have the same name '%s'");
  static const StaticWarningCode EXTRA_POSITIONAL_ARGUMENTS = const StaticWarningCode.D_con1('EXTRA_POSITIONAL_ARGUMENTS', 20, "%d positional arguments expected, but %d found");
  static const StaticWarningCode FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION = const StaticWarningCode.D_con1('FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION', 21, "Values cannot be set in the constructor if they are final, and have already been set");
  static const StaticWarningCode FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR = const StaticWarningCode.D_con1('FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR', 22, "'%s' is final and was given a value when it was declared, so it cannot be set to a new value");
  static const StaticWarningCode FIELD_INITIALIZER_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('FIELD_INITIALIZER_NOT_ASSIGNABLE', 23, "The initializer type '%s' cannot be assigned to the field type '%s'");
  static const StaticWarningCode FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE', 24, "The parameter type '%s' is incompatable with the field type '%s'");
  static const StaticWarningCode FINAL_NOT_INITIALIZED = const StaticWarningCode.D_con1('FINAL_NOT_INITIALIZED', 25, "The final variable '%s' must be initialized");
  static const StaticWarningCode FUNCTION_WITHOUT_CALL = const StaticWarningCode.D_con1('FUNCTION_WITHOUT_CALL', 26, "Concrete classes that implement Function must implement the method call()");
  static const StaticWarningCode IMPORT_DUPLICATED_LIBRARY_NAME = const StaticWarningCode.D_con1('IMPORT_DUPLICATED_LIBRARY_NAME', 27, "The imported libraries '%s' and '%s' should not have the same name '%s'");
  static const StaticWarningCode IMPORT_OF_NON_LIBRARY = const StaticWarningCode.D_con1('IMPORT_OF_NON_LIBRARY', 28, "The imported library '%s' must not have a part-of directive");
  static const StaticWarningCode INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD = const StaticWarningCode.D_con1('INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD', 29, "'%s' is inherited as a getter and also a method");
  static const StaticWarningCode INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC = const StaticWarningCode.D_con1('INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC', 30, "'%s' collides with a static member in the superclass '%s'");
  static const StaticWarningCode INVALID_GETTER_OVERRIDE_RETURN_TYPE = const StaticWarningCode.D_con1('INVALID_GETTER_OVERRIDE_RETURN_TYPE', 31, "The return type '%s' is not assignable to '%s' as required by the getter it is overriding from '%s'");
  static const StaticWarningCode INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE = const StaticWarningCode.D_con1('INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE', 32, "The parameter type '%s' is not assignable to '%s' as required by the method it is overriding from '%s'");
  static const StaticWarningCode INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE = const StaticWarningCode.D_con1('INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE', 33, "The parameter type '%s' is not assignable to '%s' as required by the method it is overriding from '%s'");
  static const StaticWarningCode INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE = const StaticWarningCode.D_con1('INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE', 34, "The parameter type '%s' is not assignable to '%s' as required by the method it is overriding from '%s'");
  static const StaticWarningCode INVALID_METHOD_OVERRIDE_RETURN_TYPE = const StaticWarningCode.D_con1('INVALID_METHOD_OVERRIDE_RETURN_TYPE', 35, "The return type '%s' is not assignable to '%s' as required by the method it is overriding from '%s'");
  static const StaticWarningCode INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED = const StaticWarningCode.D_con1('INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED', 36, "Parameters cannot override default values, this method overrides '%s.%s' where '%s' has a different value");
  static const StaticWarningCode INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL = const StaticWarningCode.D_con1('INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL', 37, "Parameters cannot override default values, this method overrides '%s.%s' where this positional parameter has a different value");
  static const StaticWarningCode INVALID_OVERRIDE_NAMED = const StaticWarningCode.D_con1('INVALID_OVERRIDE_NAMED', 38, "Missing the named parameter '%s' to match the overridden method from '%s'");
  static const StaticWarningCode INVALID_OVERRIDE_POSITIONAL = const StaticWarningCode.D_con1('INVALID_OVERRIDE_POSITIONAL', 39, "Must have at least %d parameters to match the overridden method from '%s'");
  static const StaticWarningCode INVALID_OVERRIDE_REQUIRED = const StaticWarningCode.D_con1('INVALID_OVERRIDE_REQUIRED', 40, "Must have %d required parameters or less to match the overridden method from '%s'");
  static const StaticWarningCode INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE = const StaticWarningCode.D_con1('INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE', 41, "The parameter type '%s' is not assignable to '%s' as required by the setter it is overriding from '%s'");
  static const StaticWarningCode LIST_ELEMENT_TYPE_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('LIST_ELEMENT_TYPE_NOT_ASSIGNABLE', 42, "The element type '%s' cannot be assigned to the list type '%s'");
  static const StaticWarningCode MAP_KEY_TYPE_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('MAP_KEY_TYPE_NOT_ASSIGNABLE', 43, "The element type '%s' cannot be assigned to the map key type '%s'");
  static const StaticWarningCode MAP_VALUE_TYPE_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('MAP_VALUE_TYPE_NOT_ASSIGNABLE', 44, "The element type '%s' cannot be assigned to the map value type '%s'");
  static const StaticWarningCode MISMATCHED_GETTER_AND_SETTER_TYPES = const StaticWarningCode.D_con1('MISMATCHED_GETTER_AND_SETTER_TYPES', 45, "The parameter type for setter '%s' is '%s' which is not assignable to its getter (of type '%s')");
  static const StaticWarningCode MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE = const StaticWarningCode.D_con1('MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE', 46, "The parameter type for setter '%s' is '%s' which is not assignable to its getter (of type '%s'), from superclass '%s'");
  static const StaticWarningCode MIXED_RETURN_TYPES = const StaticWarningCode.D_con1('MIXED_RETURN_TYPES', 47, "Methods and functions cannot use return both with and without values");
  static const StaticWarningCode NEW_WITH_ABSTRACT_CLASS = const StaticWarningCode.D_con1('NEW_WITH_ABSTRACT_CLASS', 48, "Abstract classes cannot be created with a 'new' expression");
  static const StaticWarningCode NEW_WITH_INVALID_TYPE_PARAMETERS = const StaticWarningCode.D_con1('NEW_WITH_INVALID_TYPE_PARAMETERS', 49, "The type '%s' is declared with %d type parameters, but %d type arguments were given");
  static const StaticWarningCode NEW_WITH_NON_TYPE = const StaticWarningCode.D_con1('NEW_WITH_NON_TYPE', 50, "The name '%s' is not a class");
  static const StaticWarningCode NEW_WITH_UNDEFINED_CONSTRUCTOR = const StaticWarningCode.D_con1('NEW_WITH_UNDEFINED_CONSTRUCTOR', 51, "The class '%s' does not have a constructor '%s'");
  static const StaticWarningCode NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT = const StaticWarningCode.D_con1('NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT', 52, "The class '%s' does not have a default constructor");
  static const StaticWarningCode NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS = const StaticWarningCode.D_con1('NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS', 53, "Missing concrete implementation of %s, %s, %s, %s and %d more");
  static const StaticWarningCode NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR = const StaticWarningCode.D_con1('NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR', 54, "Missing concrete implementation of %s, %s, %s and %s");
  static const StaticWarningCode NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE = const StaticWarningCode.D_con1('NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE', 55, "Missing concrete implementation of %s");
  static const StaticWarningCode NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE = const StaticWarningCode.D_con1('NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE', 56, "Missing concrete implementation of %s, %s and %s");
  static const StaticWarningCode NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO = const StaticWarningCode.D_con1('NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO', 57, "Missing concrete implementation of %s and %s");
  static const StaticWarningCode NON_TYPE_IN_CATCH_CLAUSE = const StaticWarningCode.D_con1('NON_TYPE_IN_CATCH_CLAUSE', 58, "The name '%s' is not a type and cannot be used in an on-catch clause");
  static const StaticWarningCode NON_VOID_RETURN_FOR_OPERATOR = const StaticWarningCode.D_con1('NON_VOID_RETURN_FOR_OPERATOR', 59, "The return type of the operator []= must be 'void'");
  static const StaticWarningCode NON_VOID_RETURN_FOR_SETTER = const StaticWarningCode.D_con1('NON_VOID_RETURN_FOR_SETTER', 60, "The return type of the setter must be 'void'");
  static const StaticWarningCode NOT_A_TYPE = const StaticWarningCode.D_con1('NOT_A_TYPE', 61, "%s is not a type");
  static const StaticWarningCode NOT_ENOUGH_REQUIRED_ARGUMENTS = const StaticWarningCode.D_con1('NOT_ENOUGH_REQUIRED_ARGUMENTS', 62, "%d required argument(s) expected, but %d found");
  static const StaticWarningCode PART_OF_DIFFERENT_LIBRARY = const StaticWarningCode.D_con1('PART_OF_DIFFERENT_LIBRARY', 63, "Expected this library to be part of '%s', not '%s'");
  static const StaticWarningCode REDIRECT_TO_INVALID_FUNCTION_TYPE = const StaticWarningCode.D_con1('REDIRECT_TO_INVALID_FUNCTION_TYPE', 64, "The redirected constructor '%s' has incompatible parameters with '%s'");
  static const StaticWarningCode REDIRECT_TO_INVALID_RETURN_TYPE = const StaticWarningCode.D_con1('REDIRECT_TO_INVALID_RETURN_TYPE', 65, "The return type '%s' of the redirected constructor is not assignable to '%s'");
  static const StaticWarningCode REDIRECT_TO_MISSING_CONSTRUCTOR = const StaticWarningCode.D_con1('REDIRECT_TO_MISSING_CONSTRUCTOR', 66, "The constructor '%s' could not be found in '%s'");
  static const StaticWarningCode REDIRECT_TO_NON_CLASS = const StaticWarningCode.D_con1('REDIRECT_TO_NON_CLASS', 67, "The name '%s' is not a type and cannot be used in a redirected constructor");
  static const StaticWarningCode RETURN_WITHOUT_VALUE = const StaticWarningCode.D_con1('RETURN_WITHOUT_VALUE', 68, "Missing return value after 'return'");
  static const StaticWarningCode STATIC_ACCESS_TO_INSTANCE_MEMBER = const StaticWarningCode.D_con1('STATIC_ACCESS_TO_INSTANCE_MEMBER', 69, "Instance member '%s' cannot be accessed using static access");
  static const StaticWarningCode SWITCH_EXPRESSION_NOT_ASSIGNABLE = const StaticWarningCode.D_con1('SWITCH_EXPRESSION_NOT_ASSIGNABLE', 70, "Type '%s' of the switch expression is not assignable to the type '%s' of case expressions");
  static const StaticWarningCode TYPE_ANNOTATION_DEFERRED_CLASS = const StaticWarningCode.D_con1('TYPE_ANNOTATION_DEFERRED_CLASS', 71, "The deferred type '%s' cannot be used in a declaration, cast or type test");
  static const StaticWarningCode TYPE_TEST_NON_TYPE = const StaticWarningCode.D_con1('TYPE_TEST_NON_TYPE', 72, "The name '%s' is not a type and cannot be used in an 'is' expression");
  static const StaticWarningCode TYPE_PARAMETER_REFERENCED_BY_STATIC = const StaticWarningCode.D_con1('TYPE_PARAMETER_REFERENCED_BY_STATIC', 73, "Static members cannot reference type parameters");
  static const StaticWarningCode UNDEFINED_CLASS = const StaticWarningCode.D_con1('UNDEFINED_CLASS', 74, "Undefined class '%s'");
  static const StaticWarningCode UNDEFINED_CLASS_BOOLEAN = const StaticWarningCode.D_con1('UNDEFINED_CLASS_BOOLEAN', 75, "Undefined class 'boolean'; did you mean 'bool'?");
  static const StaticWarningCode UNDEFINED_GETTER = const StaticWarningCode.D_con1('UNDEFINED_GETTER', 76, "There is no such getter '%s' in '%s'");
  static const StaticWarningCode UNDEFINED_IDENTIFIER = const StaticWarningCode.D_con1('UNDEFINED_IDENTIFIER', 77, "Undefined name '%s'");
  static const StaticWarningCode UNDEFINED_NAMED_PARAMETER = const StaticWarningCode.D_con1('UNDEFINED_NAMED_PARAMETER', 78, "The named parameter '%s' is not defined");
  static const StaticWarningCode UNDEFINED_SETTER = const StaticWarningCode.D_con1('UNDEFINED_SETTER', 79, "There is no such setter '%s' in '%s'");
  static const StaticWarningCode VOID_RETURN_FOR_GETTER = const StaticWarningCode.D_con1('VOID_RETURN_FOR_GETTER', 81, "The return type of the getter must not be 'void'");
  final String message;
  final String correction;
  const StaticWarningCode.D_con1(String A_name, int ordinal, String A_message) : this.D_con2(A_name, ordinal, A_message, null);
  const StaticWarningCode.D_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorType.STATIC_WARNING.severity;
  ErrorType get type => ErrorType.STATIC_WARNING;
}
class TodoCode extends Enum<TodoCode> implements ErrorCode {
  static const TodoCode TODO = const TodoCode('TODO', 0);
  static RegExp TODO_REGEX = new RegExp("([\\s/\\*])((TODO[^\\w\\d][^\\r\\n]*)|(TODO:?\$))");
  const TodoCode(String A_name, int ordinal) : super(A_name, ordinal);
  String get correction => null;
  ErrorSeverity get errorSeverity => ErrorSeverity.INFO;
  String get message => "%s";
  ErrorType get type => ErrorType.TODO;
}
abstract class AbstractScanner {
  static List<String> _NO_PASS_THROUGH_ELEMENTS = <String>[];
  final Source source;
  Token _tokens;
  Token A__tail;
  List<int> _lineStarts = new List<int>();
  List<String> _passThroughElements = _NO_PASS_THROUGH_ELEMENTS;
  AbstractScanner(this.source) {
    _tokens = new Token.E_con1(TokenType.EOF, -1);
    _tokens.setNext(_tokens);
    A__tail = _tokens;
    recordStartOfLine();
  }
  List<int> get lineStarts => _lineStarts;
  int get offset;
  void set passThroughElements(List<String> A_passThroughElements) {
    this._passThroughElements = A_passThroughElements != null ? A_passThroughElements : _NO_PASS_THROUGH_ELEMENTS;
  }
  Token tokenize() {
    _scan();
    _appendEofToken();
    return _firstToken();
  }
  int advance();
  String getString(int A_start, int endDelta);
  int peek();
  void recordStartOfLine() {
    _lineStarts.add(offset);
  }
  void _appendEofToken() {
    Token eofToken = new Token.E_con1(TokenType.EOF, offset);
    eofToken.setNext(eofToken);
    A__tail = A__tail.setNext(eofToken);
  }
  Token _emit(Token token) {
    A__tail.setNext(token);
    A__tail = token;
    return token;
  }
  Token _emitWithOffset(TokenType A_type, int A_start) => _emit(new Token.E_con1(A_type, A_start));
  Token _emitWithOffsetAndLength(TokenType A_type, int A_start, int count) => _emit(new Token.E_con2(A_type, A_start, getString(A_start, count)));
  Token _firstToken() => _tokens.next;
  int _recordStartOfLineAndAdvance(int c) {
    if (c == 0xD) {
      c = advance();
      if (c == 0xA) {
        c = advance();
      }
      recordStartOfLine();
    } else if (c == 0xA) {
      c = advance();
      recordStartOfLine();
    } else {
      c = advance();
    }
    return c;
  }
  void _scan() {
    bool inBrackets = false;
    String endPassThrough = null;
    int c = advance();
    while (c >= 0) {
      int A_start = offset;
      if (c == 0x3C) {
        c = advance();
        if (c == 0x21) {
          c = advance();
          if (c == 0x2D && peek() == 0x2D) {
            c = advance();
            int dashCount = 1;
            while (c >= 0) {
              if (c == 0x2D) {
                dashCount++;
              } else if (c == 0x3E && dashCount >= 2) {
                c = advance();
                break;
              } else {
                dashCount = 0;
              }
              c = _recordStartOfLineAndAdvance(c);
            }
            _emitWithOffsetAndLength(TokenType.COMMENT, A_start, -1);
            if (A__tail.length < 7) {}
          } else {
            while (c >= 0) {
              if (c == 0x3E) {
                c = advance();
                break;
              }
              c = _recordStartOfLineAndAdvance(c);
            }
            _emitWithOffsetAndLength(TokenType.B_DECLARATION, A_start, -1);
            if (!StringUtilities.endsWithChar(A__tail.lexeme, 0x3E)) {}
          }
        } else if (c == 0x3F) {
          while (c >= 0) {
            if (c == 0x3F) {
              c = advance();
              if (c == 0x3E) {
                c = advance();
                break;
              }
            } else {
              c = _recordStartOfLineAndAdvance(c);
            }
          }
          _emitWithOffsetAndLength(TokenType.DIRECTIVE, A_start, -1);
          if (A__tail.length < 4) {}
        } else if (c == 0x2F) {
          _emitWithOffset(TokenType.LT_SLASH, A_start);
          inBrackets = true;
          c = advance();
        } else {
          inBrackets = true;
          _emitWithOffset(TokenType.LT, A_start);
          while (Character.A_isWhitespace(c)) {
            c = _recordStartOfLineAndAdvance(c);
          }
          if (Character.isLetterOrDigit(c)) {
            int tagStart = offset;
            c = advance();
            while (Character.isLetterOrDigit(c) || c == 0x2D || c == 0x5F) {
              c = advance();
            }
            _emitWithOffsetAndLength(TokenType.TAG, tagStart, -1);
            String tag = A__tail.lexeme;
            for (String str in _passThroughElements) {
              if (str == tag) {
                endPassThrough = "</${str}>";
                break;
              }
            }
          }
        }
      } else if (c == 0x3E) {
        _emitWithOffset(TokenType.GT, A_start);
        inBrackets = false;
        c = advance();
        if (endPassThrough != null) {
          bool endFound = false;
          int len = endPassThrough.length;
          int firstC = endPassThrough.codeUnitAt(0);
          int A_index = 0;
          int nextC = firstC;
          while (c >= 0) {
            if (c == nextC) {
              A_index++;
              if (A_index == len) {
                endFound = true;
                break;
              }
              nextC = endPassThrough.codeUnitAt(A_index);
            } else if (c == firstC) {
              A_index = 1;
              nextC = endPassThrough.codeUnitAt(1);
            } else {
              A_index = 0;
              nextC = firstC;
            }
            c = _recordStartOfLineAndAdvance(c);
          }
          if (A_start + 1 < offset) {
            if (endFound) {
              _emitWithOffsetAndLength(TokenType.A_TEXT, A_start + 1, -len);
              _emitWithOffset(TokenType.LT_SLASH, offset - len + 1);
              _emitWithOffsetAndLength(TokenType.TAG, offset - len + 3, -1);
            } else {
              _emitWithOffsetAndLength(TokenType.A_TEXT, A_start + 1, -1);
            }
          }
          endPassThrough = null;
        }
      } else if (c == 0x2F && peek() == 0x3E) {
        advance();
        _emitWithOffset(TokenType.SLASH_GT, A_start);
        inBrackets = false;
        c = advance();
      } else if (!inBrackets) {
        c = _recordStartOfLineAndAdvance(c);
        while (c != 0x3C && c >= 0) {
          c = _recordStartOfLineAndAdvance(c);
        }
        _emitWithOffsetAndLength(TokenType.A_TEXT, A_start, -1);
      } else if (c == 0x22 || c == 0x27) {
        int endQuote = c;
        c = advance();
        while (c >= 0) {
          if (c == endQuote) {
            c = advance();
            break;
          }
          c = _recordStartOfLineAndAdvance(c);
        }
        _emitWithOffsetAndLength(TokenType.STRING, A_start, -1);
      } else if (c == 0x3D) {
        _emitWithOffset(TokenType.EQ, A_start);
        c = advance();
      } else if (Character.A_isWhitespace(c)) {
        do {
          c = _recordStartOfLineAndAdvance(c);
        } while (Character.A_isWhitespace(c));
      } else if (Character.isLetterOrDigit(c)) {
        c = advance();
        while (Character.isLetterOrDigit(c) || c == 0x2D || c == 0x5F) {
          c = advance();
        }
        _emitWithOffsetAndLength(TokenType.TAG, A_start, -1);
      } else {
        _emitWithOffsetAndLength(TokenType.A_TEXT, A_start, 0);
        c = advance();
      }
    }
  }
}
class HtmlParser extends XmlParser {
  LineInfo A__lineInfo;
  final AnalysisErrorListener B__errorListener;
  static String _APPLICATION_DART_IN_DOUBLE_QUOTES = "\"application/dart\"";
  static String _APPLICATION_DART_IN_SINGLE_QUOTES = "'application/dart'";
  static String _SCRIPT = "script";
  static String A__TYPE = "type";
  static Set<String> SELF_CLOSING = new A_p.HashSet<String>.from(JavaArrays.asList(<String>["area", "base", "basefont", "br", "col", "frame", "hr", "img", "input", "link", "meta", "param", "!"]));
  static A_Token scanDartSource(Source A_source, LineInfo lineInfo, String contents, int contentOffset, AnalysisErrorListener errorListener) {
    LineInfo_Location A_location = lineInfo.getLocation(contentOffset);
    Scanner scanner = new Scanner(A_source, new SubSequenceReader(contents, contentOffset), errorListener);
    scanner.setSourceStart(A_location.lineNumber, A_location.columnNumber);
    return scanner.tokenize();
  }
  HtmlParser(Source A_source, this.B__errorListener) : super(A_source);
  HtmlUnit parse(Token token, LineInfo lineInfo) {
    this.A__lineInfo = lineInfo;
    List<XmlTagNode> tagNodes = parseTopTagNodes(token);
    return new HtmlUnit(token, tagNodes, currentToken);
  }
  XmlAttributeNode createAttributeNode(Token A_name, Token A_equals, Token A_value) => new XmlAttributeNode(A_name, A_equals, A_value);
  XmlTagNode createTagNode(Token nodeStart, Token tag, List<XmlAttributeNode> attributes, Token attributeEnd, List<XmlTagNode> tagNodes, Token contentEnd, Token closingTag, Token nodeEnd) {
    if (_isScriptNode(tag, attributes, tagNodes)) {
      HtmlScriptTagNode tagNode = new HtmlScriptTagNode(nodeStart, tag, attributes, attributeEnd, tagNodes, contentEnd, closingTag, nodeEnd);
      String contents = tagNode.content;
      int contentOffset = attributeEnd.end;
      LineInfo_Location A_location = A__lineInfo.getLocation(contentOffset);
      Scanner scanner = new Scanner(source, new SubSequenceReader(contents, contentOffset), B__errorListener);
      scanner.setSourceStart(A_location.lineNumber, A_location.columnNumber);
      A_Token firstToken = scanner.tokenize();
      Parser parser = new Parser(source, B__errorListener);
      CompilationUnit unit = parser.parseCompilationUnit(firstToken);
      unit.lineInfo = A__lineInfo;
      tagNode.script = unit;
      return tagNode;
    }
    return new XmlTagNode(nodeStart, tag, attributes, attributeEnd, tagNodes, contentEnd, closingTag, nodeEnd);
  }
  bool isSelfClosing(Token tag) => SELF_CLOSING.contains(tag.lexeme);
  bool _isScriptNode(Token tag, List<XmlAttributeNode> attributes, List<XmlTagNode> tagNodes) {
    if (tagNodes.length != 0 || tag.lexeme != _SCRIPT) {
      return false;
    }
    for (XmlAttributeNode attribute in attributes) {
      if (attribute.name == A__TYPE) {
        Token valueToken = attribute.valueToken;
        if (valueToken != null) {
          String A_value = valueToken.lexeme;
          if (A_value == _APPLICATION_DART_IN_DOUBLE_QUOTES || A_value == _APPLICATION_DART_IN_SINGLE_QUOTES) {
            return true;
          }
        }
      }
    }
    return false;
  }
}
class HtmlScriptTagNode extends XmlTagNode {
  CompilationUnit _script;
  HtmlScriptElement scriptElement;
  HtmlScriptTagNode(Token nodeStart, Token tag, List<XmlAttributeNode> attributes, Token attributeEnd, List<XmlTagNode> tagNodes, Token contentEnd, Token closingTag, Token nodeEnd) : super(nodeStart, tag, attributes, attributeEnd, tagNodes, contentEnd, closingTag, nodeEnd);
  accept(XmlVisitor visitor) => visitor.visitHtmlScriptTagNode(this);
  CompilationUnit get script => _script;
  void set script(CompilationUnit unit) {
    _script = unit;
  }
}
class HtmlUnit extends XmlNode {
  final Token beginToken;
  final Token endToken;
  List<XmlTagNode> _tagNodes;
  HtmlUnit(this.beginToken, List<XmlTagNode> A_tagNodes, this.endToken) {
    this._tagNodes = becomeParentOfAll(A_tagNodes);
  }
  accept(XmlVisitor visitor) => visitor.visitHtmlUnit(this);
  HtmlElement get element => super.element as HtmlElement;
  List<XmlTagNode> get tagNodes => _tagNodes;
  void set element(A_Element A_element) {
    if (A_element != null && A_element is! HtmlElement) {
      throw new IllegalArgumentException("HtmlElement expected, but ${A_element.runtimeType} given");
    }
    super.element = A_element;
  }
  void visitChildren(XmlVisitor visitor) {
    for (XmlTagNode node in _tagNodes) {
      node.accept(visitor);
    }
  }
}
class RawXmlExpression extends XmlExpression {
  final Expression expression;
  RawXmlExpression(this.expression);
  int get end => expression.end;
  int get length => expression.length;
  int get offset => expression.offset;
}
class RecursiveXmlVisitor<B_R> implements XmlVisitor<B_R> {
  B_R visitHtmlScriptTagNode(HtmlScriptTagNode node) {
    node.visitChildren(this);
    return null;
  }
  B_R visitHtmlUnit(HtmlUnit node) {
    node.visitChildren(this);
    return null;
  }
  B_R visitXmlAttributeNode(XmlAttributeNode node) {
    node.visitChildren(this);
    return null;
  }
  B_R visitXmlTagNode(XmlTagNode node) {
    node.visitChildren(this);
    return null;
  }
}
class StringScanner extends AbstractScanner {
  final String A__string;
  int _stringLength = 0;
  int _charOffset = 0;
  StringScanner(Source A_source, this.A__string) : super(A_source) {
    this._stringLength = A__string.length;
    this._charOffset = -1;
  }
  int get offset => _charOffset;
  void set offset(int A_offset) {
    _charOffset = A_offset;
  }
  int advance() {
    if (++_charOffset < _stringLength) {
      return A__string.codeUnitAt(_charOffset);
    }
    _charOffset = _stringLength;
    return -1;
  }
  String getString(int A_start, int endDelta) => A__string.substring(A_start, _charOffset + 1 + endDelta).toString();
  int peek() {
    if (_charOffset + 1 < _stringLength) {
      return A__string.codeUnitAt(_charOffset + 1);
    }
    return -1;
  }
}
class A_ToSourceVisitor implements XmlVisitor<Object> {
  final PrintWriter A__writer;
  A_ToSourceVisitor(this.A__writer);
  Object visitHtmlScriptTagNode(HtmlScriptTagNode node) => visitXmlTagNode(node);
  Object visitHtmlUnit(HtmlUnit node) {
    for (XmlTagNode child in node.tagNodes) {
      _visit(child);
    }
    return null;
  }
  Object visitXmlAttributeNode(XmlAttributeNode node) {
    String A_name = node.name;
    Token A_value = node.valueToken;
    if (A_name.length == 0) {
      A__writer.print("__");
    } else {
      A__writer.print(A_name);
    }
    A__writer.print("=");
    if (A_value == null) {
      A__writer.print("__");
    } else {
      A__writer.print(A_value.lexeme);
    }
    return null;
  }
  Object visitXmlTagNode(XmlTagNode node) {
    A__writer.print("<");
    String tagName = node.tag;
    A__writer.print(tagName);
    for (XmlAttributeNode attribute in node.attributes) {
      A__writer.print(" ");
      _visit(attribute);
    }
    A__writer.print(node.attributeEnd.lexeme);
    if (node.closingTag != null) {
      for (XmlTagNode child in node.tagNodes) {
        _visit(child);
      }
      A__writer.print("</");
      A__writer.print(tagName);
      A__writer.print(">");
    }
    return null;
  }
  void _visit(XmlNode node) {
    if (node != null) {
      node.accept(this);
    }
  }
}
class Token {
  final int offset;
  Token previous;
  Token A__next;
  final TokenType type;
  String C__value;
  Token.E_con1(TokenType A_type, int A_offset) : this.E_con2(A_type, A_offset, A_type.lexeme);
  Token.E_con2(this.type, this.offset, String A_value) {
    this.C__value = StringUtilities.intern(A_value);
  }
  int get end => offset + length;
  int get length => lexeme.length;
  String get lexeme => C__value;
  Token get next => A__next;
  bool get isSynthetic => length == 0;
  Token setNext(Token token) {
    A__next = token;
    token.previous = this;
    return token;
  }
  String toString() => lexeme;
}
class TokenType extends Enum<TokenType> {
  static const TokenType EOF = const TokenType_EOF('EOF', 0, "");
  static const TokenType EQ = const TokenType('EQ', 1, "=");
  static const TokenType GT = const TokenType('GT', 2, ">");
  static const TokenType LT_SLASH = const TokenType('LT_SLASH', 3, "</");
  static const TokenType LT = const TokenType('LT', 4, "<");
  static const TokenType SLASH_GT = const TokenType('SLASH_GT', 5, "/>");
  static const TokenType COMMENT = const TokenType('COMMENT', 6, null);
  static const TokenType B_DECLARATION = const TokenType('DECLARATION', 7, null);
  static const TokenType DIRECTIVE = const TokenType('DIRECTIVE', 8, null);
  static const TokenType STRING = const TokenType('STRING', 9, null);
  static const TokenType TAG = const TokenType('TAG', 10, null);
  static const TokenType A_TEXT = const TokenType('TEXT', 11, null);
  final String lexeme;
  const TokenType(String A_name, int ordinal, this.lexeme) : super(A_name, ordinal);
}
class TokenType_EOF extends TokenType {
  const TokenType_EOF(String A_name, int ordinal, String arg0) : super(A_name, ordinal, arg0);
  String toString() => "-eof-";
}
class XmlAttributeNode extends XmlNode {
  final Token D__name;
  final Token A_equals;
  final Token C__value;
  List<XmlExpression> expressions = XmlExpression.D_EMPTY_ARRAY;
  XmlAttributeNode(this.D__name, this.A_equals, this.C__value);
  accept(XmlVisitor visitor) => visitor.visitXmlAttributeNode(this);
  Token get beginToken => D__name;
  Token get endToken => C__value;
  String get name => D__name.lexeme;
  Token get nameToken => D__name;
  String get text {
    if (C__value == null) {
      return null;
    }
    String A_text = C__value.lexeme;
    int len = A_text.length;
    if (len > 0) {
      if (A_text.codeUnitAt(0) == 0x22) {
        if (len > 1 && A_text.codeUnitAt(len - 1) == 0x22) {
          return A_text.substring(1, len - 1);
        } else {
          return A_text.substring(1);
        }
      } else if (A_text.codeUnitAt(0) == 0x27) {
        if (len > 1 && A_text.codeUnitAt(len - 1) == 0x27) {
          return A_text.substring(1, len - 1);
        } else {
          return A_text.substring(1);
        }
      }
    }
    return A_text;
  }
  int get textOffset {
    if (C__value == null) {
      return -1;
    }
    String A_text = C__value.lexeme;
    if (StringUtilities.startsWithChar(A_text, 0x22) || StringUtilities.startsWithChar(A_text, 0x27)) {
      return C__value.offset + 1;
    }
    return C__value.offset;
  }
  Token get valueToken => C__value;
  void visitChildren(XmlVisitor visitor) {}
}
abstract class XmlExpression {
  static List<XmlExpression> D_EMPTY_ARRAY = new List<XmlExpression>(0);
  bool contains(int A_offset) => this.offset <= A_offset && A_offset < end;
  int get end;
  int get length;
  int get offset;
}
abstract class XmlNode {
  XmlNode B__parent;
  A_Element G__element;
  accept(XmlVisitor visitor);
  Token get beginToken;
  A_Element get element => G__element;
  int get end => offset + length;
  Token get endToken;
  int get length {
    Token A_beginToken = this.beginToken;
    Token A_endToken = this.endToken;
    if (A_beginToken == null || A_endToken == null) {
      return -1;
    }
    return A_endToken.offset + A_endToken.length - A_beginToken.offset;
  }
  int get offset {
    Token A_beginToken = this.beginToken;
    if (A_beginToken == null) {
      return -1;
    }
    return this.beginToken.offset;
  }
  XmlNode get parent => B__parent;
  void set element(A_Element A_element) {
    this.G__element = A_element;
  }
  String toString() {
    PrintStringWriter writer = new PrintStringWriter();
    accept(new A_ToSourceVisitor(writer));
    return writer.toString();
  }
  void visitChildren(XmlVisitor visitor);
  XmlNode becomeParentOf(XmlNode child) {
    if (child != null) {
      XmlNode node = child;
      node.parent = this;
    }
    return child;
  }
  List becomeParentOfAll(List children, {List ifEmpty}) {
    if (children == null || children.isEmpty) {
      if (ifEmpty != null) {
        return ifEmpty;
      }
    }
    if (children != null) {
      for (JavaIterator iter = new JavaIterator(children); iter.hasNext;) {
        XmlNode node = iter.next();
        node.parent = this;
      }
      return new List.from(children);
    }
    return children;
  }
  void _appendIdentifier(JavaStringBuilder A_builder, XmlNode node) {
    if (node is XmlTagNode) {
      A_builder.append(node.tag);
    } else if (node is XmlAttributeNode) {
      A_builder.append(node.name);
    } else {
      A_builder.append("htmlUnit");
    }
  }
  String _buildRecursiveStructureMessage(XmlNode newParent) {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("Attempt to create recursive structure: ");
    XmlNode B_current = newParent;
    while (B_current != null) {
      if (!identical(B_current, newParent)) {
        A_builder.append(" -> ");
      }
      if (identical(B_current, this)) {
        A_builder.appendChar(0x2A);
        _appendIdentifier(A_builder, B_current);
        A_builder.appendChar(0x2A);
      } else {
        _appendIdentifier(A_builder, B_current);
      }
      B_current = B_current.parent;
    }
    return A_builder.toString();
  }
  void set parent(XmlNode newParent) {
    XmlNode B_current = newParent;
    while (B_current != null) {
      if (identical(B_current, this)) {
        AnalysisEngine.A_instance.logger.logError2("Circular structure while setting an XML node's parent", new IllegalArgumentException(_buildRecursiveStructureMessage(newParent)));
        return;
      }
      B_current = B_current.parent;
    }
    B__parent = newParent;
  }
}
class XmlParser {
  final Source source;
  Token _currentToken;
  XmlParser(this.source);
  XmlAttributeNode createAttributeNode(Token A_name, Token A_equals, Token A_value) => new XmlAttributeNode(A_name, A_equals, A_value);
  XmlTagNode createTagNode(Token nodeStart, Token tag, List<XmlAttributeNode> attributes, Token attributeEnd, List<XmlTagNode> tagNodes, Token contentEnd, Token closingTag, Token nodeEnd) => new XmlTagNode(nodeStart, tag, attributes, attributeEnd, tagNodes, contentEnd, closingTag, nodeEnd);
  bool isSelfClosing(Token tag) => false;
  List<XmlTagNode> parseTopTagNodes(Token firstToken) {
    _currentToken = firstToken;
    List<XmlTagNode> tagNodes = new List<XmlTagNode>();
    TokenType A_type = _currentToken.type;
    while (A_type != TokenType.EOF) {
      if (A_type == TokenType.LT) {
        tagNodes.add(_parseTagNode());
      } else if (A_type == TokenType.B_DECLARATION || A_type == TokenType.DIRECTIVE || A_type == TokenType.COMMENT) {
        _currentToken = _currentToken.next;
      } else {
        _reportUnexpectedToken();
        _currentToken = _currentToken.next;
      }
      A_type = _currentToken.type;
    }
    return tagNodes;
  }
  Token get currentToken => _currentToken;
  Token _insertSyntheticToken(TokenType A_type) {
    Token token = new Token.E_con2(A_type, _currentToken.offset, "");
    _currentToken.previous.setNext(token);
    token.setNext(_currentToken);
    return token;
  }
  XmlAttributeNode _parseAttribute() {
    Token A_name = _currentToken;
    _currentToken = _currentToken.next;
    Token A_equals;
    if (_currentToken.type == TokenType.EQ) {
      A_equals = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      A_equals = _insertSyntheticToken(TokenType.EQ);
    }
    Token A_value;
    if (_currentToken.type == TokenType.STRING) {
      A_value = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      A_value = _insertSyntheticToken(TokenType.STRING);
    }
    return createAttributeNode(A_name, A_equals, A_value);
  }
  List<XmlAttributeNode> _parseAttributes() {
    TokenType A_type = _currentToken.type;
    if (A_type == TokenType.GT || A_type == TokenType.SLASH_GT || A_type == TokenType.EOF) {
      return XmlTagNode.NO_ATTRIBUTES;
    }
    List<XmlAttributeNode> attributes = new List<XmlAttributeNode>();
    while (A_type != TokenType.GT && A_type != TokenType.SLASH_GT && A_type != TokenType.EOF) {
      if (A_type == TokenType.TAG) {
        attributes.add(_parseAttribute());
      } else {
        _reportUnexpectedToken();
        _currentToken = _currentToken.next;
      }
      A_type = _currentToken.type;
    }
    return attributes;
  }
  List<XmlTagNode> _parseChildTagNodes() {
    TokenType A_type = _currentToken.type;
    if (A_type == TokenType.LT_SLASH || A_type == TokenType.EOF) {
      return XmlTagNode.NO_TAG_NODES;
    }
    List<XmlTagNode> nodes = new List<XmlTagNode>();
    while (A_type != TokenType.LT_SLASH && A_type != TokenType.EOF) {
      if (A_type == TokenType.LT) {
        nodes.add(_parseTagNode());
      } else if (A_type == TokenType.COMMENT) {
        _currentToken = _currentToken.next;
      } else {
        _reportUnexpectedToken();
        _currentToken = _currentToken.next;
      }
      A_type = _currentToken.type;
    }
    return nodes;
  }
  XmlTagNode _parseTagNode() {
    Token nodeStart = _currentToken;
    _currentToken = _currentToken.next;
    Token tag;
    if (_currentToken.type == TokenType.TAG) {
      tag = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      tag = _insertSyntheticToken(TokenType.TAG);
    }
    List<XmlAttributeNode> attributes = _parseAttributes();
    Token attributeEnd;
    if (_currentToken.type == TokenType.GT || _currentToken.type == TokenType.SLASH_GT) {
      attributeEnd = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      attributeEnd = _insertSyntheticToken(TokenType.SLASH_GT);
    }
    if (attributeEnd.type == TokenType.SLASH_GT || isSelfClosing(tag)) {
      return createTagNode(nodeStart, tag, attributes, attributeEnd, XmlTagNode.NO_TAG_NODES, _currentToken, null, attributeEnd);
    }
    List<XmlTagNode> tagNodes = _parseChildTagNodes();
    Token contentEnd;
    if (_currentToken.type == TokenType.LT_SLASH) {
      contentEnd = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      contentEnd = _insertSyntheticToken(TokenType.LT_SLASH);
    }
    Token closingTag;
    if (_currentToken.type == TokenType.TAG) {
      closingTag = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      closingTag = _insertSyntheticToken(TokenType.TAG);
    }
    Token nodeEnd;
    if (_currentToken.type == TokenType.GT) {
      nodeEnd = _currentToken;
      _currentToken = _currentToken.next;
    } else {
      _reportUnexpectedToken();
      nodeEnd = _insertSyntheticToken(TokenType.GT);
    }
    return createTagNode(nodeStart, tag, attributes, attributeEnd, tagNodes, contentEnd, closingTag, nodeEnd);
  }
  void _reportUnexpectedToken() {}
}
class XmlTagNode extends XmlNode {
  static List<XmlAttributeNode> NO_ATTRIBUTES = new A_p.UnmodifiableListView(new List<XmlAttributeNode>());
  static List<XmlTagNode> NO_TAG_NODES = new A_p.UnmodifiableListView(new List<XmlTagNode>());
  final Token nodeStart;
  final Token _tag;
  List<XmlAttributeNode> A__attributes;
  final Token attributeEnd;
  List<XmlTagNode> _tagNodes;
  final Token contentEnd;
  final Token closingTag;
  final Token nodeEnd;
  List<XmlExpression> expressions = XmlExpression.D_EMPTY_ARRAY;
  XmlTagNode(this.nodeStart, this._tag, List<XmlAttributeNode> A_attributes, this.attributeEnd, List<XmlTagNode> A_tagNodes, this.contentEnd, this.closingTag, this.nodeEnd) {
    this.A__attributes = becomeParentOfAll(A_attributes, ifEmpty: NO_ATTRIBUTES);
    this._tagNodes = becomeParentOfAll(A_tagNodes, ifEmpty: NO_TAG_NODES);
  }
  accept(XmlVisitor visitor) => visitor.visitXmlTagNode(this);
  XmlAttributeNode getAttribute(String A_name) {
    for (XmlAttributeNode attribute in A__attributes) {
      if (attribute.name == A_name) {
        return attribute;
      }
    }
    return null;
  }
  List<XmlAttributeNode> get attributes => A__attributes;
  Token get beginToken => nodeStart;
  String get content {
    Token token = attributeEnd.next;
    if (identical(token, contentEnd)) {
      return "";
    }
    String A_content = token.lexeme;
    token = token.next;
    if (identical(token, contentEnd)) {
      return A_content;
    }
    JavaStringBuilder A_buffer = new JavaStringBuilder();
    while (!identical(token, contentEnd)) {
      A_buffer.append(token.lexeme);
      token = token.next;
    }
    return A_buffer.toString();
  }
  Token get endToken {
    if (nodeEnd != null) {
      return nodeEnd;
    }
    if (closingTag != null) {
      return closingTag;
    }
    if (contentEnd != null) {
      return contentEnd;
    }
    if (!_tagNodes.isEmpty) {
      return _tagNodes[_tagNodes.length - 1].endToken;
    }
    if (attributeEnd != null) {
      return attributeEnd;
    }
    if (!A__attributes.isEmpty) {
      return A__attributes[A__attributes.length - 1].endToken;
    }
    return _tag;
  }
  String get tag => _tag.lexeme;
  List<XmlTagNode> get tagNodes => _tagNodes;
  Token get tagToken => _tag;
  void visitChildren(XmlVisitor visitor) {
    for (XmlAttributeNode node in A__attributes) {
      node.accept(visitor);
    }
    for (XmlTagNode node in _tagNodes) {
      node.accept(visitor);
    }
  }
}
abstract class XmlVisitor<B_R> {
  B_R visitHtmlScriptTagNode(HtmlScriptTagNode node);
  B_R visitHtmlUnit(HtmlUnit htmlUnit);
  B_R visitXmlAttributeNode(XmlAttributeNode xmlAttributeNode);
  B_R visitXmlTagNode(XmlTagNode xmlTagNode);
}
class Instrumentation {
  static InstrumentationBuilder _NULL_INSTRUMENTATION_BUILDER = new InstrumentationBuilder_Instrumentation_NULL_INSTRUMENTATION_BUILDER();
  static InstrumentationLogger _NULL_LOGGER = new InstrumentationLogger_Instrumentation_NULL_LOGGER();
  static InstrumentationLogger _CURRENT_LOGGER = _NULL_LOGGER;
  static InstrumentationBuilder builder2(String A_name) => _CURRENT_LOGGER.createBuilder(A_name);
  static bool get isNullLogger => identical(_CURRENT_LOGGER, _NULL_LOGGER);
}
abstract class InstrumentationBuilder {
  InstrumentationBuilder data(String A_name, bool A_value);
  InstrumentationBuilder data3(String A_name, String A_value);
  void log();
  void log2(int minTimeToLog);
  InstrumentationBuilder metric(String A_name, bool A_value);
  InstrumentationBuilder metric2(String A_name, int A_value);
  InstrumentationBuilder metric3(String A_name, String A_value);
  InstrumentationBuilder record(Exception exception);
}
class InstrumentationBuilder_Instrumentation_NULL_INSTRUMENTATION_BUILDER implements InstrumentationBuilder {
  InstrumentationBuilder data(String A_name, bool A_value) => this;
  InstrumentationBuilder data3(String A_name, String A_value) => this;
  void log() {}
  void log2(int minTimeToLong) {}
  InstrumentationBuilder metric(String A_name, bool A_value) => this;
  InstrumentationBuilder metric2(String A_name, int A_value) => this;
  InstrumentationBuilder metric3(String A_name, String A_value) => this;
  InstrumentationBuilder record(Exception exception) => this;
}
abstract class InstrumentationLogger {
  InstrumentationBuilder createBuilder(String A_name);
}
class InstrumentationLogger_Instrumentation_NULL_LOGGER implements InstrumentationLogger {
  InstrumentationBuilder createBuilder(String A_name) => Instrumentation._NULL_INSTRUMENTATION_BUILDER;
}
abstract class Interner {
  String A_intern(String A_string);
}
class NullInterner implements Interner {
  String A_intern(String A_string) => A_string;
}
final Stopwatch nanoTimeStopwatch = new Stopwatch();
class JavaSystem {
  static int currentTimeMillis() {
    return (new DateTime.now()).millisecondsSinceEpoch;
  }
  static int nanoTime() {
    if (!nanoTimeStopwatch.isRunning) {
      nanoTimeStopwatch.start();
    }
    return nanoTimeStopwatch.elapsedMicroseconds * 1000;
  }
  static void arraycopy(List src, int srcPos, List dest, int destPos, int A_length) {
    for (int i = 0; i < A_length; i++) {
      dest[destPos + i] = src[srcPos + i];
    }
  }
}
class JavaArrays {
  static bool equals(List a, List b) {
    if (identical(a, b)) {
      return true;
    }
    if (a.length != b.length) {
      return false;
    }
    var len = a.length;
    for (int i = 0; i < len; i++) {
      if (a[i] != b[i]) {
        return false;
      }
    }
    return true;
  }
  static int makeHashCode(List a) {
    if (a == null) {
      return 0;
    }
    int result = 1;
    for (var A_element in a) {
      result = 31 * result + (A_element == null ? 0 : A_element.hashCode);
    }
    return result;
  }
  static List asList(List A_list) => A_list;
}
class Character {
  static const int MAX_VALUE = 0xffff;
  static const int MAX_CODE_POINT = 0x10ffff;
  static const int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000;
  static const int MIN_LOW_SURROGATE = 0xDC00;
  static const int MIN_HIGH_SURROGATE = 0xD800;
  static bool isDigit(int c) {
    return c >= 0x30 && c <= 0x39;
  }
  static bool isLetter(int c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
  }
  static bool isLetterOrDigit(int c) {
    return isLetter(c) || isDigit(c);
  }
  static bool A_isWhitespace(int c) {
    return c == 0x09 || c == 0x20 || c == 0x0A || c == 0x0D;
  }
  static int digit(int codePoint, int radix) {
    if (radix != 16) {
      throw new ArgumentError("only radix == 16 is supported");
    }
    if (0x30 <= codePoint && codePoint <= 0x39) {
      return codePoint - 0x30;
    }
    if (0x41 <= codePoint && codePoint <= 0x46) {
      return 0xA + (codePoint - 0x41);
    }
    if (0x61 <= codePoint && codePoint <= 0x66) {
      return 0xA + (codePoint - 0x61);
    }
    return -1;
  }
  static String toChars(int codePoint) {
    if (codePoint < 0 || codePoint > MAX_CODE_POINT) {
      throw new IllegalArgumentException();
    }
    if (codePoint < MIN_SUPPLEMENTARY_CODE_POINT) {
      return new String.fromCharCode(codePoint);
    }
    int A_offset = codePoint - MIN_SUPPLEMENTARY_CODE_POINT;
    int c0 = ((A_offset & 0x7FFFFFFF) >> 10) + MIN_HIGH_SURROGATE;
    int c1 = (A_offset & 0x3ff) + MIN_LOW_SURROGATE;
    return new String.fromCharCodes([c0, c1]);
  }
}
class JavaString {
  static String A_format(String fmt, List args) {
    var A_index = 0;
    return fmt.replaceAllMapped(new RegExp(r'%(.)'), (match) {
      switch (match.group(1)) {
        case '%':
          return '%';

        case 'd': case 's':
          if (A_index >= args.length) {
            throw new MissingFormatArgumentException(match.group(0));
          }
          return args[A_index++].toString();

        default:
          return match.group(1);
      }
    });
  }
  static int A_indexOf(String A_target, String str, int fromIndex) {
    if (fromIndex > A_target.length) return -1;
    if (fromIndex < 0) fromIndex = 0;
    return A_target.indexOf(str, fromIndex);
  }
}
abstract class PrintWriter {
  void print(A_x);
  void newLine() {
    this.print('\n');
  }
  void println(String s) {
    this.print(s);
    this.newLine();
  }
}
class PrintStringWriter extends PrintWriter {
  final StringBuffer _sb = new StringBuffer();
  void print(A_x) {
    _sb.write(A_x);
  }
  String toString() => _sb.toString();
}
class StringUtils {
  static bool B_isEmpty(String str) {
    return str == null || str.isEmpty;
  }
  static String A_join(Iterable iter, [String A_separator = ' ', int A_start = 0, int A_end = -1]) {
    if (A_start != 0) {
      iter = iter.skip(A_start);
    }
    if (A_end != -1) {
      iter = iter.take(A_end - A_start);
    }
    return iter.join(A_separator);
  }
  static List<String> A_split(String s, [String A_pattern = '']) {
    return s.split(A_pattern);
  }
}
class Math {
  static num A_max(num a, num b) => D_p.max(a, b);
  static num A_min(num a, num b) => D_p.min(a, b);
}
class RuntimeException extends JavaException {
  RuntimeException({String message: "", Exception cause: null}) : super(message, cause);
}
class JavaException implements Exception {
  final String message;
  final Exception cause;
  JavaException([this.message = "", this.cause = null]);
  String toString() => "${runtimeType}: ${message} ${cause}";
}
class JavaIOException extends JavaException {}
class IllegalArgumentException extends JavaException {
  IllegalArgumentException([A_message = "", A_cause = null]) : super(A_message, A_cause);
}
class StringIndexOutOfBoundsException extends JavaException {
  StringIndexOutOfBoundsException(int A_index) : super('${A_index}');
}
class IllegalStateException extends JavaException {
  IllegalStateException([A_message = ""]) : super(A_message);
}
class UnsupportedOperationException extends JavaException {
  UnsupportedOperationException([A_message = ""]) : super(A_message);
}
class NoSuchElementException extends JavaException {
  String toString() => "NoSuchElementException";
}
Uri parseUriWithException(String str) {
  Uri A_uri = Uri.parse(str);
  if (A_uri.path.isEmpty) {
    throw new URISyntaxException();
  }
  return A_uri;
}
class URISyntaxException implements Exception {
  String toString() => "URISyntaxException";
}
class MissingFormatArgumentException implements Exception {
  final String s;
  String toString() => "MissingFormatArgumentException: ${s}";
  MissingFormatArgumentException(this.s);
}
class JavaIterator<F_E> {
  Iterable<F_E> A__iterable;
  List<F_E> C__elements = new List<F_E>();
  int _coPos = 0;
  int _elPos = 0;
  F_E B__current = null;
  JavaIterator(this.A__iterable) {
    Iterator A_iterator = A__iterable.iterator;
    while (A_iterator.moveNext()) {
      C__elements.add(A_iterator.current);
    }
  }
  bool get hasNext {
    return _elPos < C__elements.length;
  }
  F_E next() {
    B__current = C__elements[_elPos];
    _coPos++;
    _elPos++;
    return B__current;
  }
  void remove() {
    if (A__iterable is List) {
      _coPos--;
      (A__iterable as List).remove(_coPos);
    } else if (A__iterable is Set) {
      (A__iterable as Set).remove(B__current);
    } else {
      throw new StateError("Unsupported iterable ${A__iterable.runtimeType}");
    }
  }
}
class MapEntry<K, V> {
  final Map<K, V> B__map;
  final K A__key;
  V D__value;
  MapEntry(this.B__map, this.A__key, this.D__value);
  K getKey() => A__key;
  V getValue() => D__value;
}
Iterable<MapEntry> getMapEntrySet(Map m) {
  List<MapEntry> result = [];
  m.forEach((k, v) {
    result.add(new MapEntry(m, k, v));
  });
  return result;
}
bool javaCollectionContainsAll(Iterable A_list, Iterable c) {
  return c.fold(true, (bool prev, e) => prev && A_list.contains(e));
}
javaMapPut(Map A_target, A_key, A_value) {
  var oldValue = A_target[A_key];
  A_target[A_key] = A_value;
  return oldValue;
}
bool javaStringEqualsIgnoreCase(String a, String b) {
  return a.toLowerCase() == b.toLowerCase();
}
bool javaBooleanOr(bool a, bool b) {
  return a || b;
}
bool javaBooleanAnd(bool a, bool b) {
  return a && b;
}
class JavaStringBuilder {
  StringBuffer sb = new StringBuffer();
  String toString() => sb.toString();
  JavaStringBuilder append(A_x) {
    sb.write(A_x);
    return this;
  }
  JavaStringBuilder appendChar(int c) {
    sb.writeCharCode(c);
    return this;
  }
  int get length => sb.length;
  void set length(int newLength) {
    if (newLength < 0) {
      throw new StringIndexOutOfBoundsException(newLength);
    }
    if (sb.length < newLength) {
      while (sb.length < newLength) {
        sb.writeCharCode(0);
      }
    } else if (sb.length > newLength) {
      var s = sb.toString().substring(0, newLength);
      sb = new StringBuffer(s);
    }
  }
  void clear() {
    sb = new StringBuffer();
  }
}
abstract class Enum<F_E extends Enum> implements Comparable<F_E> {
  final String name;
  final int ordinal;
  const Enum(this.name, this.ordinal);
  int get hashCode => ordinal;
  String toString() => name;
  int compareTo(F_E other) => ordinal - other.ordinal;
}
class JavaPatternMatcher {
  Iterator<Match> _matches;
  Match A__match;
  JavaPatternMatcher(RegExp re, String A_input) {
    _matches = re.allMatches(A_input).iterator;
  }
  bool matches() => find();
  bool find() {
    if (!_matches.moveNext()) {
      return false;
    }
    A__match = _matches.current;
    return true;
  }
  String group(int i) => A__match[i];
  int start() => A__match.start;
  int end() => A__match.end;
}
typedef bool A_Predicate<G_E>(G_E argument);
class StringUtilities {
  static const String EMPTY = '';
  static const List<String> E_EMPTY_ARRAY = const<String>[];
  static Interner INTERNER = new NullInterner();
  static String intern(String A_string) => INTERNER.A_intern(A_string);
  static bool isTagName(String s) {
    if (s == null || s.length == 0) {
      return false;
    }
    int sz = s.length;
    for (int i = 0; i < sz; i++) {
      int c = s.codeUnitAt(i);
      if (!Character.isLetter(c)) {
        if (i == 0) {
          return false;
        }
        if (!Character.isDigit(c) && c != 0x2D) {
          return false;
        }
      }
    }
    return true;
  }
  static bool C_isEmpty(String s) {
    return s == null || s.isEmpty;
  }
  static endsWithChar(String str, int c) {
    int A_length = str.length;
    return A_length > 0 && str.codeUnitAt(A_length - 1) == c;
  }
  static endsWith3(String str, int c1, int c2, int c3) {
    var A_length = str.length;
    return A_length >= 3 && str.codeUnitAt(A_length - 3) == c1 && str.codeUnitAt(A_length - 2) == c2 && str.codeUnitAt(A_length - 1) == c3;
  }
  static startsWithChar(String str, int c) {
    return str.length != 0 && str.codeUnitAt(0) == c;
  }
  static startsWith2(String str, int A_start, int c1, int c2) {
    return str.length - A_start >= 2 && str.codeUnitAt(A_start) == c1 && str.codeUnitAt(A_start + 1) == c2;
  }
  static startsWith3(String str, int A_start, int c1, int c2, int c3) {
    return str.length - A_start >= 3 && str.codeUnitAt(A_start) == c1 && str.codeUnitAt(A_start + 1) == c2 && str.codeUnitAt(A_start + 2) == c3;
  }
  static startsWith4(String str, int A_start, int c1, int c2, int c3, int c4) {
    return str.length - A_start >= 4 && str.codeUnitAt(A_start) == c1 && str.codeUnitAt(A_start + 1) == c2 && str.codeUnitAt(A_start + 2) == c3 && str.codeUnitAt(A_start + 3) == c4;
  }
  static startsWith5(String str, int A_start, int c1, int c2, int c3, int c4, int c5) {
    return str.length - A_start >= 5 && str.codeUnitAt(A_start) == c1 && str.codeUnitAt(A_start + 1) == c2 && str.codeUnitAt(A_start + 2) == c3 && str.codeUnitAt(A_start + 3) == c4 && str.codeUnitAt(A_start + 4) == c5;
  }
  static startsWith6(String str, int A_start, int c1, int c2, int c3, int c4, int c5, int c6) {
    return str.length - A_start >= 6 && str.codeUnitAt(A_start) == c1 && str.codeUnitAt(A_start + 1) == c2 && str.codeUnitAt(A_start + 2) == c3 && str.codeUnitAt(A_start + 3) == c4 && str.codeUnitAt(A_start + 4) == c5 && str.codeUnitAt(A_start + 5) == c6;
  }
  static int indexOf1(String str, int A_start, int c) {
    int A_index = A_start;
    int A_last = str.length;
    while (A_index < A_last) {
      if (str.codeUnitAt(A_index) == c) {
        return A_index;
      }
      A_index++;
    }
    return -1;
  }
  static int indexOf2(String str, int A_start, int c1, int c2) {
    int A_index = A_start;
    int A_last = str.length - 1;
    while (A_index < A_last) {
      if (str.codeUnitAt(A_index) == c1 && str.codeUnitAt(A_index + 1) == c2) {
        return A_index;
      }
      A_index++;
    }
    return -1;
  }
  static String substringBeforeChar(String str, int c) {
    if (C_isEmpty(str)) {
      return str;
    }
    int pos = indexOf1(str, 0, c);
    if (pos < 0) {
      return str;
    }
    return str.substring(0, pos);
  }
  static int indexOfFirstNotLetterDigit(String A_string, int startIndex) {
    int A_index = startIndex;
    int A_last = A_string.length;
    while (A_index < A_last) {
      int c = A_string.codeUnitAt(A_index);
      if (!Character.isLetterOrDigit(c)) {
        return A_index;
      }
      A_index++;
    }
    return A_last;
  }
  static String printListOfQuotedNames(List<String> names) {
    if (names == null) {
      throw new IllegalArgumentException("The list must not be null");
    }
    int count = names.length;
    if (count < 2) {
      throw new IllegalArgumentException("The list must contain at least two names");
    }
    StringBuffer A_buffer = new StringBuffer();
    A_buffer.write("'");
    A_buffer.write(names[0]);
    A_buffer.write("'");
    for (int i = 1; i < count - 1; i++) {
      A_buffer.write(", '");
      A_buffer.write(names[i]);
      A_buffer.write("'");
    }
    A_buffer.write(" and '");
    A_buffer.write(names[count - 1]);
    A_buffer.write("'");
    return A_buffer.toString();
  }
}
class FileNameUtilities {
  static String getExtension(String fileName) {
    if (fileName == null) {
      return "";
    }
    int A_index = fileName.lastIndexOf('.');
    if (A_index >= 0) {
      return fileName.substring(A_index + 1);
    }
    return "";
  }
}
class ArrayUtils {
  static List A_add(List A_target, Object A_value) {
    A_target = new List.from(A_target);
    A_target.add(A_value);
    return A_target;
  }
}
class ObjectUtilities {
  static int combineHashCodes(int A_first, int A_second) => A_first * 31 + A_second;
}
class UUID {
  static int __nextId = 0;
  final String id;
  UUID(this.id);
  String toString() => id;
  static UUID randomUUID() => new UUID((__nextId).toString());
}
class AnalysisException implements Exception {
  final String message;
  final CaughtException cause;
  AnalysisException([this.message = 'Exception', this.cause = null]);
  String toString() {
    StringBuffer A_buffer = new StringBuffer();
    A_buffer.write("AnalysisException: ");
    A_buffer.writeln(message);
    if (cause != null) {
      A_buffer.write('Caused by ');
      cause._writeOn(A_buffer);
    }
    return A_buffer.toString();
  }
}
class CaughtException implements Exception {
  final Object exception;
  StackTrace stackTrace;
  CaughtException(this.exception, A_stackTrace) {
    if (A_stackTrace == null) {
      try {
        throw this;
      } catch (L__, st) {
        A_stackTrace = st;
      }
    }
    this.stackTrace = A_stackTrace;
  }
  String toString() {
    StringBuffer A_buffer = new StringBuffer();
    _writeOn(A_buffer);
    return A_buffer.toString();
  }
  void _writeOn(StringBuffer A_buffer) {
    if (exception is AnalysisException) {
      AnalysisException analysisException = exception;
      A_buffer.writeln(analysisException.message);
      if (stackTrace != null) {
        A_buffer.writeln(stackTrace.toString());
      }
      CaughtException A_cause = analysisException.cause;
      if (A_cause != null) {
        A_buffer.write('Caused by ');
        A_cause._writeOn(A_buffer);
      }
    } else {
      A_buffer.writeln(exception.toString());
      A_buffer.writeln(stackTrace.toString());
    }
  }
}
class OSUtilities {
  static bool A_isWindows() => C_p.Platform.operatingSystem == 'windows';
}
class JavaSystemIO {
  static Map<String, String> _properties = new Map();
  static String A_getProperty(String A_name) {
    {
      String A_value = _properties[A_name];
      if (A_value != null) {
        return A_value;
      }
    }
    if (A_name == 'os.name') {
      return C_p.Platform.operatingSystem;
    }
    if (A_name == 'line.separator') {
      if (C_p.Platform.isWindows) {
        return '\r\n';
      }
      return '\n';
    }
    if (A_name == 'com.google.dart.sdk') {
      String exec = C_p.Platform.executable;
      if (exec.length != 0) {
        String sdkPath;
        {
          var outDir = dirname(dirname(exec));
          sdkPath = B_join(dirname(outDir), "sdk");
          if (new C_p.Directory(sdkPath).existsSync()) {
            _properties[A_name] = sdkPath;
            return sdkPath;
          }
        }
        sdkPath = dirname(dirname(exec));
        _properties[A_name] = sdkPath;
        return sdkPath;
      }
    }
    return null;
  }
}
class JavaFile {
  static final String separator = C_p.Platform.pathSeparator;
  String A__path;
  JavaFile(String A_path) {
    A__path = A_path;
  }
  JavaFile.A_relative(JavaFile A_base, String child) {
    if (child.isEmpty) {
      this.A__path = A_base.A__path;
    } else {
      this.A__path = B_join(A_base.A__path, child);
    }
  }
  JavaFile.B_fromUri(Uri A_uri) : this(A_fromUri(A_uri));
  String toString() => A__path.toString();
  int get hashCode => A__path.hashCode;
  bool operator==(other) {
    return other is JavaFile && other.A__path == A__path;
  }
  String getName() => basename(A__path);
  String getParent() {
    var result = dirname(A__path);
    if (result.length < 4) return null;
    return result;
  }
  JavaFile getParentFile() {
    var A_parent = getParent();
    if (A_parent == null) return null;
    return new JavaFile(A_parent);
  }
  String getAbsolutePath() => A_absolute(A__path);
  JavaFile getAbsoluteFile() => new JavaFile(getAbsolutePath());
  bool exists() {
    if (_newFile().existsSync()) {
      return true;
    }
    if (_newDirectory().existsSync()) {
      return true;
    }
    return false;
  }
  bool isExecutable() {
    return _newFile().statSync().mode & 0x111 != 0;
  }
  bool isFile() {
    return _newFile().existsSync();
  }
  bool isDirectory() {
    return _newDirectory().existsSync();
  }
  Uri toURI() => toUri(A__path);
  String readAsStringSync() => _newFile().readAsStringSync();
  int lastModified() {
    if (!_newFile().existsSync()) return 0;
    return _newFile().lastModifiedSync().millisecondsSinceEpoch;
  }
  C_p.File _newFile() => new C_p.File(A__path);
  C_p.Directory _newDirectory() => new C_p.Directory(A__path);
}
class CommentAndMetadata {
  final Comment comment;
  final List<Annotation> metadata;
  CommentAndMetadata(this.comment, this.metadata);
}
class FinalConstVarOrType {
  final A_Token keyword;
  final TypeName type;
  FinalConstVarOrType(this.keyword, this.type);
}
class IncrementalParseDispatcher implements AstVisitor<AstNode> {
  final Parser _parser;
  final AstNode A__oldNode;
  IncrementalParseDispatcher(this._parser, this.A__oldNode);
  AstNode visitAdjacentStrings(AdjacentStrings node) {
    if (node.strings.contains(A__oldNode)) {
      return _parser.parseStringLiteral();
    }
    return _notAChild(node);
  }
  AstNode visitAnnotation(Annotation node) {
    if (identical(A__oldNode, node.name)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.constructorName)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.arguments)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitArgumentList(ArgumentList node) {
    if (node.arguments.contains(A__oldNode)) {
      return _parser.parseArgument();
    }
    return _notAChild(node);
  }
  AstNode visitAsExpression(AsExpression node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseBitwiseOrExpression();
    } else if (identical(A__oldNode, node.type)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitAssertStatement(AssertStatement node) {
    if (identical(A__oldNode, node.condition)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitAssignmentExpression(AssignmentExpression node) {
    if (identical(A__oldNode, node.leftHandSide)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.rightHandSide)) {
      if (_isCascadeAllowedInAssignment(node)) {
        return _parser.parseExpression2();
      }
      return _parser.parseExpressionWithoutCascade();
    }
    return _notAChild(node);
  }
  AstNode visitAwaitExpression(AwaitExpression node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitBinaryExpression(BinaryExpression node) {
    if (identical(A__oldNode, node.leftOperand)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.rightOperand)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitBlock(Block node) {
    if (node.statements.contains(A__oldNode)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitBlockFunctionBody(BlockFunctionBody node) {
    if (identical(A__oldNode, node.block)) {
      return _parser.parseBlock();
    }
    return _notAChild(node);
  }
  AstNode visitBooleanLiteral(BooleanLiteral node) => _notAChild(node);
  AstNode visitBreakStatement(BreakStatement node) {
    if (identical(A__oldNode, node.label)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitCascadeExpression(CascadeExpression node) {
    if (identical(A__oldNode, node.target)) {
      return _parser.parseConditionalExpression();
    } else if (node.cascadeSections.contains(A__oldNode)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitCatchClause(CatchClause node) {
    if (identical(A__oldNode, node.exceptionType)) {
      return _parser.parseTypeName();
    } else if (identical(A__oldNode, node.exceptionParameter)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.stackTraceParameter)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.body)) {
      return _parser.parseBlock();
    }
    return _notAChild(node);
  }
  AstNode visitClassDeclaration(ClassDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.typeParameters)) {
      return _parser.parseTypeParameterList();
    } else if (identical(A__oldNode, node.extendsClause)) {
      return _parser.parseExtendsClause();
    } else if (identical(A__oldNode, node.withClause)) {
      return _parser.parseWithClause();
    } else if (identical(A__oldNode, node.implementsClause)) {
      return _parser.parseImplementsClause();
    } else if (node.members.contains(A__oldNode)) {
      ClassMember member = _parser.parseClassMember(node.name.name);
      if (member == null) {
        throw new InsufficientContextException();
      }
      return member;
    }
    return _notAChild(node);
  }
  AstNode visitClassTypeAlias(ClassTypeAlias node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.typeParameters)) {
      return _parser.parseTypeParameterList();
    } else if (identical(A__oldNode, node.superclass)) {
      return _parser.parseTypeName();
    } else if (identical(A__oldNode, node.withClause)) {
      return _parser.parseWithClause();
    } else if (identical(A__oldNode, node.implementsClause)) {
      return _parser.parseImplementsClause();
    }
    return _notAChild(node);
  }
  AstNode visitComment(Comment node) {
    throw new InsufficientContextException();
  }
  AstNode visitCommentReference(CommentReference node) {
    if (identical(A__oldNode, node.identifier)) {
      return _parser.parsePrefixedIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitCompilationUnit(CompilationUnit node) {
    throw new InsufficientContextException();
  }
  AstNode visitConditionalExpression(ConditionalExpression node) {
    if (identical(A__oldNode, node.condition)) {
      return _parser.parseLogicalOrExpression();
    } else if (identical(A__oldNode, node.thenExpression)) {
      return _parser.parseExpressionWithoutCascade();
    } else if (identical(A__oldNode, node.elseExpression)) {
      return _parser.parseExpressionWithoutCascade();
    }
    return _notAChild(node);
  }
  AstNode visitConstructorDeclaration(ConstructorDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.returnType)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.name)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.parameters)) {
      return _parser.parseFormalParameterList();
    } else if (identical(A__oldNode, node.redirectedConstructor)) {
      throw new InsufficientContextException();
    } else if (node.initializers.contains(A__oldNode)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.body)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    if (identical(A__oldNode, node.fieldName)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.expression)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitConstructorName(ConstructorName node) {
    if (identical(A__oldNode, node.type)) {
      return _parser.parseTypeName();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitContinueStatement(ContinueStatement node) {
    if (identical(A__oldNode, node.label)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitDeclaredIdentifier(DeclaredIdentifier node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.type)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.identifier)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitDefaultFormalParameter(DefaultFormalParameter node) {
    if (identical(A__oldNode, node.parameter)) {
      return _parser.parseNormalFormalParameter();
    } else if (identical(A__oldNode, node.defaultValue)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitDoStatement(DoStatement node) {
    if (identical(A__oldNode, node.body)) {
      return _parser.parseStatement2();
    } else if (identical(A__oldNode, node.condition)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitDoubleLiteral(DoubleLiteral node) => _notAChild(node);
  AstNode visitEmptyFunctionBody(EmptyFunctionBody node) => _notAChild(node);
  AstNode visitEmptyStatement(EmptyStatement node) => _notAChild(node);
  AstNode visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitEnumDeclaration(EnumDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (node.constants.contains(A__oldNode)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitExportDirective(ExportDirective node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.uri)) {
      return _parser.parseStringLiteral();
    } else if (node.combinators.contains(A__oldNode)) {
      throw new IncrementalParseException();
    }
    return _notAChild(node);
  }
  AstNode visitExpressionFunctionBody(ExpressionFunctionBody node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitExpressionStatement(ExpressionStatement node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitExtendsClause(ExtendsClause node) {
    if (identical(A__oldNode, node.superclass)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitFieldDeclaration(FieldDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.fields)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitFieldFormalParameter(FieldFormalParameter node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.type)) {
      return _parser.parseTypeName();
    } else if (identical(A__oldNode, node.identifier)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.parameters)) {
      return _parser.parseFormalParameterList();
    }
    return _notAChild(node);
  }
  AstNode visitForEachStatement(ForEachStatement node) {
    if (identical(A__oldNode, node.loopVariable)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.identifier)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.body)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitFormalParameterList(FormalParameterList node) {
    throw new InsufficientContextException();
  }
  AstNode visitForStatement(ForStatement node) {
    if (identical(A__oldNode, node.variables)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.initialization)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.condition)) {
      return _parser.parseExpression2();
    } else if (node.updaters.contains(A__oldNode)) {
      return _parser.parseExpression2();
    } else if (identical(A__oldNode, node.body)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionDeclaration(FunctionDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.returnType)) {
      return _parser.parseReturnType();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.functionExpression)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionDeclarationStatement(FunctionDeclarationStatement node) {
    if (identical(A__oldNode, node.functionDeclaration)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionExpression(FunctionExpression node) {
    if (identical(A__oldNode, node.parameters)) {
      return _parser.parseFormalParameterList();
    } else if (identical(A__oldNode, node.body)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    if (identical(A__oldNode, node.function)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.argumentList)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionTypeAlias(FunctionTypeAlias node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.returnType)) {
      return _parser.parseReturnType();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.typeParameters)) {
      return _parser.parseTypeParameterList();
    } else if (identical(A__oldNode, node.parameters)) {
      return _parser.parseFormalParameterList();
    }
    return _notAChild(node);
  }
  AstNode visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.returnType)) {
      return _parser.parseReturnType();
    } else if (identical(A__oldNode, node.identifier)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.parameters)) {
      return _parser.parseFormalParameterList();
    }
    return _notAChild(node);
  }
  AstNode visitHideCombinator(HideCombinator node) {
    if (node.hiddenNames.contains(A__oldNode)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitIfStatement(IfStatement node) {
    if (identical(A__oldNode, node.condition)) {
      return _parser.parseExpression2();
    } else if (identical(A__oldNode, node.thenStatement)) {
      return _parser.parseStatement2();
    } else if (identical(A__oldNode, node.elseStatement)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitImplementsClause(ImplementsClause node) {
    if (node.interfaces.contains(node)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitImportDirective(ImportDirective node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.uri)) {
      return _parser.parseStringLiteral();
    } else if (identical(A__oldNode, node.prefix)) {
      return _parser.parseSimpleIdentifier();
    } else if (node.combinators.contains(A__oldNode)) {
      throw new IncrementalParseException();
    }
    return _notAChild(node);
  }
  AstNode visitIndexExpression(IndexExpression node) {
    if (identical(A__oldNode, node.target)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.index)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitInstanceCreationExpression(InstanceCreationExpression node) {
    if (identical(A__oldNode, node.constructorName)) {
      return _parser.parseConstructorName();
    } else if (identical(A__oldNode, node.argumentList)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitIntegerLiteral(IntegerLiteral node) => _notAChild(node);
  AstNode visitInterpolationExpression(InterpolationExpression node) {
    if (identical(A__oldNode, node.expression)) {
      if (node.leftBracket == null) {
        throw new InsufficientContextException();
      }
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitInterpolationString(InterpolationString node) {
    throw new InsufficientContextException();
  }
  AstNode visitIsExpression(IsExpression node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseBitwiseOrExpression();
    } else if (identical(A__oldNode, node.type)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitLabel(Label node) {
    if (identical(A__oldNode, node.label)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitLabeledStatement(LabeledStatement node) {
    if (node.labels.contains(A__oldNode)) {
      return _parser.parseLabel();
    } else if (identical(A__oldNode, node.statement)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitLibraryDirective(LibraryDirective node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseLibraryIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitLibraryIdentifier(LibraryIdentifier node) {
    if (node.components.contains(A__oldNode)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitListLiteral(ListLiteral node) {
    if (identical(A__oldNode, node.typeArguments)) {
      return _parser.parseTypeArgumentList();
    } else if (node.elements.contains(A__oldNode)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitMapLiteral(MapLiteral node) {
    if (identical(A__oldNode, node.typeArguments)) {
      return _parser.parseTypeArgumentList();
    } else if (node.entries.contains(A__oldNode)) {
      return _parser.parseMapLiteralEntry();
    }
    return _notAChild(node);
  }
  AstNode visitMapLiteralEntry(MapLiteralEntry node) {
    if (identical(A__oldNode, node.key)) {
      return _parser.parseExpression2();
    } else if (identical(A__oldNode, node.value)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitMethodDeclaration(MethodDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.returnType)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.name)) {
      if (node.operatorKeyword != null) {
        throw new InsufficientContextException();
      }
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.body)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitMethodInvocation(MethodInvocation node) {
    if (identical(A__oldNode, node.target)) {
      throw new IncrementalParseException();
    } else if (identical(A__oldNode, node.methodName)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.argumentList)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitNamedExpression(NamedExpression node) {
    if (identical(A__oldNode, node.name)) {
      return _parser.parseLabel();
    } else if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitNativeClause(NativeClause node) {
    if (identical(A__oldNode, node.name)) {
      return _parser.parseStringLiteral();
    }
    return _notAChild(node);
  }
  AstNode visitNativeFunctionBody(NativeFunctionBody node) {
    if (identical(A__oldNode, node.stringLiteral)) {
      return _parser.parseStringLiteral();
    }
    return _notAChild(node);
  }
  AstNode visitNullLiteral(NullLiteral node) => _notAChild(node);
  AstNode visitParenthesizedExpression(ParenthesizedExpression node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitPartDirective(PartDirective node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.uri)) {
      return _parser.parseStringLiteral();
    }
    return _notAChild(node);
  }
  AstNode visitPartOfDirective(PartOfDirective node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.libraryName)) {
      return _parser.parseLibraryIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitPostfixExpression(PostfixExpression node) {
    if (identical(A__oldNode, node.operand)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitPrefixedIdentifier(PrefixedIdentifier node) {
    if (identical(A__oldNode, node.prefix)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.identifier)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitPrefixExpression(PrefixExpression node) {
    if (identical(A__oldNode, node.operand)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitPropertyAccess(PropertyAccess node) {
    if (identical(A__oldNode, node.target)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.propertyName)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    if (identical(A__oldNode, node.constructorName)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.argumentList)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitRethrowExpression(RethrowExpression node) => _notAChild(node);
  AstNode visitReturnStatement(ReturnStatement node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  AstNode visitScriptTag(ScriptTag node) => _notAChild(node);
  AstNode visitShowCombinator(ShowCombinator node) {
    if (node.shownNames.contains(A__oldNode)) {
      return _parser.parseSimpleIdentifier();
    }
    return _notAChild(node);
  }
  AstNode visitSimpleFormalParameter(SimpleFormalParameter node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.type)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.identifier)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitSimpleIdentifier(SimpleIdentifier node) => _notAChild(node);
  AstNode visitSimpleStringLiteral(SimpleStringLiteral node) => _notAChild(node);
  AstNode visitStringInterpolation(StringInterpolation node) {
    if (node.elements.contains(A__oldNode)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    if (identical(A__oldNode, node.constructorName)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.argumentList)) {
      return _parser.parseArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitSuperExpression(SuperExpression node) => _notAChild(node);
  AstNode visitSwitchCase(SwitchCase node) {
    if (node.labels.contains(A__oldNode)) {
      return _parser.parseLabel();
    } else if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    } else if (node.statements.contains(A__oldNode)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitSwitchDefault(SwitchDefault node) {
    if (node.labels.contains(A__oldNode)) {
      return _parser.parseLabel();
    } else if (node.statements.contains(A__oldNode)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitSwitchStatement(SwitchStatement node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    } else if (node.members.contains(A__oldNode)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitSymbolLiteral(SymbolLiteral node) => _notAChild(node);
  AstNode visitThisExpression(ThisExpression node) => _notAChild(node);
  AstNode visitThrowExpression(ThrowExpression node) {
    if (identical(A__oldNode, node.expression)) {
      if (_isCascadeAllowedInThrow(node)) {
        return _parser.parseExpression2();
      }
      return _parser.parseExpressionWithoutCascade();
    }
    return _notAChild(node);
  }
  AstNode visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.variables)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitTryStatement(TryStatement node) {
    if (identical(A__oldNode, node.body)) {
      return _parser.parseBlock();
    } else if (node.catchClauses.contains(A__oldNode)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.finallyBlock)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitTypeArgumentList(TypeArgumentList node) {
    if (node.arguments.contains(A__oldNode)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitTypeName(TypeName node) {
    if (identical(A__oldNode, node.name)) {
      return _parser.parsePrefixedIdentifier();
    } else if (identical(A__oldNode, node.typeArguments)) {
      return _parser.parseTypeArgumentList();
    }
    return _notAChild(node);
  }
  AstNode visitTypeParameter(TypeParameter node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      return _parser.parseSimpleIdentifier();
    } else if (identical(A__oldNode, node.bound)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitTypeParameterList(TypeParameterList node) {
    if (node.typeParameters.contains(node)) {
      return _parser.parseTypeParameter();
    }
    return _notAChild(node);
  }
  AstNode visitVariableDeclaration(VariableDeclaration node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (identical(A__oldNode, node.name)) {
      throw new InsufficientContextException();
    } else if (identical(A__oldNode, node.initializer)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitVariableDeclarationList(VariableDeclarationList node) {
    if (identical(A__oldNode, node.documentationComment)) {
      throw new InsufficientContextException();
    } else if (node.metadata.contains(A__oldNode)) {
      return _parser.parseAnnotation();
    } else if (node.variables.contains(A__oldNode)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    if (identical(A__oldNode, node.variables)) {
      throw new InsufficientContextException();
    }
    return _notAChild(node);
  }
  AstNode visitWhileStatement(WhileStatement node) {
    if (identical(A__oldNode, node.condition)) {
      return _parser.parseExpression2();
    } else if (identical(A__oldNode, node.body)) {
      return _parser.parseStatement2();
    }
    return _notAChild(node);
  }
  AstNode visitWithClause(WithClause node) {
    if (node.mixinTypes.contains(node)) {
      return _parser.parseTypeName();
    }
    return _notAChild(node);
  }
  AstNode visitYieldStatement(YieldStatement node) {
    if (identical(A__oldNode, node.expression)) {
      return _parser.parseExpression2();
    }
    return _notAChild(node);
  }
  bool _isCascadeAllowedInAssignment(AssignmentExpression node) {
    throw new InsufficientContextException();
  }
  bool _isCascadeAllowedInThrow(ThrowExpression node) {
    throw new InsufficientContextException();
  }
  AstNode _notAChild(AstNode visitedNode) {
    throw new IncrementalParseException.F_con1("Internal error: the visited node (a ${visitedNode.runtimeType.toString()}) was not the parent of the node to be replaced (a ${A__oldNode.runtimeType.toString()})");
  }
}
class IncrementalParseException extends RuntimeException {
  IncrementalParseException() : super();
  IncrementalParseException.F_con1(String A_message) : super(message: A_message);
}
class IncrementalParser {
  final Source D__source;
  final TokenMap A__tokenMap;
  final AnalysisErrorListener C__errorListener;
  AstNode _updatedNode;
  IncrementalParser(this.D__source, this.A__tokenMap, this.C__errorListener);
  AstNode get updatedNode => _updatedNode;
  AstNode reparse(AstNode originalStructure, A_Token leftToken, A_Token rightToken, int originalStart, int originalEnd) {
    AstNode oldNode = null;
    AstNode newNode = null;
    A_Token firstToken = leftToken.next;
    if (identical(firstToken, rightToken)) {
      firstToken = leftToken;
    }
    if (originalEnd < originalStart) {
      oldNode = new NodeLocator.con1(originalStart).searchWithin(originalStructure);
    } else {
      oldNode = new NodeLocator.con2(originalStart, originalEnd).searchWithin(originalStructure);
    }
    int originalOffset = oldNode.offset;
    A_Token parseToken = _findTokenAt(firstToken, originalOffset);
    if (parseToken == null) {
      return null;
    }
    Parser parser = new Parser(D__source, C__errorListener);
    parser.currentToken = parseToken;
    while (newNode == null) {
      AstNode A_parent = oldNode.parent;
      if (A_parent == null) {
        parseToken = _findFirstToken(parseToken);
        parser.currentToken = parseToken;
        return parser.parseCompilationUnit2();
      }
      bool advanceToParent = false;
      try {
        IncrementalParseDispatcher dispatcher = new IncrementalParseDispatcher(parser, oldNode);
        newNode = A_parent.accept(dispatcher);
        A_Token mappedToken = A__tokenMap.get(oldNode.endToken.next);
        if (mappedToken == null || mappedToken.offset != newNode.endToken.next.offset || newNode.offset != oldNode.offset) {
          advanceToParent = true;
        }
      }on InsufficientContextException  catch (exception) {
        advanceToParent = true;
      }  catch (exception) {
        return null;
      }
      if (advanceToParent) {
        newNode = null;
        oldNode = A_parent;
        originalOffset = oldNode.offset;
        parseToken = _findTokenAt(parseToken, originalOffset);
        parser.currentToken = parseToken;
      }
    }
    _updatedNode = newNode;
    if (identical(oldNode, originalStructure)) {
      ResolutionCopier.copyResolutionData(oldNode, newNode);
      return newNode;
    }
    ResolutionCopier.copyResolutionData(oldNode, newNode);
    IncrementalAstCloner cloner = new IncrementalAstCloner(oldNode, newNode, A__tokenMap);
    return originalStructure.accept(cloner) as AstNode;
  }
  A_Token _findFirstToken(A_Token firstToken) {
    while (firstToken.type != A_TokenType.A_EOF) {
      firstToken = firstToken.previous;
    }
    return firstToken.next;
  }
  A_Token _findTokenAt(A_Token firstToken, int A_offset) {
    while (firstToken.offset > A_offset && firstToken.type != A_TokenType.A_EOF) {
      firstToken = firstToken.previous;
    }
    return firstToken;
  }
}
class InsufficientContextException extends IncrementalParseException {
  InsufficientContextException() : super();
}
class Modifiers {
  A_Token abstractKeyword;
  A_Token constKeyword;
  A_Token externalKeyword;
  A_Token factoryKeyword;
  A_Token finalKeyword;
  A_Token staticKeyword;
  A_Token varKeyword;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    bool needsSpace = _appendKeyword(A_builder, false, abstractKeyword);
    needsSpace = _appendKeyword(A_builder, needsSpace, constKeyword);
    needsSpace = _appendKeyword(A_builder, needsSpace, externalKeyword);
    needsSpace = _appendKeyword(A_builder, needsSpace, factoryKeyword);
    needsSpace = _appendKeyword(A_builder, needsSpace, finalKeyword);
    needsSpace = _appendKeyword(A_builder, needsSpace, staticKeyword);
    _appendKeyword(A_builder, needsSpace, varKeyword);
    return A_builder.toString();
  }
  bool _appendKeyword(JavaStringBuilder A_builder, bool needsSpace, A_Token keyword) {
    if (keyword != null) {
      if (needsSpace) {
        A_builder.appendChar(0x20);
      }
      A_builder.append(keyword.lexeme);
      return true;
    }
    return needsSpace;
  }
}
class Parser {
  final Source D__source;
  final AnalysisErrorListener C__errorListener;
  int _errorListenerLock = 0;
  bool _parseFunctionBodies = true;
  bool _parseAsync = AnalysisOptionsImpl.DEFAULT_ENABLE_ASYNC;
  bool _parseDeferredLibraries = AnalysisOptionsImpl.DEFAULT_ENABLE_DEFERRED_LOADING;
  bool _parseEnum = AnalysisOptionsImpl.DEFAULT_ENABLE_ENUM;
  A_Token A__currentToken;
  bool _inLoop = false;
  bool _inSwitch = false;
  bool _inInitializer = false;
  static String ASYNC = "async";
  static String _AWAIT = "await";
  static String _HIDE = "hide";
  static String _OF = "of";
  static String _ON = "on";
  static String _NATIVE = "native";
  static String _SHOW = "show";
  static String SYNC = "sync";
  static String _YIELD = "yield";
  Parser(this.D__source, this.C__errorListener);
  CompilationUnit parseCompilationUnit(A_Token token) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.Parser.parseCompilationUnit");
    try {
      A__currentToken = token;
      return parseCompilationUnit2();
    } finally {
      instrumentation.log2(2);
    }
  }
  Expression parseExpression(A_Token token) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.Parser.parseExpression");
    try {
      A__currentToken = token;
      return parseExpression2();
    } finally {
      instrumentation.log();
    }
  }
  void set parseAsync(bool A_parseAsync) {
    this._parseAsync = A_parseAsync;
  }
  void set parseDeferredLibraries(bool A_parseDeferredLibraries) {
    this._parseDeferredLibraries = A_parseDeferredLibraries;
  }
  void set parseEnum(bool A_parseEnum) {
    this._parseEnum = A_parseEnum;
  }
  void set parseFunctionBodies(bool A_parseFunctionBodies) {
    this._parseFunctionBodies = A_parseFunctionBodies;
  }
  Annotation parseAnnotation() {
    A_Token atSign = A__expect(A_TokenType.AT);
    Identifier A_name = parsePrefixedIdentifier();
    A_Token period = null;
    SimpleIdentifier constructorName = null;
    if (A__matches(A_TokenType.PERIOD)) {
      period = andAdvance;
      constructorName = parseSimpleIdentifier();
    }
    ArgumentList A_arguments = null;
    if (A__matches(A_TokenType.OPEN_PAREN)) {
      A_arguments = parseArgumentList();
    }
    return new Annotation(atSign, A_name, period, constructorName, A_arguments);
  }
  Expression parseArgument() {
    if (_matchesIdentifier() && _tokenMatches(_peek(), A_TokenType.A_COLON)) {
      return new NamedExpression(parseLabel(), parseExpression2());
    } else {
      return parseExpression2();
    }
  }
  ArgumentList parseArgumentList() {
    A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
    List<Expression> A_arguments = new List<Expression>();
    if (A__matches(A_TokenType.CLOSE_PAREN)) {
      return new ArgumentList(leftParenthesis, A_arguments, andAdvance);
    }
    bool wasInInitializer = _inInitializer;
    _inInitializer = false;
    try {
      Expression argument = parseArgument();
      A_arguments.add(argument);
      bool foundNamedArgument = argument is NamedExpression;
      bool generatedError = false;
      while (_optional(A_TokenType.A_COMMA)) {
        argument = parseArgument();
        A_arguments.add(argument);
        if (foundNamedArgument) {
          if (!generatedError && argument is! NamedExpression) {
            _reportErrorForCurrentToken(ParserErrorCode.POSITIONAL_AFTER_NAMED_ARGUMENT, []);
            generatedError = true;
          }
        } else if (argument is NamedExpression) {
          foundNamedArgument = true;
        }
      }
      A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      return new ArgumentList(leftParenthesis, A_arguments, rightParenthesis);
    } finally {
      _inInitializer = wasInInitializer;
    }
  }
  Expression parseBitwiseOrExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && _tokenMatches(_peek(), A_TokenType.BAR)) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseBitwiseXorExpression();
    }
    while (A__matches(A_TokenType.BAR)) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseBitwiseXorExpression());
    }
    return expression;
  }
  Block parseBlock() {
    A_Token leftBracket = A__expect(A_TokenType.OPEN_CURLY_BRACKET);
    List<Statement> statements = new List<Statement>();
    A_Token statementStart = A__currentToken;
    while (!A__matches(A_TokenType.A_EOF) && !A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
      Statement statement = parseStatement2();
      if (statement != null) {
        statements.add(statement);
      }
      if (identical(A__currentToken, statementStart)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
      }
      statementStart = A__currentToken;
    }
    A_Token rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
    return new Block(leftBracket, statements, rightBracket);
  }
  ClassMember parseClassMember(String className) {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    Modifiers modifiers = _parseModifiers();
    if (_matchesKeyword(Keyword.VOID)) {
      TypeName A_returnType = parseReturnType();
      if (_matchesKeyword(Keyword.GET) && _tokenMatchesIdentifier(_peek())) {
        _validateModifiersForGetterOrSetterOrMethod(modifiers);
        return _parseGetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_returnType);
      } else if (_matchesKeyword(Keyword.SET) && _tokenMatchesIdentifier(_peek())) {
        _validateModifiersForGetterOrSetterOrMethod(modifiers);
        return _parseSetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_returnType);
      } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
        _validateModifiersForOperator(modifiers);
        return _parseOperator(commentAndMetadata, modifiers.externalKeyword, A_returnType);
      } else if (_matchesIdentifier() && _peek().matchesAny([A_TokenType.OPEN_PAREN, A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.D_FUNCTION])) {
        _validateModifiersForGetterOrSetterOrMethod(modifiers);
        return _parseMethodDeclarationAfterReturnType(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_returnType);
      } else {
        if (_matchesIdentifier()) {
          if (_peek().matchesAny([A_TokenType.A_EQ, A_TokenType.A_COMMA, A_TokenType.SEMICOLON])) {
            A__reportErrorForNode(ParserErrorCode.VOID_VARIABLE, A_returnType, []);
            return _parseInitializedIdentifierList(commentAndMetadata, modifiers.staticKeyword, _validateModifiersForField(modifiers), A_returnType);
          }
        }
        if (_isOperator(A__currentToken)) {
          _validateModifiersForOperator(modifiers);
          return _parseOperator(commentAndMetadata, modifiers.externalKeyword, A_returnType);
        }
        A__reportErrorForToken(ParserErrorCode.EXPECTED_EXECUTABLE, A__currentToken, []);
        return null;
      }
    } else if (_matchesKeyword(Keyword.GET) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      return _parseGetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, null);
    } else if (_matchesKeyword(Keyword.SET) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      return _parseSetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, null);
    } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
      _validateModifiersForOperator(modifiers);
      return _parseOperator(commentAndMetadata, modifiers.externalKeyword, null);
    } else if (!_matchesIdentifier()) {
      if (_isOperator(A__currentToken)) {
        _validateModifiersForOperator(modifiers);
        return _parseOperator(commentAndMetadata, modifiers.externalKeyword, null);
      }
      A__reportErrorForToken(ParserErrorCode.EXPECTED_CLASS_MEMBER, A__currentToken, []);
      if (commentAndMetadata.comment != null || !commentAndMetadata.metadata.isEmpty) {
        return new MethodDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, null, null, null, null, null, _createSyntheticIdentifier(), new FormalParameterList(null, new List<FormalParameter>(), null, null, null), new EmptyFunctionBody(_createSyntheticToken(A_TokenType.SEMICOLON)));
      }
      return null;
    } else if (_tokenMatches(_peek(), A_TokenType.PERIOD) && _tokenMatchesIdentifier(_peekAt(2)) && _tokenMatches(_peekAt(3), A_TokenType.OPEN_PAREN)) {
      return _parseConstructor(commentAndMetadata, modifiers.externalKeyword, _validateModifiersForConstructor(modifiers), modifiers.factoryKeyword, parseSimpleIdentifier(), andAdvance, parseSimpleIdentifier(), parseFormalParameterList());
    } else if (_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      SimpleIdentifier methodName = parseSimpleIdentifier();
      FormalParameterList A_parameters = parseFormalParameterList();
      if (A__matches(A_TokenType.A_COLON) || modifiers.factoryKeyword != null || methodName.name == className) {
        return _parseConstructor(commentAndMetadata, modifiers.externalKeyword, _validateModifiersForConstructor(modifiers), modifiers.factoryKeyword, methodName, null, null, A_parameters);
      }
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      _validateFormalParameterList(A_parameters);
      return _parseMethodDeclarationAfterParameters(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, null, methodName, A_parameters);
    } else if (_peek().matchesAny([A_TokenType.A_EQ, A_TokenType.A_COMMA, A_TokenType.SEMICOLON])) {
      if (modifiers.constKeyword == null && modifiers.finalKeyword == null && modifiers.varKeyword == null) {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_CONST_FINAL_VAR_OR_TYPE, []);
      }
      return _parseInitializedIdentifierList(commentAndMetadata, modifiers.staticKeyword, _validateModifiersForField(modifiers), null);
    }
    TypeName A_type = parseTypeName();
    if (_matchesKeyword(Keyword.GET) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      return _parseGetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_type);
    } else if (_matchesKeyword(Keyword.SET) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      return _parseSetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_type);
    } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
      _validateModifiersForOperator(modifiers);
      return _parseOperator(commentAndMetadata, modifiers.externalKeyword, A_type);
    } else if (!_matchesIdentifier()) {
      if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
        return _parseInitializedIdentifierList(commentAndMetadata, modifiers.staticKeyword, _validateModifiersForField(modifiers), A_type);
      }
      if (_isOperator(A__currentToken)) {
        _validateModifiersForOperator(modifiers);
        return _parseOperator(commentAndMetadata, modifiers.externalKeyword, A_type);
      }
      A__reportErrorForToken(ParserErrorCode.EXPECTED_CLASS_MEMBER, A__currentToken, []);
      try {
        _lockErrorListener();
        return _parseInitializedIdentifierList(commentAndMetadata, modifiers.staticKeyword, _validateModifiersForField(modifiers), A_type);
      } finally {
        _unlockErrorListener();
      }
    } else if (_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      SimpleIdentifier methodName = parseSimpleIdentifier();
      FormalParameterList A_parameters = parseFormalParameterList();
      if (methodName.name == className) {
        A__reportErrorForNode(ParserErrorCode.CONSTRUCTOR_WITH_RETURN_TYPE, A_type, []);
        return _parseConstructor(commentAndMetadata, modifiers.externalKeyword, _validateModifiersForConstructor(modifiers), modifiers.factoryKeyword, methodName, null, null, A_parameters);
      }
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      _validateFormalParameterList(A_parameters);
      return _parseMethodDeclarationAfterParameters(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_type, methodName, A_parameters);
    } else if (_tokenMatches(_peek(), A_TokenType.OPEN_CURLY_BRACKET)) {
      _validateModifiersForGetterOrSetterOrMethod(modifiers);
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_GET, []);
      A__currentToken = _injectToken(new Parser_SyntheticKeywordToken(Keyword.GET, A__currentToken.offset));
      return _parseGetter(commentAndMetadata, modifiers.externalKeyword, modifiers.staticKeyword, A_type);
    }
    return _parseInitializedIdentifierList(commentAndMetadata, modifiers.staticKeyword, _validateModifiersForField(modifiers), A_type);
  }
  CompilationUnit parseCompilationUnit2() {
    A_Token firstToken = A__currentToken;
    ScriptTag scriptTag = null;
    if (A__matches(A_TokenType.SCRIPT_TAG)) {
      scriptTag = new ScriptTag(andAdvance);
    }
    bool libraryDirectiveFound = false;
    bool partOfDirectiveFound = false;
    bool partDirectiveFound = false;
    bool directiveFoundAfterDeclaration = false;
    List<Directive> directives = new List<Directive>();
    List<CompilationUnitMember> declarations = new List<CompilationUnitMember>();
    A_Token memberStart = A__currentToken;
    while (!A__matches(A_TokenType.A_EOF)) {
      CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
      if ((_matchesKeyword(Keyword.B_IMPORT) || _matchesKeyword(Keyword.A_EXPORT) || _matchesKeyword(Keyword.C_LIBRARY) || _matchesKeyword(Keyword.PART)) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT) && !_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
        Directive directive = _parseDirective(commentAndMetadata);
        if (declarations.length > 0 && !directiveFoundAfterDeclaration) {
          _reportErrorForCurrentToken(ParserErrorCode.DIRECTIVE_AFTER_DECLARATION, []);
          directiveFoundAfterDeclaration = true;
        }
        if (directive is LibraryDirective) {
          if (libraryDirectiveFound) {
            _reportErrorForCurrentToken(ParserErrorCode.MULTIPLE_LIBRARY_DIRECTIVES, []);
          } else {
            if (directives.length > 0) {
              A__reportErrorForToken(ParserErrorCode.LIBRARY_DIRECTIVE_NOT_FIRST, directive.libraryToken, []);
            }
            libraryDirectiveFound = true;
          }
        } else if (directive is PartDirective) {
          partDirectiveFound = true;
        } else if (partDirectiveFound) {
          if (directive is ExportDirective) {
            A__reportErrorForToken(ParserErrorCode.EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE, directive.keyword, []);
          } else if (directive is ImportDirective) {
            A__reportErrorForToken(ParserErrorCode.IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE, directive.keyword, []);
          }
        }
        if (directive is PartOfDirective) {
          if (partOfDirectiveFound) {
            _reportErrorForCurrentToken(ParserErrorCode.MULTIPLE_PART_OF_DIRECTIVES, []);
          } else {
            int directiveCount = directives.length;
            for (int i = 0; i < directiveCount; i++) {
              A__reportErrorForToken(ParserErrorCode.NON_PART_OF_DIRECTIVE_IN_PART, directives[i].keyword, []);
            }
            partOfDirectiveFound = true;
          }
        } else {
          if (partOfDirectiveFound) {
            A__reportErrorForToken(ParserErrorCode.NON_PART_OF_DIRECTIVE_IN_PART, directive.keyword, []);
          }
        }
        directives.add(directive);
      } else if (A__matches(A_TokenType.SEMICOLON)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
      } else {
        CompilationUnitMember member = _parseCompilationUnitMember(commentAndMetadata);
        if (member != null) {
          declarations.add(member);
        }
      }
      if (identical(A__currentToken, memberStart)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
        while (!A__matches(A_TokenType.A_EOF) && !_couldBeStartOfCompilationUnitMember()) {
          A__advance();
        }
      }
      memberStart = A__currentToken;
    }
    return new CompilationUnit(firstToken, scriptTag, directives, declarations, A__currentToken);
  }
  Expression parseConditionalExpression() {
    Expression condition = parseLogicalOrExpression();
    if (!A__matches(A_TokenType.QUESTION)) {
      return condition;
    }
    A_Token question = andAdvance;
    Expression thenExpression = parseExpressionWithoutCascade();
    A_Token colon = A__expect(A_TokenType.A_COLON);
    Expression elseExpression = parseExpressionWithoutCascade();
    return new ConditionalExpression(condition, question, thenExpression, colon, elseExpression);
  }
  ConstructorName parseConstructorName() {
    TypeName A_type = parseTypeName();
    A_Token period = null;
    SimpleIdentifier A_name = null;
    if (A__matches(A_TokenType.PERIOD)) {
      period = andAdvance;
      A_name = parseSimpleIdentifier();
    }
    return new ConstructorName(A_type, period, A_name);
  }
  Expression parseExpression2() {
    if (_matchesKeyword(Keyword.THROW)) {
      return _parseThrowExpression();
    } else if (_matchesKeyword(Keyword.RETHROW)) {
      return _parseRethrowExpression();
    } else if (_parseAsync && _matchesString(_AWAIT)) {
      return _parseAwaitExpression();
    }
    Expression expression = parseConditionalExpression();
    A_TokenType tokenType = A__currentToken.type;
    if (tokenType == A_TokenType.PERIOD_PERIOD) {
      List<Expression> cascadeSections = new List<Expression>();
      while (tokenType == A_TokenType.PERIOD_PERIOD) {
        Expression section = _parseCascadeSection();
        if (section != null) {
          cascadeSections.add(section);
        }
        tokenType = A__currentToken.type;
      }
      return new CascadeExpression(expression, cascadeSections);
    } else if (tokenType.isAssignmentOperator) {
      A_Token operator = andAdvance;
      _ensureAssignable(expression);
      return new AssignmentExpression(expression, operator, parseExpression2());
    }
    return expression;
  }
  Expression parseExpressionWithoutCascade() {
    if (_matchesKeyword(Keyword.THROW)) {
      return _parseThrowExpressionWithoutCascade();
    } else if (_matchesKeyword(Keyword.RETHROW)) {
      return _parseRethrowExpression();
    }
    Expression expression = parseConditionalExpression();
    if (A__currentToken.type.isAssignmentOperator) {
      A_Token operator = andAdvance;
      _ensureAssignable(expression);
      expression = new AssignmentExpression(expression, operator, parseExpressionWithoutCascade());
    }
    return expression;
  }
  ExtendsClause parseExtendsClause() {
    A_Token keyword = _expectKeyword(Keyword.EXTENDS);
    TypeName superclass = parseTypeName();
    return new ExtendsClause(keyword, superclass);
  }
  FormalParameterList parseFormalParameterList() {
    A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
    if (A__matches(A_TokenType.CLOSE_PAREN)) {
      return new FormalParameterList(leftParenthesis, null, null, null, andAdvance);
    }
    List<FormalParameter> A_parameters = new List<FormalParameter>();
    List<FormalParameter> normalParameters = new List<FormalParameter>();
    List<FormalParameter> positionalParameters = new List<FormalParameter>();
    List<FormalParameter> A_namedParameters = new List<FormalParameter>();
    List<FormalParameter> currentParameters = normalParameters;
    A_Token leftSquareBracket = null;
    A_Token rightSquareBracket = null;
    A_Token leftCurlyBracket = null;
    A_Token rightCurlyBracket = null;
    ParameterKind kind = ParameterKind.REQUIRED;
    bool firstParameter = true;
    bool reportedMuliplePositionalGroups = false;
    bool reportedMulipleNamedGroups = false;
    bool reportedMixedGroups = false;
    bool wasOptionalParameter = false;
    A_Token initialToken = null;
    do {
      if (firstParameter) {
        firstParameter = false;
      } else if (!_optional(A_TokenType.A_COMMA)) {
        if (_getEndToken(leftParenthesis) != null) {
          _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [A_TokenType.A_COMMA.lexeme]);
        } else {
          A__reportErrorForToken(ParserErrorCode.MISSING_CLOSING_PARENTHESIS, A__currentToken.previous, []);
          break;
        }
      }
      initialToken = A__currentToken;
      if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET)) {
        wasOptionalParameter = true;
        if (leftSquareBracket != null && !reportedMuliplePositionalGroups) {
          _reportErrorForCurrentToken(ParserErrorCode.MULTIPLE_POSITIONAL_PARAMETER_GROUPS, []);
          reportedMuliplePositionalGroups = true;
        }
        if (leftCurlyBracket != null && !reportedMixedGroups) {
          _reportErrorForCurrentToken(ParserErrorCode.MIXED_PARAMETER_GROUPS, []);
          reportedMixedGroups = true;
        }
        leftSquareBracket = andAdvance;
        currentParameters = positionalParameters;
        kind = ParameterKind.POSITIONAL;
      } else if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
        wasOptionalParameter = true;
        if (leftCurlyBracket != null && !reportedMulipleNamedGroups) {
          _reportErrorForCurrentToken(ParserErrorCode.MULTIPLE_NAMED_PARAMETER_GROUPS, []);
          reportedMulipleNamedGroups = true;
        }
        if (leftSquareBracket != null && !reportedMixedGroups) {
          _reportErrorForCurrentToken(ParserErrorCode.MIXED_PARAMETER_GROUPS, []);
          reportedMixedGroups = true;
        }
        leftCurlyBracket = andAdvance;
        currentParameters = A_namedParameters;
        kind = ParameterKind.NAMED;
      }
      FormalParameter parameter = _parseFormalParameter(kind);
      A_parameters.add(parameter);
      currentParameters.add(parameter);
      if (kind == ParameterKind.REQUIRED && wasOptionalParameter) {
        A__reportErrorForNode(ParserErrorCode.NORMAL_BEFORE_OPTIONAL_PARAMETERS, parameter, []);
      }
      if (A__matches(A_TokenType.CLOSE_SQUARE_BRACKET)) {
        rightSquareBracket = andAdvance;
        currentParameters = normalParameters;
        if (leftSquareBracket == null) {
          if (leftCurlyBracket != null) {
            _reportErrorForCurrentToken(ParserErrorCode.WRONG_TERMINATOR_FOR_PARAMETER_GROUP, ["}"]);
            rightCurlyBracket = rightSquareBracket;
            rightSquareBracket = null;
          } else {
            _reportErrorForCurrentToken(ParserErrorCode.UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP, ["["]);
          }
        }
        kind = ParameterKind.REQUIRED;
      } else if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
        rightCurlyBracket = andAdvance;
        currentParameters = normalParameters;
        if (leftCurlyBracket == null) {
          if (leftSquareBracket != null) {
            _reportErrorForCurrentToken(ParserErrorCode.WRONG_TERMINATOR_FOR_PARAMETER_GROUP, ["]"]);
            rightSquareBracket = rightCurlyBracket;
            rightCurlyBracket = null;
          } else {
            _reportErrorForCurrentToken(ParserErrorCode.UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP, ["{"]);
          }
        }
        kind = ParameterKind.REQUIRED;
      }
    } while (!A__matches(A_TokenType.CLOSE_PAREN) && !identical(initialToken, A__currentToken));
    A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
    if (leftSquareBracket != null && rightSquareBracket == null) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_TERMINATOR_FOR_PARAMETER_GROUP, ["]"]);
    }
    if (leftCurlyBracket != null && rightCurlyBracket == null) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_TERMINATOR_FOR_PARAMETER_GROUP, ["}"]);
    }
    if (leftSquareBracket == null) {
      leftSquareBracket = leftCurlyBracket;
    }
    if (rightSquareBracket == null) {
      rightSquareBracket = rightCurlyBracket;
    }
    return new FormalParameterList(leftParenthesis, A_parameters, leftSquareBracket, rightSquareBracket, rightParenthesis);
  }
  FunctionExpression parseFunctionExpression() {
    FormalParameterList A_parameters = parseFormalParameterList();
    _validateFormalParameterList(A_parameters);
    FunctionBody body = _parseFunctionBody(false, ParserErrorCode.MISSING_FUNCTION_BODY, true);
    return new FunctionExpression(A_parameters, body);
  }
  ImplementsClause parseImplementsClause() {
    A_Token keyword = _expectKeyword(Keyword.IMPLEMENTS);
    List<TypeName> interfaces = new List<TypeName>();
    interfaces.add(parseTypeName());
    while (_optional(A_TokenType.A_COMMA)) {
      interfaces.add(parseTypeName());
    }
    return new ImplementsClause(keyword, interfaces);
  }
  Label parseLabel() {
    SimpleIdentifier label = parseSimpleIdentifier();
    A_Token colon = A__expect(A_TokenType.A_COLON);
    return new Label(label, colon);
  }
  LibraryIdentifier parseLibraryIdentifier() {
    List<SimpleIdentifier> components = new List<SimpleIdentifier>();
    components.add(parseSimpleIdentifier());
    while (A__matches(A_TokenType.PERIOD)) {
      A__advance();
      components.add(parseSimpleIdentifier());
    }
    return new LibraryIdentifier(components);
  }
  Expression parseLogicalOrExpression() {
    Expression expression = _parseLogicalAndExpression();
    while (A__matches(A_TokenType.BAR_BAR)) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseLogicalAndExpression());
    }
    return expression;
  }
  MapLiteralEntry parseMapLiteralEntry() {
    Expression A_key = parseExpression2();
    A_Token A_separator = A__expect(A_TokenType.A_COLON);
    Expression A_value = parseExpression2();
    return new MapLiteralEntry(A_key, A_separator, A_value);
  }
  NormalFormalParameter parseNormalFormalParameter() {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    FinalConstVarOrType holder = _parseFinalConstVarOrType(true);
    A_Token thisKeyword = null;
    A_Token period = null;
    if (_matchesKeyword(Keyword.THIS)) {
      thisKeyword = andAdvance;
      period = A__expect(A_TokenType.PERIOD);
    }
    SimpleIdentifier identifier = parseSimpleIdentifier();
    if (A__matches(A_TokenType.OPEN_PAREN)) {
      FormalParameterList A_parameters = parseFormalParameterList();
      if (thisKeyword == null) {
        if (holder.keyword != null) {
          A__reportErrorForToken(ParserErrorCode.FUNCTION_TYPED_PARAMETER_VAR, holder.keyword, []);
        }
        return new FunctionTypedFormalParameter(commentAndMetadata.comment, commentAndMetadata.metadata, holder.type, identifier, A_parameters);
      } else {
        return new FieldFormalParameter(commentAndMetadata.comment, commentAndMetadata.metadata, holder.keyword, holder.type, thisKeyword, period, identifier, A_parameters);
      }
    }
    TypeName A_type = holder.type;
    if (A_type != null) {
      if (_tokenMatchesKeyword(A_type.name.beginToken, Keyword.VOID)) {
        A__reportErrorForToken(ParserErrorCode.VOID_PARAMETER, A_type.name.beginToken, []);
      } else if (holder.keyword != null && _tokenMatchesKeyword(holder.keyword, Keyword.VAR)) {
        A__reportErrorForToken(ParserErrorCode.VAR_AND_TYPE, holder.keyword, []);
      }
    }
    if (thisKeyword != null) {
      return new FieldFormalParameter(commentAndMetadata.comment, commentAndMetadata.metadata, holder.keyword, holder.type, thisKeyword, period, identifier, null);
    }
    return new SimpleFormalParameter(commentAndMetadata.comment, commentAndMetadata.metadata, holder.keyword, holder.type, identifier);
  }
  Identifier parsePrefixedIdentifier() {
    SimpleIdentifier qualifier = parseSimpleIdentifier();
    if (!A__matches(A_TokenType.PERIOD)) {
      return qualifier;
    }
    A_Token period = andAdvance;
    SimpleIdentifier qualified = parseSimpleIdentifier();
    return new PrefixedIdentifier(qualifier, period, qualified);
  }
  TypeName parseReturnType() {
    if (_matchesKeyword(Keyword.VOID)) {
      return new TypeName(new SimpleIdentifier(andAdvance), null);
    } else {
      return parseTypeName();
    }
  }
  SimpleIdentifier parseSimpleIdentifier() {
    if (_matchesIdentifier()) {
      return new SimpleIdentifier(andAdvance);
    }
    _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
    return _createSyntheticIdentifier();
  }
  Statement parseStatement2() {
    List<Label> labels = new List<Label>();
    while (_matchesIdentifier() && _tokenMatches(_peek(), A_TokenType.A_COLON)) {
      labels.add(parseLabel());
    }
    Statement statement = _parseNonLabeledStatement();
    if (labels.isEmpty) {
      return statement;
    }
    return new LabeledStatement(labels, statement);
  }
  StringLiteral parseStringLiteral() {
    List<StringLiteral> strings = new List<StringLiteral>();
    while (A__matches(A_TokenType.A_STRING)) {
      A_Token A_string = andAdvance;
      if (A__matches(A_TokenType.STRING_INTERPOLATION_EXPRESSION) || A__matches(A_TokenType.STRING_INTERPOLATION_IDENTIFIER)) {
        strings.add(_parseStringInterpolation(A_string));
      } else {
        strings.add(new SimpleStringLiteral(A_string, _computeStringValue(A_string.lexeme, true, true)));
      }
    }
    if (strings.length < 1) {
      _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_STRING_LITERAL, []);
      return _createSyntheticStringLiteral();
    } else if (strings.length == 1) {
      return strings[0];
    } else {
      return new AdjacentStrings(strings);
    }
  }
  TypeArgumentList parseTypeArgumentList() {
    A_Token leftBracket = A__expect(A_TokenType.A_LT);
    List<TypeName> A_arguments = new List<TypeName>();
    A_arguments.add(parseTypeName());
    while (_optional(A_TokenType.A_COMMA)) {
      A_arguments.add(parseTypeName());
    }
    A_Token rightBracket = _expectGt();
    return new TypeArgumentList(leftBracket, A_arguments, rightBracket);
  }
  TypeName parseTypeName() {
    Identifier typeName;
    if (_matchesKeyword(Keyword.VAR)) {
      _reportErrorForCurrentToken(ParserErrorCode.VAR_AS_TYPE_NAME, []);
      typeName = new SimpleIdentifier(andAdvance);
    } else if (_matchesIdentifier()) {
      typeName = parsePrefixedIdentifier();
    } else {
      typeName = _createSyntheticIdentifier();
      _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TYPE_NAME, []);
    }
    TypeArgumentList typeArguments = null;
    if (A__matches(A_TokenType.A_LT)) {
      typeArguments = parseTypeArgumentList();
    }
    return new TypeName(typeName, typeArguments);
  }
  TypeParameter parseTypeParameter() {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    SimpleIdentifier A_name = parseSimpleIdentifier();
    if (_matchesKeyword(Keyword.EXTENDS)) {
      A_Token keyword = andAdvance;
      TypeName A_bound = parseTypeName();
      return new TypeParameter(commentAndMetadata.comment, commentAndMetadata.metadata, A_name, keyword, A_bound);
    }
    return new TypeParameter(commentAndMetadata.comment, commentAndMetadata.metadata, A_name, null, null);
  }
  TypeParameterList parseTypeParameterList() {
    A_Token leftBracket = A__expect(A_TokenType.A_LT);
    List<TypeParameter> typeParameters = new List<TypeParameter>();
    typeParameters.add(parseTypeParameter());
    while (_optional(A_TokenType.A_COMMA)) {
      typeParameters.add(parseTypeParameter());
    }
    A_Token rightBracket = _expectGt();
    return new TypeParameterList(leftBracket, typeParameters, rightBracket);
  }
  WithClause parseWithClause() {
    A_Token with2 = _expectKeyword(Keyword.WITH);
    List<TypeName> A_types = new List<TypeName>();
    A_types.add(parseTypeName());
    while (_optional(A_TokenType.A_COMMA)) {
      A_types.add(parseTypeName());
    }
    return new WithClause(with2, A_types);
  }
  void set currentToken(A_Token A_currentToken) {
    this.A__currentToken = A_currentToken;
  }
  void A__advance() {
    A__currentToken = A__currentToken.next;
  }
  void _appendScalarValue(JavaStringBuilder A_builder, String escapeSequence, int scalarValue, int startIndex, int endIndex) {
    if (scalarValue < 0 || scalarValue > Character.MAX_CODE_POINT || (scalarValue >= 0xD800 && scalarValue <= 0xDFFF)) {
      _reportErrorForCurrentToken(ParserErrorCode.INVALID_CODE_POINT, [escapeSequence]);
      return;
    }
    if (scalarValue < Character.MAX_VALUE) {
      A_builder.appendChar(scalarValue);
    } else {
      A_builder.append(Character.toChars(scalarValue));
    }
  }
  String _computeStringValue(String lexeme, bool A_first, bool A_last) {
    bool isRaw = false;
    int A_start = 0;
    if (A_first) {
      if (StringUtilities.startsWith4(lexeme, 0, 0x72, 0x22, 0x22, 0x22) || StringUtilities.startsWith4(lexeme, 0, 0x72, 0x27, 0x27, 0x27)) {
        isRaw = true;
        A_start += 4;
      } else if (StringUtilities.startsWith2(lexeme, 0, 0x72, 0x22) || StringUtilities.startsWith2(lexeme, 0, 0x72, 0x27)) {
        isRaw = true;
        A_start += 2;
      } else if (StringUtilities.startsWith3(lexeme, 0, 0x22, 0x22, 0x22) || StringUtilities.startsWith3(lexeme, 0, 0x27, 0x27, 0x27)) {
        A_start += 3;
      } else if (StringUtilities.startsWithChar(lexeme, 0x22) || StringUtilities.startsWithChar(lexeme, 0x27)) {
        A_start += 1;
      }
    }
    int A_end = lexeme.length;
    if (A_last) {
      if (StringUtilities.endsWith3(lexeme, 0x22, 0x22, 0x22) || StringUtilities.endsWith3(lexeme, 0x27, 0x27, 0x27)) {
        A_end -= 3;
      } else if (StringUtilities.endsWithChar(lexeme, 0x22) || StringUtilities.endsWithChar(lexeme, 0x27)) {
        A_end -= 1;
      }
    }
    if (A_end - A_start + 1 < 0) {
      AnalysisEngine.A_instance.logger.logError("Internal error: computeStringValue(${lexeme}, ${A_first}, ${A_last})");
      return "";
    }
    if (isRaw) {
      return lexeme.substring(A_start, A_end);
    }
    JavaStringBuilder A_builder = new JavaStringBuilder();
    int A_index = A_start;
    while (A_index < A_end) {
      A_index = _translateCharacter(A_builder, lexeme, A_index);
    }
    return A_builder.toString();
  }
  FunctionDeclaration _convertToFunctionDeclaration(MethodDeclaration A_method) => new FunctionDeclaration(A_method.documentationComment, A_method.metadata, A_method.externalKeyword, A_method.returnType, A_method.propertyKeyword, A_method.name, new FunctionExpression(A_method.parameters, A_method.body));
  bool _couldBeStartOfCompilationUnitMember() {
    if ((_matchesKeyword(Keyword.B_IMPORT) || _matchesKeyword(Keyword.A_EXPORT) || _matchesKeyword(Keyword.C_LIBRARY) || _matchesKeyword(Keyword.PART)) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT)) {
      return true;
    } else if (_matchesKeyword(Keyword.D_CLASS)) {
      return true;
    } else if (_matchesKeyword(Keyword.A_TYPEDEF) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT)) {
      return true;
    } else if (_matchesKeyword(Keyword.VOID) || ((_matchesKeyword(Keyword.GET) || _matchesKeyword(Keyword.SET)) && _tokenMatchesIdentifier(_peek())) || (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek()))) {
      return true;
    } else if (_matchesIdentifier()) {
      if (_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
        return true;
      }
      A_Token token = _skipReturnType(A__currentToken);
      if (token == null) {
        return false;
      }
      if (_matchesKeyword(Keyword.GET) || _matchesKeyword(Keyword.SET) || (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) || _matchesIdentifier()) {
        return true;
      }
    }
    return false;
  }
  SimpleIdentifier _createSyntheticIdentifier() {
    A_Token syntheticToken;
    if (A__currentToken.type == A_TokenType.A_KEYWORD) {
      syntheticToken = _injectToken(new SyntheticStringToken(A_TokenType.IDENTIFIER, A__currentToken.lexeme, A__currentToken.offset));
    } else {
      syntheticToken = _createSyntheticToken(A_TokenType.IDENTIFIER);
    }
    return new SimpleIdentifier(syntheticToken);
  }
  A_Token _createSyntheticKeyword(Keyword keyword) => _injectToken(new Parser_SyntheticKeywordToken(keyword, A__currentToken.offset));
  SimpleStringLiteral _createSyntheticStringLiteral() => new SimpleStringLiteral(_createSyntheticToken(A_TokenType.A_STRING), "");
  A_Token _createSyntheticToken(A_TokenType A_type) => _injectToken(new StringToken(A_type, "", A__currentToken.offset));
  void _ensureAssignable(Expression expression) {
    if (expression != null && !expression.isAssignable) {
      _reportErrorForCurrentToken(ParserErrorCode.ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE, []);
    }
  }
  A_Token A__expect(A_TokenType A_type) {
    if (A__matches(A_type)) {
      return andAdvance;
    }
    if (A_type == A_TokenType.SEMICOLON) {
      A__reportErrorForToken(ParserErrorCode.EXPECTED_TOKEN, A__currentToken.previous, [A_type.lexeme]);
    } else {
      _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [A_type.lexeme]);
    }
    return A__currentToken;
  }
  A_Token _expectGt() {
    if (_matchesGt()) {
      return andAdvance;
    }
    _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [A_TokenType.A_GT.lexeme]);
    return A__currentToken;
  }
  A_Token _expectKeyword(Keyword keyword) {
    if (_matchesKeyword(keyword)) {
      return andAdvance;
    }
    _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [keyword.syntax]);
    return A__currentToken;
  }
  A_Token _expectSemicolon() {
    if (A__matches(A_TokenType.SEMICOLON)) {
      return andAdvance;
    } else {
      A__reportErrorForToken(ParserErrorCode.EXPECTED_TOKEN, A__currentToken.previous, [";"]);
      return _createSyntheticToken(A_TokenType.SEMICOLON);
    }
  }
  List<int> _findRange(List<List<int>> ranges, int A_index) {
    int rangeCount = ranges.length;
    for (int i = 0; i < rangeCount; i++) {
      List<int> A_range = ranges[i];
      if (A_range[0] <= A_index && A_index <= A_range[1]) {
        return A_range;
      } else if (A_index < A_range[0]) {
        return null;
      }
    }
    return null;
  }
  A_Token get andAdvance {
    A_Token token = A__currentToken;
    A__advance();
    return token;
  }
  List<List<int>> _getCodeBlockRanges(String comment) {
    List<List<int>> ranges = new List<List<int>>();
    int A_length = comment.length;
    if (A_length < 3) {
      return ranges;
    }
    int A_index = 0;
    int firstChar = comment.codeUnitAt(0);
    if (firstChar == 0x2F) {
      int secondChar = comment.codeUnitAt(1);
      int thirdChar = comment.codeUnitAt(2);
      if ((secondChar == 0x2A && thirdChar == 0x2A) || (secondChar == 0x2F && thirdChar == 0x2F)) {
        A_index = 3;
      }
    }
    while (A_index < A_length) {
      int currentChar = comment.codeUnitAt(A_index);
      if (currentChar == 0xD || currentChar == 0xA) {
        A_index = A_index + 1;
        while (A_index < A_length && Character.A_isWhitespace(comment.codeUnitAt(A_index))) {
          A_index = A_index + 1;
        }
        if (StringUtilities.startsWith6(comment, A_index, 0x2A, 0x20, 0x20, 0x20, 0x20, 0x20)) {
          int A_end = A_index + 6;
          while (A_end < A_length && comment.codeUnitAt(A_end) != 0xD && comment.codeUnitAt(A_end) != 0xA) {
            A_end = A_end + 1;
          }
          ranges.add(<int>[A_index, A_end]);
          A_index = A_end;
        }
      } else if (A_index + 1 < A_length && currentChar == 0x5B && comment.codeUnitAt(A_index + 1) == 0x3A) {
        int A_end = StringUtilities.indexOf2(comment, A_index + 2, 0x3A, 0x5D);
        if (A_end < 0) {
          A_end = A_length;
        }
        ranges.add(<int>[A_index, A_end]);
        A_index = A_end + 1;
      } else {
        A_index = A_index + 1;
      }
    }
    return ranges;
  }
  A_Token _getEndToken(A_Token beginToken) {
    if (beginToken is BeginToken) {
      return beginToken.endToken;
    }
    return null;
  }
  bool get hasReturnTypeInTypeAlias {
    A_Token A_next = _skipReturnType(A__currentToken);
    if (A_next == null) {
      return false;
    }
    return _tokenMatchesIdentifier(A_next);
  }
  A_Token _injectToken(A_Token token) {
    A_Token A_previous = A__currentToken.previous;
    token.setNext(A__currentToken);
    A_previous.setNext(token);
    return token;
  }
  bool _isFunctionDeclaration() {
    if (_matchesKeyword(Keyword.VOID)) {
      return true;
    }
    A_Token afterReturnType = _skipTypeName(A__currentToken);
    if (afterReturnType == null) {
      afterReturnType = A__currentToken;
    }
    A_Token afterIdentifier = _skipSimpleIdentifier(afterReturnType);
    if (afterIdentifier == null) {
      afterIdentifier = _skipSimpleIdentifier(A__currentToken);
    }
    if (afterIdentifier == null) {
      return false;
    }
    if (_isFunctionExpression(afterIdentifier)) {
      return true;
    }
    if (_matchesKeyword(Keyword.GET)) {
      A_Token afterName = _skipSimpleIdentifier(A__currentToken.next);
      if (afterName == null) {
        return false;
      }
      return _tokenMatches(afterName, A_TokenType.D_FUNCTION) || _tokenMatches(afterName, A_TokenType.OPEN_CURLY_BRACKET);
    }
    return false;
  }
  bool _isFunctionExpression(A_Token startToken) {
    if (_inInitializer) {
      return false;
    }
    A_Token afterParameters = _skipFormalParameterList(startToken);
    if (afterParameters == null) {
      return false;
    }
    return afterParameters.matchesAny([A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.D_FUNCTION]);
  }
  bool A__isHexDigit(int character) => (0x30 <= character && character <= 0x39) || (0x41 <= character && character <= 0x46) || (0x61 <= character && character <= 0x66);
  bool _isInitializedVariableDeclaration() {
    if (_matchesKeyword(Keyword.A_FINAL) || _matchesKeyword(Keyword.VAR)) {
      return true;
    }
    if (_matchesKeyword(Keyword.B_CONST)) {
      return !_peek().matchesAny([A_TokenType.A_LT, A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.OPEN_SQUARE_BRACKET, A_TokenType.INDEX]);
    }
    A_Token token = _skipTypeName(A__currentToken);
    if (token == null) {
      return false;
    }
    token = _skipSimpleIdentifier(token);
    if (token == null) {
      return false;
    }
    A_TokenType A_type = token.type;
    return A_type == A_TokenType.A_EQ || A_type == A_TokenType.A_COMMA || A_type == A_TokenType.SEMICOLON || _tokenMatchesKeyword(token, Keyword.IN);
  }
  bool _isLinkText(String comment, int rightIndex) {
    int A_length = comment.length;
    int A_index = rightIndex + 1;
    if (A_index >= A_length) {
      return false;
    }
    int nextChar = comment.codeUnitAt(A_index);
    if (nextChar == 0x28 || nextChar == 0x3A) {
      return true;
    }
    while (Character.A_isWhitespace(nextChar)) {
      A_index = A_index + 1;
      if (A_index >= A_length) {
        return false;
      }
      nextChar = comment.codeUnitAt(A_index);
    }
    return nextChar == 0x5B;
  }
  bool _isOperator(A_Token startToken) {
    if (!startToken.isOperator) {
      return false;
    }
    if (startToken.type == A_TokenType.A_EQ) {
      return false;
    }
    A_Token token = startToken.next;
    while (token.isOperator) {
      token = token.next;
    }
    return _tokenMatches(token, A_TokenType.OPEN_PAREN);
  }
  bool _isSwitchMember() {
    A_Token token = A__currentToken;
    while (_tokenMatches(token, A_TokenType.IDENTIFIER) && _tokenMatches(token.next, A_TokenType.A_COLON)) {
      token = token.next.next;
    }
    if (token.type == A_TokenType.A_KEYWORD) {
      Keyword keyword = (token as KeywordToken).keyword;
      return keyword == Keyword.CASE || keyword == Keyword.A_DEFAULT;
    }
    return false;
  }
  bool _isTypedIdentifier(A_Token startToken) {
    A_Token token = _skipReturnType(startToken);
    if (token == null) {
      return false;
    } else if (_tokenMatchesIdentifier(token)) {
      return true;
    } else if (_tokenMatchesKeyword(token, Keyword.THIS) && _tokenMatches(token.next, A_TokenType.PERIOD) && _tokenMatchesIdentifier(token.next.next)) {
      return true;
    }
    return false;
  }
  A_Token _lexicallyFirst(List<A_Token> tokens) {
    A_Token A_first = null;
    int firstOffset = 2147483647;
    for (A_Token token in tokens) {
      if (token != null) {
        int A_offset = token.offset;
        if (A_offset < firstOffset) {
          A_first = token;
          firstOffset = A_offset;
        }
      }
    }
    return A_first;
  }
  void _lockErrorListener() {
    _errorListenerLock++;
  }
  bool A__matches(A_TokenType A_type) => A__currentToken.type == A_type;
  bool _matchesGt() {
    A_TokenType currentType = A__currentToken.type;
    if (currentType == A_TokenType.A_GT) {
      return true;
    } else if (currentType == A_TokenType.GT_GT) {
      int A_offset = A__currentToken.offset;
      A_Token A_first = new A_Token(A_TokenType.A_GT, A_offset);
      A_Token A_second = new A_Token(A_TokenType.A_GT, A_offset + 1);
      A_second.setNext(A__currentToken.next);
      A_first.setNext(A_second);
      A__currentToken.previous.setNext(A_first);
      A__currentToken = A_first;
      return true;
    } else if (currentType == A_TokenType.GT_EQ) {
      int A_offset = A__currentToken.offset;
      A_Token A_first = new A_Token(A_TokenType.A_GT, A_offset);
      A_Token A_second = new A_Token(A_TokenType.A_EQ, A_offset + 1);
      A_second.setNext(A__currentToken.next);
      A_first.setNext(A_second);
      A__currentToken.previous.setNext(A_first);
      A__currentToken = A_first;
      return true;
    } else if (currentType == A_TokenType.GT_GT_EQ) {
      int A_offset = A__currentToken.offset;
      A_Token A_first = new A_Token(A_TokenType.A_GT, A_offset);
      A_Token A_second = new A_Token(A_TokenType.A_GT, A_offset + 1);
      A_Token third = new A_Token(A_TokenType.A_EQ, A_offset + 2);
      third.setNext(A__currentToken.next);
      A_second.setNext(third);
      A_first.setNext(A_second);
      A__currentToken.previous.setNext(A_first);
      A__currentToken = A_first;
      return true;
    }
    return false;
  }
  bool _matchesIdentifier() => _tokenMatchesIdentifier(A__currentToken);
  bool _matchesKeyword(Keyword keyword) => _tokenMatchesKeyword(A__currentToken, keyword);
  bool _matchesString(String identifier) => A__currentToken.type == A_TokenType.IDENTIFIER && A__currentToken.lexeme == identifier;
  bool _optional(A_TokenType A_type) {
    if (A__matches(A_type)) {
      A__advance();
      return true;
    }
    return false;
  }
  Expression _parseAdditiveExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && A__currentToken.next.type.isAdditiveOperator) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseMultiplicativeExpression();
    }
    while (A__currentToken.type.isAdditiveOperator) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseMultiplicativeExpression());
    }
    return expression;
  }
  AssertStatement _parseAssertStatement() {
    A_Token keyword = _expectKeyword(Keyword.ASSERT);
    A_Token leftParen = A__expect(A_TokenType.OPEN_PAREN);
    Expression expression = parseExpression2();
    if (expression is AssignmentExpression) {
      A__reportErrorForNode(ParserErrorCode.ASSERT_DOES_NOT_TAKE_ASSIGNMENT, expression, []);
    } else if (expression is CascadeExpression) {
      A__reportErrorForNode(ParserErrorCode.ASSERT_DOES_NOT_TAKE_CASCADE, expression, []);
    } else if (expression is ThrowExpression) {
      A__reportErrorForNode(ParserErrorCode.ASSERT_DOES_NOT_TAKE_THROW, expression, []);
    } else if (expression is RethrowExpression) {
      A__reportErrorForNode(ParserErrorCode.ASSERT_DOES_NOT_TAKE_RETHROW, expression, []);
    }
    A_Token rightParen = A__expect(A_TokenType.CLOSE_PAREN);
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new AssertStatement(keyword, leftParen, expression, rightParen, semicolon);
  }
  Expression _parseAssignableExpression(bool primaryAllowed) {
    if (_matchesKeyword(Keyword.SUPER)) {
      return _parseAssignableSelector(new SuperExpression(andAdvance), false);
    }
    Expression expression = _parsePrimaryExpression();
    bool isOptional = primaryAllowed || expression is SimpleIdentifier;
    while (true) {
      while (A__matches(A_TokenType.OPEN_PAREN)) {
        ArgumentList argumentList = parseArgumentList();
        if (expression is SimpleIdentifier) {
          expression = new MethodInvocation(null, null, expression as SimpleIdentifier, argumentList);
        } else if (expression is PrefixedIdentifier) {
          PrefixedIdentifier identifier = expression as PrefixedIdentifier;
          expression = new MethodInvocation(identifier.prefix, identifier.period, identifier.identifier, argumentList);
        } else if (expression is PropertyAccess) {
          PropertyAccess access = expression as PropertyAccess;
          expression = new MethodInvocation(access.target, access.operator, access.propertyName, argumentList);
        } else {
          expression = new FunctionExpressionInvocation(expression, argumentList);
        }
        if (!primaryAllowed) {
          isOptional = false;
        }
      }
      Expression selectorExpression = _parseAssignableSelector(expression, isOptional || (expression is PrefixedIdentifier));
      if (identical(selectorExpression, expression)) {
        if (!isOptional && (expression is PrefixedIdentifier)) {
          PrefixedIdentifier identifier = expression as PrefixedIdentifier;
          expression = new PropertyAccess(identifier.prefix, identifier.period, identifier.identifier);
        }
        return expression;
      }
      expression = selectorExpression;
      isOptional = true;
    }
  }
  Expression _parseAssignableSelector(Expression prefix, bool optional) {
    if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET)) {
      A_Token leftBracket = andAdvance;
      bool wasInInitializer = _inInitializer;
      _inInitializer = false;
      try {
        Expression A_index = parseExpression2();
        A_Token rightBracket = A__expect(A_TokenType.CLOSE_SQUARE_BRACKET);
        return new IndexExpression.forTarget(prefix, leftBracket, A_index, rightBracket);
      } finally {
        _inInitializer = wasInInitializer;
      }
    } else if (A__matches(A_TokenType.PERIOD)) {
      A_Token period = andAdvance;
      return new PropertyAccess(prefix, period, parseSimpleIdentifier());
    } else {
      if (!optional) {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_ASSIGNABLE_SELECTOR, []);
      }
      return prefix;
    }
  }
  AwaitExpression _parseAwaitExpression() {
    A_Token awaitToken = andAdvance;
    Expression expression = parseExpression2();
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new AwaitExpression(awaitToken, expression, semicolon);
  }
  Expression _parseBitwiseAndExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && _tokenMatches(_peek(), A_TokenType.A_AMPERSAND)) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseShiftExpression();
    }
    while (A__matches(A_TokenType.A_AMPERSAND)) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseShiftExpression());
    }
    return expression;
  }
  Expression _parseBitwiseXorExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && _tokenMatches(_peek(), A_TokenType.CARET)) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseBitwiseAndExpression();
    }
    while (A__matches(A_TokenType.CARET)) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseBitwiseAndExpression());
    }
    return expression;
  }
  Statement _parseBreakStatement() {
    A_Token breakKeyword = _expectKeyword(Keyword.BREAK);
    SimpleIdentifier label = null;
    if (_matchesIdentifier()) {
      label = parseSimpleIdentifier();
    }
    if (!_inLoop && !_inSwitch && label == null) {
      A__reportErrorForToken(ParserErrorCode.BREAK_OUTSIDE_OF_LOOP, breakKeyword, []);
    }
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new BreakStatement(breakKeyword, label, semicolon);
  }
  Expression _parseCascadeSection() {
    A_Token period = A__expect(A_TokenType.PERIOD_PERIOD);
    Expression expression = null;
    SimpleIdentifier functionName = null;
    if (_matchesIdentifier()) {
      functionName = parseSimpleIdentifier();
    } else if (A__currentToken.type == A_TokenType.OPEN_SQUARE_BRACKET) {
      A_Token leftBracket = andAdvance;
      bool wasInInitializer = _inInitializer;
      _inInitializer = false;
      try {
        Expression A_index = parseExpression2();
        A_Token rightBracket = A__expect(A_TokenType.CLOSE_SQUARE_BRACKET);
        expression = new IndexExpression.forCascade(period, leftBracket, A_index, rightBracket);
        period = null;
      } finally {
        _inInitializer = wasInInitializer;
      }
    } else {
      A__reportErrorForToken(ParserErrorCode.MISSING_IDENTIFIER, A__currentToken, [A__currentToken.lexeme]);
      functionName = _createSyntheticIdentifier();
    }
    assert((expression == null && functionName != null) || (expression != null && functionName == null));
    if (A__currentToken.type == A_TokenType.OPEN_PAREN) {
      while (A__currentToken.type == A_TokenType.OPEN_PAREN) {
        if (functionName != null) {
          expression = new MethodInvocation(expression, period, functionName, parseArgumentList());
          period = null;
          functionName = null;
        } else if (expression == null) {
          expression = new MethodInvocation(expression, period, _createSyntheticIdentifier(), parseArgumentList());
        } else {
          expression = new FunctionExpressionInvocation(expression, parseArgumentList());
        }
      }
    } else if (functionName != null) {
      expression = new PropertyAccess(expression, period, functionName);
      period = null;
    }
    assert(expression != null);
    bool A_progress = true;
    while (A_progress) {
      A_progress = false;
      Expression selector = _parseAssignableSelector(expression, true);
      if (!identical(selector, expression)) {
        expression = selector;
        A_progress = true;
        while (A__currentToken.type == A_TokenType.OPEN_PAREN) {
          if (expression is PropertyAccess) {
            PropertyAccess propertyAccess = expression as PropertyAccess;
            expression = new MethodInvocation(propertyAccess.target, propertyAccess.operator, propertyAccess.propertyName, parseArgumentList());
          } else {
            expression = new FunctionExpressionInvocation(expression, parseArgumentList());
          }
        }
      }
    }
    if (A__currentToken.type.isAssignmentOperator) {
      A_Token operator = andAdvance;
      _ensureAssignable(expression);
      expression = new AssignmentExpression(expression, operator, parseExpressionWithoutCascade());
    }
    return expression;
  }
  CompilationUnitMember _parseClassDeclaration(CommentAndMetadata commentAndMetadata, A_Token abstractKeyword) {
    A_Token keyword = _expectKeyword(Keyword.D_CLASS);
    if (_matchesIdentifier()) {
      A_Token A_next = _peek();
      if (_tokenMatches(A_next, A_TokenType.A_LT)) {
        A_next = _skipTypeParameterList(A_next);
        if (A_next != null && _tokenMatches(A_next, A_TokenType.A_EQ)) {
          return _parseClassTypeAlias(commentAndMetadata, abstractKeyword, keyword);
        }
      } else if (_tokenMatches(A_next, A_TokenType.A_EQ)) {
        return _parseClassTypeAlias(commentAndMetadata, abstractKeyword, keyword);
      }
    }
    SimpleIdentifier A_name = parseSimpleIdentifier();
    String className = A_name.name;
    TypeParameterList typeParameters = null;
    if (A__matches(A_TokenType.A_LT)) {
      typeParameters = parseTypeParameterList();
    }
    ExtendsClause extendsClause = null;
    WithClause withClause = null;
    ImplementsClause implementsClause = null;
    bool foundClause = true;
    while (foundClause) {
      if (_matchesKeyword(Keyword.EXTENDS)) {
        if (extendsClause == null) {
          extendsClause = parseExtendsClause();
          if (withClause != null) {
            A__reportErrorForToken(ParserErrorCode.WITH_BEFORE_EXTENDS, withClause.withKeyword, []);
          } else if (implementsClause != null) {
            A__reportErrorForToken(ParserErrorCode.IMPLEMENTS_BEFORE_EXTENDS, implementsClause.keyword, []);
          }
        } else {
          A__reportErrorForToken(ParserErrorCode.MULTIPLE_EXTENDS_CLAUSES, extendsClause.keyword, []);
          parseExtendsClause();
        }
      } else if (_matchesKeyword(Keyword.WITH)) {
        if (withClause == null) {
          withClause = parseWithClause();
          if (implementsClause != null) {
            A__reportErrorForToken(ParserErrorCode.IMPLEMENTS_BEFORE_WITH, implementsClause.keyword, []);
          }
        } else {
          A__reportErrorForToken(ParserErrorCode.MULTIPLE_WITH_CLAUSES, withClause.withKeyword, []);
          parseWithClause();
        }
      } else if (_matchesKeyword(Keyword.IMPLEMENTS)) {
        if (implementsClause == null) {
          implementsClause = parseImplementsClause();
        } else {
          A__reportErrorForToken(ParserErrorCode.MULTIPLE_IMPLEMENTS_CLAUSES, implementsClause.keyword, []);
          parseImplementsClause();
        }
      } else {
        foundClause = false;
      }
    }
    if (withClause != null && extendsClause == null) {
      A__reportErrorForToken(ParserErrorCode.WITH_WITHOUT_EXTENDS, withClause.withKeyword, []);
    }
    NativeClause nativeClause = null;
    if (_matchesString(_NATIVE) && _tokenMatches(_peek(), A_TokenType.A_STRING)) {
      nativeClause = _parseNativeClause();
    }
    A_Token leftBracket = null;
    List<ClassMember> members = null;
    A_Token rightBracket = null;
    if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      leftBracket = A__expect(A_TokenType.OPEN_CURLY_BRACKET);
      members = _parseClassMembers(className, _getEndToken(leftBracket));
      rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
    } else {
      leftBracket = _createSyntheticToken(A_TokenType.OPEN_CURLY_BRACKET);
      rightBracket = _createSyntheticToken(A_TokenType.CLOSE_CURLY_BRACKET);
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_CLASS_BODY, []);
    }
    ClassDeclaration classDeclaration = new ClassDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, abstractKeyword, keyword, A_name, typeParameters, extendsClause, withClause, implementsClause, leftBracket, members, rightBracket);
    classDeclaration.nativeClause = nativeClause;
    return classDeclaration;
  }
  List<ClassMember> _parseClassMembers(String className, A_Token closingBracket) {
    List<ClassMember> members = new List<ClassMember>();
    A_Token memberStart = A__currentToken;
    while (!A__matches(A_TokenType.A_EOF) && !A__matches(A_TokenType.CLOSE_CURLY_BRACKET) && (closingBracket != null || (!_matchesKeyword(Keyword.D_CLASS) && !_matchesKeyword(Keyword.A_TYPEDEF)))) {
      if (A__matches(A_TokenType.SEMICOLON)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
      } else {
        ClassMember member = parseClassMember(className);
        if (member != null) {
          members.add(member);
        }
      }
      if (identical(A__currentToken, memberStart)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
      }
      memberStart = A__currentToken;
    }
    return members;
  }
  ClassTypeAlias _parseClassTypeAlias(CommentAndMetadata commentAndMetadata, A_Token abstractKeyword, A_Token classKeyword) {
    SimpleIdentifier className = parseSimpleIdentifier();
    TypeParameterList typeParameters = null;
    if (A__matches(A_TokenType.A_LT)) {
      typeParameters = parseTypeParameterList();
    }
    A_Token A_equals = A__expect(A_TokenType.A_EQ);
    TypeName superclass = parseTypeName();
    WithClause withClause = null;
    if (_matchesKeyword(Keyword.WITH)) {
      withClause = parseWithClause();
    } else {
      _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [Keyword.WITH.syntax]);
    }
    ImplementsClause implementsClause = null;
    if (_matchesKeyword(Keyword.IMPLEMENTS)) {
      implementsClause = parseImplementsClause();
    }
    A_Token semicolon;
    if (A__matches(A_TokenType.SEMICOLON)) {
      semicolon = andAdvance;
    } else {
      if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
        _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_TOKEN, [A_TokenType.SEMICOLON.lexeme]);
        A_Token leftBracket = andAdvance;
        _parseClassMembers(className.name, _getEndToken(leftBracket));
        A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
      } else {
        A__reportErrorForToken(ParserErrorCode.EXPECTED_TOKEN, A__currentToken.previous, [A_TokenType.SEMICOLON.lexeme]);
      }
      semicolon = _createSyntheticToken(A_TokenType.SEMICOLON);
    }
    return new ClassTypeAlias(commentAndMetadata.comment, commentAndMetadata.metadata, classKeyword, className, typeParameters, A_equals, abstractKeyword, superclass, withClause, implementsClause, semicolon);
  }
  List<Combinator> _parseCombinators() {
    List<Combinator> combinators = new List<Combinator>();
    while (_matchesString(_SHOW) || _matchesString(_HIDE)) {
      A_Token keyword = A__expect(A_TokenType.IDENTIFIER);
      if (keyword.lexeme == _SHOW) {
        List<SimpleIdentifier> shownNames = _parseIdentifierList();
        combinators.add(new ShowCombinator(keyword, shownNames));
      } else {
        List<SimpleIdentifier> hiddenNames = _parseIdentifierList();
        combinators.add(new HideCombinator(keyword, hiddenNames));
      }
    }
    return combinators;
  }
  CommentAndMetadata _parseCommentAndMetadata() {
    Comment comment = _parseDocumentationComment();
    List<Annotation> metadata = new List<Annotation>();
    while (A__matches(A_TokenType.AT)) {
      metadata.add(parseAnnotation());
      Comment optionalComment = _parseDocumentationComment();
      if (optionalComment != null) {
        comment = optionalComment;
      }
    }
    return new CommentAndMetadata(comment, metadata);
  }
  CommentReference _parseCommentReference(String referenceSource, int sourceOffset) {
    if (referenceSource.length == 0) {
      A_Token syntheticToken = new SyntheticStringToken(A_TokenType.IDENTIFIER, "", sourceOffset);
      return new CommentReference(null, new SimpleIdentifier(syntheticToken));
    }
    try {
      BooleanErrorListener listener = new BooleanErrorListener();
      Scanner scanner = new Scanner(null, new SubSequenceReader(referenceSource, sourceOffset), listener);
      scanner.setSourceStart(1, 1);
      A_Token firstToken = scanner.tokenize();
      if (listener.errorReported) {
        return null;
      }
      A_Token newKeyword = null;
      if (_tokenMatchesKeyword(firstToken, Keyword.NEW)) {
        newKeyword = firstToken;
        firstToken = firstToken.next;
      }
      if (_tokenMatchesIdentifier(firstToken)) {
        A_Token secondToken = firstToken.next;
        A_Token thirdToken = secondToken.next;
        A_Token nextToken;
        Identifier identifier;
        if (_tokenMatches(secondToken, A_TokenType.PERIOD) && _tokenMatchesIdentifier(thirdToken)) {
          identifier = new PrefixedIdentifier(new SimpleIdentifier(firstToken), secondToken, new SimpleIdentifier(thirdToken));
          nextToken = thirdToken.next;
        } else {
          identifier = new SimpleIdentifier(firstToken);
          nextToken = firstToken.next;
        }
        if (nextToken.type != A_TokenType.A_EOF) {
          return null;
        }
        return new CommentReference(newKeyword, identifier);
      } else if (_tokenMatchesKeyword(firstToken, Keyword.THIS) || _tokenMatchesKeyword(firstToken, Keyword.A_NULL) || _tokenMatchesKeyword(firstToken, Keyword.TRUE) || _tokenMatchesKeyword(firstToken, Keyword.FALSE)) {
        return null;
      }
    } catch (exception) {}
    return null;
  }
  List<CommentReference> _parseCommentReferences(List<A_Token> tokens) {
    List<CommentReference> references = new List<CommentReference>();
    for (A_Token token in tokens) {
      String comment = token.lexeme;
      int A_length = comment.length;
      List<List<int>> codeBlockRanges = _getCodeBlockRanges(comment);
      int leftIndex = comment.indexOf('[');
      while (leftIndex >= 0 && leftIndex + 1 < A_length) {
        List<int> A_range = _findRange(codeBlockRanges, leftIndex);
        if (A_range == null) {
          int nameOffset = token.offset + leftIndex + 1;
          int rightIndex = JavaString.A_indexOf(comment, ']', leftIndex);
          if (rightIndex >= 0) {
            int firstChar = comment.codeUnitAt(leftIndex + 1);
            if (firstChar != 0x27 && firstChar != 0x22) {
              if (_isLinkText(comment, rightIndex)) {} else {
                CommentReference A_reference = _parseCommentReference(comment.substring(leftIndex + 1, rightIndex), nameOffset);
                if (A_reference != null) {
                  references.add(A_reference);
                }
              }
            }
          } else {
            int charAfterLeft = comment.codeUnitAt(leftIndex + 1);
            if (Character.isLetterOrDigit(charAfterLeft)) {
              int nameEnd = StringUtilities.indexOfFirstNotLetterDigit(comment, leftIndex + 1);
              String A_name = comment.substring(leftIndex + 1, nameEnd);
              A_Token nameToken = new StringToken(A_TokenType.IDENTIFIER, A_name, nameOffset);
              references.add(new CommentReference(null, new SimpleIdentifier(nameToken)));
            } else {
              A_Token nameToken = new SyntheticStringToken(A_TokenType.IDENTIFIER, "", nameOffset);
              references.add(new CommentReference(null, new SimpleIdentifier(nameToken)));
            }
            rightIndex = leftIndex + 1;
          }
          leftIndex = JavaString.A_indexOf(comment, '[', rightIndex);
        } else {
          leftIndex = JavaString.A_indexOf(comment, '[', A_range[1] + 1);
        }
      }
    }
    return references;
  }
  CompilationUnitMember _parseCompilationUnitMember(CommentAndMetadata commentAndMetadata) {
    Modifiers modifiers = _parseModifiers();
    if (_matchesKeyword(Keyword.D_CLASS)) {
      return _parseClassDeclaration(commentAndMetadata, _validateModifiersForClass(modifiers));
    } else if (_matchesKeyword(Keyword.A_TYPEDEF) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT) && !_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      _validateModifiersForTypedef(modifiers);
      return _parseTypeAlias(commentAndMetadata);
    } else if (_parseEnum && _matchesKeyword(Keyword.ENUM)) {
      _validateModifiersForEnum(modifiers);
      return _parseEnumDeclaration(commentAndMetadata);
    }
    if (_matchesKeyword(Keyword.VOID)) {
      TypeName A_returnType = parseReturnType();
      if ((_matchesKeyword(Keyword.GET) || _matchesKeyword(Keyword.SET)) && _tokenMatchesIdentifier(_peek())) {
        _validateModifiersForTopLevelFunction(modifiers);
        return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, A_returnType);
      } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
        A__reportErrorForToken(ParserErrorCode.TOP_LEVEL_OPERATOR, A__currentToken, []);
        return _convertToFunctionDeclaration(_parseOperator(commentAndMetadata, modifiers.externalKeyword, A_returnType));
      } else if (_matchesIdentifier() && _peek().matchesAny([A_TokenType.OPEN_PAREN, A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.D_FUNCTION])) {
        _validateModifiersForTopLevelFunction(modifiers);
        return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, A_returnType);
      } else {
        if (_matchesIdentifier()) {
          if (_peek().matchesAny([A_TokenType.A_EQ, A_TokenType.A_COMMA, A_TokenType.SEMICOLON])) {
            A__reportErrorForNode(ParserErrorCode.VOID_VARIABLE, A_returnType, []);
            return new TopLevelVariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, _parseVariableDeclarationListAfterType(null, _validateModifiersForTopLevelVariable(modifiers), null), A__expect(A_TokenType.SEMICOLON));
          }
        }
        A__reportErrorForToken(ParserErrorCode.EXPECTED_EXECUTABLE, A__currentToken, []);
        return null;
      }
    } else if ((_matchesKeyword(Keyword.GET) || _matchesKeyword(Keyword.SET)) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForTopLevelFunction(modifiers);
      return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, null);
    } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
      A__reportErrorForToken(ParserErrorCode.TOP_LEVEL_OPERATOR, A__currentToken, []);
      return _convertToFunctionDeclaration(_parseOperator(commentAndMetadata, modifiers.externalKeyword, null));
    } else if (!_matchesIdentifier()) {
      A__reportErrorForToken(ParserErrorCode.EXPECTED_EXECUTABLE, A__currentToken, []);
      return null;
    } else if (_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      _validateModifiersForTopLevelFunction(modifiers);
      return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, null);
    } else if (_peek().matchesAny([A_TokenType.A_EQ, A_TokenType.A_COMMA, A_TokenType.SEMICOLON])) {
      if (modifiers.constKeyword == null && modifiers.finalKeyword == null && modifiers.varKeyword == null) {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_CONST_FINAL_VAR_OR_TYPE, []);
      }
      return new TopLevelVariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, _parseVariableDeclarationListAfterType(null, _validateModifiersForTopLevelVariable(modifiers), null), A__expect(A_TokenType.SEMICOLON));
    }
    TypeName A_returnType = parseReturnType();
    if ((_matchesKeyword(Keyword.GET) || _matchesKeyword(Keyword.SET)) && _tokenMatchesIdentifier(_peek())) {
      _validateModifiersForTopLevelFunction(modifiers);
      return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, A_returnType);
    } else if (_matchesKeyword(Keyword.OPERATOR) && _isOperator(_peek())) {
      A__reportErrorForToken(ParserErrorCode.TOP_LEVEL_OPERATOR, A__currentToken, []);
      return _convertToFunctionDeclaration(_parseOperator(commentAndMetadata, modifiers.externalKeyword, A_returnType));
    } else if (A__matches(A_TokenType.AT)) {
      return new TopLevelVariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, _parseVariableDeclarationListAfterType(null, _validateModifiersForTopLevelVariable(modifiers), A_returnType), A__expect(A_TokenType.SEMICOLON));
    } else if (!_matchesIdentifier()) {
      A__reportErrorForToken(ParserErrorCode.EXPECTED_EXECUTABLE, A__currentToken, []);
      A_Token semicolon;
      if (A__matches(A_TokenType.SEMICOLON)) {
        semicolon = andAdvance;
      } else {
        semicolon = _createSyntheticToken(A_TokenType.SEMICOLON);
      }
      List<VariableDeclaration> variables = new List<VariableDeclaration>();
      variables.add(new VariableDeclaration(null, null, _createSyntheticIdentifier(), null, null));
      return new TopLevelVariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, new VariableDeclarationList(null, null, null, A_returnType, variables), semicolon);
    }
    if (_peek().matchesAny([A_TokenType.OPEN_PAREN, A_TokenType.D_FUNCTION, A_TokenType.OPEN_CURLY_BRACKET])) {
      _validateModifiersForTopLevelFunction(modifiers);
      return _parseFunctionDeclaration(commentAndMetadata, modifiers.externalKeyword, A_returnType);
    }
    return new TopLevelVariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, _parseVariableDeclarationListAfterType(null, _validateModifiersForTopLevelVariable(modifiers), A_returnType), A__expect(A_TokenType.SEMICOLON));
  }
  Expression _parseConstExpression() {
    A_Token keyword = _expectKeyword(Keyword.B_CONST);
    if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET) || A__matches(A_TokenType.INDEX)) {
      return _parseListLiteral(keyword, null);
    } else if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      return _parseMapLiteral(keyword, null);
    } else if (A__matches(A_TokenType.A_LT)) {
      return _parseListOrMapLiteral(keyword);
    }
    return _parseInstanceCreationExpression(keyword);
  }
  ConstructorDeclaration _parseConstructor(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, A_Token constKeyword, A_Token factoryKeyword, SimpleIdentifier A_returnType, A_Token period, SimpleIdentifier A_name, FormalParameterList A_parameters) {
    bool bodyAllowed = externalKeyword == null;
    A_Token A_separator = null;
    List<ConstructorInitializer> initializers = null;
    if (A__matches(A_TokenType.A_COLON)) {
      A_separator = andAdvance;
      initializers = new List<ConstructorInitializer>();
      do {
        if (_matchesKeyword(Keyword.THIS)) {
          if (_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
            bodyAllowed = false;
            initializers.add(_parseRedirectingConstructorInvocation());
          } else if (_tokenMatches(_peek(), A_TokenType.PERIOD) && _tokenMatches(_peekAt(3), A_TokenType.OPEN_PAREN)) {
            bodyAllowed = false;
            initializers.add(_parseRedirectingConstructorInvocation());
          } else {
            initializers.add(_parseConstructorFieldInitializer());
          }
        } else if (_matchesKeyword(Keyword.SUPER)) {
          initializers.add(_parseSuperConstructorInvocation());
        } else {
          initializers.add(_parseConstructorFieldInitializer());
        }
      } while (_optional(A_TokenType.A_COMMA));
    }
    ConstructorName redirectedConstructor = null;
    FunctionBody body;
    if (A__matches(A_TokenType.A_EQ)) {
      A_separator = andAdvance;
      redirectedConstructor = parseConstructorName();
      body = new EmptyFunctionBody(A__expect(A_TokenType.SEMICOLON));
      if (factoryKeyword == null) {
        A__reportErrorForNode(ParserErrorCode.REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR, redirectedConstructor, []);
      }
    } else {
      body = _parseFunctionBody(true, ParserErrorCode.MISSING_FUNCTION_BODY, false);
      if (constKeyword != null && factoryKeyword != null && externalKeyword == null) {
        A__reportErrorForToken(ParserErrorCode.CONST_FACTORY, factoryKeyword, []);
      } else if (body is EmptyFunctionBody) {
        if (factoryKeyword != null && externalKeyword == null) {
          A__reportErrorForToken(ParserErrorCode.FACTORY_WITHOUT_BODY, factoryKeyword, []);
        }
      } else {
        if (constKeyword != null) {
          A__reportErrorForNode(ParserErrorCode.CONST_CONSTRUCTOR_WITH_BODY, body, []);
        } else if (!bodyAllowed) {
          A__reportErrorForNode(ParserErrorCode.EXTERNAL_CONSTRUCTOR_WITH_BODY, body, []);
        }
      }
    }
    return new ConstructorDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, constKeyword, factoryKeyword, A_returnType, period, A_name, A_parameters, A_separator, initializers, redirectedConstructor, body);
  }
  ConstructorFieldInitializer _parseConstructorFieldInitializer() {
    A_Token keyword = null;
    A_Token period = null;
    if (_matchesKeyword(Keyword.THIS)) {
      keyword = andAdvance;
      period = A__expect(A_TokenType.PERIOD);
    }
    SimpleIdentifier fieldName = parseSimpleIdentifier();
    A_Token A_equals = A__expect(A_TokenType.A_EQ);
    bool wasInInitializer = _inInitializer;
    _inInitializer = true;
    try {
      Expression expression = parseConditionalExpression();
      A_TokenType tokenType = A__currentToken.type;
      if (tokenType == A_TokenType.PERIOD_PERIOD) {
        List<Expression> cascadeSections = new List<Expression>();
        while (tokenType == A_TokenType.PERIOD_PERIOD) {
          Expression section = _parseCascadeSection();
          if (section != null) {
            cascadeSections.add(section);
          }
          tokenType = A__currentToken.type;
        }
        expression = new CascadeExpression(expression, cascadeSections);
      }
      return new ConstructorFieldInitializer(keyword, period, fieldName, A_equals, expression);
    } finally {
      _inInitializer = wasInInitializer;
    }
  }
  Statement _parseContinueStatement() {
    A_Token continueKeyword = _expectKeyword(Keyword.A_CONTINUE);
    if (!_inLoop && !_inSwitch) {
      A__reportErrorForToken(ParserErrorCode.CONTINUE_OUTSIDE_OF_LOOP, continueKeyword, []);
    }
    SimpleIdentifier label = null;
    if (_matchesIdentifier()) {
      label = parseSimpleIdentifier();
    }
    if (_inSwitch && !_inLoop && label == null) {
      A__reportErrorForToken(ParserErrorCode.CONTINUE_WITHOUT_LABEL_IN_CASE, continueKeyword, []);
    }
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new ContinueStatement(continueKeyword, label, semicolon);
  }
  Directive _parseDirective(CommentAndMetadata commentAndMetadata) {
    if (_matchesKeyword(Keyword.B_IMPORT)) {
      return _parseImportDirective(commentAndMetadata);
    } else if (_matchesKeyword(Keyword.A_EXPORT)) {
      return _parseExportDirective(commentAndMetadata);
    } else if (_matchesKeyword(Keyword.C_LIBRARY)) {
      return _parseLibraryDirective(commentAndMetadata);
    } else if (_matchesKeyword(Keyword.PART)) {
      return _parsePartDirective(commentAndMetadata);
    } else {
      throw new IllegalStateException("parseDirective invoked in an invalid state; currentToken = ${A__currentToken}");
    }
  }
  Comment _parseDocumentationComment() {
    List<A_Token> commentTokens = new List<A_Token>();
    A_Token commentToken = A__currentToken.precedingComments;
    while (commentToken != null) {
      if (commentToken.type == A_TokenType.SINGLE_LINE_COMMENT) {
        if (StringUtilities.startsWith3(commentToken.lexeme, 0, 0x2F, 0x2F, 0x2F)) {
          if (commentTokens.length == 1 && StringUtilities.startsWith3(commentTokens[0].lexeme, 0, 0x2F, 0x2A, 0x2A)) {
            commentTokens.clear();
          }
          commentTokens.add(commentToken);
        }
      } else {
        if (StringUtilities.startsWith3(commentToken.lexeme, 0, 0x2F, 0x2A, 0x2A)) {
          commentTokens.clear();
          commentTokens.add(commentToken);
        }
      }
      commentToken = commentToken.next;
    }
    if (commentTokens.isEmpty) {
      return null;
    }
    List<A_Token> tokens = new List.from(commentTokens);
    List<CommentReference> references = _parseCommentReferences(tokens);
    return Comment.createDocumentationCommentWithReferences(tokens, references);
  }
  Statement _parseDoStatement() {
    bool wasInLoop = _inLoop;
    _inLoop = true;
    try {
      A_Token doKeyword = _expectKeyword(Keyword.DO);
      Statement body = parseStatement2();
      A_Token whileKeyword = _expectKeyword(Keyword.WHILE);
      A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
      Expression condition = parseExpression2();
      A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
      return new DoStatement(doKeyword, body, whileKeyword, leftParenthesis, condition, rightParenthesis, semicolon);
    } finally {
      _inLoop = wasInLoop;
    }
  }
  Statement _parseEmptyStatement() => new EmptyStatement(andAdvance);
  EnumConstantDeclaration _parseEnumConstantDeclaration() {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    SimpleIdentifier A_name;
    if (_matchesIdentifier()) {
      A_name = parseSimpleIdentifier();
    } else {
      A_name = _createSyntheticIdentifier();
    }
    return new EnumConstantDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, A_name);
  }
  EnumDeclaration _parseEnumDeclaration(CommentAndMetadata commentAndMetadata) {
    A_Token keyword = _expectKeyword(Keyword.ENUM);
    SimpleIdentifier A_name = parseSimpleIdentifier();
    A_Token leftBracket = null;
    List<EnumConstantDeclaration> constants = new List<EnumConstantDeclaration>();
    A_Token rightBracket = null;
    if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      leftBracket = A__expect(A_TokenType.OPEN_CURLY_BRACKET);
      if (_matchesIdentifier()) {
        constants.add(_parseEnumConstantDeclaration());
      } else if (A__matches(A_TokenType.A_COMMA) && _tokenMatchesIdentifier(_peek())) {
        constants.add(_parseEnumConstantDeclaration());
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
      } else {
        constants.add(_parseEnumConstantDeclaration());
        _reportErrorForCurrentToken(ParserErrorCode.EMPTY_ENUM_BODY, []);
      }
      while (_optional(A_TokenType.A_COMMA)) {
        if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
          break;
        }
        constants.add(_parseEnumConstantDeclaration());
      }
      rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
    } else {
      leftBracket = _createSyntheticToken(A_TokenType.OPEN_CURLY_BRACKET);
      rightBracket = _createSyntheticToken(A_TokenType.CLOSE_CURLY_BRACKET);
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_ENUM_BODY, []);
    }
    return new EnumDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_name, leftBracket, constants, rightBracket);
  }
  Expression _parseEqualityExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && A__currentToken.next.type.isEqualityOperator) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseRelationalExpression();
    }
    bool leftEqualityExpression = false;
    while (A__currentToken.type.isEqualityOperator) {
      A_Token operator = andAdvance;
      if (leftEqualityExpression) {
        A__reportErrorForNode(ParserErrorCode.EQUALITY_CANNOT_BE_EQUALITY_OPERAND, expression, []);
      }
      expression = new BinaryExpression(expression, operator, _parseRelationalExpression());
      leftEqualityExpression = true;
    }
    return expression;
  }
  ExportDirective _parseExportDirective(CommentAndMetadata commentAndMetadata) {
    A_Token exportKeyword = _expectKeyword(Keyword.A_EXPORT);
    StringLiteral libraryUri = parseStringLiteral();
    List<Combinator> combinators = _parseCombinators();
    A_Token semicolon = _expectSemicolon();
    return new ExportDirective(commentAndMetadata.comment, commentAndMetadata.metadata, exportKeyword, libraryUri, combinators, semicolon);
  }
  List<Expression> _parseExpressionList() {
    List<Expression> expressions = new List<Expression>();
    expressions.add(parseExpression2());
    while (_optional(A_TokenType.A_COMMA)) {
      expressions.add(parseExpression2());
    }
    return expressions;
  }
  FinalConstVarOrType _parseFinalConstVarOrType(bool optional) {
    A_Token keyword = null;
    TypeName A_type = null;
    if (_matchesKeyword(Keyword.A_FINAL) || _matchesKeyword(Keyword.B_CONST)) {
      keyword = andAdvance;
      if (_isTypedIdentifier(A__currentToken)) {
        A_type = parseTypeName();
      }
    } else if (_matchesKeyword(Keyword.VAR)) {
      keyword = andAdvance;
    } else {
      if (_isTypedIdentifier(A__currentToken)) {
        A_type = parseReturnType();
      } else if (!optional) {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_CONST_FINAL_VAR_OR_TYPE, []);
      }
    }
    return new FinalConstVarOrType(keyword, A_type);
  }
  FormalParameter _parseFormalParameter(ParameterKind kind) {
    NormalFormalParameter parameter = parseNormalFormalParameter();
    if (A__matches(A_TokenType.A_EQ)) {
      A_Token seperator = andAdvance;
      Expression A_defaultValue = parseExpression2();
      if (kind == ParameterKind.NAMED) {
        A__reportErrorForToken(ParserErrorCode.WRONG_SEPARATOR_FOR_NAMED_PARAMETER, seperator, []);
      } else if (kind == ParameterKind.REQUIRED) {
        A__reportErrorForNode(ParserErrorCode.POSITIONAL_PARAMETER_OUTSIDE_GROUP, parameter, []);
      }
      return new DefaultFormalParameter(parameter, kind, seperator, A_defaultValue);
    } else if (A__matches(A_TokenType.A_COLON)) {
      A_Token seperator = andAdvance;
      Expression A_defaultValue = parseExpression2();
      if (kind == ParameterKind.POSITIONAL) {
        A__reportErrorForToken(ParserErrorCode.WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER, seperator, []);
      } else if (kind == ParameterKind.REQUIRED) {
        A__reportErrorForNode(ParserErrorCode.NAMED_PARAMETER_OUTSIDE_GROUP, parameter, []);
      }
      return new DefaultFormalParameter(parameter, kind, seperator, A_defaultValue);
    } else if (kind != ParameterKind.REQUIRED) {
      return new DefaultFormalParameter(parameter, kind, null, null);
    }
    return parameter;
  }
  Statement _parseForStatement() {
    bool wasInLoop = _inLoop;
    _inLoop = true;
    try {
      A_Token awaitKeyword = null;
      if (_matchesString(_AWAIT)) {
        awaitKeyword = andAdvance;
      }
      A_Token forKeyword = _expectKeyword(Keyword.FOR);
      A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
      VariableDeclarationList variableList = null;
      Expression initialization = null;
      if (!A__matches(A_TokenType.SEMICOLON)) {
        CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
        if (_matchesIdentifier() && _tokenMatchesKeyword(_peek(), Keyword.IN)) {
          List<VariableDeclaration> variables = new List<VariableDeclaration>();
          SimpleIdentifier A_variableName = parseSimpleIdentifier();
          variables.add(new VariableDeclaration(null, null, A_variableName, null, null));
          variableList = new VariableDeclarationList(commentAndMetadata.comment, commentAndMetadata.metadata, null, null, variables);
        } else if (_isInitializedVariableDeclaration()) {
          variableList = _parseVariableDeclarationListAfterMetadata(commentAndMetadata);
        } else {
          initialization = parseExpression2();
        }
        if (_matchesKeyword(Keyword.IN)) {
          DeclaredIdentifier loopVariable = null;
          SimpleIdentifier identifier = null;
          if (variableList == null) {
            _reportErrorForCurrentToken(ParserErrorCode.MISSING_VARIABLE_IN_FOR_EACH, []);
          } else {
            NodeList<VariableDeclaration> variables = variableList.variables;
            if (variables.length > 1) {
              _reportErrorForCurrentToken(ParserErrorCode.MULTIPLE_VARIABLES_IN_FOR_EACH, [variables.length.toString()]);
            }
            VariableDeclaration variable = variables[0];
            if (variable.initializer != null) {
              _reportErrorForCurrentToken(ParserErrorCode.INITIALIZED_VARIABLE_IN_FOR_EACH, []);
            }
            A_Token keyword = variableList.keyword;
            TypeName A_type = variableList.type;
            if (keyword != null || A_type != null) {
              loopVariable = new DeclaredIdentifier(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_type, variable.name);
            } else {
              if (!commentAndMetadata.metadata.isEmpty) {}
              identifier = variable.name;
            }
          }
          A_Token inKeyword = _expectKeyword(Keyword.IN);
          Expression A_iterator = parseExpression2();
          A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
          Statement body = parseStatement2();
          if (loopVariable == null) {
            return new ForEachStatement.con2(awaitKeyword, forKeyword, leftParenthesis, identifier, inKeyword, A_iterator, rightParenthesis, body);
          }
          return new ForEachStatement.con1(awaitKeyword, forKeyword, leftParenthesis, loopVariable, inKeyword, A_iterator, rightParenthesis, body);
        }
      }
      if (awaitKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.INVALID_AWAIT_IN_FOR, awaitKeyword, []);
      }
      A_Token leftSeparator = A__expect(A_TokenType.SEMICOLON);
      Expression condition = null;
      if (!A__matches(A_TokenType.SEMICOLON)) {
        condition = parseExpression2();
      }
      A_Token rightSeparator = A__expect(A_TokenType.SEMICOLON);
      List<Expression> updaters = null;
      if (!A__matches(A_TokenType.CLOSE_PAREN)) {
        updaters = _parseExpressionList();
      }
      A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      Statement body = parseStatement2();
      return new ForStatement(forKeyword, leftParenthesis, variableList, initialization, leftSeparator, condition, rightSeparator, updaters, rightParenthesis, body);
    } finally {
      _inLoop = wasInLoop;
    }
  }
  FunctionBody _parseFunctionBody(bool mayBeEmpty, ParserErrorCode emptyErrorCode, bool inExpression) {
    bool wasInLoop = _inLoop;
    bool wasInSwitch = _inSwitch;
    _inLoop = false;
    _inSwitch = false;
    try {
      if (A__matches(A_TokenType.SEMICOLON)) {
        if (!mayBeEmpty) {
          _reportErrorForCurrentToken(emptyErrorCode, []);
        }
        return new EmptyFunctionBody(andAdvance);
      } else if (_matchesString(_NATIVE)) {
        A_Token nativeToken = andAdvance;
        StringLiteral stringLiteral = null;
        if (A__matches(A_TokenType.A_STRING)) {
          stringLiteral = parseStringLiteral();
        }
        return new NativeFunctionBody(nativeToken, stringLiteral, A__expect(A_TokenType.SEMICOLON));
      }
      A_Token keyword = null;
      A_Token star = null;
      if (_parseAsync) {
        if (_matchesString(ASYNC)) {
          keyword = andAdvance;
          if (A__matches(A_TokenType.STAR)) {
            star = andAdvance;
          }
        } else if (_matchesString(SYNC)) {
          keyword = andAdvance;
          if (A__matches(A_TokenType.STAR)) {
            star = andAdvance;
          }
        }
      }
      if (A__matches(A_TokenType.D_FUNCTION)) {
        if (keyword != null) {
          if (!_tokenMatchesString(keyword, ASYNC)) {
            A__reportErrorForToken(ParserErrorCode.INVALID_SYNC, keyword, []);
            keyword = null;
          } else if (star != null) {
            A__reportErrorForToken(ParserErrorCode.INVALID_STAR_AFTER_ASYNC, star, []);
          }
        }
        A_Token functionDefinition = andAdvance;
        Expression expression = parseExpression2();
        A_Token semicolon = null;
        if (!inExpression) {
          semicolon = A__expect(A_TokenType.SEMICOLON);
        }
        if (!_parseFunctionBodies) {
          return new EmptyFunctionBody(_createSyntheticToken(A_TokenType.SEMICOLON));
        }
        return new ExpressionFunctionBody(keyword, functionDefinition, expression, semicolon);
      } else if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
        if (keyword != null) {
          if (_tokenMatchesString(keyword, SYNC) && star == null) {
            A__reportErrorForToken(ParserErrorCode.MISSING_STAR_AFTER_SYNC, keyword, []);
          }
        }
        if (!_parseFunctionBodies) {
          _skipBlock();
          return new EmptyFunctionBody(_createSyntheticToken(A_TokenType.SEMICOLON));
        }
        return new BlockFunctionBody(keyword, star, parseBlock());
      } else {
        _reportErrorForCurrentToken(emptyErrorCode, []);
        return new EmptyFunctionBody(_createSyntheticToken(A_TokenType.SEMICOLON));
      }
    } finally {
      _inLoop = wasInLoop;
      _inSwitch = wasInSwitch;
    }
  }
  FunctionDeclaration _parseFunctionDeclaration(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, TypeName A_returnType) {
    A_Token keyword = null;
    bool A_isGetter = false;
    if (_matchesKeyword(Keyword.GET) && !_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      keyword = andAdvance;
      A_isGetter = true;
    } else if (_matchesKeyword(Keyword.SET) && !_tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
      keyword = andAdvance;
    }
    SimpleIdentifier A_name = parseSimpleIdentifier();
    FormalParameterList A_parameters = null;
    if (!A_isGetter) {
      if (A__matches(A_TokenType.OPEN_PAREN)) {
        A_parameters = parseFormalParameterList();
        _validateFormalParameterList(A_parameters);
      } else {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_FUNCTION_PARAMETERS, []);
      }
    } else if (A__matches(A_TokenType.OPEN_PAREN)) {
      _reportErrorForCurrentToken(ParserErrorCode.GETTER_WITH_PARAMETERS, []);
      parseFormalParameterList();
    }
    FunctionBody body;
    if (externalKeyword == null) {
      body = _parseFunctionBody(false, ParserErrorCode.MISSING_FUNCTION_BODY, false);
    } else {
      body = new EmptyFunctionBody(A__expect(A_TokenType.SEMICOLON));
    }
    return new FunctionDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, A_returnType, keyword, A_name, new FunctionExpression(A_parameters, body));
  }
  Statement _parseFunctionDeclarationStatement() {
    Modifiers modifiers = _parseModifiers();
    _validateModifiersForFunctionDeclarationStatement(modifiers);
    return _parseFunctionDeclarationStatementAfterReturnType(_parseCommentAndMetadata(), _parseOptionalReturnType());
  }
  Statement _parseFunctionDeclarationStatementAfterReturnType(CommentAndMetadata commentAndMetadata, TypeName A_returnType) {
    FunctionDeclaration declaration = _parseFunctionDeclaration(commentAndMetadata, null, A_returnType);
    A_Token propertyKeyword = declaration.propertyKeyword;
    if (propertyKeyword != null) {
      if ((propertyKeyword as KeywordToken).keyword == Keyword.GET) {
        A__reportErrorForToken(ParserErrorCode.GETTER_IN_FUNCTION, propertyKeyword, []);
      } else {
        A__reportErrorForToken(ParserErrorCode.SETTER_IN_FUNCTION, propertyKeyword, []);
      }
    }
    return new FunctionDeclarationStatement(declaration);
  }
  FunctionTypeAlias _parseFunctionTypeAlias(CommentAndMetadata commentAndMetadata, A_Token keyword) {
    TypeName A_returnType = null;
    if (hasReturnTypeInTypeAlias) {
      A_returnType = parseReturnType();
    }
    SimpleIdentifier A_name = parseSimpleIdentifier();
    TypeParameterList typeParameters = null;
    if (A__matches(A_TokenType.A_LT)) {
      typeParameters = parseTypeParameterList();
    }
    if (A__matches(A_TokenType.SEMICOLON) || A__matches(A_TokenType.A_EOF)) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_TYPEDEF_PARAMETERS, []);
      FormalParameterList A_parameters = new FormalParameterList(_createSyntheticToken(A_TokenType.OPEN_PAREN), null, null, null, _createSyntheticToken(A_TokenType.CLOSE_PAREN));
      A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
      return new FunctionTypeAlias(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_returnType, A_name, typeParameters, A_parameters, semicolon);
    } else if (!A__matches(A_TokenType.OPEN_PAREN)) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_TYPEDEF_PARAMETERS, []);
      return new FunctionTypeAlias(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_returnType, A_name, typeParameters, new FormalParameterList(_createSyntheticToken(A_TokenType.OPEN_PAREN), null, null, null, _createSyntheticToken(A_TokenType.CLOSE_PAREN)), _createSyntheticToken(A_TokenType.SEMICOLON));
    }
    FormalParameterList A_parameters = parseFormalParameterList();
    _validateFormalParameterList(A_parameters);
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new FunctionTypeAlias(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_returnType, A_name, typeParameters, A_parameters, semicolon);
  }
  MethodDeclaration _parseGetter(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, A_Token staticKeyword, TypeName A_returnType) {
    A_Token propertyKeyword = _expectKeyword(Keyword.GET);
    SimpleIdentifier A_name = parseSimpleIdentifier();
    if (A__matches(A_TokenType.OPEN_PAREN) && _tokenMatches(_peek(), A_TokenType.CLOSE_PAREN)) {
      _reportErrorForCurrentToken(ParserErrorCode.GETTER_WITH_PARAMETERS, []);
      A__advance();
      A__advance();
    }
    FunctionBody body = _parseFunctionBody(externalKeyword != null || staticKeyword == null, ParserErrorCode.STATIC_GETTER_WITHOUT_BODY, false);
    if (externalKeyword != null && body is! EmptyFunctionBody) {
      _reportErrorForCurrentToken(ParserErrorCode.EXTERNAL_GETTER_WITH_BODY, []);
    }
    return new MethodDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, A_returnType, propertyKeyword, null, A_name, null, body);
  }
  List<SimpleIdentifier> _parseIdentifierList() {
    List<SimpleIdentifier> identifiers = new List<SimpleIdentifier>();
    identifiers.add(parseSimpleIdentifier());
    while (A__matches(A_TokenType.A_COMMA)) {
      A__advance();
      identifiers.add(parseSimpleIdentifier());
    }
    return identifiers;
  }
  Statement _parseIfStatement() {
    A_Token ifKeyword = _expectKeyword(Keyword.IF);
    A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
    Expression condition = parseExpression2();
    A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
    Statement thenStatement = parseStatement2();
    A_Token elseKeyword = null;
    Statement elseStatement = null;
    if (_matchesKeyword(Keyword.ELSE)) {
      elseKeyword = andAdvance;
      elseStatement = parseStatement2();
    }
    return new IfStatement(ifKeyword, leftParenthesis, condition, rightParenthesis, thenStatement, elseKeyword, elseStatement);
  }
  ImportDirective _parseImportDirective(CommentAndMetadata commentAndMetadata) {
    A_Token importKeyword = _expectKeyword(Keyword.B_IMPORT);
    StringLiteral libraryUri = parseStringLiteral();
    A_Token deferredToken = null;
    A_Token asToken = null;
    SimpleIdentifier prefix = null;
    if (_matchesKeyword(Keyword.A_DEFERRED)) {
      if (_parseDeferredLibraries) {
        deferredToken = andAdvance;
      } else {
        _reportErrorForCurrentToken(ParserErrorCode.DEFERRED_IMPORTS_NOT_SUPPORTED, []);
        A__advance();
      }
    }
    if (_matchesKeyword(Keyword.AS)) {
      asToken = andAdvance;
      prefix = parseSimpleIdentifier();
    } else if (deferredToken != null) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_PREFIX_IN_DEFERRED_IMPORT, []);
    }
    List<Combinator> combinators = _parseCombinators();
    A_Token semicolon = _expectSemicolon();
    return new ImportDirective(commentAndMetadata.comment, commentAndMetadata.metadata, importKeyword, libraryUri, deferredToken, asToken, prefix, combinators, semicolon);
  }
  FieldDeclaration _parseInitializedIdentifierList(CommentAndMetadata commentAndMetadata, A_Token staticKeyword, A_Token keyword, TypeName A_type) {
    VariableDeclarationList fieldList = _parseVariableDeclarationListAfterType(null, keyword, A_type);
    return new FieldDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, staticKeyword, fieldList, A__expect(A_TokenType.SEMICOLON));
  }
  InstanceCreationExpression _parseInstanceCreationExpression(A_Token keyword) {
    ConstructorName constructorName = parseConstructorName();
    ArgumentList argumentList = parseArgumentList();
    return new InstanceCreationExpression(keyword, constructorName, argumentList);
  }
  LibraryDirective _parseLibraryDirective(CommentAndMetadata commentAndMetadata) {
    A_Token keyword = _expectKeyword(Keyword.C_LIBRARY);
    LibraryIdentifier A_libraryName = _parseLibraryName(ParserErrorCode.MISSING_NAME_IN_LIBRARY_DIRECTIVE, keyword);
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new LibraryDirective(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, A_libraryName, semicolon);
  }
  LibraryIdentifier _parseLibraryName(ParserErrorCode missingNameError, A_Token missingNameToken) {
    if (_matchesIdentifier()) {
      return parseLibraryIdentifier();
    } else if (A__matches(A_TokenType.A_STRING)) {
      StringLiteral A_string = parseStringLiteral();
      A__reportErrorForNode(ParserErrorCode.NON_IDENTIFIER_LIBRARY_NAME, A_string, []);
    } else {
      A__reportErrorForToken(missingNameError, missingNameToken, []);
    }
    List<SimpleIdentifier> components = new List<SimpleIdentifier>();
    components.add(_createSyntheticIdentifier());
    return new LibraryIdentifier(components);
  }
  ListLiteral _parseListLiteral(A_Token modifier, TypeArgumentList typeArguments) {
    if (A__matches(A_TokenType.INDEX)) {
      BeginToken leftBracket = new BeginToken(A_TokenType.OPEN_SQUARE_BRACKET, A__currentToken.offset);
      A_Token rightBracket = new A_Token(A_TokenType.CLOSE_SQUARE_BRACKET, A__currentToken.offset + 1);
      leftBracket.endToken = rightBracket;
      rightBracket.setNext(A__currentToken.next);
      leftBracket.setNext(rightBracket);
      A__currentToken.previous.setNext(leftBracket);
      A__currentToken = A__currentToken.next;
      return new ListLiteral(modifier, typeArguments, leftBracket, null, rightBracket);
    }
    A_Token leftBracket = A__expect(A_TokenType.OPEN_SQUARE_BRACKET);
    if (A__matches(A_TokenType.CLOSE_SQUARE_BRACKET)) {
      return new ListLiteral(modifier, typeArguments, leftBracket, null, andAdvance);
    }
    bool wasInInitializer = _inInitializer;
    _inInitializer = false;
    try {
      List<Expression> elements = new List<Expression>();
      elements.add(parseExpression2());
      while (_optional(A_TokenType.A_COMMA)) {
        if (A__matches(A_TokenType.CLOSE_SQUARE_BRACKET)) {
          return new ListLiteral(modifier, typeArguments, leftBracket, elements, andAdvance);
        }
        elements.add(parseExpression2());
      }
      A_Token rightBracket = A__expect(A_TokenType.CLOSE_SQUARE_BRACKET);
      return new ListLiteral(modifier, typeArguments, leftBracket, elements, rightBracket);
    } finally {
      _inInitializer = wasInInitializer;
    }
  }
  TypedLiteral _parseListOrMapLiteral(A_Token modifier) {
    TypeArgumentList typeArguments = null;
    if (A__matches(A_TokenType.A_LT)) {
      typeArguments = parseTypeArgumentList();
    }
    if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      return _parseMapLiteral(modifier, typeArguments);
    } else if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET) || A__matches(A_TokenType.INDEX)) {
      return _parseListLiteral(modifier, typeArguments);
    }
    _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_LIST_OR_MAP_LITERAL, []);
    return new ListLiteral(modifier, typeArguments, _createSyntheticToken(A_TokenType.OPEN_SQUARE_BRACKET), null, _createSyntheticToken(A_TokenType.CLOSE_SQUARE_BRACKET));
  }
  Expression _parseLogicalAndExpression() {
    Expression expression = _parseEqualityExpression();
    while (A__matches(A_TokenType.AMPERSAND_AMPERSAND)) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseEqualityExpression());
    }
    return expression;
  }
  MapLiteral _parseMapLiteral(A_Token modifier, TypeArgumentList typeArguments) {
    A_Token leftBracket = A__expect(A_TokenType.OPEN_CURLY_BRACKET);
    List<MapLiteralEntry> entries = new List<MapLiteralEntry>();
    if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
      return new MapLiteral(modifier, typeArguments, leftBracket, entries, andAdvance);
    }
    bool wasInInitializer = _inInitializer;
    _inInitializer = false;
    try {
      entries.add(parseMapLiteralEntry());
      while (_optional(A_TokenType.A_COMMA)) {
        if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
          return new MapLiteral(modifier, typeArguments, leftBracket, entries, andAdvance);
        }
        entries.add(parseMapLiteralEntry());
      }
      A_Token rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
      return new MapLiteral(modifier, typeArguments, leftBracket, entries, rightBracket);
    } finally {
      _inInitializer = wasInInitializer;
    }
  }
  MethodDeclaration _parseMethodDeclarationAfterParameters(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, A_Token staticKeyword, TypeName A_returnType, SimpleIdentifier A_name, FormalParameterList A_parameters) {
    FunctionBody body = _parseFunctionBody(externalKeyword != null || staticKeyword == null, ParserErrorCode.MISSING_FUNCTION_BODY, false);
    if (externalKeyword != null) {
      if (body is! EmptyFunctionBody) {
        A__reportErrorForNode(ParserErrorCode.EXTERNAL_METHOD_WITH_BODY, body, []);
      }
    } else if (staticKeyword != null) {
      if (body is EmptyFunctionBody) {
        A__reportErrorForNode(ParserErrorCode.ABSTRACT_STATIC_METHOD, body, []);
      }
    }
    return new MethodDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, A_returnType, null, null, A_name, A_parameters, body);
  }
  MethodDeclaration _parseMethodDeclarationAfterReturnType(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, A_Token staticKeyword, TypeName A_returnType) {
    SimpleIdentifier methodName = parseSimpleIdentifier();
    FormalParameterList A_parameters = parseFormalParameterList();
    _validateFormalParameterList(A_parameters);
    return _parseMethodDeclarationAfterParameters(commentAndMetadata, externalKeyword, staticKeyword, A_returnType, methodName, A_parameters);
  }
  Modifiers _parseModifiers() {
    Modifiers modifiers = new Modifiers();
    bool A_progress = true;
    while (A_progress) {
      if (_tokenMatches(_peek(), A_TokenType.PERIOD) || _tokenMatches(_peek(), A_TokenType.A_LT) || _tokenMatches(_peek(), A_TokenType.OPEN_PAREN)) {
        return modifiers;
      }
      if (_matchesKeyword(Keyword.A_ABSTRACT)) {
        if (modifiers.abstractKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.abstractKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.B_CONST)) {
        if (modifiers.constKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.constKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.EXTERNAL) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT)) {
        if (modifiers.externalKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.externalKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.A_FACTORY) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT)) {
        if (modifiers.factoryKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.factoryKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.A_FINAL)) {
        if (modifiers.finalKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.finalKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.A_STATIC) && !_tokenMatches(_peek(), A_TokenType.PERIOD) && !_tokenMatches(_peek(), A_TokenType.A_LT)) {
        if (modifiers.staticKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.staticKeyword = andAdvance;
        }
      } else if (_matchesKeyword(Keyword.VAR)) {
        if (modifiers.varKeyword != null) {
          _reportErrorForCurrentToken(ParserErrorCode.DUPLICATED_MODIFIER, [A__currentToken.lexeme]);
          A__advance();
        } else {
          modifiers.varKeyword = andAdvance;
        }
      } else {
        A_progress = false;
      }
    }
    return modifiers;
  }
  Expression _parseMultiplicativeExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && A__currentToken.next.type.isMultiplicativeOperator) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseUnaryExpression();
    }
    while (A__currentToken.type.isMultiplicativeOperator) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseUnaryExpression());
    }
    return expression;
  }
  NativeClause _parseNativeClause() {
    A_Token keyword = andAdvance;
    StringLiteral A_name = parseStringLiteral();
    return new NativeClause(keyword, A_name);
  }
  InstanceCreationExpression _parseNewExpression() => _parseInstanceCreationExpression(_expectKeyword(Keyword.NEW));
  Statement _parseNonLabeledStatement() {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      if (_tokenMatches(_peek(), A_TokenType.A_STRING)) {
        A_Token afterString = _skipStringLiteral(A__currentToken.next);
        if (afterString != null && afterString.type == A_TokenType.A_COLON) {
          return new ExpressionStatement(parseExpression2(), A__expect(A_TokenType.SEMICOLON));
        }
      }
      return parseBlock();
    } else if (A__matches(A_TokenType.A_KEYWORD) && !(A__currentToken as KeywordToken).keyword.isPseudoKeyword) {
      Keyword keyword = (A__currentToken as KeywordToken).keyword;
      if (keyword == Keyword.ASSERT) {
        return _parseAssertStatement();
      } else if (keyword == Keyword.BREAK) {
        return _parseBreakStatement();
      } else if (keyword == Keyword.A_CONTINUE) {
        return _parseContinueStatement();
      } else if (keyword == Keyword.DO) {
        return _parseDoStatement();
      } else if (keyword == Keyword.FOR) {
        return _parseForStatement();
      } else if (keyword == Keyword.IF) {
        return _parseIfStatement();
      } else if (keyword == Keyword.RETHROW) {
        return new ExpressionStatement(_parseRethrowExpression(), A__expect(A_TokenType.SEMICOLON));
      } else if (keyword == Keyword.RETURN) {
        return _parseReturnStatement();
      } else if (keyword == Keyword.SWITCH) {
        return _parseSwitchStatement();
      } else if (keyword == Keyword.THROW) {
        return new ExpressionStatement(_parseThrowExpression(), A__expect(A_TokenType.SEMICOLON));
      } else if (keyword == Keyword.TRY) {
        return _parseTryStatement();
      } else if (keyword == Keyword.WHILE) {
        return _parseWhileStatement();
      } else if (keyword == Keyword.VAR || keyword == Keyword.A_FINAL) {
        return _parseVariableDeclarationStatementAfterMetadata(commentAndMetadata);
      } else if (keyword == Keyword.VOID) {
        TypeName A_returnType = parseReturnType();
        if (_matchesIdentifier() && _peek().matchesAny([A_TokenType.OPEN_PAREN, A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.D_FUNCTION])) {
          return _parseFunctionDeclarationStatementAfterReturnType(commentAndMetadata, A_returnType);
        } else {
          if (_matchesIdentifier()) {
            if (_peek().matchesAny([A_TokenType.A_EQ, A_TokenType.A_COMMA, A_TokenType.SEMICOLON])) {
              A__reportErrorForNode(ParserErrorCode.VOID_VARIABLE, A_returnType, []);
              return _parseVariableDeclarationStatementAfterMetadata(commentAndMetadata);
            }
          } else if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
            return _parseVariableDeclarationStatementAfterType(commentAndMetadata, null, A_returnType);
          }
          _reportErrorForCurrentToken(ParserErrorCode.MISSING_STATEMENT, []);
          return new EmptyStatement(_createSyntheticToken(A_TokenType.SEMICOLON));
        }
      } else if (keyword == Keyword.B_CONST) {
        if (_peek().matchesAny([A_TokenType.A_LT, A_TokenType.OPEN_CURLY_BRACKET, A_TokenType.OPEN_SQUARE_BRACKET, A_TokenType.INDEX])) {
          return new ExpressionStatement(parseExpression2(), A__expect(A_TokenType.SEMICOLON));
        } else if (_tokenMatches(_peek(), A_TokenType.IDENTIFIER)) {
          A_Token afterType = _skipTypeName(_peek());
          if (afterType != null) {
            if (_tokenMatches(afterType, A_TokenType.OPEN_PAREN) || (_tokenMatches(afterType, A_TokenType.PERIOD) && _tokenMatches(afterType.next, A_TokenType.IDENTIFIER) && _tokenMatches(afterType.next.next, A_TokenType.OPEN_PAREN))) {
              return new ExpressionStatement(parseExpression2(), A__expect(A_TokenType.SEMICOLON));
            }
          }
        }
        return _parseVariableDeclarationStatementAfterMetadata(commentAndMetadata);
      } else if (keyword == Keyword.NEW || keyword == Keyword.TRUE || keyword == Keyword.FALSE || keyword == Keyword.A_NULL || keyword == Keyword.SUPER || keyword == Keyword.THIS) {
        return new ExpressionStatement(parseExpression2(), A__expect(A_TokenType.SEMICOLON));
      } else {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_STATEMENT, []);
        return new EmptyStatement(_createSyntheticToken(A_TokenType.SEMICOLON));
      }
    } else if (_parseAsync && _matchesString(_YIELD)) {
      return _parseYieldStatement();
    } else if (_parseAsync && _matchesString(_AWAIT) && _tokenMatchesKeyword(_peek(), Keyword.FOR)) {
      return _parseForStatement();
    } else if (A__matches(A_TokenType.SEMICOLON)) {
      return _parseEmptyStatement();
    } else if (_isInitializedVariableDeclaration()) {
      return _parseVariableDeclarationStatementAfterMetadata(commentAndMetadata);
    } else if (_isFunctionDeclaration()) {
      return _parseFunctionDeclarationStatement();
    } else if (A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_STATEMENT, []);
      return new EmptyStatement(_createSyntheticToken(A_TokenType.SEMICOLON));
    } else {
      return new ExpressionStatement(parseExpression2(), A__expect(A_TokenType.SEMICOLON));
    }
  }
  MethodDeclaration _parseOperator(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, TypeName A_returnType) {
    A_Token operatorKeyword;
    if (_matchesKeyword(Keyword.OPERATOR)) {
      operatorKeyword = andAdvance;
    } else {
      A__reportErrorForToken(ParserErrorCode.MISSING_KEYWORD_OPERATOR, A__currentToken, []);
      operatorKeyword = _createSyntheticKeyword(Keyword.OPERATOR);
    }
    if (!A__currentToken.isUserDefinableOperator) {
      _reportErrorForCurrentToken(ParserErrorCode.NON_USER_DEFINABLE_OPERATOR, [A__currentToken.lexeme]);
    }
    SimpleIdentifier A_name = new SimpleIdentifier(andAdvance);
    if (A__matches(A_TokenType.A_EQ)) {
      A_Token A_previous = A__currentToken.previous;
      if ((_tokenMatches(A_previous, A_TokenType.EQ_EQ) || _tokenMatches(A_previous, A_TokenType.BANG_EQ)) && A__currentToken.offset == A_previous.offset + 2) {
        _reportErrorForCurrentToken(ParserErrorCode.INVALID_OPERATOR, ["${A_previous.lexeme}${A__currentToken.lexeme}"]);
        A__advance();
      }
    }
    FormalParameterList A_parameters = parseFormalParameterList();
    _validateFormalParameterList(A_parameters);
    FunctionBody body = _parseFunctionBody(true, ParserErrorCode.MISSING_FUNCTION_BODY, false);
    if (externalKeyword != null && body is! EmptyFunctionBody) {
      _reportErrorForCurrentToken(ParserErrorCode.EXTERNAL_OPERATOR_WITH_BODY, []);
    }
    return new MethodDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, null, A_returnType, null, operatorKeyword, A_name, A_parameters, body);
  }
  TypeName _parseOptionalReturnType() {
    if (_matchesKeyword(Keyword.VOID)) {
      return parseReturnType();
    } else if (_matchesIdentifier() && !_matchesKeyword(Keyword.GET) && !_matchesKeyword(Keyword.SET) && !_matchesKeyword(Keyword.OPERATOR) && (_tokenMatchesIdentifier(_peek()) || _tokenMatches(_peek(), A_TokenType.A_LT))) {
      return parseReturnType();
    } else if (_matchesIdentifier() && _tokenMatches(_peek(), A_TokenType.PERIOD) && _tokenMatchesIdentifier(_peekAt(2)) && (_tokenMatchesIdentifier(_peekAt(3)) || _tokenMatches(_peekAt(3), A_TokenType.A_LT))) {
      return parseReturnType();
    }
    return null;
  }
  Directive _parsePartDirective(CommentAndMetadata commentAndMetadata) {
    A_Token partKeyword = _expectKeyword(Keyword.PART);
    if (_matchesString(_OF)) {
      A_Token ofKeyword = andAdvance;
      LibraryIdentifier A_libraryName = _parseLibraryName(ParserErrorCode.MISSING_NAME_IN_PART_OF_DIRECTIVE, ofKeyword);
      A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
      return new PartOfDirective(commentAndMetadata.comment, commentAndMetadata.metadata, partKeyword, ofKeyword, A_libraryName, semicolon);
    }
    StringLiteral partUri = parseStringLiteral();
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new PartDirective(commentAndMetadata.comment, commentAndMetadata.metadata, partKeyword, partUri, semicolon);
  }
  Expression _parsePostfixExpression() {
    Expression operand = _parseAssignableExpression(true);
    if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET) || A__matches(A_TokenType.PERIOD) || A__matches(A_TokenType.OPEN_PAREN)) {
      do {
        if (A__matches(A_TokenType.OPEN_PAREN)) {
          ArgumentList argumentList = parseArgumentList();
          if (operand is PropertyAccess) {
            PropertyAccess access = operand as PropertyAccess;
            operand = new MethodInvocation(access.target, access.operator, access.propertyName, argumentList);
          } else {
            operand = new FunctionExpressionInvocation(operand, argumentList);
          }
        } else {
          operand = _parseAssignableSelector(operand, true);
        }
      } while (A__matches(A_TokenType.OPEN_SQUARE_BRACKET) || A__matches(A_TokenType.PERIOD) || A__matches(A_TokenType.OPEN_PAREN));
      return operand;
    }
    if (!A__currentToken.type.isIncrementOperator) {
      return operand;
    }
    _ensureAssignable(operand);
    A_Token operator = andAdvance;
    return new PostfixExpression(operand, operator);
  }
  Expression _parsePrimaryExpression() {
    if (_matchesKeyword(Keyword.THIS)) {
      return new ThisExpression(andAdvance);
    } else if (_matchesKeyword(Keyword.SUPER)) {
      return _parseAssignableSelector(new SuperExpression(andAdvance), false);
    } else if (_matchesKeyword(Keyword.A_NULL)) {
      return new NullLiteral(andAdvance);
    } else if (_matchesKeyword(Keyword.FALSE)) {
      return new BooleanLiteral(andAdvance, false);
    } else if (_matchesKeyword(Keyword.TRUE)) {
      return new BooleanLiteral(andAdvance, true);
    } else if (A__matches(A_TokenType.DOUBLE)) {
      A_Token token = andAdvance;
      double A_value = 0.0;
      try {
        A_value = double.parse(token.lexeme);
      }on FormatException  catch (exception) {}
      return new DoubleLiteral(token, A_value);
    } else if (A__matches(A_TokenType.HEXADECIMAL)) {
      A_Token token = andAdvance;
      int A_value = null;
      try {
        A_value = int.parse(token.lexeme.substring(2), radix: 16);
      }on FormatException  catch (exception) {}
      return new IntegerLiteral(token, A_value);
    } else if (A__matches(A_TokenType.INT)) {
      A_Token token = andAdvance;
      int A_value = null;
      try {
        A_value = int.parse(token.lexeme);
      }on FormatException  catch (exception) {}
      return new IntegerLiteral(token, A_value);
    } else if (A__matches(A_TokenType.A_STRING)) {
      return parseStringLiteral();
    } else if (A__matches(A_TokenType.OPEN_CURLY_BRACKET)) {
      return _parseMapLiteral(null, null);
    } else if (A__matches(A_TokenType.OPEN_SQUARE_BRACKET) || A__matches(A_TokenType.INDEX)) {
      return _parseListLiteral(null, null);
    } else if (_matchesIdentifier()) {
      return parsePrefixedIdentifier();
    } else if (_matchesKeyword(Keyword.NEW)) {
      return _parseNewExpression();
    } else if (_matchesKeyword(Keyword.B_CONST)) {
      return _parseConstExpression();
    } else if (A__matches(A_TokenType.OPEN_PAREN)) {
      if (_isFunctionExpression(A__currentToken)) {
        return parseFunctionExpression();
      }
      A_Token leftParenthesis = andAdvance;
      bool wasInInitializer = _inInitializer;
      _inInitializer = false;
      try {
        Expression expression = parseExpression2();
        A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
        return new ParenthesizedExpression(leftParenthesis, expression, rightParenthesis);
      } finally {
        _inInitializer = wasInInitializer;
      }
    } else if (A__matches(A_TokenType.A_LT)) {
      return _parseListOrMapLiteral(null);
    } else if (A__matches(A_TokenType.QUESTION) && _tokenMatches(_peek(), A_TokenType.IDENTIFIER)) {
      _reportErrorForCurrentToken(ParserErrorCode.UNEXPECTED_TOKEN, [A__currentToken.lexeme]);
      A__advance();
      return _parsePrimaryExpression();
    } else if (_matchesKeyword(Keyword.VOID)) {
      _reportErrorForCurrentToken(ParserErrorCode.UNEXPECTED_TOKEN, [A__currentToken.lexeme]);
      A__advance();
      return _parsePrimaryExpression();
    } else if (A__matches(A_TokenType.HASH)) {
      return _parseSymbolLiteral();
    } else {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
      return _createSyntheticIdentifier();
    }
  }
  RedirectingConstructorInvocation _parseRedirectingConstructorInvocation() {
    A_Token keyword = _expectKeyword(Keyword.THIS);
    A_Token period = null;
    SimpleIdentifier constructorName = null;
    if (A__matches(A_TokenType.PERIOD)) {
      period = andAdvance;
      constructorName = parseSimpleIdentifier();
    }
    ArgumentList argumentList = parseArgumentList();
    return new RedirectingConstructorInvocation(keyword, period, constructorName, argumentList);
  }
  Expression _parseRelationalExpression() {
    if (_matchesKeyword(Keyword.SUPER) && A__currentToken.next.type.isRelationalOperator) {
      Expression expression = new SuperExpression(andAdvance);
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, parseBitwiseOrExpression());
      return expression;
    }
    Expression expression = parseBitwiseOrExpression();
    if (_matchesKeyword(Keyword.AS)) {
      A_Token asOperator = andAdvance;
      expression = new AsExpression(expression, asOperator, parseTypeName());
    } else if (_matchesKeyword(Keyword.IS)) {
      A_Token isOperator = andAdvance;
      A_Token notOperator = null;
      if (A__matches(A_TokenType.BANG)) {
        notOperator = andAdvance;
      }
      expression = new IsExpression(expression, isOperator, notOperator, parseTypeName());
    } else if (A__currentToken.type.isRelationalOperator) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, parseBitwiseOrExpression());
    }
    return expression;
  }
  Expression _parseRethrowExpression() => new RethrowExpression(_expectKeyword(Keyword.RETHROW));
  Statement _parseReturnStatement() {
    A_Token returnKeyword = _expectKeyword(Keyword.RETURN);
    if (A__matches(A_TokenType.SEMICOLON)) {
      return new ReturnStatement(returnKeyword, null, andAdvance);
    }
    Expression expression = parseExpression2();
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new ReturnStatement(returnKeyword, expression, semicolon);
  }
  MethodDeclaration _parseSetter(CommentAndMetadata commentAndMetadata, A_Token externalKeyword, A_Token staticKeyword, TypeName A_returnType) {
    A_Token propertyKeyword = _expectKeyword(Keyword.SET);
    SimpleIdentifier A_name = parseSimpleIdentifier();
    FormalParameterList A_parameters = parseFormalParameterList();
    _validateFormalParameterList(A_parameters);
    FunctionBody body = _parseFunctionBody(externalKeyword != null || staticKeyword == null, ParserErrorCode.STATIC_SETTER_WITHOUT_BODY, false);
    if (externalKeyword != null && body is! EmptyFunctionBody) {
      _reportErrorForCurrentToken(ParserErrorCode.EXTERNAL_SETTER_WITH_BODY, []);
    }
    return new MethodDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, A_returnType, propertyKeyword, null, A_name, A_parameters, body);
  }
  Expression _parseShiftExpression() {
    Expression expression;
    if (_matchesKeyword(Keyword.SUPER) && A__currentToken.next.type.isShiftOperator) {
      expression = new SuperExpression(andAdvance);
    } else {
      expression = _parseAdditiveExpression();
    }
    while (A__currentToken.type.isShiftOperator) {
      A_Token operator = andAdvance;
      expression = new BinaryExpression(expression, operator, _parseAdditiveExpression());
    }
    return expression;
  }
  List<Statement> _parseStatementList() {
    List<Statement> statements = new List<Statement>();
    A_Token statementStart = A__currentToken;
    while (!A__matches(A_TokenType.A_EOF) && !A__matches(A_TokenType.CLOSE_CURLY_BRACKET) && !_isSwitchMember()) {
      statements.add(parseStatement2());
      if (identical(A__currentToken, statementStart)) {
        A__reportErrorForToken(ParserErrorCode.UNEXPECTED_TOKEN, A__currentToken, [A__currentToken.lexeme]);
        A__advance();
      }
      statementStart = A__currentToken;
    }
    return statements;
  }
  StringInterpolation _parseStringInterpolation(A_Token A_string) {
    List<InterpolationElement> elements = new List<InterpolationElement>();
    bool hasMore = A__matches(A_TokenType.STRING_INTERPOLATION_EXPRESSION) || A__matches(A_TokenType.STRING_INTERPOLATION_IDENTIFIER);
    elements.add(new InterpolationString(A_string, _computeStringValue(A_string.lexeme, true, !hasMore)));
    while (hasMore) {
      if (A__matches(A_TokenType.STRING_INTERPOLATION_EXPRESSION)) {
        A_Token openToken = andAdvance;
        bool wasInInitializer = _inInitializer;
        _inInitializer = false;
        try {
          Expression expression = parseExpression2();
          A_Token rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
          elements.add(new InterpolationExpression(openToken, expression, rightBracket));
        } finally {
          _inInitializer = wasInInitializer;
        }
      } else {
        A_Token openToken = andAdvance;
        Expression expression = null;
        if (_matchesKeyword(Keyword.THIS)) {
          expression = new ThisExpression(andAdvance);
        } else {
          expression = parseSimpleIdentifier();
        }
        elements.add(new InterpolationExpression(openToken, expression, null));
      }
      if (A__matches(A_TokenType.A_STRING)) {
        A_string = andAdvance;
        hasMore = A__matches(A_TokenType.STRING_INTERPOLATION_EXPRESSION) || A__matches(A_TokenType.STRING_INTERPOLATION_IDENTIFIER);
        elements.add(new InterpolationString(A_string, _computeStringValue(A_string.lexeme, false, !hasMore)));
      } else {
        hasMore = false;
      }
    }
    return new StringInterpolation(elements);
  }
  SuperConstructorInvocation _parseSuperConstructorInvocation() {
    A_Token keyword = _expectKeyword(Keyword.SUPER);
    A_Token period = null;
    SimpleIdentifier constructorName = null;
    if (A__matches(A_TokenType.PERIOD)) {
      period = andAdvance;
      constructorName = parseSimpleIdentifier();
    }
    ArgumentList argumentList = parseArgumentList();
    return new SuperConstructorInvocation(keyword, period, constructorName, argumentList);
  }
  SwitchStatement _parseSwitchStatement() {
    bool wasInSwitch = _inSwitch;
    _inSwitch = true;
    try {
      A_p.HashSet<String> definedLabels = new A_p.HashSet<String>();
      A_Token keyword = _expectKeyword(Keyword.SWITCH);
      A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
      Expression expression = parseExpression2();
      A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      A_Token leftBracket = A__expect(A_TokenType.OPEN_CURLY_BRACKET);
      A_Token defaultKeyword = null;
      List<SwitchMember> members = new List<SwitchMember>();
      while (!A__matches(A_TokenType.A_EOF) && !A__matches(A_TokenType.CLOSE_CURLY_BRACKET)) {
        List<Label> labels = new List<Label>();
        while (_matchesIdentifier() && _tokenMatches(_peek(), A_TokenType.A_COLON)) {
          SimpleIdentifier identifier = parseSimpleIdentifier();
          String label = identifier.token.lexeme;
          if (definedLabels.contains(label)) {
            A__reportErrorForToken(ParserErrorCode.DUPLICATE_LABEL_IN_SWITCH_STATEMENT, identifier.token, [label]);
          } else {
            definedLabels.add(label);
          }
          A_Token colon = A__expect(A_TokenType.A_COLON);
          labels.add(new Label(identifier, colon));
        }
        if (_matchesKeyword(Keyword.CASE)) {
          A_Token caseKeyword = andAdvance;
          Expression caseExpression = parseExpression2();
          A_Token colon = A__expect(A_TokenType.A_COLON);
          members.add(new SwitchCase(labels, caseKeyword, caseExpression, colon, _parseStatementList()));
          if (defaultKeyword != null) {
            A__reportErrorForToken(ParserErrorCode.SWITCH_HAS_CASE_AFTER_DEFAULT_CASE, caseKeyword, []);
          }
        } else if (_matchesKeyword(Keyword.A_DEFAULT)) {
          if (defaultKeyword != null) {
            A__reportErrorForToken(ParserErrorCode.SWITCH_HAS_MULTIPLE_DEFAULT_CASES, _peek(), []);
          }
          defaultKeyword = andAdvance;
          A_Token colon = A__expect(A_TokenType.A_COLON);
          members.add(new SwitchDefault(labels, defaultKeyword, colon, _parseStatementList()));
        } else {
          _reportErrorForCurrentToken(ParserErrorCode.EXPECTED_CASE_OR_DEFAULT, []);
          while (!A__matches(A_TokenType.A_EOF) && !A__matches(A_TokenType.CLOSE_CURLY_BRACKET) && !_matchesKeyword(Keyword.CASE) && !_matchesKeyword(Keyword.A_DEFAULT)) {
            A__advance();
          }
        }
      }
      A_Token rightBracket = A__expect(A_TokenType.CLOSE_CURLY_BRACKET);
      return new SwitchStatement(keyword, leftParenthesis, expression, rightParenthesis, leftBracket, members, rightBracket);
    } finally {
      _inSwitch = wasInSwitch;
    }
  }
  SymbolLiteral _parseSymbolLiteral() {
    A_Token poundSign = andAdvance;
    List<A_Token> components = new List<A_Token>();
    if (_matchesIdentifier()) {
      components.add(andAdvance);
      while (A__matches(A_TokenType.PERIOD)) {
        A__advance();
        if (_matchesIdentifier()) {
          components.add(andAdvance);
        } else {
          _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
          components.add(_createSyntheticToken(A_TokenType.IDENTIFIER));
          break;
        }
      }
    } else if (A__currentToken.isOperator) {
      components.add(andAdvance);
    } else if (_tokenMatchesKeyword(A__currentToken, Keyword.VOID)) {
      components.add(andAdvance);
    } else {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
      components.add(_createSyntheticToken(A_TokenType.IDENTIFIER));
    }
    return new SymbolLiteral(poundSign, new List.from(components));
  }
  Expression _parseThrowExpression() {
    A_Token keyword = _expectKeyword(Keyword.THROW);
    if (A__matches(A_TokenType.SEMICOLON) || A__matches(A_TokenType.CLOSE_PAREN)) {
      A__reportErrorForToken(ParserErrorCode.MISSING_EXPRESSION_IN_THROW, A__currentToken, []);
      return new ThrowExpression(keyword, _createSyntheticIdentifier());
    }
    Expression expression = parseExpression2();
    return new ThrowExpression(keyword, expression);
  }
  Expression _parseThrowExpressionWithoutCascade() {
    A_Token keyword = _expectKeyword(Keyword.THROW);
    if (A__matches(A_TokenType.SEMICOLON) || A__matches(A_TokenType.CLOSE_PAREN)) {
      A__reportErrorForToken(ParserErrorCode.MISSING_EXPRESSION_IN_THROW, A__currentToken, []);
      return new ThrowExpression(keyword, _createSyntheticIdentifier());
    }
    Expression expression = parseExpressionWithoutCascade();
    return new ThrowExpression(keyword, expression);
  }
  Statement _parseTryStatement() {
    A_Token tryKeyword = _expectKeyword(Keyword.TRY);
    Block body = parseBlock();
    List<CatchClause> catchClauses = new List<CatchClause>();
    Block finallyClause = null;
    while (_matchesString(_ON) || _matchesKeyword(Keyword.CATCH)) {
      A_Token onKeyword = null;
      TypeName exceptionType = null;
      if (_matchesString(_ON)) {
        onKeyword = andAdvance;
        exceptionType = parseTypeName();
      }
      A_Token catchKeyword = null;
      A_Token leftParenthesis = null;
      SimpleIdentifier exceptionParameter = null;
      A_Token comma = null;
      SimpleIdentifier stackTraceParameter = null;
      A_Token rightParenthesis = null;
      if (_matchesKeyword(Keyword.CATCH)) {
        catchKeyword = andAdvance;
        leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
        exceptionParameter = parseSimpleIdentifier();
        if (A__matches(A_TokenType.A_COMMA)) {
          comma = andAdvance;
          stackTraceParameter = parseSimpleIdentifier();
        }
        rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      }
      Block catchBody = parseBlock();
      catchClauses.add(new CatchClause(onKeyword, exceptionType, catchKeyword, leftParenthesis, exceptionParameter, comma, stackTraceParameter, rightParenthesis, catchBody));
    }
    A_Token finallyKeyword = null;
    if (_matchesKeyword(Keyword.FINALLY)) {
      finallyKeyword = andAdvance;
      finallyClause = parseBlock();
    } else {
      if (catchClauses.isEmpty) {
        _reportErrorForCurrentToken(ParserErrorCode.MISSING_CATCH_OR_FINALLY, []);
      }
    }
    return new TryStatement(tryKeyword, body, catchClauses, finallyKeyword, finallyClause);
  }
  TypeAlias _parseTypeAlias(CommentAndMetadata commentAndMetadata) {
    A_Token keyword = _expectKeyword(Keyword.A_TYPEDEF);
    if (_matchesIdentifier()) {
      A_Token A_next = _peek();
      if (_tokenMatches(A_next, A_TokenType.A_LT)) {
        A_next = _skipTypeParameterList(A_next);
        if (A_next != null && _tokenMatches(A_next, A_TokenType.A_EQ)) {
          TypeAlias typeAlias = _parseClassTypeAlias(commentAndMetadata, null, keyword);
          A__reportErrorForToken(ParserErrorCode.DEPRECATED_CLASS_TYPE_ALIAS, keyword, []);
          return typeAlias;
        }
      } else if (_tokenMatches(A_next, A_TokenType.A_EQ)) {
        TypeAlias typeAlias = _parseClassTypeAlias(commentAndMetadata, null, keyword);
        A__reportErrorForToken(ParserErrorCode.DEPRECATED_CLASS_TYPE_ALIAS, keyword, []);
        return typeAlias;
      }
    }
    return _parseFunctionTypeAlias(commentAndMetadata, keyword);
  }
  Expression _parseUnaryExpression() {
    if (A__matches(A_TokenType.MINUS) || A__matches(A_TokenType.BANG) || A__matches(A_TokenType.TILDE)) {
      A_Token operator = andAdvance;
      if (_matchesKeyword(Keyword.SUPER)) {
        if (_tokenMatches(_peek(), A_TokenType.OPEN_SQUARE_BRACKET) || _tokenMatches(_peek(), A_TokenType.PERIOD)) {
          return new PrefixExpression(operator, _parseUnaryExpression());
        }
        return new PrefixExpression(operator, new SuperExpression(andAdvance));
      }
      return new PrefixExpression(operator, _parseUnaryExpression());
    } else if (A__currentToken.type.isIncrementOperator) {
      A_Token operator = andAdvance;
      if (_matchesKeyword(Keyword.SUPER)) {
        if (_tokenMatches(_peek(), A_TokenType.OPEN_SQUARE_BRACKET) || _tokenMatches(_peek(), A_TokenType.PERIOD)) {
          return new PrefixExpression(operator, _parseUnaryExpression());
        }
        if (operator.type == A_TokenType.MINUS_MINUS) {
          int A_offset = operator.offset;
          A_Token firstOperator = new A_Token(A_TokenType.MINUS, A_offset);
          A_Token secondOperator = new A_Token(A_TokenType.MINUS, A_offset + 1);
          secondOperator.setNext(A__currentToken);
          firstOperator.setNext(secondOperator);
          operator.previous.setNext(firstOperator);
          return new PrefixExpression(firstOperator, new PrefixExpression(secondOperator, new SuperExpression(andAdvance)));
        } else {
          _reportErrorForCurrentToken(ParserErrorCode.INVALID_OPERATOR_FOR_SUPER, [operator.lexeme]);
          return new PrefixExpression(operator, new SuperExpression(andAdvance));
        }
      }
      return new PrefixExpression(operator, _parseAssignableExpression(false));
    } else if (A__matches(A_TokenType.PLUS)) {
      _reportErrorForCurrentToken(ParserErrorCode.MISSING_IDENTIFIER, []);
      return _createSyntheticIdentifier();
    }
    return _parsePostfixExpression();
  }
  VariableDeclaration _parseVariableDeclaration() {
    CommentAndMetadata commentAndMetadata = _parseCommentAndMetadata();
    SimpleIdentifier A_name = parseSimpleIdentifier();
    A_Token A_equals = null;
    Expression initializer = null;
    if (A__matches(A_TokenType.A_EQ)) {
      A_equals = andAdvance;
      initializer = parseExpression2();
    }
    return new VariableDeclaration(commentAndMetadata.comment, commentAndMetadata.metadata, A_name, A_equals, initializer);
  }
  VariableDeclarationList _parseVariableDeclarationListAfterMetadata(CommentAndMetadata commentAndMetadata) {
    FinalConstVarOrType holder = _parseFinalConstVarOrType(false);
    return _parseVariableDeclarationListAfterType(commentAndMetadata, holder.keyword, holder.type);
  }
  VariableDeclarationList _parseVariableDeclarationListAfterType(CommentAndMetadata commentAndMetadata, A_Token keyword, TypeName A_type) {
    if (A_type != null && keyword != null && _tokenMatchesKeyword(keyword, Keyword.VAR)) {
      A__reportErrorForToken(ParserErrorCode.VAR_AND_TYPE, keyword, []);
    }
    List<VariableDeclaration> variables = new List<VariableDeclaration>();
    variables.add(_parseVariableDeclaration());
    while (A__matches(A_TokenType.A_COMMA)) {
      A__advance();
      variables.add(_parseVariableDeclaration());
    }
    return new VariableDeclarationList(commentAndMetadata != null ? commentAndMetadata.comment : null, commentAndMetadata != null ? commentAndMetadata.metadata : null, keyword, A_type, variables);
  }
  VariableDeclarationStatement _parseVariableDeclarationStatementAfterMetadata(CommentAndMetadata commentAndMetadata) {
    VariableDeclarationList variableList = _parseVariableDeclarationListAfterMetadata(commentAndMetadata);
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new VariableDeclarationStatement(variableList, semicolon);
  }
  VariableDeclarationStatement _parseVariableDeclarationStatementAfterType(CommentAndMetadata commentAndMetadata, A_Token keyword, TypeName A_type) {
    VariableDeclarationList variableList = _parseVariableDeclarationListAfterType(commentAndMetadata, keyword, A_type);
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new VariableDeclarationStatement(variableList, semicolon);
  }
  Statement _parseWhileStatement() {
    bool wasInLoop = _inLoop;
    _inLoop = true;
    try {
      A_Token keyword = _expectKeyword(Keyword.WHILE);
      A_Token leftParenthesis = A__expect(A_TokenType.OPEN_PAREN);
      Expression condition = parseExpression2();
      A_Token rightParenthesis = A__expect(A_TokenType.CLOSE_PAREN);
      Statement body = parseStatement2();
      return new WhileStatement(keyword, leftParenthesis, condition, rightParenthesis, body);
    } finally {
      _inLoop = wasInLoop;
    }
  }
  YieldStatement _parseYieldStatement() {
    A_Token yieldToken = andAdvance;
    A_Token star = null;
    if (A__matches(A_TokenType.STAR)) {
      star = andAdvance;
    }
    Expression expression = parseExpression2();
    A_Token semicolon = A__expect(A_TokenType.SEMICOLON);
    return new YieldStatement(yieldToken, star, expression, semicolon);
  }
  A_Token _peek() => A__currentToken.next;
  A_Token _peekAt(int distance) {
    A_Token token = A__currentToken;
    for (int i = 0; i < distance; i++) {
      token = token.next;
    }
    return token;
  }
  void A__reportError(A_AnalysisError A_error) {
    if (_errorListenerLock != 0) {
      return;
    }
    C__errorListener.onError(A_error);
  }
  void _reportErrorForCurrentToken(ParserErrorCode A_errorCode, List<Object> A_arguments) {
    A__reportErrorForToken(A_errorCode, A__currentToken, A_arguments);
  }
  void A__reportErrorForNode(ParserErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    A__reportError(new A_AnalysisError.D_con2(D__source, node.offset, node.length, A_errorCode, A_arguments));
  }
  void A__reportErrorForToken(ParserErrorCode A_errorCode, A_Token token, List<Object> A_arguments) {
    if (token.type == A_TokenType.A_EOF) {
      token = token.previous;
    }
    A__reportError(new A_AnalysisError.D_con2(D__source, token.offset, Math.A_max(token.length, 1), A_errorCode, A_arguments));
  }
  void _skipBlock() {
    A_Token endToken = (A__currentToken as BeginToken).endToken;
    if (endToken == null) {
      endToken = A__currentToken.next;
      while (!identical(endToken, A__currentToken)) {
        A__currentToken = endToken;
        endToken = A__currentToken.next;
      }
      A__reportErrorForToken(ParserErrorCode.EXPECTED_TOKEN, A__currentToken.previous, ["}"]);
    } else {
      A__currentToken = endToken.next;
    }
  }
  A_Token _skipFinalConstVarOrType(A_Token startToken) {
    if (_tokenMatchesKeyword(startToken, Keyword.A_FINAL) || _tokenMatchesKeyword(startToken, Keyword.B_CONST)) {
      A_Token A_next = startToken.next;
      if (_tokenMatchesIdentifier(A_next)) {
        A_Token next2 = A_next.next;
        if (_tokenMatchesIdentifier(next2) || _tokenMatches(next2, A_TokenType.A_LT) || _tokenMatches(next2, A_TokenType.PERIOD)) {
          return _skipTypeName(A_next);
        }
        return A_next;
      }
    } else if (_tokenMatchesKeyword(startToken, Keyword.VAR)) {
      return startToken.next;
    } else if (_tokenMatchesIdentifier(startToken)) {
      A_Token A_next = startToken.next;
      if (_tokenMatchesIdentifier(A_next) || _tokenMatches(A_next, A_TokenType.A_LT) || _tokenMatchesKeyword(A_next, Keyword.THIS) || (_tokenMatches(A_next, A_TokenType.PERIOD) && _tokenMatchesIdentifier(A_next.next) && (_tokenMatchesIdentifier(A_next.next.next) || _tokenMatches(A_next.next.next, A_TokenType.A_LT) || _tokenMatchesKeyword(A_next.next.next, Keyword.THIS)))) {
        return _skipReturnType(startToken);
      }
    }
    return null;
  }
  A_Token _skipFormalParameterList(A_Token startToken) {
    if (!_tokenMatches(startToken, A_TokenType.OPEN_PAREN)) {
      return null;
    }
    A_Token A_next = startToken.next;
    if (_tokenMatches(A_next, A_TokenType.CLOSE_PAREN)) {
      return A_next.next;
    }
    if (A_next.matchesAny([A_TokenType.AT, A_TokenType.OPEN_SQUARE_BRACKET, A_TokenType.OPEN_CURLY_BRACKET]) || _tokenMatchesKeyword(A_next, Keyword.VOID) || (_tokenMatchesIdentifier(A_next) && (A_next.next.matchesAny([A_TokenType.A_COMMA, A_TokenType.CLOSE_PAREN])))) {
      return _skipPastMatchingToken(startToken);
    }
    if (_tokenMatchesIdentifier(A_next) && _tokenMatches(A_next.next, A_TokenType.OPEN_PAREN)) {
      A_Token afterParameters = _skipFormalParameterList(A_next.next);
      if (afterParameters != null && (afterParameters.matchesAny([A_TokenType.A_COMMA, A_TokenType.CLOSE_PAREN]))) {
        return _skipPastMatchingToken(startToken);
      }
    }
    A_Token afterType = _skipFinalConstVarOrType(A_next);
    if (afterType == null) {
      return null;
    }
    if (_skipSimpleIdentifier(afterType) == null) {
      return null;
    }
    return _skipPastMatchingToken(startToken);
  }
  A_Token _skipPastMatchingToken(A_Token startToken) {
    if (startToken is! BeginToken) {
      return null;
    }
    A_Token closeParen = (startToken as BeginToken).endToken;
    if (closeParen == null) {
      return null;
    }
    return closeParen.next;
  }
  A_Token _skipPrefixedIdentifier(A_Token startToken) {
    A_Token token = _skipSimpleIdentifier(startToken);
    if (token == null) {
      return null;
    } else if (!_tokenMatches(token, A_TokenType.PERIOD)) {
      return token;
    }
    return _skipSimpleIdentifier(token.next);
  }
  A_Token _skipReturnType(A_Token startToken) {
    if (_tokenMatchesKeyword(startToken, Keyword.VOID)) {
      return startToken.next;
    } else {
      return _skipTypeName(startToken);
    }
  }
  A_Token _skipSimpleIdentifier(A_Token startToken) {
    if (_tokenMatches(startToken, A_TokenType.IDENTIFIER) || (_tokenMatches(startToken, A_TokenType.A_KEYWORD) && (startToken as KeywordToken).keyword.isPseudoKeyword)) {
      return startToken.next;
    }
    return null;
  }
  A_Token _skipStringInterpolation(A_Token startToken) {
    A_Token token = startToken;
    A_TokenType A_type = token.type;
    while (A_type == A_TokenType.STRING_INTERPOLATION_EXPRESSION || A_type == A_TokenType.STRING_INTERPOLATION_IDENTIFIER) {
      if (A_type == A_TokenType.STRING_INTERPOLATION_EXPRESSION) {
        token = token.next;
        A_type = token.type;
        int bracketNestingLevel = 1;
        while (bracketNestingLevel > 0) {
          if (A_type == A_TokenType.A_EOF) {
            return null;
          } else if (A_type == A_TokenType.OPEN_CURLY_BRACKET) {
            bracketNestingLevel++;
          } else if (A_type == A_TokenType.CLOSE_CURLY_BRACKET) {
            bracketNestingLevel--;
          } else if (A_type == A_TokenType.A_STRING) {
            token = _skipStringLiteral(token);
            if (token == null) {
              return null;
            }
          } else {
            token = token.next;
          }
          A_type = token.type;
        }
        token = token.next;
        A_type = token.type;
      } else {
        token = token.next;
        if (token.type != A_TokenType.IDENTIFIER) {
          return null;
        }
        token = token.next;
      }
      A_type = token.type;
      if (A_type == A_TokenType.A_STRING) {
        token = token.next;
        A_type = token.type;
      }
    }
    return token;
  }
  A_Token _skipStringLiteral(A_Token startToken) {
    A_Token token = startToken;
    while (token != null && _tokenMatches(token, A_TokenType.A_STRING)) {
      token = token.next;
      A_TokenType A_type = token.type;
      if (A_type == A_TokenType.STRING_INTERPOLATION_EXPRESSION || A_type == A_TokenType.STRING_INTERPOLATION_IDENTIFIER) {
        token = _skipStringInterpolation(token);
      }
    }
    if (identical(token, startToken)) {
      return null;
    }
    return token;
  }
  A_Token _skipTypeArgumentList(A_Token startToken) {
    A_Token token = startToken;
    if (!_tokenMatches(token, A_TokenType.A_LT)) {
      return null;
    }
    token = _skipTypeName(token.next);
    if (token == null) {
      return null;
    }
    while (_tokenMatches(token, A_TokenType.A_COMMA)) {
      token = _skipTypeName(token.next);
      if (token == null) {
        return null;
      }
    }
    if (token.type == A_TokenType.A_GT) {
      return token.next;
    } else if (token.type == A_TokenType.GT_GT) {
      A_Token A_second = new A_Token(A_TokenType.A_GT, token.offset + 1);
      A_second.setNextWithoutSettingPrevious(token.next);
      return A_second;
    }
    return null;
  }
  A_Token _skipTypeName(A_Token startToken) {
    A_Token token = _skipPrefixedIdentifier(startToken);
    if (token == null) {
      return null;
    }
    if (_tokenMatches(token, A_TokenType.A_LT)) {
      token = _skipTypeArgumentList(token);
    }
    return token;
  }
  A_Token _skipTypeParameterList(A_Token startToken) {
    if (!_tokenMatches(startToken, A_TokenType.A_LT)) {
      return null;
    }
    int depth = 1;
    A_Token A_next = startToken.next;
    while (depth > 0) {
      if (_tokenMatches(A_next, A_TokenType.A_EOF)) {
        return null;
      } else if (_tokenMatches(A_next, A_TokenType.A_LT)) {
        depth++;
      } else if (_tokenMatches(A_next, A_TokenType.A_GT)) {
        depth--;
      } else if (_tokenMatches(A_next, A_TokenType.GT_EQ)) {
        if (depth == 1) {
          A_Token fakeEquals = new A_Token(A_TokenType.A_EQ, A_next.offset + 2);
          fakeEquals.setNextWithoutSettingPrevious(A_next.next);
          return fakeEquals;
        }
        depth--;
      } else if (_tokenMatches(A_next, A_TokenType.GT_GT)) {
        depth -= 2;
      } else if (_tokenMatches(A_next, A_TokenType.GT_GT_EQ)) {
        if (depth < 2) {
          return null;
        } else if (depth == 2) {
          A_Token fakeEquals = new A_Token(A_TokenType.A_EQ, A_next.offset + 2);
          fakeEquals.setNextWithoutSettingPrevious(A_next.next);
          return fakeEquals;
        }
        depth -= 2;
      }
      A_next = A_next.next;
    }
    return A_next;
  }
  bool _tokenMatches(A_Token token, A_TokenType A_type) => token.type == A_type;
  bool _tokenMatchesIdentifier(A_Token token) => _tokenMatches(token, A_TokenType.IDENTIFIER) || (_tokenMatches(token, A_TokenType.A_KEYWORD) && (token as KeywordToken).keyword.isPseudoKeyword);
  bool _tokenMatchesKeyword(A_Token token, Keyword keyword) => token.type == A_TokenType.A_KEYWORD && (token as KeywordToken).keyword == keyword;
  bool _tokenMatchesString(A_Token token, String identifier) => token.type == A_TokenType.IDENTIFIER && token.lexeme == identifier;
  int _translateCharacter(JavaStringBuilder A_builder, String lexeme, int A_index) {
    int currentChar = lexeme.codeUnitAt(A_index);
    if (currentChar != 0x5C) {
      A_builder.appendChar(currentChar);
      return A_index + 1;
    }
    int A_length = lexeme.length;
    int currentIndex = A_index + 1;
    if (currentIndex >= A_length) {
      return A_length;
    }
    currentChar = lexeme.codeUnitAt(currentIndex);
    if (currentChar == 0x6E) {
      A_builder.appendChar(0xA);
    } else if (currentChar == 0x72) {
      A_builder.appendChar(0xD);
    } else if (currentChar == 0x66) {
      A_builder.appendChar(0xC);
    } else if (currentChar == 0x62) {
      A_builder.appendChar(0x8);
    } else if (currentChar == 0x74) {
      A_builder.appendChar(0x9);
    } else if (currentChar == 0x76) {
      A_builder.appendChar(0xB);
    } else if (currentChar == 0x78) {
      if (currentIndex + 2 >= A_length) {
        _reportErrorForCurrentToken(ParserErrorCode.INVALID_HEX_ESCAPE, []);
        return A_length;
      }
      int firstDigit = lexeme.codeUnitAt(currentIndex + 1);
      int secondDigit = lexeme.codeUnitAt(currentIndex + 2);
      if (!A__isHexDigit(firstDigit) || !A__isHexDigit(secondDigit)) {
        _reportErrorForCurrentToken(ParserErrorCode.INVALID_HEX_ESCAPE, []);
      } else {
        A_builder.appendChar(((Character.digit(firstDigit, 16) << 4) + Character.digit(secondDigit, 16)));
      }
      return currentIndex + 3;
    } else if (currentChar == 0x75) {
      currentIndex++;
      if (currentIndex >= A_length) {
        _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
        return A_length;
      }
      currentChar = lexeme.codeUnitAt(currentIndex);
      if (currentChar == 0x7B) {
        currentIndex++;
        if (currentIndex >= A_length) {
          _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
          return A_length;
        }
        currentChar = lexeme.codeUnitAt(currentIndex);
        int digitCount = 0;
        int A_value = 0;
        while (currentChar != 0x7D) {
          if (!A__isHexDigit(currentChar)) {
            _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
            currentIndex++;
            while (currentIndex < A_length && lexeme.codeUnitAt(currentIndex) != 0x7D) {
              currentIndex++;
            }
            return currentIndex + 1;
          }
          digitCount++;
          A_value = (A_value << 4) + Character.digit(currentChar, 16);
          currentIndex++;
          if (currentIndex >= A_length) {
            _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
            return A_length;
          }
          currentChar = lexeme.codeUnitAt(currentIndex);
        }
        if (digitCount < 1 || digitCount > 6) {
          _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
        }
        _appendScalarValue(A_builder, lexeme.substring(A_index, currentIndex + 1), A_value, A_index, currentIndex);
        return currentIndex + 1;
      } else {
        if (currentIndex + 3 >= A_length) {
          _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
          return A_length;
        }
        int firstDigit = currentChar;
        int secondDigit = lexeme.codeUnitAt(currentIndex + 1);
        int thirdDigit = lexeme.codeUnitAt(currentIndex + 2);
        int fourthDigit = lexeme.codeUnitAt(currentIndex + 3);
        if (!A__isHexDigit(firstDigit) || !A__isHexDigit(secondDigit) || !A__isHexDigit(thirdDigit) || !A__isHexDigit(fourthDigit)) {
          _reportErrorForCurrentToken(ParserErrorCode.INVALID_UNICODE_ESCAPE, []);
        } else {
          _appendScalarValue(A_builder, lexeme.substring(A_index, currentIndex + 1), (((((Character.digit(firstDigit, 16) << 4) + Character.digit(secondDigit, 16)) << 4) + Character.digit(thirdDigit, 16)) << 4) + Character.digit(fourthDigit, 16), A_index, currentIndex + 3);
        }
        return currentIndex + 4;
      }
    } else {
      A_builder.appendChar(currentChar);
    }
    return currentIndex + 1;
  }
  void _unlockErrorListener() {
    if (_errorListenerLock == 0) {
      throw new IllegalStateException("Attempt to unlock not locked error listener.");
    }
    _errorListenerLock--;
  }
  void _validateFormalParameterList(FormalParameterList parameterList) {
    for (FormalParameter parameter in parameterList.parameters) {
      if (parameter is FieldFormalParameter) {
        A__reportErrorForNode(ParserErrorCode.A_FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR, parameter.identifier, []);
      }
    }
  }
  A_Token _validateModifiersForClass(Modifiers modifiers) {
    _validateModifiersForTopLevelDeclaration(modifiers);
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_CLASS, modifiers.constKeyword, []);
    }
    if (modifiers.externalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_CLASS, modifiers.externalKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_CLASS, modifiers.finalKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_CLASS, modifiers.varKeyword, []);
    }
    return modifiers.abstractKeyword;
  }
  A_Token _validateModifiersForConstructor(Modifiers modifiers) {
    if (modifiers.abstractKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.ABSTRACT_CLASS_MEMBER, modifiers.abstractKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_CONSTRUCTOR, modifiers.finalKeyword, []);
    }
    if (modifiers.staticKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.STATIC_CONSTRUCTOR, modifiers.staticKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONSTRUCTOR_WITH_RETURN_TYPE, modifiers.varKeyword, []);
    }
    A_Token externalKeyword = modifiers.externalKeyword;
    A_Token constKeyword = modifiers.constKeyword;
    A_Token factoryKeyword = modifiers.factoryKeyword;
    if (externalKeyword != null && constKeyword != null && constKeyword.offset < externalKeyword.offset) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_AFTER_CONST, externalKeyword, []);
    }
    if (externalKeyword != null && factoryKeyword != null && factoryKeyword.offset < externalKeyword.offset) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_AFTER_FACTORY, externalKeyword, []);
    }
    return constKeyword;
  }
  void _validateModifiersForEnum(Modifiers modifiers) {
    _validateModifiersForTopLevelDeclaration(modifiers);
    if (modifiers.abstractKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.ABSTRACT_ENUM, modifiers.abstractKeyword, []);
    }
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_ENUM, modifiers.constKeyword, []);
    }
    if (modifiers.externalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_ENUM, modifiers.externalKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_ENUM, modifiers.finalKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_ENUM, modifiers.varKeyword, []);
    }
  }
  A_Token _validateModifiersForField(Modifiers modifiers) {
    if (modifiers.abstractKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.ABSTRACT_CLASS_MEMBER, []);
    }
    if (modifiers.externalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_FIELD, modifiers.externalKeyword, []);
    }
    if (modifiers.factoryKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.NON_CONSTRUCTOR_FACTORY, modifiers.factoryKeyword, []);
    }
    A_Token staticKeyword = modifiers.staticKeyword;
    A_Token constKeyword = modifiers.constKeyword;
    A_Token finalKeyword = modifiers.finalKeyword;
    A_Token varKeyword = modifiers.varKeyword;
    if (constKeyword != null) {
      if (finalKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.CONST_AND_FINAL, finalKeyword, []);
      }
      if (varKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.CONST_AND_VAR, varKeyword, []);
      }
      if (staticKeyword != null && constKeyword.offset < staticKeyword.offset) {
        A__reportErrorForToken(ParserErrorCode.STATIC_AFTER_CONST, staticKeyword, []);
      }
    } else if (finalKeyword != null) {
      if (varKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.FINAL_AND_VAR, varKeyword, []);
      }
      if (staticKeyword != null && finalKeyword.offset < staticKeyword.offset) {
        A__reportErrorForToken(ParserErrorCode.STATIC_AFTER_FINAL, staticKeyword, []);
      }
    } else if (varKeyword != null && staticKeyword != null && varKeyword.offset < staticKeyword.offset) {
      A__reportErrorForToken(ParserErrorCode.STATIC_AFTER_VAR, staticKeyword, []);
    }
    return _lexicallyFirst([constKeyword, finalKeyword, varKeyword]);
  }
  void _validateModifiersForFunctionDeclarationStatement(Modifiers modifiers) {
    if (modifiers.abstractKeyword != null || modifiers.constKeyword != null || modifiers.externalKeyword != null || modifiers.factoryKeyword != null || modifiers.finalKeyword != null || modifiers.staticKeyword != null || modifiers.varKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.LOCAL_FUNCTION_DECLARATION_MODIFIER, []);
    }
  }
  void _validateModifiersForGetterOrSetterOrMethod(Modifiers modifiers) {
    if (modifiers.abstractKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.ABSTRACT_CLASS_MEMBER, []);
    }
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_METHOD, modifiers.constKeyword, []);
    }
    if (modifiers.factoryKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.NON_CONSTRUCTOR_FACTORY, modifiers.factoryKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_METHOD, modifiers.finalKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_RETURN_TYPE, modifiers.varKeyword, []);
    }
    A_Token externalKeyword = modifiers.externalKeyword;
    A_Token staticKeyword = modifiers.staticKeyword;
    if (externalKeyword != null && staticKeyword != null && staticKeyword.offset < externalKeyword.offset) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_AFTER_STATIC, externalKeyword, []);
    }
  }
  void _validateModifiersForOperator(Modifiers modifiers) {
    if (modifiers.abstractKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.ABSTRACT_CLASS_MEMBER, []);
    }
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_METHOD, modifiers.constKeyword, []);
    }
    if (modifiers.factoryKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.NON_CONSTRUCTOR_FACTORY, modifiers.factoryKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_METHOD, modifiers.finalKeyword, []);
    }
    if (modifiers.staticKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.STATIC_OPERATOR, modifiers.staticKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_RETURN_TYPE, modifiers.varKeyword, []);
    }
  }
  void _validateModifiersForTopLevelDeclaration(Modifiers modifiers) {
    if (modifiers.factoryKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FACTORY_TOP_LEVEL_DECLARATION, modifiers.factoryKeyword, []);
    }
    if (modifiers.staticKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.STATIC_TOP_LEVEL_DECLARATION, modifiers.staticKeyword, []);
    }
  }
  void _validateModifiersForTopLevelFunction(Modifiers modifiers) {
    _validateModifiersForTopLevelDeclaration(modifiers);
    if (modifiers.abstractKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.ABSTRACT_TOP_LEVEL_FUNCTION, []);
    }
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_CLASS, modifiers.constKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_CLASS, modifiers.finalKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_RETURN_TYPE, modifiers.varKeyword, []);
    }
  }
  A_Token _validateModifiersForTopLevelVariable(Modifiers modifiers) {
    _validateModifiersForTopLevelDeclaration(modifiers);
    if (modifiers.abstractKeyword != null) {
      _reportErrorForCurrentToken(ParserErrorCode.ABSTRACT_TOP_LEVEL_VARIABLE, []);
    }
    if (modifiers.externalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_FIELD, modifiers.externalKeyword, []);
    }
    A_Token constKeyword = modifiers.constKeyword;
    A_Token finalKeyword = modifiers.finalKeyword;
    A_Token varKeyword = modifiers.varKeyword;
    if (constKeyword != null) {
      if (finalKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.CONST_AND_FINAL, finalKeyword, []);
      }
      if (varKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.CONST_AND_VAR, varKeyword, []);
      }
    } else if (finalKeyword != null) {
      if (varKeyword != null) {
        A__reportErrorForToken(ParserErrorCode.FINAL_AND_VAR, varKeyword, []);
      }
    }
    return _lexicallyFirst([constKeyword, finalKeyword, varKeyword]);
  }
  void _validateModifiersForTypedef(Modifiers modifiers) {
    _validateModifiersForTopLevelDeclaration(modifiers);
    if (modifiers.abstractKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.ABSTRACT_TYPEDEF, modifiers.abstractKeyword, []);
    }
    if (modifiers.constKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.CONST_TYPEDEF, modifiers.constKeyword, []);
    }
    if (modifiers.externalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.EXTERNAL_TYPEDEF, modifiers.externalKeyword, []);
    }
    if (modifiers.finalKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.FINAL_TYPEDEF, modifiers.finalKeyword, []);
    }
    if (modifiers.varKeyword != null) {
      A__reportErrorForToken(ParserErrorCode.VAR_TYPEDEF, modifiers.varKeyword, []);
    }
  }
}
class ParserErrorCode extends Enum<ParserErrorCode> implements ErrorCode {
  static const ParserErrorCode ABSTRACT_CLASS_MEMBER = const ParserErrorCode.A_con3('ABSTRACT_CLASS_MEMBER', 0, "Members of classes cannot be declared to be 'abstract'");
  static const ParserErrorCode ABSTRACT_ENUM = const ParserErrorCode.A_con3('ABSTRACT_ENUM', 1, "Enums cannot be declared to be 'abstract'");
  static const ParserErrorCode ABSTRACT_STATIC_METHOD = const ParserErrorCode.A_con3('ABSTRACT_STATIC_METHOD', 2, "Static methods cannot be declared to be 'abstract'");
  static const ParserErrorCode ABSTRACT_TOP_LEVEL_FUNCTION = const ParserErrorCode.A_con3('ABSTRACT_TOP_LEVEL_FUNCTION', 3, "Top-level functions cannot be declared to be 'abstract'");
  static const ParserErrorCode ABSTRACT_TOP_LEVEL_VARIABLE = const ParserErrorCode.A_con3('ABSTRACT_TOP_LEVEL_VARIABLE', 4, "Top-level variables cannot be declared to be 'abstract'");
  static const ParserErrorCode ABSTRACT_TYPEDEF = const ParserErrorCode.A_con3('ABSTRACT_TYPEDEF', 5, "Type aliases cannot be declared to be 'abstract'");
  static const ParserErrorCode ASSERT_DOES_NOT_TAKE_ASSIGNMENT = const ParserErrorCode.A_con3('ASSERT_DOES_NOT_TAKE_ASSIGNMENT', 6, "Assert cannot be called on an assignment");
  static const ParserErrorCode ASSERT_DOES_NOT_TAKE_CASCADE = const ParserErrorCode.A_con3('ASSERT_DOES_NOT_TAKE_CASCADE', 7, "Assert cannot be called on cascade");
  static const ParserErrorCode ASSERT_DOES_NOT_TAKE_THROW = const ParserErrorCode.A_con3('ASSERT_DOES_NOT_TAKE_THROW', 8, "Assert cannot be called on throws");
  static const ParserErrorCode ASSERT_DOES_NOT_TAKE_RETHROW = const ParserErrorCode.A_con3('ASSERT_DOES_NOT_TAKE_RETHROW', 9, "Assert cannot be called on rethrows");
  static const ParserErrorCode BREAK_OUTSIDE_OF_LOOP = const ParserErrorCode.A_con3('BREAK_OUTSIDE_OF_LOOP', 10, "A break statement cannot be used outside of a loop or switch statement");
  static const ParserErrorCode CONST_AND_FINAL = const ParserErrorCode.A_con3('CONST_AND_FINAL', 11, "Members cannot be declared to be both 'const' and 'final'");
  static const ParserErrorCode CONST_AND_VAR = const ParserErrorCode.A_con3('CONST_AND_VAR', 12, "Members cannot be declared to be both 'const' and 'var'");
  static const ParserErrorCode CONST_CLASS = const ParserErrorCode.A_con3('CONST_CLASS', 13, "Classes cannot be declared to be 'const'");
  static const ParserErrorCode CONST_CONSTRUCTOR_WITH_BODY = const ParserErrorCode.A_con3('CONST_CONSTRUCTOR_WITH_BODY', 14, "'const' constructors cannot have a body");
  static const ParserErrorCode CONST_ENUM = const ParserErrorCode.A_con3('CONST_ENUM', 15, "Enums cannot be declared to be 'const'");
  static const ParserErrorCode CONST_FACTORY = const ParserErrorCode.A_con3('CONST_FACTORY', 16, "Only redirecting factory constructors can be declared to be 'const'");
  static const ParserErrorCode CONST_METHOD = const ParserErrorCode.A_con3('CONST_METHOD', 17, "Getters, setters and methods cannot be declared to be 'const'");
  static const ParserErrorCode CONST_TYPEDEF = const ParserErrorCode.A_con3('CONST_TYPEDEF', 18, "Type aliases cannot be declared to be 'const'");
  static const ParserErrorCode CONSTRUCTOR_WITH_RETURN_TYPE = const ParserErrorCode.A_con3('CONSTRUCTOR_WITH_RETURN_TYPE', 19, "Constructors cannot have a return type");
  static const ParserErrorCode CONTINUE_OUTSIDE_OF_LOOP = const ParserErrorCode.A_con3('CONTINUE_OUTSIDE_OF_LOOP', 20, "A continue statement cannot be used outside of a loop or switch statement");
  static const ParserErrorCode CONTINUE_WITHOUT_LABEL_IN_CASE = const ParserErrorCode.A_con3('CONTINUE_WITHOUT_LABEL_IN_CASE', 21, "A continue statement in a switch statement must have a label as a target");
  static const ParserErrorCode DEFERRED_IMPORTS_NOT_SUPPORTED = const ParserErrorCode.A_con3('DEFERRED_IMPORTS_NOT_SUPPORTED', 22, "Deferred imports are not supported by default");
  static const ParserErrorCode DEPRECATED_CLASS_TYPE_ALIAS = const ParserErrorCode.A_con3('DEPRECATED_CLASS_TYPE_ALIAS', 23, "The 'typedef' mixin application was replaced with 'class'");
  static const ParserErrorCode DIRECTIVE_AFTER_DECLARATION = const ParserErrorCode.A_con3('DIRECTIVE_AFTER_DECLARATION', 24, "Directives must appear before any declarations");
  static const ParserErrorCode DUPLICATE_LABEL_IN_SWITCH_STATEMENT = const ParserErrorCode.A_con3('DUPLICATE_LABEL_IN_SWITCH_STATEMENT', 25, "The label %s was already used in this switch statement");
  static const ParserErrorCode DUPLICATED_MODIFIER = const ParserErrorCode.A_con3('DUPLICATED_MODIFIER', 26, "The modifier '%s' was already specified.");
  static const ParserErrorCode EMPTY_ENUM_BODY = const ParserErrorCode.A_con3('EMPTY_ENUM_BODY', 27, "An enum must declare at least one constant name");
  static const ParserErrorCode EQUALITY_CANNOT_BE_EQUALITY_OPERAND = const ParserErrorCode.A_con3('EQUALITY_CANNOT_BE_EQUALITY_OPERAND', 28, "Equality expression cannot be operand of another equality expression.");
  static const ParserErrorCode EXPECTED_CASE_OR_DEFAULT = const ParserErrorCode.A_con3('EXPECTED_CASE_OR_DEFAULT', 29, "Expected 'case' or 'default'");
  static const ParserErrorCode EXPECTED_CLASS_MEMBER = const ParserErrorCode.A_con3('EXPECTED_CLASS_MEMBER', 30, "Expected a class member");
  static const ParserErrorCode EXPECTED_EXECUTABLE = const ParserErrorCode.A_con3('EXPECTED_EXECUTABLE', 31, "Expected a method, getter, setter or operator declaration");
  static const ParserErrorCode EXPECTED_LIST_OR_MAP_LITERAL = const ParserErrorCode.A_con3('EXPECTED_LIST_OR_MAP_LITERAL', 32, "Expected a list or map literal");
  static const ParserErrorCode EXPECTED_STRING_LITERAL = const ParserErrorCode.A_con3('EXPECTED_STRING_LITERAL', 33, "Expected a string literal");
  static const ParserErrorCode EXPECTED_TOKEN = const ParserErrorCode.A_con3('EXPECTED_TOKEN', 34, "Expected to find '%s'");
  static const ParserErrorCode EXPECTED_TYPE_NAME = const ParserErrorCode.A_con3('EXPECTED_TYPE_NAME', 35, "Expected a type name");
  static const ParserErrorCode EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE = const ParserErrorCode.A_con3('EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE', 36, "Export directives must preceed part directives");
  static const ParserErrorCode EXTERNAL_AFTER_CONST = const ParserErrorCode.A_con3('EXTERNAL_AFTER_CONST', 37, "The modifier 'external' should be before the modifier 'const'");
  static const ParserErrorCode EXTERNAL_AFTER_FACTORY = const ParserErrorCode.A_con3('EXTERNAL_AFTER_FACTORY', 38, "The modifier 'external' should be before the modifier 'factory'");
  static const ParserErrorCode EXTERNAL_AFTER_STATIC = const ParserErrorCode.A_con3('EXTERNAL_AFTER_STATIC', 39, "The modifier 'external' should be before the modifier 'static'");
  static const ParserErrorCode EXTERNAL_CLASS = const ParserErrorCode.A_con3('EXTERNAL_CLASS', 40, "Classes cannot be declared to be 'external'");
  static const ParserErrorCode EXTERNAL_CONSTRUCTOR_WITH_BODY = const ParserErrorCode.A_con3('EXTERNAL_CONSTRUCTOR_WITH_BODY', 41, "External constructors cannot have a body");
  static const ParserErrorCode EXTERNAL_ENUM = const ParserErrorCode.A_con3('EXTERNAL_ENUM', 42, "Enums cannot be declared to be 'external'");
  static const ParserErrorCode EXTERNAL_FIELD = const ParserErrorCode.A_con3('EXTERNAL_FIELD', 43, "Fields cannot be declared to be 'external'");
  static const ParserErrorCode EXTERNAL_GETTER_WITH_BODY = const ParserErrorCode.A_con3('EXTERNAL_GETTER_WITH_BODY', 44, "External getters cannot have a body");
  static const ParserErrorCode EXTERNAL_METHOD_WITH_BODY = const ParserErrorCode.A_con3('EXTERNAL_METHOD_WITH_BODY', 45, "External methods cannot have a body");
  static const ParserErrorCode EXTERNAL_OPERATOR_WITH_BODY = const ParserErrorCode.A_con3('EXTERNAL_OPERATOR_WITH_BODY', 46, "External operators cannot have a body");
  static const ParserErrorCode EXTERNAL_SETTER_WITH_BODY = const ParserErrorCode.A_con3('EXTERNAL_SETTER_WITH_BODY', 47, "External setters cannot have a body");
  static const ParserErrorCode EXTERNAL_TYPEDEF = const ParserErrorCode.A_con3('EXTERNAL_TYPEDEF', 48, "Type aliases cannot be declared to be 'external'");
  static const ParserErrorCode FACTORY_TOP_LEVEL_DECLARATION = const ParserErrorCode.A_con3('FACTORY_TOP_LEVEL_DECLARATION', 49, "Top-level declarations cannot be declared to be 'factory'");
  static const ParserErrorCode FACTORY_WITHOUT_BODY = const ParserErrorCode.A_con3('FACTORY_WITHOUT_BODY', 50, "A non-redirecting 'factory' constructor must have a body");
  static const ParserErrorCode A_FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR = const ParserErrorCode.A_con3('FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR', 51, "Field initializers can only be used in a constructor");
  static const ParserErrorCode FINAL_AND_VAR = const ParserErrorCode.A_con3('FINAL_AND_VAR', 52, "Members cannot be declared to be both 'final' and 'var'");
  static const ParserErrorCode FINAL_CLASS = const ParserErrorCode.A_con3('FINAL_CLASS', 53, "Classes cannot be declared to be 'final'");
  static const ParserErrorCode FINAL_CONSTRUCTOR = const ParserErrorCode.A_con3('FINAL_CONSTRUCTOR', 54, "A constructor cannot be declared to be 'final'");
  static const ParserErrorCode FINAL_ENUM = const ParserErrorCode.A_con3('FINAL_ENUM', 55, "Enums cannot be declared to be 'final'");
  static const ParserErrorCode FINAL_METHOD = const ParserErrorCode.A_con3('FINAL_METHOD', 56, "Getters, setters and methods cannot be declared to be 'final'");
  static const ParserErrorCode FINAL_TYPEDEF = const ParserErrorCode.A_con3('FINAL_TYPEDEF', 57, "Type aliases cannot be declared to be 'final'");
  static const ParserErrorCode FUNCTION_TYPED_PARAMETER_VAR = const ParserErrorCode.A_con3('FUNCTION_TYPED_PARAMETER_VAR', 58, "Function typed parameters cannot specify 'const', 'final' or 'var' instead of return type");
  static const ParserErrorCode GETTER_IN_FUNCTION = const ParserErrorCode.A_con3('GETTER_IN_FUNCTION', 59, "Getters cannot be defined within methods or functions");
  static const ParserErrorCode GETTER_WITH_PARAMETERS = const ParserErrorCode.A_con3('GETTER_WITH_PARAMETERS', 60, "Getter should be declared without a parameter list");
  static const ParserErrorCode ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE = const ParserErrorCode.A_con3('ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE', 61, "Illegal assignment to non-assignable expression");
  static const ParserErrorCode IMPLEMENTS_BEFORE_EXTENDS = const ParserErrorCode.A_con3('IMPLEMENTS_BEFORE_EXTENDS', 62, "The extends clause must be before the implements clause");
  static const ParserErrorCode IMPLEMENTS_BEFORE_WITH = const ParserErrorCode.A_con3('IMPLEMENTS_BEFORE_WITH', 63, "The with clause must be before the implements clause");
  static const ParserErrorCode IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE = const ParserErrorCode.A_con3('IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE', 64, "Import directives must preceed part directives");
  static const ParserErrorCode INITIALIZED_VARIABLE_IN_FOR_EACH = const ParserErrorCode.A_con3('INITIALIZED_VARIABLE_IN_FOR_EACH', 65, "The loop variable in a for-each loop cannot be initialized");
  static const ParserErrorCode INVALID_AWAIT_IN_FOR = const ParserErrorCode.con4('INVALID_AWAIT_IN_FOR', 66, "The modifier 'await' is not allowed for a normal 'for' statement", "Remove the keyword or use a for-each statement.");
  static const ParserErrorCode INVALID_CODE_POINT = const ParserErrorCode.A_con3('INVALID_CODE_POINT', 67, "The escape sequence '%s' is not a valid code point");
  static const ParserErrorCode INVALID_HEX_ESCAPE = const ParserErrorCode.A_con3('INVALID_HEX_ESCAPE', 69, "An escape sequence starting with '\\x' must be followed by 2 hexidecimal digits");
  static const ParserErrorCode INVALID_OPERATOR = const ParserErrorCode.A_con3('INVALID_OPERATOR', 70, "The string '%s' is not a valid operator");
  static const ParserErrorCode INVALID_OPERATOR_FOR_SUPER = const ParserErrorCode.A_con3('INVALID_OPERATOR_FOR_SUPER', 71, "The operator '%s' cannot be used with 'super'");
  static const ParserErrorCode INVALID_STAR_AFTER_ASYNC = const ParserErrorCode.con4('INVALID_STAR_AFTER_ASYNC', 72, "The modifier 'async*' is not allowed for an expression function body", "Convert the body to a block.");
  static const ParserErrorCode INVALID_SYNC = const ParserErrorCode.con4('INVALID_SYNC', 73, "The modifier 'sync' is not allowed for an exrpression function body", "Convert the body to a block.");
  static const ParserErrorCode INVALID_UNICODE_ESCAPE = const ParserErrorCode.A_con3('INVALID_UNICODE_ESCAPE', 74, "An escape sequence starting with '\\u' must be followed by 4 hexidecimal digits or from 1 to 6 digits between '{' and '}'");
  static const ParserErrorCode LIBRARY_DIRECTIVE_NOT_FIRST = const ParserErrorCode.A_con3('LIBRARY_DIRECTIVE_NOT_FIRST', 75, "The library directive must appear before all other directives");
  static const ParserErrorCode LOCAL_FUNCTION_DECLARATION_MODIFIER = const ParserErrorCode.A_con3('LOCAL_FUNCTION_DECLARATION_MODIFIER', 76, "Local function declarations cannot specify any modifier");
  static const ParserErrorCode MISSING_ASSIGNABLE_SELECTOR = const ParserErrorCode.A_con3('MISSING_ASSIGNABLE_SELECTOR', 77, "Missing selector such as \".<identifier>\" or \"[0]\"");
  static const ParserErrorCode MISSING_CATCH_OR_FINALLY = const ParserErrorCode.A_con3('MISSING_CATCH_OR_FINALLY', 78, "A try statement must have either a catch or finally clause");
  static const ParserErrorCode MISSING_CLASS_BODY = const ParserErrorCode.A_con3('MISSING_CLASS_BODY', 79, "A class definition must have a body, even if it is empty");
  static const ParserErrorCode MISSING_CLOSING_PARENTHESIS = const ParserErrorCode.A_con3('MISSING_CLOSING_PARENTHESIS', 80, "The closing parenthesis is missing");
  static const ParserErrorCode MISSING_CONST_FINAL_VAR_OR_TYPE = const ParserErrorCode.A_con3('MISSING_CONST_FINAL_VAR_OR_TYPE', 81, "Variables must be declared using the keywords 'const', 'final', 'var' or a type name");
  static const ParserErrorCode MISSING_ENUM_BODY = const ParserErrorCode.A_con3('MISSING_ENUM_BODY', 82, "An enum definition must have a body with at least one constant name");
  static const ParserErrorCode MISSING_EXPRESSION_IN_THROW = const ParserErrorCode.A_con3('MISSING_EXPRESSION_IN_THROW', 83, "Throw expressions must compute the object to be thrown");
  static const ParserErrorCode MISSING_FUNCTION_BODY = const ParserErrorCode.A_con3('MISSING_FUNCTION_BODY', 84, "A function body must be provided");
  static const ParserErrorCode MISSING_FUNCTION_PARAMETERS = const ParserErrorCode.A_con3('MISSING_FUNCTION_PARAMETERS', 85, "Functions must have an explicit list of parameters");
  static const ParserErrorCode MISSING_GET = const ParserErrorCode.A_con3('MISSING_GET', 86, "Getters must have the keyword 'get' before the getter name");
  static const ParserErrorCode MISSING_IDENTIFIER = const ParserErrorCode.A_con3('MISSING_IDENTIFIER', 87, "Expected an identifier");
  static const ParserErrorCode MISSING_KEYWORD_OPERATOR = const ParserErrorCode.A_con3('MISSING_KEYWORD_OPERATOR', 88, "Operator declarations must be preceeded by the keyword 'operator'");
  static const ParserErrorCode MISSING_NAME_IN_LIBRARY_DIRECTIVE = const ParserErrorCode.A_con3('MISSING_NAME_IN_LIBRARY_DIRECTIVE', 89, "Library directives must include a library name");
  static const ParserErrorCode MISSING_NAME_IN_PART_OF_DIRECTIVE = const ParserErrorCode.A_con3('MISSING_NAME_IN_PART_OF_DIRECTIVE', 90, "Library directives must include a library name");
  static const ParserErrorCode MISSING_PREFIX_IN_DEFERRED_IMPORT = const ParserErrorCode.A_con3('MISSING_PREFIX_IN_DEFERRED_IMPORT', 91, "Deferred imports must have a prefix");
  static const ParserErrorCode MISSING_STAR_AFTER_SYNC = const ParserErrorCode.con4('MISSING_STAR_AFTER_SYNC', 92, "The modifier 'sync' must be followed by a star ('*')", "Remove the modifier or add a star.");
  static const ParserErrorCode MISSING_STATEMENT = const ParserErrorCode.A_con3('MISSING_STATEMENT', 93, "Expected a statement");
  static const ParserErrorCode MISSING_TERMINATOR_FOR_PARAMETER_GROUP = const ParserErrorCode.A_con3('MISSING_TERMINATOR_FOR_PARAMETER_GROUP', 94, "There is no '%s' to close the parameter group");
  static const ParserErrorCode MISSING_TYPEDEF_PARAMETERS = const ParserErrorCode.A_con3('MISSING_TYPEDEF_PARAMETERS', 95, "Type aliases for functions must have an explicit list of parameters");
  static const ParserErrorCode MISSING_VARIABLE_IN_FOR_EACH = const ParserErrorCode.A_con3('MISSING_VARIABLE_IN_FOR_EACH', 96, "A loop variable must be declared in a for-each loop before the 'in', but none were found");
  static const ParserErrorCode MIXED_PARAMETER_GROUPS = const ParserErrorCode.A_con3('MIXED_PARAMETER_GROUPS', 97, "Cannot have both positional and named parameters in a single parameter list");
  static const ParserErrorCode MULTIPLE_EXTENDS_CLAUSES = const ParserErrorCode.A_con3('MULTIPLE_EXTENDS_CLAUSES', 98, "Each class definition can have at most one extends clause");
  static const ParserErrorCode MULTIPLE_IMPLEMENTS_CLAUSES = const ParserErrorCode.A_con3('MULTIPLE_IMPLEMENTS_CLAUSES', 99, "Each class definition can have at most one implements clause");
  static const ParserErrorCode MULTIPLE_LIBRARY_DIRECTIVES = const ParserErrorCode.A_con3('MULTIPLE_LIBRARY_DIRECTIVES', 100, "Only one library directive may be declared in a file");
  static const ParserErrorCode MULTIPLE_NAMED_PARAMETER_GROUPS = const ParserErrorCode.A_con3('MULTIPLE_NAMED_PARAMETER_GROUPS', 101, "Cannot have multiple groups of named parameters in a single parameter list");
  static const ParserErrorCode MULTIPLE_PART_OF_DIRECTIVES = const ParserErrorCode.A_con3('MULTIPLE_PART_OF_DIRECTIVES', 102, "Only one part-of directive may be declared in a file");
  static const ParserErrorCode MULTIPLE_POSITIONAL_PARAMETER_GROUPS = const ParserErrorCode.A_con3('MULTIPLE_POSITIONAL_PARAMETER_GROUPS', 103, "Cannot have multiple groups of positional parameters in a single parameter list");
  static const ParserErrorCode MULTIPLE_VARIABLES_IN_FOR_EACH = const ParserErrorCode.A_con3('MULTIPLE_VARIABLES_IN_FOR_EACH', 104, "A single loop variable must be declared in a for-each loop before the 'in', but %s were found");
  static const ParserErrorCode MULTIPLE_WITH_CLAUSES = const ParserErrorCode.A_con3('MULTIPLE_WITH_CLAUSES', 105, "Each class definition can have at most one with clause");
  static const ParserErrorCode NAMED_PARAMETER_OUTSIDE_GROUP = const ParserErrorCode.A_con3('NAMED_PARAMETER_OUTSIDE_GROUP', 107, "Named parameters must be enclosed in curly braces ('{' and '}')");
  static const ParserErrorCode NATIVE_CLAUSE_IN_NON_SDK_CODE = const ParserErrorCode.A_con3('NATIVE_CLAUSE_IN_NON_SDK_CODE', 108, "Native clause can only be used in the SDK and code that is loaded through native extensions");
  static const ParserErrorCode NATIVE_FUNCTION_BODY_IN_NON_SDK_CODE = const ParserErrorCode.A_con3('NATIVE_FUNCTION_BODY_IN_NON_SDK_CODE', 109, "Native functions can only be declared in the SDK and code that is loaded through native extensions");
  static const ParserErrorCode NON_CONSTRUCTOR_FACTORY = const ParserErrorCode.A_con3('NON_CONSTRUCTOR_FACTORY', 110, "Only constructors can be declared to be a 'factory'");
  static const ParserErrorCode NON_IDENTIFIER_LIBRARY_NAME = const ParserErrorCode.A_con3('NON_IDENTIFIER_LIBRARY_NAME', 111, "The name of a library must be an identifier");
  static const ParserErrorCode NON_PART_OF_DIRECTIVE_IN_PART = const ParserErrorCode.A_con3('NON_PART_OF_DIRECTIVE_IN_PART', 112, "The part-of directive must be the only directive in a part");
  static const ParserErrorCode NON_USER_DEFINABLE_OPERATOR = const ParserErrorCode.A_con3('NON_USER_DEFINABLE_OPERATOR', 113, "The operator '%s' is not user definable");
  static const ParserErrorCode NORMAL_BEFORE_OPTIONAL_PARAMETERS = const ParserErrorCode.A_con3('NORMAL_BEFORE_OPTIONAL_PARAMETERS', 114, "Normal parameters must occur before optional parameters");
  static const ParserErrorCode POSITIONAL_AFTER_NAMED_ARGUMENT = const ParserErrorCode.A_con3('POSITIONAL_AFTER_NAMED_ARGUMENT', 115, "Positional arguments must occur before named arguments");
  static const ParserErrorCode POSITIONAL_PARAMETER_OUTSIDE_GROUP = const ParserErrorCode.A_con3('POSITIONAL_PARAMETER_OUTSIDE_GROUP', 116, "Positional parameters must be enclosed in square brackets ('[' and ']')");
  static const ParserErrorCode REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR = const ParserErrorCode.A_con3('REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR', 117, "Only factory constructor can specify '=' redirection.");
  static const ParserErrorCode SETTER_IN_FUNCTION = const ParserErrorCode.A_con3('SETTER_IN_FUNCTION', 118, "Setters cannot be defined within methods or functions");
  static const ParserErrorCode STATIC_AFTER_CONST = const ParserErrorCode.A_con3('STATIC_AFTER_CONST', 119, "The modifier 'static' should be before the modifier 'const'");
  static const ParserErrorCode STATIC_AFTER_FINAL = const ParserErrorCode.A_con3('STATIC_AFTER_FINAL', 120, "The modifier 'static' should be before the modifier 'final'");
  static const ParserErrorCode STATIC_AFTER_VAR = const ParserErrorCode.A_con3('STATIC_AFTER_VAR', 121, "The modifier 'static' should be before the modifier 'var'");
  static const ParserErrorCode STATIC_CONSTRUCTOR = const ParserErrorCode.A_con3('STATIC_CONSTRUCTOR', 122, "Constructors cannot be static");
  static const ParserErrorCode STATIC_GETTER_WITHOUT_BODY = const ParserErrorCode.A_con3('STATIC_GETTER_WITHOUT_BODY', 123, "A 'static' getter must have a body");
  static const ParserErrorCode STATIC_OPERATOR = const ParserErrorCode.A_con3('STATIC_OPERATOR', 124, "Operators cannot be static");
  static const ParserErrorCode STATIC_SETTER_WITHOUT_BODY = const ParserErrorCode.A_con3('STATIC_SETTER_WITHOUT_BODY', 125, "A 'static' setter must have a body");
  static const ParserErrorCode STATIC_TOP_LEVEL_DECLARATION = const ParserErrorCode.A_con3('STATIC_TOP_LEVEL_DECLARATION', 126, "Top-level declarations cannot be declared to be 'static'");
  static const ParserErrorCode SWITCH_HAS_CASE_AFTER_DEFAULT_CASE = const ParserErrorCode.A_con3('SWITCH_HAS_CASE_AFTER_DEFAULT_CASE', 127, "The 'default' case should be the last case in a switch statement");
  static const ParserErrorCode SWITCH_HAS_MULTIPLE_DEFAULT_CASES = const ParserErrorCode.A_con3('SWITCH_HAS_MULTIPLE_DEFAULT_CASES', 128, "The 'default' case can only be declared once");
  static const ParserErrorCode TOP_LEVEL_OPERATOR = const ParserErrorCode.A_con3('TOP_LEVEL_OPERATOR', 129, "Operators must be declared within a class");
  static const ParserErrorCode UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP = const ParserErrorCode.A_con3('UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP', 130, "There is no '%s' to open a parameter group");
  static const ParserErrorCode UNEXPECTED_TOKEN = const ParserErrorCode.A_con3('UNEXPECTED_TOKEN', 131, "Unexpected token '%s'");
  static const ParserErrorCode WITH_BEFORE_EXTENDS = const ParserErrorCode.A_con3('WITH_BEFORE_EXTENDS', 132, "The extends clause must be before the with clause");
  static const ParserErrorCode WITH_WITHOUT_EXTENDS = const ParserErrorCode.A_con3('WITH_WITHOUT_EXTENDS', 133, "The with clause cannot be used without an extends clause");
  static const ParserErrorCode WRONG_SEPARATOR_FOR_NAMED_PARAMETER = const ParserErrorCode.A_con3('WRONG_SEPARATOR_FOR_NAMED_PARAMETER', 134, "The default value of a named parameter should be preceeded by ':'");
  static const ParserErrorCode WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER = const ParserErrorCode.A_con3('WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER', 135, "The default value of a positional parameter should be preceeded by '='");
  static const ParserErrorCode WRONG_TERMINATOR_FOR_PARAMETER_GROUP = const ParserErrorCode.A_con3('WRONG_TERMINATOR_FOR_PARAMETER_GROUP', 136, "Expected '%s' to close parameter group");
  static const ParserErrorCode VAR_AND_TYPE = const ParserErrorCode.A_con3('VAR_AND_TYPE', 137, "Variables cannot be declared using both 'var' and a type name; remove the 'var'");
  static const ParserErrorCode VAR_AS_TYPE_NAME = const ParserErrorCode.A_con3('VAR_AS_TYPE_NAME', 138, "The keyword 'var' cannot be used as a type name");
  static const ParserErrorCode VAR_CLASS = const ParserErrorCode.A_con3('VAR_CLASS', 139, "Classes cannot be declared to be 'var'");
  static const ParserErrorCode VAR_ENUM = const ParserErrorCode.A_con3('VAR_ENUM', 140, "Enums cannot be declared to be 'var'");
  static const ParserErrorCode VAR_RETURN_TYPE = const ParserErrorCode.A_con3('VAR_RETURN_TYPE', 141, "The return type cannot be 'var'");
  static const ParserErrorCode VAR_TYPEDEF = const ParserErrorCode.A_con3('VAR_TYPEDEF', 142, "Type aliases cannot be declared to be 'var'");
  static const ParserErrorCode VOID_PARAMETER = const ParserErrorCode.A_con3('VOID_PARAMETER', 143, "Parameters cannot have a type of 'void'");
  static const ParserErrorCode VOID_VARIABLE = const ParserErrorCode.A_con3('VOID_VARIABLE', 144, "Variables cannot have a type of 'void'");
  final ErrorSeverity errorSeverity;
  final String message;
  final String correction;
  const ParserErrorCode.F_con2(String A_name, int ordinal, this.errorSeverity, this.message, this.correction) : super(A_name, ordinal);
  const ParserErrorCode.A_con3(String A_name, int ordinal, String A_message) : this.F_con2(A_name, ordinal, ErrorSeverity.D_ERROR, A_message, null);
  const ParserErrorCode.con4(String A_name, int ordinal, String A_message, String A_correction) : this.F_con2(A_name, ordinal, ErrorSeverity.D_ERROR, A_message, A_correction);
  ErrorType get type => ErrorType.SYNTACTIC_ERROR;
}
class Parser_SyntheticKeywordToken extends KeywordToken {
  Parser_SyntheticKeywordToken(Keyword keyword, int A_offset) : super(keyword, A_offset);
  A_Token copy() => new Parser_SyntheticKeywordToken(keyword, offset);
  int get length => 0;
}
class ResolutionCopier implements AstVisitor<bool> {
  static void copyResolutionData(AstNode fromNode, AstNode toNode) {
    ResolutionCopier copier = new ResolutionCopier();
    copier.A__isEqualNodes(fromNode, toNode);
  }
  AstNode _toNode;
  bool visitAdjacentStrings(AdjacentStrings node) {
    AdjacentStrings toNode = this._toNode as AdjacentStrings;
    return A__isEqualNodeLists(node.strings, toNode.strings);
  }
  bool visitAnnotation(Annotation node) {
    Annotation toNode = this._toNode as Annotation;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.atSign, toNode.atSign), A__isEqualNodes(node.name, toNode.name)), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.constructorName, toNode.constructorName)), A__isEqualNodes(node.arguments, toNode.arguments))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitArgumentList(ArgumentList node) {
    ArgumentList toNode = this._toNode as ArgumentList;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis), A__isEqualNodeLists(node.arguments, toNode.arguments)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis));
  }
  bool visitAsExpression(AsExpression node) {
    AsExpression toNode = this._toNode as AsExpression;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.expression, toNode.expression), A__isEqualTokens(node.asOperator, toNode.asOperator)), A__isEqualNodes(node.type, toNode.type))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitAssertStatement(AssertStatement node) {
    AssertStatement toNode = this._toNode as AssertStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.condition, toNode.condition)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitAssignmentExpression(AssignmentExpression node) {
    AssignmentExpression toNode = this._toNode as AssignmentExpression;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.leftHandSide, toNode.leftHandSide), A__isEqualTokens(node.operator, toNode.operator)), A__isEqualNodes(node.rightHandSide, toNode.rightHandSide))) {
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitAwaitExpression(AwaitExpression node) {
    AwaitExpression toNode = this._toNode as AwaitExpression;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.awaitKeyword, toNode.awaitKeyword), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitBinaryExpression(BinaryExpression node) {
    BinaryExpression toNode = this._toNode as BinaryExpression;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.leftOperand, toNode.leftOperand), A__isEqualTokens(node.operator, toNode.operator)), A__isEqualNodes(node.rightOperand, toNode.rightOperand))) {
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitBlock(Block node) {
    Block toNode = this._toNode as Block;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftBracket, toNode.leftBracket), A__isEqualNodeLists(node.statements, toNode.statements)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitBlockFunctionBody(BlockFunctionBody node) {
    BlockFunctionBody toNode = this._toNode as BlockFunctionBody;
    return A__isEqualNodes(node.block, toNode.block);
  }
  bool visitBooleanLiteral(BooleanLiteral node) {
    BooleanLiteral toNode = this._toNode as BooleanLiteral;
    if (javaBooleanAnd(A__isEqualTokens(node.literal, toNode.literal), node.value == toNode.value)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitBreakStatement(BreakStatement node) {
    BreakStatement toNode = this._toNode as BreakStatement;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.label, toNode.label)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitCascadeExpression(CascadeExpression node) {
    CascadeExpression toNode = this._toNode as CascadeExpression;
    if (javaBooleanAnd(A__isEqualNodes(node.target, toNode.target), A__isEqualNodeLists(node.cascadeSections, toNode.cascadeSections))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitCatchClause(CatchClause node) {
    CatchClause toNode = this._toNode as CatchClause;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.onKeyword, toNode.onKeyword), A__isEqualNodes(node.exceptionType, toNode.exceptionType)), A__isEqualTokens(node.catchKeyword, toNode.catchKeyword)), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.exceptionParameter, toNode.exceptionParameter)), A__isEqualTokens(node.comma, toNode.comma)), A__isEqualNodes(node.stackTraceParameter, toNode.stackTraceParameter)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualNodes(node.body, toNode.body));
  }
  bool visitClassDeclaration(ClassDeclaration node) {
    ClassDeclaration toNode = this._toNode as ClassDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.abstractKeyword, toNode.abstractKeyword)), A__isEqualTokens(node.classKeyword, toNode.classKeyword)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.typeParameters, toNode.typeParameters)), A__isEqualNodes(node.extendsClause, toNode.extendsClause)), A__isEqualNodes(node.withClause, toNode.withClause)), A__isEqualNodes(node.implementsClause, toNode.implementsClause)), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodeLists(node.members, toNode.members)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitClassTypeAlias(ClassTypeAlias node) {
    ClassTypeAlias toNode = this._toNode as ClassTypeAlias;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.typeParameters, toNode.typeParameters)), A__isEqualTokens(node.A_equals, toNode.A_equals)), A__isEqualTokens(node.abstractKeyword, toNode.abstractKeyword)), A__isEqualNodes(node.superclass, toNode.superclass)), A__isEqualNodes(node.withClause, toNode.withClause)), A__isEqualNodes(node.implementsClause, toNode.implementsClause)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitComment(Comment node) {
    Comment toNode = this._toNode as Comment;
    return A__isEqualNodeLists(node.references, toNode.references);
  }
  bool visitCommentReference(CommentReference node) {
    CommentReference toNode = this._toNode as CommentReference;
    return javaBooleanAnd(A__isEqualTokens(node.newKeyword, toNode.newKeyword), A__isEqualNodes(node.identifier, toNode.identifier));
  }
  bool visitCompilationUnit(CompilationUnit node) {
    CompilationUnit toNode = this._toNode as CompilationUnit;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.beginToken, toNode.beginToken), A__isEqualNodes(node.scriptTag, toNode.scriptTag)), A__isEqualNodeLists(node.directives, toNode.directives)), A__isEqualNodeLists(node.declarations, toNode.declarations)), A__isEqualTokens(node.endToken, toNode.endToken))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitConditionalExpression(ConditionalExpression node) {
    ConditionalExpression toNode = this._toNode as ConditionalExpression;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.condition, toNode.condition), A__isEqualTokens(node.question, toNode.question)), A__isEqualNodes(node.thenExpression, toNode.thenExpression)), A__isEqualTokens(node.colon, toNode.colon)), A__isEqualNodes(node.elseExpression, toNode.elseExpression))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitConstructorDeclaration(ConstructorDeclaration node) {
    ConstructorDeclaration toNode = this._toNode as ConstructorDeclaration;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.externalKeyword, toNode.externalKeyword)), A__isEqualTokens(node.constKeyword, toNode.constKeyword)), A__isEqualTokens(node.factoryKeyword, toNode.factoryKeyword)), A__isEqualNodes(node.returnType, toNode.returnType)), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.parameters, toNode.parameters)), A__isEqualTokens(node.A_separator, toNode.A_separator)), A__isEqualNodeLists(node.initializers, toNode.initializers)), A__isEqualNodes(node.redirectedConstructor, toNode.redirectedConstructor)), A__isEqualNodes(node.body, toNode.body))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    ConstructorFieldInitializer toNode = this._toNode as ConstructorFieldInitializer;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.fieldName, toNode.fieldName)), A__isEqualTokens(node.A_equals, toNode.A_equals)), A__isEqualNodes(node.expression, toNode.expression));
  }
  bool visitConstructorName(ConstructorName node) {
    ConstructorName toNode = this._toNode as ConstructorName;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.type, toNode.type), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.name, toNode.name))) {
      toNode.staticElement = node.staticElement;
      return true;
    }
    return false;
  }
  bool visitContinueStatement(ContinueStatement node) {
    ContinueStatement toNode = this._toNode as ContinueStatement;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.label, toNode.label)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitDeclaredIdentifier(DeclaredIdentifier node) {
    DeclaredIdentifier toNode = this._toNode as DeclaredIdentifier;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.type, toNode.type)), A__isEqualNodes(node.identifier, toNode.identifier));
  }
  bool visitDefaultFormalParameter(DefaultFormalParameter node) {
    DefaultFormalParameter toNode = this._toNode as DefaultFormalParameter;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.parameter, toNode.parameter), node.kind == toNode.kind), A__isEqualTokens(node.A_separator, toNode.A_separator)), A__isEqualNodes(node.defaultValue, toNode.defaultValue));
  }
  bool visitDoStatement(DoStatement node) {
    DoStatement toNode = this._toNode as DoStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.doKeyword, toNode.doKeyword), A__isEqualNodes(node.body, toNode.body)), A__isEqualTokens(node.whileKeyword, toNode.whileKeyword)), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.condition, toNode.condition)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitDoubleLiteral(DoubleLiteral node) {
    DoubleLiteral toNode = this._toNode as DoubleLiteral;
    if (javaBooleanAnd(A__isEqualTokens(node.literal, toNode.literal), node.value == toNode.value)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitEmptyFunctionBody(EmptyFunctionBody node) {
    EmptyFunctionBody toNode = this._toNode as EmptyFunctionBody;
    return A__isEqualTokens(node.semicolon, toNode.semicolon);
  }
  bool visitEmptyStatement(EmptyStatement node) {
    EmptyStatement toNode = this._toNode as EmptyStatement;
    return A__isEqualTokens(node.semicolon, toNode.semicolon);
  }
  bool visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    EnumConstantDeclaration toNode = this._toNode as EnumConstantDeclaration;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualNodes(node.name, toNode.name));
  }
  bool visitEnumDeclaration(EnumDeclaration node) {
    EnumDeclaration toNode = this._toNode as EnumDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.name, toNode.name)), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodeLists(node.constants, toNode.constants)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitExportDirective(ExportDirective node) {
    ExportDirective toNode = this._toNode as ExportDirective;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.uri, toNode.uri)), A__isEqualNodeLists(node.combinators, toNode.combinators)), A__isEqualTokens(node.semicolon, toNode.semicolon))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitExpressionFunctionBody(ExpressionFunctionBody node) {
    ExpressionFunctionBody toNode = this._toNode as ExpressionFunctionBody;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.functionDefinition, toNode.functionDefinition), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitExpressionStatement(ExpressionStatement node) {
    ExpressionStatement toNode = this._toNode as ExpressionStatement;
    return javaBooleanAnd(A__isEqualNodes(node.expression, toNode.expression), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitExtendsClause(ExtendsClause node) {
    ExtendsClause toNode = this._toNode as ExtendsClause;
    return javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.superclass, toNode.superclass));
  }
  bool visitFieldDeclaration(FieldDeclaration node) {
    FieldDeclaration toNode = this._toNode as FieldDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.staticKeyword, toNode.staticKeyword)), A__isEqualNodes(node.fields, toNode.fields)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitFieldFormalParameter(FieldFormalParameter node) {
    FieldFormalParameter toNode = this._toNode as FieldFormalParameter;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.type, toNode.type)), A__isEqualTokens(node.thisToken, toNode.thisToken)), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.identifier, toNode.identifier));
  }
  bool visitForEachStatement(ForEachStatement node) {
    ForEachStatement toNode = this._toNode as ForEachStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.forKeyword, toNode.forKeyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.loopVariable, toNode.loopVariable)), A__isEqualTokens(node.inKeyword, toNode.inKeyword)), A__isEqualNodes(node.iterator, toNode.iterator)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualNodes(node.body, toNode.body));
  }
  bool visitFormalParameterList(FormalParameterList node) {
    FormalParameterList toNode = this._toNode as FormalParameterList;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis), A__isEqualNodeLists(node.parameters, toNode.parameters)), A__isEqualTokens(node.leftDelimiter, toNode.leftDelimiter)), A__isEqualTokens(node.rightDelimiter, toNode.rightDelimiter)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis));
  }
  bool visitForStatement(ForStatement node) {
    ForStatement toNode = this._toNode as ForStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.forKeyword, toNode.forKeyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.variables, toNode.variables)), A__isEqualNodes(node.initialization, toNode.initialization)), A__isEqualTokens(node.leftSeparator, toNode.leftSeparator)), A__isEqualNodes(node.condition, toNode.condition)), A__isEqualTokens(node.rightSeparator, toNode.rightSeparator)), A__isEqualNodeLists(node.updaters, toNode.updaters)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualNodes(node.body, toNode.body));
  }
  bool visitFunctionDeclaration(FunctionDeclaration node) {
    FunctionDeclaration toNode = this._toNode as FunctionDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.externalKeyword, toNode.externalKeyword)), A__isEqualNodes(node.returnType, toNode.returnType)), A__isEqualTokens(node.propertyKeyword, toNode.propertyKeyword)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.functionExpression, toNode.functionExpression));
  }
  bool visitFunctionDeclarationStatement(FunctionDeclarationStatement node) {
    FunctionDeclarationStatement toNode = this._toNode as FunctionDeclarationStatement;
    return A__isEqualNodes(node.functionDeclaration, toNode.functionDeclaration);
  }
  bool visitFunctionExpression(FunctionExpression node) {
    FunctionExpression toNode = this._toNode as FunctionExpression;
    if (javaBooleanAnd(A__isEqualNodes(node.parameters, toNode.parameters), A__isEqualNodes(node.body, toNode.body))) {
      toNode.element = node.element;
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    FunctionExpressionInvocation toNode = this._toNode as FunctionExpressionInvocation;
    if (javaBooleanAnd(A__isEqualNodes(node.function, toNode.function), A__isEqualNodes(node.argumentList, toNode.argumentList))) {
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitFunctionTypeAlias(FunctionTypeAlias node) {
    FunctionTypeAlias toNode = this._toNode as FunctionTypeAlias;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.returnType, toNode.returnType)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.typeParameters, toNode.typeParameters)), A__isEqualNodes(node.parameters, toNode.parameters)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    FunctionTypedFormalParameter toNode = this._toNode as FunctionTypedFormalParameter;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualNodes(node.returnType, toNode.returnType)), A__isEqualNodes(node.identifier, toNode.identifier)), A__isEqualNodes(node.parameters, toNode.parameters));
  }
  bool visitHideCombinator(HideCombinator node) {
    HideCombinator toNode = this._toNode as HideCombinator;
    return javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodeLists(node.hiddenNames, toNode.hiddenNames));
  }
  bool visitIfStatement(IfStatement node) {
    IfStatement toNode = this._toNode as IfStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.ifKeyword, toNode.ifKeyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.condition, toNode.condition)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualNodes(node.thenStatement, toNode.thenStatement)), A__isEqualTokens(node.elseKeyword, toNode.elseKeyword)), A__isEqualNodes(node.elseStatement, toNode.elseStatement));
  }
  bool visitImplementsClause(ImplementsClause node) {
    ImplementsClause toNode = this._toNode as ImplementsClause;
    return javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodeLists(node.interfaces, toNode.interfaces));
  }
  bool visitImportDirective(ImportDirective node) {
    ImportDirective toNode = this._toNode as ImportDirective;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.uri, toNode.uri)), A__isEqualTokens(node.asToken, toNode.asToken)), A__isEqualNodes(node.prefix, toNode.prefix)), A__isEqualNodeLists(node.combinators, toNode.combinators)), A__isEqualTokens(node.semicolon, toNode.semicolon))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitIndexExpression(IndexExpression node) {
    IndexExpression toNode = this._toNode as IndexExpression;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.target, toNode.target), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodes(node.index, toNode.index)), A__isEqualTokens(node.rightBracket, toNode.rightBracket))) {
      toNode.auxiliaryElements = node.auxiliaryElements;
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitInstanceCreationExpression(InstanceCreationExpression node) {
    InstanceCreationExpression toNode = this._toNode as InstanceCreationExpression;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.constructorName, toNode.constructorName)), A__isEqualNodes(node.argumentList, toNode.argumentList))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitIntegerLiteral(IntegerLiteral node) {
    IntegerLiteral toNode = this._toNode as IntegerLiteral;
    if (javaBooleanAnd(A__isEqualTokens(node.literal, toNode.literal), identical(node.value, toNode.value))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitInterpolationExpression(InterpolationExpression node) {
    InterpolationExpression toNode = this._toNode as InterpolationExpression;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftBracket, toNode.leftBracket), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitInterpolationString(InterpolationString node) {
    InterpolationString toNode = this._toNode as InterpolationString;
    return javaBooleanAnd(A__isEqualTokens(node.contents, toNode.contents), node.value == toNode.value);
  }
  bool visitIsExpression(IsExpression node) {
    IsExpression toNode = this._toNode as IsExpression;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.expression, toNode.expression), A__isEqualTokens(node.isOperator, toNode.isOperator)), A__isEqualTokens(node.notOperator, toNode.notOperator)), A__isEqualNodes(node.type, toNode.type))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitLabel(Label node) {
    Label toNode = this._toNode as Label;
    return javaBooleanAnd(A__isEqualNodes(node.label, toNode.label), A__isEqualTokens(node.colon, toNode.colon));
  }
  bool visitLabeledStatement(LabeledStatement node) {
    LabeledStatement toNode = this._toNode as LabeledStatement;
    return javaBooleanAnd(A__isEqualNodeLists(node.labels, toNode.labels), A__isEqualNodes(node.statement, toNode.statement));
  }
  bool visitLibraryDirective(LibraryDirective node) {
    LibraryDirective toNode = this._toNode as LibraryDirective;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.libraryToken, toNode.libraryToken)), A__isEqualNodes(node.name, toNode.name)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitLibraryIdentifier(LibraryIdentifier node) {
    LibraryIdentifier toNode = this._toNode as LibraryIdentifier;
    if (A__isEqualNodeLists(node.components, toNode.components)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitListLiteral(ListLiteral node) {
    ListLiteral toNode = this._toNode as ListLiteral;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.constKeyword, toNode.constKeyword), A__isEqualNodes(node.typeArguments, toNode.typeArguments)), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodeLists(node.elements, toNode.elements)), A__isEqualTokens(node.rightBracket, toNode.rightBracket))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitMapLiteral(MapLiteral node) {
    MapLiteral toNode = this._toNode as MapLiteral;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.constKeyword, toNode.constKeyword), A__isEqualNodes(node.typeArguments, toNode.typeArguments)), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodeLists(node.entries, toNode.entries)), A__isEqualTokens(node.rightBracket, toNode.rightBracket))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitMapLiteralEntry(MapLiteralEntry node) {
    MapLiteralEntry toNode = this._toNode as MapLiteralEntry;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.key, toNode.key), A__isEqualTokens(node.A_separator, toNode.A_separator)), A__isEqualNodes(node.value, toNode.value));
  }
  bool visitMethodDeclaration(MethodDeclaration node) {
    MethodDeclaration toNode = this._toNode as MethodDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.externalKeyword, toNode.externalKeyword)), A__isEqualTokens(node.modifierKeyword, toNode.modifierKeyword)), A__isEqualNodes(node.returnType, toNode.returnType)), A__isEqualTokens(node.propertyKeyword, toNode.propertyKeyword)), A__isEqualTokens(node.propertyKeyword, toNode.propertyKeyword)), A__isEqualNodes(node.name, toNode.name)), A__isEqualNodes(node.parameters, toNode.parameters)), A__isEqualNodes(node.body, toNode.body));
  }
  bool visitMethodInvocation(MethodInvocation node) {
    MethodInvocation toNode = this._toNode as MethodInvocation;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.target, toNode.target), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.methodName, toNode.methodName)), A__isEqualNodes(node.argumentList, toNode.argumentList))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitNamedExpression(NamedExpression node) {
    NamedExpression toNode = this._toNode as NamedExpression;
    if (javaBooleanAnd(A__isEqualNodes(node.name, toNode.name), A__isEqualNodes(node.expression, toNode.expression))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitNativeClause(NativeClause node) {
    NativeClause toNode = this._toNode as NativeClause;
    return javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.name, toNode.name));
  }
  bool visitNativeFunctionBody(NativeFunctionBody node) {
    NativeFunctionBody toNode = this._toNode as NativeFunctionBody;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.nativeToken, toNode.nativeToken), A__isEqualNodes(node.stringLiteral, toNode.stringLiteral)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitNullLiteral(NullLiteral node) {
    NullLiteral toNode = this._toNode as NullLiteral;
    if (A__isEqualTokens(node.literal, toNode.literal)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitParenthesizedExpression(ParenthesizedExpression node) {
    ParenthesizedExpression toNode = this._toNode as ParenthesizedExpression;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitPartDirective(PartDirective node) {
    PartDirective toNode = this._toNode as PartDirective;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.partToken, toNode.partToken)), A__isEqualNodes(node.uri, toNode.uri)), A__isEqualTokens(node.semicolon, toNode.semicolon))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitPartOfDirective(PartOfDirective node) {
    PartOfDirective toNode = this._toNode as PartOfDirective;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.partToken, toNode.partToken)), A__isEqualTokens(node.ofToken, toNode.ofToken)), A__isEqualNodes(node.libraryName, toNode.libraryName)), A__isEqualTokens(node.semicolon, toNode.semicolon))) {
      toNode.element = node.element;
      return true;
    }
    return false;
  }
  bool visitPostfixExpression(PostfixExpression node) {
    PostfixExpression toNode = this._toNode as PostfixExpression;
    if (javaBooleanAnd(A__isEqualNodes(node.operand, toNode.operand), A__isEqualTokens(node.operator, toNode.operator))) {
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitPrefixedIdentifier(PrefixedIdentifier node) {
    PrefixedIdentifier toNode = this._toNode as PrefixedIdentifier;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.prefix, toNode.prefix), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.identifier, toNode.identifier))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitPrefixExpression(PrefixExpression node) {
    PrefixExpression toNode = this._toNode as PrefixExpression;
    if (javaBooleanAnd(A__isEqualTokens(node.operator, toNode.operator), A__isEqualNodes(node.operand, toNode.operand))) {
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitPropertyAccess(PropertyAccess node) {
    PropertyAccess toNode = this._toNode as PropertyAccess;
    if (javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.target, toNode.target), A__isEqualTokens(node.operator, toNode.operator)), A__isEqualNodes(node.propertyName, toNode.propertyName))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    RedirectingConstructorInvocation toNode = this._toNode as RedirectingConstructorInvocation;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.constructorName, toNode.constructorName)), A__isEqualNodes(node.argumentList, toNode.argumentList))) {
      toNode.staticElement = node.staticElement;
      return true;
    }
    return false;
  }
  bool visitRethrowExpression(RethrowExpression node) {
    RethrowExpression toNode = this._toNode as RethrowExpression;
    if (A__isEqualTokens(node.keyword, toNode.keyword)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitReturnStatement(ReturnStatement node) {
    ReturnStatement toNode = this._toNode as ReturnStatement;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitScriptTag(ScriptTag node) {
    ScriptTag toNode = this._toNode as ScriptTag;
    return A__isEqualTokens(node.scriptTag, toNode.scriptTag);
  }
  bool visitShowCombinator(ShowCombinator node) {
    ShowCombinator toNode = this._toNode as ShowCombinator;
    return javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodeLists(node.shownNames, toNode.shownNames));
  }
  bool visitSimpleFormalParameter(SimpleFormalParameter node) {
    SimpleFormalParameter toNode = this._toNode as SimpleFormalParameter;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.type, toNode.type)), A__isEqualNodes(node.identifier, toNode.identifier));
  }
  bool visitSimpleIdentifier(SimpleIdentifier node) {
    SimpleIdentifier toNode = this._toNode as SimpleIdentifier;
    if (A__isEqualTokens(node.token, toNode.token)) {
      toNode.staticElement = node.staticElement;
      toNode.staticType = node.staticType;
      toNode.propagatedElement = node.propagatedElement;
      toNode.propagatedType = node.propagatedType;
      toNode.auxiliaryElements = node.auxiliaryElements;
      return true;
    }
    return false;
  }
  bool visitSimpleStringLiteral(SimpleStringLiteral node) {
    SimpleStringLiteral toNode = this._toNode as SimpleStringLiteral;
    if (javaBooleanAnd(A__isEqualTokens(node.literal, toNode.literal), identical(node.value, toNode.value))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitStringInterpolation(StringInterpolation node) {
    StringInterpolation toNode = this._toNode as StringInterpolation;
    if (A__isEqualNodeLists(node.elements, toNode.elements)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    SuperConstructorInvocation toNode = this._toNode as SuperConstructorInvocation;
    if (javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.period, toNode.period)), A__isEqualNodes(node.constructorName, toNode.constructorName)), A__isEqualNodes(node.argumentList, toNode.argumentList))) {
      toNode.staticElement = node.staticElement;
      return true;
    }
    return false;
  }
  bool visitSuperExpression(SuperExpression node) {
    SuperExpression toNode = this._toNode as SuperExpression;
    if (A__isEqualTokens(node.keyword, toNode.keyword)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitSwitchCase(SwitchCase node) {
    SwitchCase toNode = this._toNode as SwitchCase;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodeLists(node.labels, toNode.labels), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.colon, toNode.colon)), A__isEqualNodeLists(node.statements, toNode.statements));
  }
  bool visitSwitchDefault(SwitchDefault node) {
    SwitchDefault toNode = this._toNode as SwitchDefault;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodeLists(node.labels, toNode.labels), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualTokens(node.colon, toNode.colon)), A__isEqualNodeLists(node.statements, toNode.statements));
  }
  bool visitSwitchStatement(SwitchStatement node) {
    SwitchStatement toNode = this._toNode as SwitchStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualTokens(node.leftBracket, toNode.leftBracket)), A__isEqualNodeLists(node.members, toNode.members)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitSymbolLiteral(SymbolLiteral node) {
    SymbolLiteral toNode = this._toNode as SymbolLiteral;
    if (javaBooleanAnd(A__isEqualTokens(node.poundSign, toNode.poundSign), A__isEqualTokenLists(node.components, toNode.components))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitThisExpression(ThisExpression node) {
    ThisExpression toNode = this._toNode as ThisExpression;
    if (A__isEqualTokens(node.keyword, toNode.keyword)) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitThrowExpression(ThrowExpression node) {
    ThrowExpression toNode = this._toNode as ThrowExpression;
    if (javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualNodes(node.expression, toNode.expression))) {
      toNode.propagatedType = node.propagatedType;
      toNode.staticType = node.staticType;
      return true;
    }
    return false;
  }
  bool visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    TopLevelVariableDeclaration toNode = this._toNode as TopLevelVariableDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualNodes(node.variables, toNode.variables)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitTryStatement(TryStatement node) {
    TryStatement toNode = this._toNode as TryStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.tryKeyword, toNode.tryKeyword), A__isEqualNodes(node.body, toNode.body)), A__isEqualNodeLists(node.catchClauses, toNode.catchClauses)), A__isEqualTokens(node.finallyKeyword, toNode.finallyKeyword)), A__isEqualNodes(node.finallyBlock, toNode.finallyBlock));
  }
  bool visitTypeArgumentList(TypeArgumentList node) {
    TypeArgumentList toNode = this._toNode as TypeArgumentList;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftBracket, toNode.leftBracket), A__isEqualNodeLists(node.arguments, toNode.arguments)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitTypeName(TypeName node) {
    TypeName toNode = this._toNode as TypeName;
    if (javaBooleanAnd(A__isEqualNodes(node.name, toNode.name), A__isEqualNodes(node.typeArguments, toNode.typeArguments))) {
      toNode.type = node.type;
      return true;
    }
    return false;
  }
  bool visitTypeParameter(TypeParameter node) {
    TypeParameter toNode = this._toNode as TypeParameter;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualNodes(node.name, toNode.name)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.bound, toNode.bound));
  }
  bool visitTypeParameterList(TypeParameterList node) {
    TypeParameterList toNode = this._toNode as TypeParameterList;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.leftBracket, toNode.leftBracket), A__isEqualNodeLists(node.typeParameters, toNode.typeParameters)), A__isEqualTokens(node.rightBracket, toNode.rightBracket));
  }
  bool visitVariableDeclaration(VariableDeclaration node) {
    VariableDeclaration toNode = this._toNode as VariableDeclaration;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualNodes(node.name, toNode.name)), A__isEqualTokens(node.A_equals, toNode.A_equals)), A__isEqualNodes(node.initializer, toNode.initializer));
  }
  bool visitVariableDeclarationList(VariableDeclarationList node) {
    VariableDeclarationList toNode = this._toNode as VariableDeclarationList;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualNodes(node.documentationComment, toNode.documentationComment), A__isEqualNodeLists(node.metadata, toNode.metadata)), A__isEqualTokens(node.keyword, toNode.keyword)), A__isEqualNodes(node.type, toNode.type)), A__isEqualNodeLists(node.variables, toNode.variables));
  }
  bool visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    VariableDeclarationStatement toNode = this._toNode as VariableDeclarationStatement;
    return javaBooleanAnd(A__isEqualNodes(node.variables, toNode.variables), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool visitWhileStatement(WhileStatement node) {
    WhileStatement toNode = this._toNode as WhileStatement;
    return javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.keyword, toNode.keyword), A__isEqualTokens(node.leftParenthesis, toNode.leftParenthesis)), A__isEqualNodes(node.condition, toNode.condition)), A__isEqualTokens(node.rightParenthesis, toNode.rightParenthesis)), A__isEqualNodes(node.body, toNode.body));
  }
  bool visitWithClause(WithClause node) {
    WithClause toNode = this._toNode as WithClause;
    return javaBooleanAnd(A__isEqualTokens(node.withKeyword, toNode.withKeyword), A__isEqualNodeLists(node.mixinTypes, toNode.mixinTypes));
  }
  bool visitYieldStatement(YieldStatement node) {
    YieldStatement toNode = this._toNode as YieldStatement;
    return javaBooleanAnd(javaBooleanAnd(A__isEqualTokens(node.yieldKeyword, toNode.yieldKeyword), A__isEqualNodes(node.expression, toNode.expression)), A__isEqualTokens(node.semicolon, toNode.semicolon));
  }
  bool A__isEqualNodeLists(NodeList A_first, NodeList A_second) {
    if (A_first == null) {
      return A_second == null;
    } else if (A_second == null) {
      return false;
    }
    int A_size = A_first.length;
    if (A_second.length != A_size) {
      return false;
    }
    bool A_equal = true;
    for (int i = 0; i < A_size; i++) {
      if (!A__isEqualNodes(A_first[i], A_second[i])) {
        A_equal = false;
      }
    }
    return A_equal;
  }
  bool A__isEqualNodes(AstNode fromNode, AstNode toNode) {
    if (fromNode == null) {
      return toNode == null;
    } else if (toNode == null) {
      return false;
    } else if (fromNode.runtimeType == toNode.runtimeType) {
      this._toNode = toNode;
      return fromNode.accept(this);
    }
    if (toNode is PrefixedIdentifier) {
      SimpleIdentifier prefix = toNode.prefix;
      if (fromNode.runtimeType == prefix.runtimeType) {
        this._toNode = prefix;
        return fromNode.accept(this);
      }
    } else if (toNode is PropertyAccess) {
      Expression A_target = toNode.target;
      if (fromNode.runtimeType == A_target.runtimeType) {
        this._toNode = A_target;
        return fromNode.accept(this);
      }
    }
    return false;
  }
  bool A__isEqualTokenLists(List<A_Token> A_first, List<A_Token> A_second) {
    int A_length = A_first.length;
    if (A_second.length != A_length) {
      return false;
    }
    for (int i = 0; i < A_length; i++) {
      if (!A__isEqualTokens(A_first[i], A_second[i])) {
        return false;
      }
    }
    return true;
  }
  bool A__isEqualTokens(A_Token A_first, A_Token A_second) {
    if (A_first == null) {
      return A_second == null;
    } else if (A_second == null) {
      return false;
    }
    return A_first.lexeme == A_second.lexeme;
  }
}
class AngularCompilationUnitBuilder {
  static String _NG_COMPONENT = "Component";
  static String _NG_CONTROLLER = "Controller";
  static String _NG_DECORATOR = "Decorator";
  static String _NG_FORMATTER = "Formatter";
  static String _NAME = "name";
  static String _SELECTOR = "selector";
  static String _PUBLISH_AS = "publishAs";
  static String _TEMPLATE_URL = "templateUrl";
  static String _CSS_URL = "cssUrl";
  static String _NG_ATTR = "NgAttr";
  static String _NG_CALLBACK = "NgCallback";
  static String _NG_ONE_WAY = "NgOneWay";
  static String _NG_ONE_WAY_ONE_TIME = "NgOneWayOneTime";
  static String _NG_TWO_WAY = "NgTwoWay";
  static AngularSelectorElement parseSelector(int A_offset, String text) {
    if (StringUtilities.startsWithChar(text, 0x5B) && StringUtilities.endsWithChar(text, 0x5D)) {
      int nameOffset = A_offset + 1;
      String attributeName = text.substring(1, text.length - 1);
      return new HasAttributeSelectorElementImpl(attributeName, nameOffset);
    }
    if (StringUtilities.startsWithChar(text, 0x2E)) {
      int nameOffset = A_offset + 1;
      String className = text.substring(1, text.length);
      return new AngularHasClassSelectorElementImpl(className, nameOffset);
    }
    if (StringUtilities.endsWithChar(text, 0x5D)) {
      int A_index = StringUtilities.indexOf1(text, 0, 0x5B);
      if (A_index != -1) {
        String tagName = text.substring(0, A_index);
        String attributeName = text.substring(A_index + 1, text.length - 1);
        if (StringUtilities.isTagName(tagName)) {
          return new IsTagHasAttributeSelectorElementImpl(tagName, attributeName);
        }
      }
    }
    if (StringUtilities.isTagName(text)) {
      return new AngularTagSelectorElementImpl(text, A_offset);
    }
    return null;
  }
  static FieldElement _getOnlyFieldElement(FieldDeclaration fieldDeclaration) {
    NodeList<VariableDeclaration> fields = fieldDeclaration.fields.variables;
    return fields[0].element as FieldElement;
  }
  static SimpleStringLiteral _getOnlySimpleStringLiteralArgument(Annotation annotation) {
    SimpleStringLiteral nameLiteral = null;
    ArgumentList argsNode = annotation.arguments;
    if (argsNode != null) {
      NodeList<Expression> args = argsNode.arguments;
      if (args.length == 1) {
        Expression arg = args[0];
        if (arg is SimpleStringLiteral) {
          nameLiteral = arg;
        }
      }
    }
    return nameLiteral;
  }
  static AngularSelectorElement _parseSelectorFromString(SimpleStringLiteral literal) {
    int A_offset = literal.valueOffset;
    String text = literal.stringValue;
    return parseSelector(A_offset, text);
  }
  final AnalysisErrorListener D__errorListener;
  final Source E__source;
  final CompilationUnit G__unit;
  ClassDeclaration _classDeclaration;
  ClassElementImpl _classElement;
  Annotation _annotation;
  AngularCompilationUnitBuilder(this.D__errorListener, this.E__source, this.G__unit);
  void build() {
    _parseViews();
    for (CompilationUnitMember unitMember in G__unit.declarations) {
      if (unitMember is ClassDeclaration) {
        this._classDeclaration = unitMember;
        this._classElement = _classDeclaration.element as ClassElementImpl;
        NodeList<Annotation> annotations = _classDeclaration.metadata;
        for (Annotation annotation in annotations) {
          if (annotation.arguments == null) {
            continue;
          }
          this._annotation = annotation;
          if (_isAngularAnnotation(annotation, _NG_FORMATTER)) {
            _parseFormatter();
            continue;
          }
          if (_isAngularAnnotation(annotation, _NG_COMPONENT)) {
            _parseComponent();
            continue;
          }
          if (_isAngularAnnotation(annotation, _NG_CONTROLLER)) {
            _parseController();
            continue;
          }
          if (_isAngularAnnotation(annotation, _NG_DECORATOR)) {
            _parseDecorator();
            continue;
          }
        }
      }
    }
  }
  Expression _getArgument(String A_name) {
    List<Expression> A_arguments = _annotation.arguments.arguments;
    for (Expression argument in A_arguments) {
      if (argument is NamedExpression) {
        NamedExpression namedExpression = argument;
        String argumentName = namedExpression.name.label.name;
        if (A_name == argumentName) {
          return namedExpression.expression;
        }
      }
    }
    return null;
  }
  String _getStringArgument(String A_name) => _getStringLiteral(A_name).value;
  int _getStringArgumentOffset(String A_name) {
    Expression argument = _getArgument(A_name);
    return (argument as SimpleStringLiteral).valueOffset;
  }
  SimpleStringLiteral _getStringLiteral(String A_name) {
    Expression argument = _getArgument(A_name);
    return argument as SimpleStringLiteral;
  }
  bool _hasStringArgument(String A_name) {
    Expression argument = _getArgument(A_name);
    return argument is SimpleStringLiteral;
  }
  bool _isAngularAnnotation(Annotation annotation, String A_name) {
    A_Element A_element = annotation.element;
    if (A_element is ConstructorElement) {
      ConstructorElement constructorElement = A_element;
      if (constructorElement.returnType.displayName != A_name) {
        return false;
      }
      return _isAngularLibraryElement(constructorElement);
    }
    return false;
  }
  bool _isAngularLibraryElement(A_Element A_element) {
    LibraryElement library = A_element.library;
    return library != null && library.name != null && library.name.startsWith("angular");
  }
  void _parseComponent() {
    bool isValid = true;
    String A_name = null;
    int nameOffset = -1;
    if (_hasStringArgument(_PUBLISH_AS)) {
      A_name = _getStringArgument(_PUBLISH_AS);
      nameOffset = _getStringArgumentOffset(_PUBLISH_AS);
    }
    AngularSelectorElement selector = null;
    if (!_hasStringArgument(_SELECTOR)) {
      _reportErrorForAnnotation(AngularCode.MISSING_SELECTOR, []);
      isValid = false;
    } else {
      SimpleStringLiteral selectorLiteral = _getStringLiteral(_SELECTOR);
      selector = _parseSelectorFromString(selectorLiteral);
      if (selector == null) {
        _reportErrorForArgument(_SELECTOR, AngularCode.CANNOT_PARSE_SELECTOR, [selectorLiteral]);
        isValid = false;
      }
    }
    String templateUri = null;
    int templateUriOffset = -1;
    if (_hasStringArgument(_TEMPLATE_URL)) {
      templateUri = _getStringArgument(_TEMPLATE_URL);
      templateUriOffset = _getStringArgumentOffset(_TEMPLATE_URL);
    }
    String styleUri = null;
    int styleUriOffset = -1;
    if (_hasStringArgument(_CSS_URL)) {
      styleUri = _getStringArgument(_CSS_URL);
      styleUriOffset = _getStringArgumentOffset(_CSS_URL);
    }
    if (isValid) {
      AngularComponentElementImpl A_element = new AngularComponentElementImpl(A_name, nameOffset, _annotation.offset);
      A_element.selector = selector;
      A_element.templateUri = templateUri;
      A_element.templateUriOffset = templateUriOffset;
      A_element.styleUri = styleUri;
      A_element.styleUriOffset = styleUriOffset;
      A_element.properties = _parseComponentProperties();
      A_element.scopeProperties = _parseScopeProperties();
      _classElement.addToolkitObjects(A_element);
    }
  }
  List<AngularPropertyElement> _parseComponentProperties() {
    List<AngularPropertyElement> properties = [];
    _parseComponentProperties_fromMap(properties);
    _parseComponentProperties_fromFields(properties);
    return new List.from(properties);
  }
  void _parseComponentProperties_fromFields(List<AngularPropertyElement> properties) {
    NodeList<ClassMember> members = _classDeclaration.members;
    for (ClassMember member in members) {
      if (member is FieldDeclaration) {
        FieldDeclaration fieldDeclaration = member;
        for (Annotation annotation in fieldDeclaration.metadata) {
          AngularPropertyKind kind = null;
          if (_isAngularAnnotation(annotation, _NG_ATTR)) {
            kind = AngularPropertyKind.ATTR;
          } else if (_isAngularAnnotation(annotation, _NG_CALLBACK)) {
            kind = AngularPropertyKind.CALLBACK;
          } else if (_isAngularAnnotation(annotation, _NG_ONE_WAY)) {
            kind = AngularPropertyKind.ONE_WAY;
          } else if (_isAngularAnnotation(annotation, _NG_ONE_WAY_ONE_TIME)) {
            kind = AngularPropertyKind.ONE_WAY_ONE_TIME;
          } else if (_isAngularAnnotation(annotation, _NG_TWO_WAY)) {
            kind = AngularPropertyKind.TWO_WAY;
          }
          if (kind != null) {
            SimpleStringLiteral nameLiteral = _getOnlySimpleStringLiteralArgument(annotation);
            FieldElement field = _getOnlyFieldElement(fieldDeclaration);
            if (nameLiteral != null && field != null) {
              AngularPropertyElementImpl property = new AngularPropertyElementImpl(nameLiteral.value, nameLiteral.valueOffset);
              property.field = field;
              property.propertyKind = kind;
              properties.add(property);
            }
          }
        }
      }
    }
  }
  void _parseComponentProperties_fromMap(List<AngularPropertyElement> properties) {
    Expression mapExpression = _getArgument("map");
    if (mapExpression == null) {
      return;
    }
    if (mapExpression is! MapLiteral) {
      B__reportErrorForNode(AngularCode.INVALID_PROPERTY_MAP, mapExpression, []);
      return;
    }
    MapLiteral mapLiteral = mapExpression as MapLiteral;
    for (MapLiteralEntry A_entry in mapLiteral.entries) {
      Expression nameExpression = A_entry.key;
      if (nameExpression is! SimpleStringLiteral) {
        B__reportErrorForNode(AngularCode.INVALID_PROPERTY_NAME, nameExpression, []);
        continue;
      }
      SimpleStringLiteral nameLiteral = nameExpression as SimpleStringLiteral;
      String A_name = nameLiteral.value;
      int nameOffset = nameLiteral.valueOffset;
      Expression specExpression = A_entry.value;
      if (specExpression is! SimpleStringLiteral) {
        B__reportErrorForNode(AngularCode.INVALID_PROPERTY_SPEC, specExpression, []);
        continue;
      }
      SimpleStringLiteral specLiteral = specExpression as SimpleStringLiteral;
      String spec = specLiteral.value;
      AngularPropertyKind kind;
      int fieldNameOffset;
      if (StringUtilities.startsWithChar(spec, 0x40)) {
        kind = AngularPropertyKind.ATTR;
        fieldNameOffset = 1;
      } else if (StringUtilities.startsWithChar(spec, 0x26)) {
        kind = AngularPropertyKind.CALLBACK;
        fieldNameOffset = 1;
      } else if (StringUtilities.startsWith3(spec, 0, 0x3D, 0x3E, 0x21)) {
        kind = AngularPropertyKind.ONE_WAY_ONE_TIME;
        fieldNameOffset = 3;
      } else if (StringUtilities.startsWith2(spec, 0, 0x3D, 0x3E)) {
        kind = AngularPropertyKind.ONE_WAY;
        fieldNameOffset = 2;
      } else if (StringUtilities.startsWith3(spec, 0, 0x3C, 0x3D, 0x3E)) {
        kind = AngularPropertyKind.TWO_WAY;
        fieldNameOffset = 3;
      } else {
        B__reportErrorForNode(AngularCode.INVALID_PROPERTY_KIND, specLiteral, [spec]);
        continue;
      }
      String fieldName = spec.substring(fieldNameOffset);
      fieldNameOffset += specLiteral.valueOffset;
      PropertyAccessorElement setter = _classElement.type.lookUpSetter(fieldName, _classElement.library);
      if (setter == null) {
        A__reportErrorForOffset(AngularCode.INVALID_PROPERTY_FIELD, fieldNameOffset, fieldName.length, [fieldName]);
        continue;
      }
      FieldElement field = setter.variable as FieldElement;
      AngularPropertyElementImpl property = new AngularPropertyElementImpl(A_name, nameOffset);
      property.field = field;
      property.propertyKind = kind;
      property.fieldNameOffset = fieldNameOffset;
      properties.add(property);
    }
  }
  void _parseController() {
    bool isValid = true;
    if (!_hasStringArgument(_PUBLISH_AS)) {
      _reportErrorForAnnotation(AngularCode.MISSING_PUBLISH_AS, []);
      isValid = false;
    }
    AngularSelectorElement selector = null;
    if (!_hasStringArgument(_SELECTOR)) {
      _reportErrorForAnnotation(AngularCode.MISSING_SELECTOR, []);
      isValid = false;
    } else {
      SimpleStringLiteral selectorLiteral = _getStringLiteral(_SELECTOR);
      selector = _parseSelectorFromString(selectorLiteral);
      if (selector == null) {
        _reportErrorForArgument(_SELECTOR, AngularCode.CANNOT_PARSE_SELECTOR, [selectorLiteral]);
        isValid = false;
      }
    }
    if (isValid) {
      String A_name = _getStringArgument(_PUBLISH_AS);
      int nameOffset = _getStringArgumentOffset(_PUBLISH_AS);
      AngularControllerElementImpl A_element = new AngularControllerElementImpl(A_name, nameOffset);
      A_element.selector = selector;
      _classElement.addToolkitObjects(A_element);
    }
  }
  void _parseDecorator() {
    bool isValid = true;
    AngularSelectorElement selector = null;
    if (!_hasStringArgument(_SELECTOR)) {
      _reportErrorForAnnotation(AngularCode.MISSING_SELECTOR, []);
      isValid = false;
    } else {
      SimpleStringLiteral selectorLiteral = _getStringLiteral(_SELECTOR);
      selector = _parseSelectorFromString(selectorLiteral);
      if (selector == null) {
        _reportErrorForArgument(_SELECTOR, AngularCode.CANNOT_PARSE_SELECTOR, [selectorLiteral]);
        isValid = false;
      }
    }
    if (isValid) {
      int A_offset = _annotation.offset;
      AngularDecoratorElementImpl A_element = new AngularDecoratorElementImpl(A_offset);
      A_element.selector = selector;
      A_element.properties = _parseComponentProperties();
      _classElement.addToolkitObjects(A_element);
    }
  }
  void _parseFormatter() {
    bool isValid = true;
    if (!_hasStringArgument(_NAME)) {
      _reportErrorForAnnotation(AngularCode.MISSING_NAME, []);
      isValid = false;
    }
    if (isValid) {
      String A_name = _getStringArgument(_NAME);
      int nameOffset = _getStringArgumentOffset(_NAME);
      _classElement.addToolkitObjects(new AngularFormatterElementImpl(A_name, nameOffset));
    }
  }
  List<AngularScopePropertyElement> _parseScopeProperties() {
    List<AngularScopePropertyElement> properties = [];
    _classDeclaration.accept(new RecursiveAstVisitor_AngularCompilationUnitBuilder_parseScopeProperties(properties));
    return new List.from(properties);
  }
  void _parseViews() {
    List<AngularViewElement> views = [];
    G__unit.accept(new RecursiveAstVisitor_AngularCompilationUnitBuilder_parseViews(views));
    if (!views.isEmpty) {
      List<AngularViewElement> viewArray = new List.from(views);
      (G__unit.element as CompilationUnitElementImpl).angularViews = viewArray;
    }
  }
  void _reportErrorForAnnotation(ErrorCode A_errorCode, List<Object> A_arguments) {
    B__reportErrorForNode(A_errorCode, _annotation, A_arguments);
  }
  void _reportErrorForArgument(String argumentName, ErrorCode A_errorCode, List<Object> A_arguments) {
    Expression argument = _getArgument(argumentName);
    B__reportErrorForNode(A_errorCode, argument, A_arguments);
  }
  void B__reportErrorForNode(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    int A_offset = node.offset;
    int A_length = node.length;
    A__reportErrorForOffset(A_errorCode, A_offset, A_length, A_arguments);
  }
  void A__reportErrorForOffset(ErrorCode A_errorCode, int A_offset, int A_length, List<Object> A_arguments) {
    D__errorListener.onError(new A_AnalysisError.D_con2(E__source, A_offset, A_length, A_errorCode, A_arguments));
  }
}
class BestPracticesVerifier extends RecursiveAstVisitor<Object> {
  static String _NULL_TYPE_NAME = "Null";
  static String _TO_INT_METHOD_NAME = "toInt";
  static ParenthesizedExpression _wrapParenthesizedExpression(ParenthesizedExpression parenthesizedExpression) {
    if (parenthesizedExpression.parent is ParenthesizedExpression) {
      return _wrapParenthesizedExpression(parenthesizedExpression.parent as ParenthesizedExpression);
    }
    return parenthesizedExpression;
  }
  ClassElement _enclosingClass;
  final ErrorReporter _errorReporter;
  BestPracticesVerifier(this._errorReporter);
  Object visitArgumentList(ArgumentList node) {
    _checkForArgumentTypesNotAssignableInList(node);
    return super.visitArgumentList(node);
  }
  Object visitAsExpression(AsExpression node) {
    _checkForUnnecessaryCast(node);
    return super.visitAsExpression(node);
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    A_TokenType operatorType = node.operator.type;
    if (operatorType == A_TokenType.A_EQ) {
      _checkForUseOfVoidResult(node.rightHandSide);
      _checkForInvalidAssignment(node.leftHandSide, node.rightHandSide);
    } else {
      _checkForDeprecatedMemberUse(node.bestElement, node);
    }
    return super.visitAssignmentExpression(node);
  }
  Object visitBinaryExpression(BinaryExpression node) {
    _checkForDivisionOptimizationHint(node);
    _checkForDeprecatedMemberUse(node.bestElement, node);
    return super.visitBinaryExpression(node);
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement outerClass = _enclosingClass;
    try {
      _enclosingClass = node.element;
      return super.visitClassDeclaration(node);
    } finally {
      _enclosingClass = outerClass;
    }
  }
  Object visitExportDirective(ExportDirective node) {
    _checkForDeprecatedMemberUse(node.uriElement, node);
    return super.visitExportDirective(node);
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    _checkForMissingReturn(node.returnType, node.functionExpression.body);
    return super.visitFunctionDeclaration(node);
  }
  Object visitImportDirective(ImportDirective node) {
    _checkForDeprecatedMemberUse(node.uriElement, node);
    ImportElement importElement = node.element;
    if (importElement != null) {
      if (importElement.isDeferred) {
        _checkForLoadLibraryFunction(node, importElement);
      }
    }
    return super.visitImportDirective(node);
  }
  Object visitIndexExpression(IndexExpression node) {
    _checkForDeprecatedMemberUse(node.bestElement, node);
    return super.visitIndexExpression(node);
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    _checkForDeprecatedMemberUse(node.staticElement, node);
    return super.visitInstanceCreationExpression(node);
  }
  Object visitIsExpression(IsExpression node) {
    _checkAllTypeChecks(node);
    return super.visitIsExpression(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    _checkForMissingReturn(node.returnType, node.body);
    return super.visitMethodDeclaration(node);
  }
  Object visitPostfixExpression(PostfixExpression node) {
    _checkForDeprecatedMemberUse(node.bestElement, node);
    return super.visitPostfixExpression(node);
  }
  Object visitPrefixExpression(PrefixExpression node) {
    _checkForDeprecatedMemberUse(node.bestElement, node);
    return super.visitPrefixExpression(node);
  }
  Object visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    _checkForDeprecatedMemberUse(node.staticElement, node);
    return super.visitRedirectingConstructorInvocation(node);
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    _checkForDeprecatedMemberUseAtIdentifier(node);
    return super.visitSimpleIdentifier(node);
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    _checkForDeprecatedMemberUse(node.staticElement, node);
    return super.visitSuperConstructorInvocation(node);
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    _checkForUseOfVoidResult(node.initializer);
    _checkForInvalidAssignment(node.name, node.initializer);
    return super.visitVariableDeclaration(node);
  }
  bool _checkAllTypeChecks(IsExpression node) {
    Expression expression = node.expression;
    TypeName typeName = node.type;
    DartType lhsType = expression.staticType;
    DartType rhsType = typeName.type;
    if (lhsType == null || rhsType == null) {
      return false;
    }
    String rhsNameStr = typeName.name.name;
    if (rhsType.isDynamic && rhsNameStr == Keyword.A_DYNAMIC.syntax) {
      if (node.notOperator == null) {
        _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_TYPE_CHECK_TRUE, node, []);
      } else {
        _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_TYPE_CHECK_FALSE, node, []);
      }
      return true;
    }
    A_Element rhsElement = rhsType.element;
    LibraryElement libraryElement = rhsElement != null ? rhsElement.library : null;
    if (libraryElement != null && libraryElement.isDartCore) {
      if (rhsType.isObject || (expression is NullLiteral && rhsNameStr == _NULL_TYPE_NAME)) {
        if (node.notOperator == null) {
          _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_TYPE_CHECK_TRUE, node, []);
        } else {
          _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_TYPE_CHECK_FALSE, node, []);
        }
        return true;
      } else if (rhsNameStr == _NULL_TYPE_NAME) {
        if (node.notOperator == null) {
          _errorReporter.reportErrorForNode(HintCode.TYPE_CHECK_IS_NULL, node, []);
        } else {
          _errorReporter.reportErrorForNode(HintCode.TYPE_CHECK_IS_NOT_NULL, node, []);
        }
        return true;
      }
    }
    return false;
  }
  bool _checkForArgumentTypeNotAssignable(Expression expression, DartType expectedStaticType, DartType actualStaticType, DartType expectedPropagatedType, DartType actualPropagatedType, ErrorCode hintCode) {
    if (actualStaticType != null && expectedStaticType != null) {
      if (!actualStaticType.isAssignableTo(expectedStaticType)) {
        return false;
      }
    }
    DartType expectedBestType = expectedPropagatedType != null ? expectedPropagatedType : expectedStaticType;
    DartType actualBestType = actualPropagatedType != null ? actualPropagatedType : actualStaticType;
    if (actualBestType != null && expectedBestType != null) {
      if (!actualBestType.isAssignableTo(expectedBestType)) {
        _errorReporter.reportTypeErrorForNode(hintCode, expression, [actualBestType, expectedBestType]);
        return true;
      }
    }
    return false;
  }
  bool _checkForArgumentTypeNotAssignableForArgument(Expression argument) {
    if (argument == null) {
      return false;
    }
    ParameterElement staticParameterElement = argument.staticParameterElement;
    DartType staticParameterType = staticParameterElement == null ? null : staticParameterElement.type;
    ParameterElement propagatedParameterElement = argument.propagatedParameterElement;
    DartType propagatedParameterType = propagatedParameterElement == null ? null : propagatedParameterElement.type;
    return _checkForArgumentTypeNotAssignableWithExpectedTypes(argument, staticParameterType, propagatedParameterType, HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE);
  }
  bool _checkForArgumentTypeNotAssignableWithExpectedTypes(Expression expression, DartType expectedStaticType, DartType expectedPropagatedType, ErrorCode A_errorCode) => _checkForArgumentTypeNotAssignable(expression, expectedStaticType, expression.staticType, expectedPropagatedType, expression.propagatedType, A_errorCode);
  bool _checkForArgumentTypesNotAssignableInList(ArgumentList argumentList) {
    if (argumentList == null) {
      return false;
    }
    bool problemReported = false;
    for (Expression argument in argumentList.arguments) {
      problemReported = javaBooleanOr(problemReported, _checkForArgumentTypeNotAssignableForArgument(argument));
    }
    return problemReported;
  }
  bool _checkForDeprecatedMemberUse(A_Element A_element, AstNode node) {
    if (A_element != null && A_element.isDeprecated) {
      String displayName = A_element.displayName;
      if (A_element is ConstructorElement) {
        ConstructorElement constructorElement = A_element;
        displayName = constructorElement.enclosingElement.displayName;
        if (!constructorElement.displayName.isEmpty) {
          displayName = "${displayName}.${constructorElement.displayName}";
        }
      }
      _errorReporter.reportErrorForNode(HintCode.DEPRECATED_MEMBER_USE, node, [displayName]);
      return true;
    }
    return false;
  }
  bool _checkForDeprecatedMemberUseAtIdentifier(SimpleIdentifier identifier) {
    if (identifier.inDeclarationContext()) {
      return false;
    }
    AstNode A_parent = identifier.parent;
    if ((A_parent is ConstructorName && identical(identifier, A_parent.name)) || (A_parent is SuperConstructorInvocation && identical(identifier, A_parent.constructorName)) || A_parent is HideCombinator) {
      return false;
    }
    return _checkForDeprecatedMemberUse(identifier.bestElement, identifier);
  }
  bool _checkForDivisionOptimizationHint(BinaryExpression node) {
    if (node.operator.type != A_TokenType.A_SLASH) {
      return false;
    }
    MethodElement methodElement = node.bestElement;
    if (methodElement == null) {
      return false;
    }
    LibraryElement libraryElement = methodElement.library;
    if (libraryElement != null && !libraryElement.isDartCore) {
      return false;
    }
    if (node.parent is ParenthesizedExpression) {
      ParenthesizedExpression parenthesizedExpression = _wrapParenthesizedExpression(node.parent as ParenthesizedExpression);
      if (parenthesizedExpression.parent is MethodInvocation) {
        MethodInvocation methodInvocation = parenthesizedExpression.parent as MethodInvocation;
        if (_TO_INT_METHOD_NAME == methodInvocation.methodName.name && methodInvocation.argumentList.arguments.isEmpty) {
          _errorReporter.reportErrorForNode(HintCode.DIVISION_OPTIMIZATION, methodInvocation, []);
          return true;
        }
      }
    }
    return false;
  }
  bool _checkForInvalidAssignment(Expression lhs, Expression rhs) {
    if (lhs == null || rhs == null) {
      return false;
    }
    VariableElement leftVariableElement = ErrorVerifier.getVariableElement(lhs);
    DartType leftType = (leftVariableElement == null) ? ErrorVerifier.getStaticType(lhs) : leftVariableElement.type;
    DartType staticRightType = ErrorVerifier.getStaticType(rhs);
    if (!staticRightType.isAssignableTo(leftType)) {
      return false;
    }
    DartType bestRightType = rhs.bestType;
    if (leftType != null && bestRightType != null) {
      if (!bestRightType.isAssignableTo(leftType)) {
        _errorReporter.reportTypeErrorForNode(HintCode.INVALID_ASSIGNMENT, rhs, [bestRightType, leftType]);
        return true;
      }
    }
    return false;
  }
  bool _checkForLoadLibraryFunction(ImportDirective node, ImportElement importElement) {
    LibraryElement importedLibrary = importElement.importedLibrary;
    if (importedLibrary == null) {
      return false;
    }
    if (importedLibrary.hasLoadLibraryFunction) {
      _errorReporter.reportErrorForNode(HintCode.IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION, node, [importedLibrary.name]);
      return true;
    }
    return false;
  }
  bool _checkForMissingReturn(TypeName A_returnType, FunctionBody body) {
    if (A_returnType == null || body == null) {
      return false;
    }
    if (body is! BlockFunctionBody) {
      return false;
    }
    DartType returnTypeType = A_returnType.type;
    if (returnTypeType == null || returnTypeType.isVoid) {
      return false;
    }
    BlockFunctionBody blockFunctionBody = body as BlockFunctionBody;
    if (!blockFunctionBody.accept(new ExitDetector())) {
      _errorReporter.reportErrorForNode(HintCode.MISSING_RETURN, A_returnType, [returnTypeType.displayName]);
      return true;
    }
    return false;
  }
  bool _checkForUnnecessaryCast(AsExpression node) {
    Expression expression = node.expression;
    TypeName typeName = node.type;
    DartType lhsType = expression.staticType;
    DartType rhsType = typeName.type;
    if (lhsType != null && rhsType != null && !lhsType.isDynamic && !rhsType.isDynamic && lhsType is! TypeParameterType && rhsType is! TypeParameterType && lhsType.isMoreSpecificThan(rhsType)) {
      _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_CAST, node, []);
      return true;
    }
    return false;
  }
  bool _checkForUseOfVoidResult(Expression expression) {
    if (expression == null || expression is! MethodInvocation) {
      return false;
    }
    MethodInvocation methodInvocation = expression as MethodInvocation;
    if (identical(methodInvocation.staticType, VoidTypeImpl.instance)) {
      SimpleIdentifier methodName = methodInvocation.methodName;
      _errorReporter.reportErrorForNode(HintCode.USE_OF_VOID_RESULT, methodName, [methodName.name]);
      return true;
    }
    return false;
  }
}
class ClassScope extends EnclosedScope {
  ClassScope(Scope enclosingScope, ClassElement typeElement) : super(enclosingScope) {
    if (typeElement == null) {
      throw new IllegalArgumentException("class element cannot be null");
    }
    _defineMembers(typeElement);
  }
  A_AnalysisError getErrorForDuplicate(A_Element existing, A_Element duplicate) {
    if (existing is PropertyAccessorElement && duplicate is MethodElement) {
      if (existing.nameOffset < duplicate.nameOffset) {
        return new A_AnalysisError.D_con2(duplicate.source, duplicate.nameOffset, duplicate.displayName.length, CompileTimeErrorCode.METHOD_AND_GETTER_WITH_SAME_NAME, [existing.displayName]);
      } else {
        return new A_AnalysisError.D_con2(existing.source, existing.nameOffset, existing.displayName.length, CompileTimeErrorCode.GETTER_AND_METHOD_WITH_SAME_NAME, [existing.displayName]);
      }
    }
    return super.getErrorForDuplicate(existing, duplicate);
  }
  void _defineMembers(ClassElement typeElement) {
    for (PropertyAccessorElement accessor in typeElement.accessors) {
      define(accessor);
    }
    for (MethodElement A_method in typeElement.methods) {
      define(A_method);
    }
  }
}
class CompilationUnitBuilder {
  CompilationUnitElementImpl buildCompilationUnit(Source A_source, CompilationUnit unit) {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      if (unit == null) {
        return null;
      }
      ElementHolder holder = new ElementHolder();
      ElementBuilder A_builder = new ElementBuilder(holder);
      unit.accept(A_builder);
      CompilationUnitElementImpl A_element = new CompilationUnitElementImpl(A_source.shortName);
      A_element.accessors = holder.accessors;
      A_element.enums = holder.enums;
      A_element.functions = holder.functions;
      A_element.source = A_source;
      A_element.typeAliases = holder.typeAliases;
      A_element.types = holder.types;
      A_element.topLevelVariables = holder.topLevelVariables;
      unit.element = A_element;
      return A_element;
    } finally {
      timeCounter.stop();
    }
  }
}
class ConstantVerifier extends RecursiveAstVisitor<Object> {
  final ErrorReporter _errorReporter;
  final TypeProvider B__typeProvider;
  InterfaceType _boolType;
  InterfaceType _intType;
  InterfaceType _numType;
  InterfaceType _stringType;
  final LibraryElement _currentLibrary;
  ConstantVerifier(this._errorReporter, this._currentLibrary, this.B__typeProvider) {
    this._boolType = B__typeProvider.boolType;
    this._intType = B__typeProvider.intType;
    this._numType = B__typeProvider.numType;
    this._stringType = B__typeProvider.stringType;
  }
  Object visitAnnotation(Annotation node) {
    super.visitAnnotation(node);
    A_Element A_element = node.element;
    if (A_element is ConstructorElement) {
      ConstructorElement constructorElement = A_element;
      if (!constructorElement.isConst) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.NON_CONSTANT_ANNOTATION_CONSTRUCTOR, node, []);
        return null;
      }
      ArgumentList argumentList = node.arguments;
      if (argumentList == null) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS, node, []);
        return null;
      }
      _validateConstantArguments(argumentList);
    }
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    if (node.constKeyword != null) {
      _validateConstructorInitializers(node);
      _validateFieldInitializers(node.parent as ClassDeclaration, node);
    }
    _validateDefaultValues(node.parameters);
    return super.visitConstructorDeclaration(node);
  }
  Object visitFunctionExpression(FunctionExpression node) {
    super.visitFunctionExpression(node);
    _validateDefaultValues(node.parameters);
    return null;
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    if (node.isConst) {
      A__validate(node, null);
    }
    _validateInstanceCreationArguments(node);
    return super.visitInstanceCreationExpression(node);
  }
  Object visitListLiteral(ListLiteral node) {
    super.visitListLiteral(node);
    if (node.constKeyword != null) {
      EvaluationResultImpl result;
      for (Expression A_element in node.elements) {
        result = A__validate(A_element, CompileTimeErrorCode.NON_CONSTANT_LIST_ELEMENT);
        if (result is ValidResult) {
          _reportErrorIfFromDeferredLibrary(A_element, CompileTimeErrorCode.NON_CONSTANT_LIST_ELEMENT_FROM_DEFERRED_LIBRARY);
        }
      }
    }
    return null;
  }
  Object visitMapLiteral(MapLiteral node) {
    super.visitMapLiteral(node);
    bool A_isConst = node.constKeyword != null;
    bool reportEqualKeys = true;
    A_p.HashSet<DartObject> A_keys = new A_p.HashSet<DartObject>();
    List<Expression> invalidKeys = new List<Expression>();
    for (MapLiteralEntry A_entry in node.entries) {
      Expression A_key = A_entry.key;
      if (A_isConst) {
        EvaluationResultImpl keyResult = A__validate(A_key, CompileTimeErrorCode.NON_CONSTANT_MAP_KEY);
        Expression valueExpression = A_entry.value;
        EvaluationResultImpl valueResult = A__validate(valueExpression, CompileTimeErrorCode.NON_CONSTANT_MAP_VALUE);
        if (valueResult is ValidResult) {
          _reportErrorIfFromDeferredLibrary(valueExpression, CompileTimeErrorCode.NON_CONSTANT_MAP_VALUE_FROM_DEFERRED_LIBRARY);
        }
        if (keyResult is ValidResult) {
          _reportErrorIfFromDeferredLibrary(A_key, CompileTimeErrorCode.NON_CONSTANT_MAP_KEY_FROM_DEFERRED_LIBRARY);
          DartObject A_value = keyResult.value;
          if (A_keys.contains(A_value)) {
            invalidKeys.add(A_key);
          } else {
            A_keys.add(A_value);
          }
          DartType A_type = A_value.type;
          if (_implementsEqualsWhenNotAllowed(A_type)) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS, A_key, [A_type.displayName]);
          }
        }
      } else {
        EvaluationResultImpl result = A_key.accept(new ConstantVisitor.A_con1(B__typeProvider));
        if (result is ValidResult) {
          DartObject A_value = result.value;
          if (A_keys.contains(A_value)) {
            invalidKeys.add(A_key);
          } else {
            A_keys.add(A_value);
          }
        } else {
          reportEqualKeys = false;
        }
      }
    }
    if (reportEqualKeys) {
      for (Expression A_key in invalidKeys) {
        _errorReporter.reportErrorForNode(StaticWarningCode.EQUAL_KEYS_IN_MAP, A_key, []);
      }
    }
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    super.visitMethodDeclaration(node);
    _validateDefaultValues(node.parameters);
    return null;
  }
  Object visitSwitchStatement(SwitchStatement node) {
    NodeList<SwitchMember> switchMembers = node.members;
    bool foundError = false;
    DartType firstType = null;
    for (SwitchMember switchMember in switchMembers) {
      if (switchMember is SwitchCase) {
        SwitchCase switchCase = switchMember;
        Expression expression = switchCase.expression;
        EvaluationResultImpl caseResult = A__validate(expression, CompileTimeErrorCode.NON_CONSTANT_CASE_EXPRESSION);
        if (caseResult is ValidResult) {
          _reportErrorIfFromDeferredLibrary(expression, CompileTimeErrorCode.NON_CONSTANT_CASE_EXPRESSION_FROM_DEFERRED_LIBRARY);
          DartObject A_value = caseResult.value;
          if (firstType == null) {
            firstType = A_value.type;
          } else {
            DartType nType = A_value.type;
            if (firstType != nType) {
              _errorReporter.reportErrorForNode(CompileTimeErrorCode.INCONSISTENT_CASE_EXPRESSION_TYPES, expression, [expression.toSource(), firstType.displayName]);
              foundError = true;
            }
          }
        }
      }
    }
    if (!foundError) {
      _checkForCaseExpressionTypeImplementsEquals(node, firstType);
    }
    return super.visitSwitchStatement(node);
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    super.visitVariableDeclaration(node);
    Expression initializer = node.initializer;
    if (initializer != null && node.isConst) {
      VariableElementImpl A_element = node.element as VariableElementImpl;
      EvaluationResultImpl result = A_element.evaluationResult;
      if (result == null) {
        result = A__validate(initializer, CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE);
        A_element.evaluationResult = result;
        return null;
      } else if (result is ErrorResult) {
        _reportErrors(result, CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE);
        return null;
      }
      _reportErrorIfFromDeferredLibrary(initializer, CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY);
    }
    return null;
  }
  bool _checkForCaseExpressionTypeImplementsEquals(SwitchStatement node, DartType A_type) {
    if (!_implementsEqualsWhenNotAllowed(A_type)) {
      return false;
    }
    _errorReporter.reportErrorForToken(CompileTimeErrorCode.CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS, node.keyword, [A_type.displayName]);
    return true;
  }
  bool _implementsEqualsWhenNotAllowed(DartType A_type) {
    if (A_type == null || A_type == _intType || A_type == B__typeProvider.stringType) {
      return false;
    } else if (A_type == B__typeProvider.doubleType) {
      return true;
    }
    A_Element A_element = A_type.element;
    if (A_element is! ClassElement) {
      return false;
    }
    ClassElement classElement = A_element as ClassElement;
    MethodElement A_method = classElement.lookUpConcreteMethod("==", _currentLibrary);
    if (A_method == null || A_method.enclosingElement.type.isObject) {
      return false;
    }
    return true;
  }
  void _reportErrorIfFromDeferredLibrary(Expression expression, ErrorCode A_errorCode) {
    DeferredLibraryReferenceDetector referenceDetector = new DeferredLibraryReferenceDetector();
    expression.accept(referenceDetector);
    if (referenceDetector.result) {
      _errorReporter.reportErrorForNode(A_errorCode, expression, []);
    }
  }
  void _reportErrors(EvaluationResultImpl result, ErrorCode A_errorCode) {
    if (result is ErrorResult) {
      for (ErrorResult_ErrorData A_data in result.errorData) {
        ErrorCode dataErrorCode = A_data.errorCode;
        if (identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION) || identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_THROWS_IDBZE) || identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING) || identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL) || identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_INT) || identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_NUM)) {
          _errorReporter.reportErrorForNode(dataErrorCode, A_data.node, []);
        } else if (A_errorCode != null) {
          _errorReporter.reportErrorForNode(A_errorCode, A_data.node, []);
        }
      }
    }
  }
  ValidResult A__valid(InterfaceType A_type, InstanceState state) => new ValidResult(new DartObjectImpl(A_type, state));
  EvaluationResultImpl A__validate(Expression expression, ErrorCode A_errorCode) {
    EvaluationResultImpl result = expression.accept(new ConstantVisitor.A_con1(B__typeProvider));
    _reportErrors(result, A_errorCode);
    return result;
  }
  void _validateConstantArguments(ArgumentList argumentList) {
    for (Expression argument in argumentList.arguments) {
      if (argument is NamedExpression) {
        argument = (argument as NamedExpression).expression;
      }
      A__validate(argument, CompileTimeErrorCode.CONST_WITH_NON_CONSTANT_ARGUMENT);
    }
  }
  void _validateConstructorInitializers(ConstructorDeclaration constructor) {
    List<ParameterElement> parameterElements = constructor.parameters.parameterElements;
    NodeList<ConstructorInitializer> initializers = constructor.initializers;
    for (ConstructorInitializer initializer in initializers) {
      if (initializer is ConstructorFieldInitializer) {
        ConstructorFieldInitializer fieldInitializer = initializer;
        _validateInitializerExpression(parameterElements, fieldInitializer.expression);
      }
      if (initializer is RedirectingConstructorInvocation) {
        RedirectingConstructorInvocation invocation = initializer;
        _validateInitializerInvocationArguments(parameterElements, invocation.argumentList);
      }
      if (initializer is SuperConstructorInvocation) {
        SuperConstructorInvocation invocation = initializer;
        _validateInitializerInvocationArguments(parameterElements, invocation.argumentList);
      }
    }
  }
  void _validateDefaultValues(FormalParameterList A_parameters) {
    if (A_parameters == null) {
      return;
    }
    for (FormalParameter parameter in A_parameters.parameters) {
      if (parameter is DefaultFormalParameter) {
        DefaultFormalParameter defaultParameter = parameter;
        Expression A_defaultValue = defaultParameter.defaultValue;
        if (A_defaultValue != null) {
          EvaluationResultImpl result = A__validate(A_defaultValue, CompileTimeErrorCode.NON_CONSTANT_DEFAULT_VALUE);
          VariableElementImpl A_element = parameter.element as VariableElementImpl;
          A_element.evaluationResult = result;
          if (result is ValidResult) {
            _reportErrorIfFromDeferredLibrary(A_defaultValue, CompileTimeErrorCode.NON_CONSTANT_DEFAULT_VALUE_FROM_DEFERRED_LIBRARY);
          }
        }
      }
    }
  }
  void _validateFieldInitializers(ClassDeclaration classDeclaration, ConstructorDeclaration errorSite) {
    NodeList<ClassMember> members = classDeclaration.members;
    for (ClassMember member in members) {
      if (member is FieldDeclaration) {
        FieldDeclaration fieldDeclaration = member;
        if (!fieldDeclaration.isStatic) {
          for (VariableDeclaration variableDeclaration in fieldDeclaration.fields.variables) {
            Expression initializer = variableDeclaration.initializer;
            if (initializer != null) {
              EvaluationResultImpl result = initializer.accept(new ConstantVisitor.A_con1(B__typeProvider));
              if (result is! ValidResult) {
                _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_FIELD_INITIALIZED_BY_NON_CONST, errorSite, [variableDeclaration.name.name]);
              }
            }
          }
        }
      }
    }
  }
  void _validateInitializerExpression(List<ParameterElement> parameterElements, Expression expression) {
    EvaluationResultImpl result = expression.accept(new ConstantVisitor_ConstantVerifier_validateInitializerExpression(B__typeProvider, this, parameterElements));
    _reportErrors(result, CompileTimeErrorCode.NON_CONSTANT_VALUE_IN_INITIALIZER);
    if (result is ValidResult) {
      _reportErrorIfFromDeferredLibrary(expression, CompileTimeErrorCode.NON_CONSTANT_VALUE_IN_INITIALIZER_FROM_DEFERRED_LIBRARY);
    }
  }
  void _validateInitializerInvocationArguments(List<ParameterElement> parameterElements, ArgumentList argumentList) {
    if (argumentList == null) {
      return;
    }
    for (Expression argument in argumentList.arguments) {
      _validateInitializerExpression(parameterElements, argument);
    }
  }
  void _validateInstanceCreationArguments(InstanceCreationExpression node) {
    if (!node.isConst) {
      return;
    }
    ArgumentList argumentList = node.argumentList;
    if (argumentList == null) {
      return;
    }
    _validateConstantArguments(argumentList);
  }
}
class ConstantVisitor_ConstantVerifier_validateInitializerExpression extends ConstantVisitor {
  final ConstantVerifier ConstantVerifier_this;
  List<ParameterElement> parameterElements;
  ConstantVisitor_ConstantVerifier_validateInitializerExpression(TypeProvider arg0, this.ConstantVerifier_this, this.parameterElements) : super.A_con1(arg0);
  EvaluationResultImpl visitSimpleIdentifier(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    for (ParameterElement parameterElement in parameterElements) {
      if (identical(parameterElement, A_element) && parameterElement != null) {
        DartType A_type = parameterElement.type;
        if (A_type != null) {
          if (A_type.isDynamic) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.objectType, DynamicState.DYNAMIC_STATE);
          } else if (A_type.isSubtypeOf(ConstantVerifier_this._boolType)) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.boolType, BoolState.UNKNOWN_VALUE);
          } else if (A_type.isSubtypeOf(ConstantVerifier_this.B__typeProvider.doubleType)) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.doubleType, DoubleState.UNKNOWN_VALUE);
          } else if (A_type.isSubtypeOf(ConstantVerifier_this._intType)) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.intType, IntState.UNKNOWN_VALUE);
          } else if (A_type.isSubtypeOf(ConstantVerifier_this._numType)) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.numType, NumState.UNKNOWN_VALUE);
          } else if (A_type.isSubtypeOf(ConstantVerifier_this._stringType)) {
            return ConstantVerifier_this.A__valid(ConstantVerifier_this.B__typeProvider.stringType, StringState.UNKNOWN_VALUE);
          }
        }
        return ConstantVerifier_this.A__valid(A_type is InterfaceType ? A_type : ConstantVerifier_this.B__typeProvider.objectType, GenericState.UNKNOWN_VALUE);
      }
    }
    return super.visitSimpleIdentifier(node);
  }
}
class Dart2JSVerifier extends RecursiveAstVisitor<Object> {
  final ErrorReporter _errorReporter;
  static String _DOUBLE_TYPE_NAME = "double";
  Dart2JSVerifier(this._errorReporter);
  Object visitIsExpression(IsExpression node) {
    _checkForIsDoubleHints(node);
    return super.visitIsExpression(node);
  }
  bool _checkForIsDoubleHints(IsExpression node) {
    TypeName typeName = node.type;
    DartType A_type = typeName.type;
    if (A_type != null && A_type.element != null) {
      A_Element A_element = A_type.element;
      String typeNameStr = A_element.name;
      LibraryElement libraryElement = A_element.library;
      if (typeNameStr == _DOUBLE_TYPE_NAME && libraryElement != null && libraryElement.isDartCore) {
        if (node.notOperator == null) {
          _errorReporter.reportErrorForNode(HintCode.IS_DOUBLE, node, []);
        } else {
          _errorReporter.reportErrorForNode(HintCode.IS_NOT_DOUBLE, node, []);
        }
        return true;
      }
    }
    return false;
  }
}
class DeadCodeVerifier extends RecursiveAstVisitor<Object> {
  final ErrorReporter _errorReporter;
  DeadCodeVerifier(this._errorReporter);
  Object visitBinaryExpression(BinaryExpression node) {
    A_Token operator = node.operator;
    bool isAmpAmp = operator.type == A_TokenType.AMPERSAND_AMPERSAND;
    bool isBarBar = operator.type == A_TokenType.BAR_BAR;
    if (isAmpAmp || isBarBar) {
      Expression lhsCondition = node.leftOperand;
      if (!_isDebugConstant(lhsCondition)) {
        ValidResult lhsResult = _getConstantBooleanValue(lhsCondition);
        if (lhsResult != null) {
          if (lhsResult.isTrue && isBarBar) {
            _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.rightOperand, []);
            _safelyVisit(lhsCondition);
            return null;
          } else if (lhsResult.isFalse && isAmpAmp) {
            _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.rightOperand, []);
            _safelyVisit(lhsCondition);
            return null;
          }
        }
      }
    }
    return super.visitBinaryExpression(node);
  }
  Object visitBlock(Block node) {
    NodeList<Statement> statements = node.statements;
    _checkForDeadStatementsInNodeList(statements);
    return null;
  }
  Object visitConditionalExpression(ConditionalExpression node) {
    Expression conditionExpression = node.condition;
    _safelyVisit(conditionExpression);
    if (!_isDebugConstant(conditionExpression)) {
      ValidResult result = _getConstantBooleanValue(conditionExpression);
      if (result != null) {
        if (result.isTrue) {
          _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.elseExpression, []);
          _safelyVisit(node.thenExpression);
          return null;
        } else {
          _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.thenExpression, []);
          _safelyVisit(node.elseExpression);
          return null;
        }
      }
    }
    return super.visitConditionalExpression(node);
  }
  Object visitIfStatement(IfStatement node) {
    Expression conditionExpression = node.condition;
    _safelyVisit(conditionExpression);
    if (!_isDebugConstant(conditionExpression)) {
      ValidResult result = _getConstantBooleanValue(conditionExpression);
      if (result != null) {
        if (result.isTrue) {
          Statement elseStatement = node.elseStatement;
          if (elseStatement != null) {
            _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, elseStatement, []);
            _safelyVisit(node.thenStatement);
            return null;
          }
        } else {
          _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.thenStatement, []);
          _safelyVisit(node.elseStatement);
          return null;
        }
      }
    }
    return super.visitIfStatement(node);
  }
  Object visitSwitchCase(SwitchCase node) {
    _checkForDeadStatementsInNodeList(node.statements);
    return super.visitSwitchCase(node);
  }
  Object visitSwitchDefault(SwitchDefault node) {
    _checkForDeadStatementsInNodeList(node.statements);
    return super.visitSwitchDefault(node);
  }
  Object visitTryStatement(TryStatement node) {
    _safelyVisit(node.body);
    _safelyVisit(node.finallyBlock);
    NodeList<CatchClause> catchClauses = node.catchClauses;
    int numOfCatchClauses = catchClauses.length;
    List<DartType> visitedTypes = new List<DartType>();
    for (int i = 0; i < numOfCatchClauses; i++) {
      CatchClause catchClause = catchClauses[i];
      if (catchClause.onKeyword != null) {
        TypeName typeName = catchClause.exceptionType;
        if (typeName != null && typeName.type != null) {
          DartType currentType = typeName.type;
          if (currentType.isObject) {
            _safelyVisit(catchClause);
            if (i + 1 != numOfCatchClauses) {
              CatchClause nextCatchClause = catchClauses[i + 1];
              CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];
              int A_offset = nextCatchClause.offset;
              int A_length = lastCatchClause.end - A_offset;
              _errorReporter.reportErrorForOffset(HintCode.DEAD_CODE_CATCH_FOLLOWING_CATCH, A_offset, A_length, []);
              return null;
            }
          }
          for (DartType A_type in visitedTypes) {
            if (currentType.isSubtypeOf(A_type)) {
              CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];
              int A_offset = catchClause.offset;
              int A_length = lastCatchClause.end - A_offset;
              _errorReporter.reportErrorForOffset(HintCode.DEAD_CODE_ON_CATCH_SUBTYPE, A_offset, A_length, [currentType.displayName, A_type.displayName]);
              return null;
            }
          }
          visitedTypes.add(currentType);
        }
        _safelyVisit(catchClause);
      } else {
        _safelyVisit(catchClause);
        if (i + 1 != numOfCatchClauses) {
          CatchClause nextCatchClause = catchClauses[i + 1];
          CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];
          int A_offset = nextCatchClause.offset;
          int A_length = lastCatchClause.end - A_offset;
          _errorReporter.reportErrorForOffset(HintCode.DEAD_CODE_CATCH_FOLLOWING_CATCH, A_offset, A_length, []);
          return null;
        }
      }
    }
    return null;
  }
  Object visitWhileStatement(WhileStatement node) {
    Expression conditionExpression = node.condition;
    _safelyVisit(conditionExpression);
    if (!_isDebugConstant(conditionExpression)) {
      ValidResult result = _getConstantBooleanValue(conditionExpression);
      if (result != null) {
        if (result.isFalse) {
          _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.body, []);
          return null;
        }
      }
    }
    _safelyVisit(node.body);
    return null;
  }
  void _checkForDeadStatementsInNodeList(NodeList<Statement> statements) {
    int A_size = statements.length;
    for (int i = 0; i < A_size; i++) {
      Statement currentStatement = statements[i];
      _safelyVisit(currentStatement);
      bool returnOrBreakingStatement = currentStatement is ReturnStatement || (currentStatement is BreakStatement && currentStatement.label == null) || (currentStatement is ContinueStatement && currentStatement.label == null);
      if (returnOrBreakingStatement && i != A_size - 1) {
        Statement nextStatement = statements[i + 1];
        Statement lastStatement = statements[A_size - 1];
        int A_offset = nextStatement.offset;
        int A_length = lastStatement.end - A_offset;
        _errorReporter.reportErrorForOffset(HintCode.DEAD_CODE, A_offset, A_length, []);
        return;
      }
    }
  }
  ValidResult _getConstantBooleanValue(Expression expression) {
    if (expression is BooleanLiteral) {
      if (expression.value) {
        return new ValidResult(new DartObjectImpl(null, BoolState.A_from(true)));
      } else {
        return new ValidResult(new DartObjectImpl(null, BoolState.A_from(false)));
      }
    }
    return null;
  }
  bool _isDebugConstant(Expression expression) {
    A_Element A_element = null;
    if (expression is Identifier) {
      Identifier identifier = expression;
      A_element = identifier.staticElement;
    } else if (expression is PropertyAccess) {
      PropertyAccess propertyAccess = expression;
      A_element = propertyAccess.propertyName.staticElement;
    }
    if (A_element is PropertyAccessorElement) {
      PropertyAccessorElement pae = A_element as PropertyAccessorElement;
      PropertyInducingElement variable = pae.variable;
      return variable != null && variable.isConst;
    }
    return false;
  }
  void _safelyVisit(AstNode node) {
    if (node != null) {
      node.accept(this);
    }
  }
}
class DeclarationMatcher extends RecursiveAstVisitor<Object> {
  CompilationUnitElement _enclosingUnit;
  FunctionTypeAliasElement _enclosingAlias;
  ClassElement _enclosingClass;
  ExecutableElement _enclosingExecutable;
  ParameterElement _enclosingParameter;
  A_p.HashSet<A_Element> _allElements = new A_p.HashSet<A_Element>();
  A_p.HashSet<A_Element> _unmatchedElements = new A_p.HashSet<A_Element>();
  bool matches(AstNode node, A_Element A_element) {
    _captureEnclosingElements(A_element);
    _gatherElements(A_element);
    try {
      node.accept(this);
    }on DeclarationMatcher_DeclarationMismatchException  catch (exception) {
      return false;
    }
    return _unmatchedElements.isEmpty;
  }
  Object visitCatchClause(CatchClause node) {
    SimpleIdentifier exceptionParameter = node.exceptionParameter;
    if (exceptionParameter != null) {
      List<LocalVariableElement> localVariables = _enclosingExecutable.localVariables;
      LocalVariableElement exceptionElement = _findIdentifier(localVariables, exceptionParameter);
      processElement(exceptionElement);
      SimpleIdentifier stackTraceParameter = node.stackTraceParameter;
      if (stackTraceParameter != null) {
        LocalVariableElement stackTraceElement = _findIdentifier(localVariables, stackTraceParameter);
        processElement(stackTraceElement);
      }
    }
    return super.visitCatchClause(node);
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement outerClass = _enclosingClass;
    try {
      SimpleIdentifier className = node.name;
      _enclosingClass = _findIdentifier(_enclosingUnit.types, className);
      processElement(_enclosingClass);
      if (!_hasConstructor(node)) {
        ConstructorElement constructor = _enclosingClass.unnamedConstructor;
        if (constructor.isSynthetic) {
          processElement(constructor);
        }
      }
      return super.visitClassDeclaration(node);
    } finally {
      _enclosingClass = outerClass;
    }
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    ClassElement outerClass = _enclosingClass;
    try {
      SimpleIdentifier className = node.name;
      _enclosingClass = _findIdentifier(_enclosingUnit.types, className);
      processElement(_enclosingClass);
      return super.visitClassTypeAlias(node);
    } finally {
      _enclosingClass = outerClass;
    }
  }
  Object visitCompilationUnit(CompilationUnit node) {
    processElement(_enclosingUnit);
    return super.visitCompilationUnit(node);
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    ExecutableElement outerExecutable = _enclosingExecutable;
    try {
      SimpleIdentifier constructorName = node.name;
      if (constructorName == null) {
        _enclosingExecutable = _enclosingClass.unnamedConstructor;
      } else {
        _enclosingExecutable = _enclosingClass.getNamedConstructor(constructorName.name);
      }
      processElement(_enclosingExecutable);
      return super.visitConstructorDeclaration(node);
    } finally {
      _enclosingExecutable = outerExecutable;
    }
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    SimpleIdentifier A_variableName = node.identifier;
    LocalVariableElement A_element = _findIdentifier(_enclosingExecutable.localVariables, A_variableName);
    processElement(A_element);
    return super.visitDeclaredIdentifier(node);
  }
  Object visitDefaultFormalParameter(DefaultFormalParameter node) {
    SimpleIdentifier A_parameterName = node.parameter.identifier;
    ParameterElement A_element = _getElementForParameter(node, A_parameterName);
    Expression A_defaultValue = node.defaultValue;
    if (A_defaultValue != null) {
      ExecutableElement outerExecutable = _enclosingExecutable;
      try {
        if (A_element == null) {} else {
          _enclosingExecutable = A_element.initializer;
        }
        A_defaultValue.accept(this);
      } finally {
        _enclosingExecutable = outerExecutable;
      }
      processElement(_enclosingExecutable);
    }
    ParameterElement outerParameter = _enclosingParameter;
    try {
      _enclosingParameter = A_element;
      processElement(_enclosingParameter);
      return super.visitDefaultFormalParameter(node);
    } finally {
      _enclosingParameter = outerParameter;
    }
  }
  Object visitEnumDeclaration(EnumDeclaration node) {
    ClassElement enclosingEnum = _findIdentifier(_enclosingUnit.enums, node.name);
    processElement(enclosingEnum);
    List<FieldElement> constants = enclosingEnum.fields;
    for (EnumConstantDeclaration constant in node.constants) {
      FieldElement constantElement = _findIdentifier(constants, constant.name);
      processElement(constantElement);
    }
    return super.visitEnumDeclaration(node);
  }
  Object visitExportDirective(ExportDirective node) {
    String A_uri = _getStringValue(node.uri);
    if (A_uri != null) {
      LibraryElement library = _enclosingUnit.library;
      ExportElement exportElement = _findExport(library.exports, _enclosingUnit.context.sourceFactory.resolveUri(_enclosingUnit.source, A_uri));
      processElement(exportElement);
    }
    return super.visitExportDirective(node);
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      ParameterElement A_element = _getElementForParameter(node, A_parameterName);
      ParameterElement outerParameter = _enclosingParameter;
      try {
        _enclosingParameter = A_element;
        processElement(_enclosingParameter);
        return super.visitFieldFormalParameter(node);
      } finally {
        _enclosingParameter = outerParameter;
      }
    } else {
      return super.visitFieldFormalParameter(node);
    }
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    ExecutableElement outerExecutable = _enclosingExecutable;
    try {
      SimpleIdentifier functionName = node.name;
      A_Token property = node.propertyKeyword;
      if (property == null) {
        if (_enclosingExecutable != null) {
          _enclosingExecutable = _findIdentifier(_enclosingExecutable.functions, functionName);
        } else {
          _enclosingExecutable = _findIdentifier(_enclosingUnit.functions, functionName);
        }
      } else {
        PropertyAccessorElement accessor = _findIdentifier(_enclosingUnit.accessors, functionName);
        if ((property as KeywordToken).keyword == Keyword.SET) {
          accessor = accessor.variable.setter;
        }
        _enclosingExecutable = accessor;
      }
      processElement(_enclosingExecutable);
      return super.visitFunctionDeclaration(node);
    } finally {
      _enclosingExecutable = outerExecutable;
    }
  }
  Object visitFunctionExpression(FunctionExpression node) {
    if (node.parent is! FunctionDeclaration) {
      FunctionElement A_element = _findAtOffset(_enclosingExecutable.functions, node.beginToken.offset);
      processElement(A_element);
    }
    ExecutableElement outerExecutable = _enclosingExecutable;
    try {
      _enclosingExecutable = node.element;
      processElement(_enclosingExecutable);
      return super.visitFunctionExpression(node);
    } finally {
      _enclosingExecutable = outerExecutable;
    }
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    FunctionTypeAliasElement outerAlias = _enclosingAlias;
    try {
      SimpleIdentifier aliasName = node.name;
      _enclosingAlias = _findIdentifier(_enclosingUnit.functionTypeAliases, aliasName);
      processElement(_enclosingAlias);
      return super.visitFunctionTypeAlias(node);
    } finally {
      _enclosingAlias = outerAlias;
    }
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      ParameterElement A_element = _getElementForParameter(node, A_parameterName);
      ParameterElement outerParameter = _enclosingParameter;
      try {
        _enclosingParameter = A_element;
        processElement(_enclosingParameter);
        return super.visitFunctionTypedFormalParameter(node);
      } finally {
        _enclosingParameter = outerParameter;
      }
    } else {
      return super.visitFunctionTypedFormalParameter(node);
    }
  }
  Object visitImportDirective(ImportDirective node) {
    String A_uri = _getStringValue(node.uri);
    if (A_uri != null) {
      LibraryElement library = _enclosingUnit.library;
      ImportElement importElement = _findImport(library.imports, _enclosingUnit.context.sourceFactory.resolveUri(_enclosingUnit.source, A_uri), node.prefix);
      processElement(importElement);
    }
    return super.visitImportDirective(node);
  }
  Object visitLabeledStatement(LabeledStatement node) {
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElement A_element = _findIdentifier(_enclosingExecutable.labels, labelName);
      processElement(A_element);
    }
    return super.visitLabeledStatement(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    ExecutableElement outerExecutable = _enclosingExecutable;
    try {
      A_Token property = node.propertyKeyword;
      SimpleIdentifier methodName = node.name;
      String nameOfMethod = methodName.name;
      if (nameOfMethod == A_TokenType.MINUS.lexeme && node.parameters.parameters.length == 0) {
        nameOfMethod = "unary-";
      }
      if (property == null) {
        _enclosingExecutable = _findWithNameAndOffset(_enclosingClass.methods, nameOfMethod, methodName.offset);
        methodName.staticElement = _enclosingExecutable;
      } else {
        PropertyAccessorElement accessor = _findIdentifier(_enclosingClass.accessors, methodName);
        if ((property as KeywordToken).keyword == Keyword.SET) {
          accessor = accessor.variable.setter;
          methodName.staticElement = accessor;
        }
        _enclosingExecutable = accessor;
      }
      processElement(_enclosingExecutable);
      return super.visitMethodDeclaration(node);
    } finally {
      _enclosingExecutable = outerExecutable;
    }
  }
  Object visitPartDirective(PartDirective node) {
    String A_uri = _getStringValue(node.uri);
    if (A_uri != null) {
      Source partSource = _enclosingUnit.context.sourceFactory.resolveUri(_enclosingUnit.source, A_uri);
      CompilationUnitElement A_element = _findPart(_enclosingUnit.library.parts, partSource);
      processElement(A_element);
    }
    return super.visitPartDirective(node);
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      ParameterElement A_element = _getElementForParameter(node, A_parameterName);
      ParameterElement outerParameter = _enclosingParameter;
      try {
        _enclosingParameter = A_element;
        processElement(_enclosingParameter);
        return super.visitSimpleFormalParameter(node);
      } finally {
        _enclosingParameter = outerParameter;
      }
    } else {}
    return super.visitSimpleFormalParameter(node);
  }
  Object visitSwitchCase(SwitchCase node) {
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElement A_element = _findIdentifier(_enclosingExecutable.labels, labelName);
      processElement(A_element);
    }
    return super.visitSwitchCase(node);
  }
  Object visitSwitchDefault(SwitchDefault node) {
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElement A_element = _findIdentifier(_enclosingExecutable.labels, labelName);
      processElement(A_element);
    }
    return super.visitSwitchDefault(node);
  }
  Object visitTypeParameter(TypeParameter node) {
    SimpleIdentifier A_parameterName = node.name;
    TypeParameterElement A_element = null;
    if (_enclosingClass != null) {
      A_element = _findIdentifier(_enclosingClass.typeParameters, A_parameterName);
    } else if (_enclosingAlias != null) {
      A_element = _findIdentifier(_enclosingAlias.typeParameters, A_parameterName);
    }
    processElement(A_element);
    return super.visitTypeParameter(node);
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    VariableElement A_element = null;
    SimpleIdentifier A_variableName = node.name;
    if (_enclosingExecutable != null) {
      A_element = _findIdentifier(_enclosingExecutable.localVariables, A_variableName);
    }
    if (A_element == null && _enclosingClass != null) {
      A_element = _findIdentifier(_enclosingClass.fields, A_variableName);
    }
    if (A_element == null && _enclosingUnit != null) {
      A_element = _findIdentifier(_enclosingUnit.topLevelVariables, A_variableName);
    }
    Expression initializer = node.initializer;
    if (initializer != null) {
      ExecutableElement outerExecutable = _enclosingExecutable;
      try {
        if (A_element == null) {} else {
          _enclosingExecutable = A_element.initializer;
        }
        processElement(A_element);
        processElement(_enclosingExecutable);
        return super.visitVariableDeclaration(node);
      } finally {
        _enclosingExecutable = outerExecutable;
      }
    }
    return super.visitVariableDeclaration(node);
  }
  void processElement(A_Element A_element) {
    if (A_element == null) {
      throw new DeclarationMatcher_DeclarationMismatchException();
    }
    if (!_allElements.contains(A_element)) {
      throw new DeclarationMatcher_DeclarationMismatchException();
    }
    _unmatchedElements.remove(A_element);
  }
  void _captureEnclosingElements(A_Element A_element) {
    A_Element A_parent = A_element is CompilationUnitElement ? A_element : A_element.enclosingElement;
    while (A_parent != null) {
      if (A_parent is CompilationUnitElement) {
        _enclosingUnit = A_parent as CompilationUnitElement;
      } else if (A_parent is ClassElement) {
        if (_enclosingClass == null) {
          _enclosingClass = A_parent as ClassElement;
        }
      } else if (A_parent is FunctionTypeAliasElement) {
        if (_enclosingAlias == null) {
          _enclosingAlias = A_parent as FunctionTypeAliasElement;
        }
      } else if (A_parent is ExecutableElement) {
        if (_enclosingExecutable == null) {
          _enclosingExecutable = A_parent as ExecutableElement;
        }
      } else if (A_parent is ParameterElement) {
        if (_enclosingParameter == null) {
          _enclosingParameter = A_parent as ParameterElement;
        }
      }
      A_parent = A_parent.enclosingElement;
    }
  }
  A_Element _findAtOffset(List<A_Element> elements, int A_offset) => _findWithNameAndOffset(elements, "", A_offset);
  ExportElement _findExport(List<ExportElement> exports, Source A_source) {
    for (ExportElement export in exports) {
      if (export.exportedLibrary.source == A_source) {
        return export;
      }
    }
    return null;
  }
  A_Element _findIdentifier(List<A_Element> elements, SimpleIdentifier identifier) => _findWithNameAndOffset(elements, identifier.name, identifier.offset);
  ImportElement _findImport(List<ImportElement> imports, Source A_source, SimpleIdentifier prefix) {
    for (ImportElement A_element in imports) {
      if (A_element.importedLibrary.source == A_source) {
        PrefixElement prefixElement = A_element.prefix;
        if (prefix == null) {
          if (prefixElement == null) {
            return A_element;
          }
        } else {
          if (prefixElement != null && prefix.name == prefixElement.displayName) {
            return A_element;
          }
        }
      }
    }
    return null;
  }
  CompilationUnitElement _findPart(List<CompilationUnitElement> parts, Source partSource) {
    for (CompilationUnitElement part in parts) {
      if (part.source == partSource) {
        return part;
      }
    }
    return null;
  }
  A_Element _findWithNameAndOffset(List<A_Element> elements, String A_name, int A_offset) {
    for (A_Element A_element in elements) {
      if (A_element.displayName == A_name && A_element.nameOffset == A_offset) {
        return A_element;
      }
    }
    return null;
  }
  void _gatherElements(A_Element A_element) {
    A_element.accept(new GeneralizingElementVisitor_DeclarationMatcher_gatherElements(this));
  }
  ParameterElement _getElementForParameter(FormalParameter node, SimpleIdentifier A_parameterName) {
    List<ParameterElement> A_parameters = null;
    if (_enclosingParameter != null) {
      A_parameters = _enclosingParameter.parameters;
    }
    if (A_parameters == null && _enclosingExecutable != null) {
      A_parameters = _enclosingExecutable.parameters;
    }
    if (A_parameters == null && _enclosingAlias != null) {
      A_parameters = _enclosingAlias.parameters;
    }
    return A_parameters == null ? null : _findIdentifier(A_parameters, A_parameterName);
  }
  String _getStringValue(StringLiteral literal) {
    if (literal is StringInterpolation) {
      return null;
    }
    return literal.stringValue;
  }
  bool _hasConstructor(ClassDeclaration node) {
    for (ClassMember member in node.members) {
      if (member is ConstructorDeclaration) {
        return true;
      }
    }
    return false;
  }
}
class DeclarationMatcher_DeclarationMismatchException extends RuntimeException {}
class ElementBuilder extends RecursiveAstVisitor<Object> {
  ElementHolder _currentHolder;
  bool _inFieldContext = false;
  bool _inFunction = false;
  bool _isValidMixin = false;
  List<FunctionTypeImpl> _functionTypesToFix = null;
  A_p.HashMap<String, FieldElement> A__fieldMap;
  ElementBuilder(ElementHolder initialHolder) {
    _currentHolder = initialHolder;
  }
  Object visitBlock(Block node) {
    bool wasInField = _inFieldContext;
    _inFieldContext = false;
    try {
      node.visitChildren(this);
    } finally {
      _inFieldContext = wasInField;
    }
    return null;
  }
  Object visitCatchClause(CatchClause node) {
    SimpleIdentifier exceptionParameter = node.exceptionParameter;
    if (exceptionParameter != null) {
      LocalVariableElementImpl exception = new LocalVariableElementImpl.forNode(exceptionParameter);
      _currentHolder.addLocalVariable(exception);
      exceptionParameter.staticElement = exception;
      SimpleIdentifier stackTraceParameter = node.stackTraceParameter;
      if (stackTraceParameter != null) {
        LocalVariableElementImpl A_stackTrace = new LocalVariableElementImpl.forNode(stackTraceParameter);
        _currentHolder.addLocalVariable(A_stackTrace);
        stackTraceParameter.staticElement = A_stackTrace;
      }
    }
    return super.visitCatchClause(node);
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ElementHolder holder = new ElementHolder();
    _isValidMixin = true;
    _functionTypesToFix = new List<FunctionTypeImpl>();
    ElementHolder previousHolder = _currentHolder;
    _currentHolder = holder;
    try {
      List<ClassMember> nonFields = new List<ClassMember>();
      node.visitChildren(new UnifyingAstVisitor_ElementBuilder_visitClassDeclaration(this, nonFields));
      _buildFieldMap(holder.fieldsWithoutFlushing);
      int count = nonFields.length;
      for (int i = 0; i < count; i++) {
        nonFields[i].accept(this);
      }
    } finally {
      _currentHolder = previousHolder;
    }
    SimpleIdentifier className = node.name;
    ClassElementImpl A_element = new ClassElementImpl.forNode(className);
    List<TypeParameterElement> typeParameters = holder.typeParameters;
    List<DartType> typeArguments = _createTypeParameterTypes(typeParameters);
    InterfaceTypeImpl interfaceType = new InterfaceTypeImpl.B_con1(A_element);
    interfaceType.typeArguments = typeArguments;
    A_element.type = interfaceType;
    List<ConstructorElement> constructors = holder.constructors;
    if (constructors.length == 0) {
      constructors = _createDefaultConstructors(interfaceType);
    }
    A_element.abstract = node.isAbstract;
    A_element.accessors = holder.accessors;
    A_element.constructors = constructors;
    A_element.fields = holder.fields;
    A_element.methods = holder.methods;
    A_element.typeParameters = typeParameters;
    A_element.validMixin = _isValidMixin;
    int functionTypeCount = _functionTypesToFix.length;
    for (int i = 0; i < functionTypeCount; i++) {
      _functionTypesToFix[i].typeArguments = typeArguments;
    }
    _functionTypesToFix = null;
    _currentHolder.addType(A_element);
    className.staticElement = A_element;
    A__fieldMap = null;
    holder.validate();
    return null;
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    ElementHolder holder = new ElementHolder();
    _functionTypesToFix = new List<FunctionTypeImpl>();
    _visitChildren(holder, node);
    SimpleIdentifier className = node.name;
    ClassElementImpl A_element = new ClassElementImpl.forNode(className);
    A_element.abstract = node.abstractKeyword != null;
    A_element.typedef = true;
    List<TypeParameterElement> typeParameters = holder.typeParameters;
    A_element.typeParameters = typeParameters;
    List<DartType> typeArguments = _createTypeParameterTypes(typeParameters);
    InterfaceTypeImpl interfaceType = new InterfaceTypeImpl.B_con1(A_element);
    interfaceType.typeArguments = typeArguments;
    A_element.type = interfaceType;
    A_element.constructors = _createDefaultConstructors(interfaceType);
    for (FunctionTypeImpl A_functionType in _functionTypesToFix) {
      A_functionType.typeArguments = typeArguments;
    }
    _functionTypesToFix = null;
    _currentHolder.addType(A_element);
    className.staticElement = A_element;
    holder.validate();
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    _isValidMixin = false;
    ElementHolder holder = new ElementHolder();
    bool wasInFunction = _inFunction;
    _inFunction = true;
    try {
      _visitChildren(holder, node);
    } finally {
      _inFunction = wasInFunction;
    }
    SimpleIdentifier constructorName = node.name;
    ConstructorElementImpl A_element = new ConstructorElementImpl.forNode(constructorName);
    if (node.factoryKeyword != null) {
      A_element.factory = true;
    }
    A_element.functions = holder.functions;
    A_element.labels = holder.labels;
    A_element.localVariables = holder.localVariables;
    A_element.parameters = holder.parameters;
    A_element.const2 = node.constKeyword != null;
    _currentHolder.addConstructor(A_element);
    node.element = A_element;
    if (constructorName == null) {
      Identifier A_returnType = node.returnType;
      if (A_returnType != null) {
        A_element.nameOffset = A_returnType.offset;
      }
    } else {
      constructorName.staticElement = A_element;
    }
    holder.validate();
    return null;
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    SimpleIdentifier A_variableName = node.identifier;
    A_Token keyword = node.keyword;
    LocalVariableElementImpl A_element = new LocalVariableElementImpl.forNode(A_variableName);
    ForEachStatement statement = node.parent as ForEachStatement;
    int declarationEnd = node.offset + node.length;
    int statementEnd = statement.offset + statement.length;
    A_element.setVisibleRange(declarationEnd, statementEnd - declarationEnd - 1);
    A_element.const3 = B__matches(keyword, Keyword.B_CONST);
    A_element.final2 = B__matches(keyword, Keyword.A_FINAL);
    _currentHolder.addLocalVariable(A_element);
    A_variableName.staticElement = A_element;
    return super.visitDeclaredIdentifier(node);
  }
  Object visitDefaultFormalParameter(DefaultFormalParameter node) {
    ElementHolder holder = new ElementHolder();
    NormalFormalParameter normalParameter = node.parameter;
    SimpleIdentifier A_parameterName = normalParameter.identifier;
    ParameterElementImpl parameter;
    if (normalParameter is FieldFormalParameter) {
      parameter = new DefaultFieldFormalParameterElementImpl(A_parameterName);
      FieldElement field = A__fieldMap == null ? null : A__fieldMap[A_parameterName.name];
      if (field != null) {
        (parameter as DefaultFieldFormalParameterElementImpl).field = field;
      }
    } else {
      parameter = new DefaultParameterElementImpl(A_parameterName);
    }
    parameter.const3 = node.isConst;
    parameter.final2 = node.isFinal;
    parameter.parameterKind = node.kind;
    Expression A_defaultValue = node.defaultValue;
    if (A_defaultValue != null) {
      A__visit(holder, A_defaultValue);
      FunctionElementImpl initializer = new FunctionElementImpl.forOffset(A_defaultValue.beginToken.offset);
      initializer.functions = holder.functions;
      initializer.labels = holder.labels;
      initializer.localVariables = holder.localVariables;
      initializer.parameters = holder.parameters;
      initializer.synthetic = true;
      parameter.initializer = initializer;
      parameter.setDefaultValueRange(A_defaultValue.offset, A_defaultValue.length);
    }
    _setParameterVisibleRange(node, parameter);
    _currentHolder.addParameter(parameter);
    A_parameterName.staticElement = parameter;
    normalParameter.accept(this);
    holder.validate();
    return null;
  }
  Object visitEnumDeclaration(EnumDeclaration node) {
    SimpleIdentifier enumName = node.name;
    ClassElementImpl enumElement = new ClassElementImpl.forNode(enumName);
    InterfaceTypeImpl enumType = new InterfaceTypeImpl.B_con1(enumElement);
    enumElement.type = enumType;
    _currentHolder.addEnum(enumElement);
    enumName.staticElement = enumElement;
    return super.visitEnumDeclaration(node);
  }
  Object visitFieldDeclaration(FieldDeclaration node) {
    bool wasInField = _inFieldContext;
    _inFieldContext = true;
    try {
      node.visitChildren(this);
    } finally {
      _inFieldContext = wasInField;
    }
    return null;
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      FieldElement field = A__fieldMap == null ? null : A__fieldMap[A_parameterName.name];
      FieldFormalParameterElementImpl parameter = new FieldFormalParameterElementImpl(A_parameterName);
      parameter.const3 = node.isConst;
      parameter.final2 = node.isFinal;
      parameter.parameterKind = node.kind;
      if (field != null) {
        parameter.field = field;
      }
      _currentHolder.addParameter(parameter);
      A_parameterName.staticElement = parameter;
    }
    ElementHolder holder = new ElementHolder();
    _visitChildren(holder, node);
    (node.element as ParameterElementImpl).parameters = holder.parameters;
    holder.validate();
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    FunctionExpression expression = node.functionExpression;
    if (expression != null) {
      ElementHolder holder = new ElementHolder();
      bool wasInFunction = _inFunction;
      _inFunction = true;
      try {
        _visitChildren(holder, expression);
      } finally {
        _inFunction = wasInFunction;
      }
      A_Token property = node.propertyKeyword;
      if (property == null) {
        SimpleIdentifier functionName = node.name;
        FunctionElementImpl A_element = new FunctionElementImpl.forNode(functionName);
        A_element.functions = holder.functions;
        A_element.labels = holder.labels;
        A_element.localVariables = holder.localVariables;
        A_element.parameters = holder.parameters;
        if (_inFunction) {
          Block enclosingBlock = node.getAncestor((node) => node is Block);
          if (enclosingBlock != null) {
            int functionEnd = node.offset + node.length;
            int blockEnd = enclosingBlock.offset + enclosingBlock.length;
            A_element.setVisibleRange(functionEnd, blockEnd - functionEnd - 1);
          }
        }
        _currentHolder.addFunction(A_element);
        expression.element = A_element;
        functionName.staticElement = A_element;
      } else {
        SimpleIdentifier propertyNameNode = node.name;
        if (propertyNameNode == null) {
          return null;
        }
        String propertyName = propertyNameNode.name;
        TopLevelVariableElementImpl variable = _currentHolder.getTopLevelVariable(propertyName) as TopLevelVariableElementImpl;
        if (variable == null) {
          variable = new TopLevelVariableElementImpl(node.name.name, -1);
          variable.final2 = true;
          variable.synthetic = true;
          _currentHolder.addTopLevelVariable(variable);
        }
        if (B__matches(property, Keyword.GET)) {
          PropertyAccessorElementImpl getter = new PropertyAccessorElementImpl.forNode(propertyNameNode);
          getter.functions = holder.functions;
          getter.labels = holder.labels;
          getter.localVariables = holder.localVariables;
          getter.variable = variable;
          getter.getter = true;
          getter.static = true;
          variable.getter = getter;
          _currentHolder.addAccessor(getter);
          expression.element = getter;
          propertyNameNode.staticElement = getter;
        } else {
          PropertyAccessorElementImpl setter = new PropertyAccessorElementImpl.forNode(propertyNameNode);
          setter.functions = holder.functions;
          setter.labels = holder.labels;
          setter.localVariables = holder.localVariables;
          setter.parameters = holder.parameters;
          setter.variable = variable;
          setter.setter = true;
          setter.static = true;
          variable.setter = setter;
          variable.final2 = false;
          _currentHolder.addAccessor(setter);
          expression.element = setter;
          propertyNameNode.staticElement = setter;
        }
      }
      holder.validate();
    }
    return null;
  }
  Object visitFunctionExpression(FunctionExpression node) {
    ElementHolder holder = new ElementHolder();
    bool wasInFunction = _inFunction;
    _inFunction = true;
    try {
      _visitChildren(holder, node);
    } finally {
      _inFunction = wasInFunction;
    }
    FunctionElementImpl A_element = new FunctionElementImpl.forOffset(node.beginToken.offset);
    A_element.functions = holder.functions;
    A_element.labels = holder.labels;
    A_element.localVariables = holder.localVariables;
    A_element.parameters = holder.parameters;
    if (_inFunction) {
      Block enclosingBlock = node.getAncestor((node) => node is Block);
      if (enclosingBlock != null) {
        int functionEnd = node.offset + node.length;
        int blockEnd = enclosingBlock.offset + enclosingBlock.length;
        A_element.setVisibleRange(functionEnd, blockEnd - functionEnd - 1);
      }
    }
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(A_element);
    if (_functionTypesToFix != null) {
      _functionTypesToFix.add(A_type);
    }
    A_element.type = A_type;
    _currentHolder.addFunction(A_element);
    node.element = A_element;
    holder.validate();
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    ElementHolder holder = new ElementHolder();
    _visitChildren(holder, node);
    SimpleIdentifier aliasName = node.name;
    List<ParameterElement> A_parameters = holder.parameters;
    List<TypeParameterElement> typeParameters = holder.typeParameters;
    FunctionTypeAliasElementImpl A_element = new FunctionTypeAliasElementImpl(aliasName);
    A_element.parameters = A_parameters;
    A_element.typeParameters = typeParameters;
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con2(A_element);
    A_type.typeArguments = _createTypeParameterTypes(typeParameters);
    A_element.type = A_type;
    _currentHolder.addTypeAlias(A_element);
    aliasName.staticElement = A_element;
    holder.validate();
    return null;
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      ParameterElementImpl parameter = new ParameterElementImpl.forNode(A_parameterName);
      parameter.parameterKind = node.kind;
      _setParameterVisibleRange(node, parameter);
      _currentHolder.addParameter(parameter);
      A_parameterName.staticElement = parameter;
    }
    ElementHolder holder = new ElementHolder();
    _visitChildren(holder, node);
    (node.element as ParameterElementImpl).parameters = holder.parameters;
    holder.validate();
    return null;
  }
  Object visitLabeledStatement(LabeledStatement node) {
    bool onSwitchStatement = node.statement is SwitchStatement;
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElementImpl A_element = new LabelElementImpl(labelName, onSwitchStatement, false);
      _currentHolder.addLabel(A_element);
      labelName.staticElement = A_element;
    }
    return super.visitLabeledStatement(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    try {
      ElementHolder holder = new ElementHolder();
      bool wasInFunction = _inFunction;
      _inFunction = true;
      try {
        _visitChildren(holder, node);
      } finally {
        _inFunction = wasInFunction;
      }
      bool A_isStatic = node.isStatic;
      A_Token property = node.propertyKeyword;
      if (property == null) {
        SimpleIdentifier methodName = node.name;
        String nameOfMethod = methodName.name;
        if (nameOfMethod == A_TokenType.MINUS.lexeme && node.parameters.parameters.length == 0) {
          nameOfMethod = "unary-";
        }
        MethodElementImpl A_element = new MethodElementImpl(nameOfMethod, methodName.offset);
        A_element.abstract = node.isAbstract;
        A_element.functions = holder.functions;
        A_element.labels = holder.labels;
        A_element.localVariables = holder.localVariables;
        A_element.parameters = holder.parameters;
        A_element.static = A_isStatic;
        _currentHolder.addMethod(A_element);
        methodName.staticElement = A_element;
      } else {
        SimpleIdentifier propertyNameNode = node.name;
        String propertyName = propertyNameNode.name;
        FieldElementImpl field = _currentHolder.getField(propertyName) as FieldElementImpl;
        if (field == null) {
          field = new FieldElementImpl(node.name.name, -1);
          field.final2 = true;
          field.static = A_isStatic;
          field.synthetic = true;
          _currentHolder.addField(field);
        }
        if (B__matches(property, Keyword.GET)) {
          PropertyAccessorElementImpl getter = new PropertyAccessorElementImpl.forNode(propertyNameNode);
          getter.functions = holder.functions;
          getter.labels = holder.labels;
          getter.localVariables = holder.localVariables;
          getter.variable = field;
          getter.abstract = node.body is EmptyFunctionBody && node.externalKeyword == null;
          getter.getter = true;
          getter.static = A_isStatic;
          field.getter = getter;
          _currentHolder.addAccessor(getter);
          propertyNameNode.staticElement = getter;
        } else {
          PropertyAccessorElementImpl setter = new PropertyAccessorElementImpl.forNode(propertyNameNode);
          setter.functions = holder.functions;
          setter.labels = holder.labels;
          setter.localVariables = holder.localVariables;
          setter.parameters = holder.parameters;
          setter.variable = field;
          setter.abstract = node.body is EmptyFunctionBody && !B__matches(node.externalKeyword, Keyword.EXTERNAL);
          setter.setter = true;
          setter.static = A_isStatic;
          field.setter = setter;
          field.final2 = false;
          _currentHolder.addAccessor(setter);
          propertyNameNode.staticElement = setter;
        }
      }
      holder.validate();
    } catch (ex) {
      if (node.name.staticElement == null) {
        ClassDeclaration classNode = node.getAncestor((node) => node is ClassDeclaration);
        JavaStringBuilder A_builder = new JavaStringBuilder();
        A_builder.append("The element for the method ");
        A_builder.append(node.name);
        A_builder.append(" in ");
        A_builder.append(classNode.name);
        A_builder.append(" was not set while trying to build the element model.");
        AnalysisEngine.A_instance.logger.logError2(A_builder.toString(), new AnalysisException(A_builder.toString(), new CaughtException(ex, null)));
      } else {
        String A_message = "Exception caught in ElementBuilder.visitMethodDeclaration()";
        AnalysisEngine.A_instance.logger.logError2(A_message, new AnalysisException(A_message, new CaughtException(ex, null)));
      }
    } finally {
      if (node.name.staticElement == null) {
        ClassDeclaration classNode = node.getAncestor((node) => node is ClassDeclaration);
        JavaStringBuilder A_builder = new JavaStringBuilder();
        A_builder.append("The element for the method ");
        A_builder.append(node.name);
        A_builder.append(" in ");
        A_builder.append(classNode.name);
        A_builder.append(" was not set while trying to resolve types.");
        AnalysisEngine.A_instance.logger.logError2(A_builder.toString(), new CaughtException(new AnalysisException(A_builder.toString()), null));
      }
    }
    return null;
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    if (node.parent is! DefaultFormalParameter) {
      SimpleIdentifier A_parameterName = node.identifier;
      ParameterElementImpl parameter = new ParameterElementImpl.forNode(A_parameterName);
      parameter.const3 = node.isConst;
      parameter.final2 = node.isFinal;
      parameter.parameterKind = node.kind;
      _setParameterVisibleRange(node, parameter);
      _currentHolder.addParameter(parameter);
      A_parameterName.staticElement = parameter;
    }
    return super.visitSimpleFormalParameter(node);
  }
  Object visitSuperExpression(SuperExpression node) {
    _isValidMixin = false;
    return super.visitSuperExpression(node);
  }
  Object visitSwitchCase(SwitchCase node) {
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElementImpl A_element = new LabelElementImpl(labelName, false, true);
      _currentHolder.addLabel(A_element);
      labelName.staticElement = A_element;
    }
    return super.visitSwitchCase(node);
  }
  Object visitSwitchDefault(SwitchDefault node) {
    for (Label label in node.labels) {
      SimpleIdentifier labelName = label.label;
      LabelElementImpl A_element = new LabelElementImpl(labelName, false, true);
      _currentHolder.addLabel(A_element);
      labelName.staticElement = A_element;
    }
    return super.visitSwitchDefault(node);
  }
  Object visitTypeParameter(TypeParameter node) {
    SimpleIdentifier A_parameterName = node.name;
    TypeParameterElementImpl typeParameter = new TypeParameterElementImpl.forNode(A_parameterName);
    TypeParameterTypeImpl typeParameterType = new TypeParameterTypeImpl(typeParameter);
    typeParameter.type = typeParameterType;
    _currentHolder.addTypeParameter(typeParameter);
    A_parameterName.staticElement = typeParameter;
    return super.visitTypeParameter(node);
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    A_Token keyword = (node.parent as VariableDeclarationList).keyword;
    bool A_isConst = B__matches(keyword, Keyword.B_CONST);
    bool A_isFinal = B__matches(keyword, Keyword.A_FINAL);
    bool hasInitializer = node.initializer != null;
    VariableElementImpl A_element;
    if (_inFieldContext) {
      SimpleIdentifier fieldName = node.name;
      FieldElementImpl field;
      if (A_isConst && hasInitializer) {
        field = new ConstFieldElementImpl.B_con1(fieldName);
      } else {
        field = new FieldElementImpl.forNode(fieldName);
      }
      A_element = field;
      _currentHolder.addField(field);
      fieldName.staticElement = field;
    } else if (_inFunction) {
      SimpleIdentifier A_variableName = node.name;
      LocalVariableElementImpl variable;
      if (A_isConst && hasInitializer) {
        variable = new ConstLocalVariableElementImpl(A_variableName);
      } else {
        variable = new LocalVariableElementImpl.forNode(A_variableName);
      }
      A_element = variable;
      Block enclosingBlock = node.getAncestor((node) => node is Block);
      int functionEnd = node.offset + node.length;
      int blockEnd = enclosingBlock.offset + enclosingBlock.length;
      variable.setVisibleRange(functionEnd, blockEnd - functionEnd - 1);
      _currentHolder.addLocalVariable(variable);
      A_variableName.staticElement = A_element;
    } else {
      SimpleIdentifier A_variableName = node.name;
      TopLevelVariableElementImpl variable;
      if (A_isConst && hasInitializer) {
        variable = new ConstTopLevelVariableElementImpl(A_variableName);
      } else {
        variable = new TopLevelVariableElementImpl.forNode(A_variableName);
      }
      A_element = variable;
      _currentHolder.addTopLevelVariable(variable);
      A_variableName.staticElement = A_element;
    }
    A_element.const3 = A_isConst;
    A_element.final2 = A_isFinal;
    if (hasInitializer) {
      ElementHolder holder = new ElementHolder();
      bool wasInFieldContext = _inFieldContext;
      _inFieldContext = false;
      try {
        A__visit(holder, node.initializer);
      } finally {
        _inFieldContext = wasInFieldContext;
      }
      FunctionElementImpl initializer = new FunctionElementImpl.forOffset(node.initializer.beginToken.offset);
      initializer.functions = holder.functions;
      initializer.labels = holder.labels;
      initializer.localVariables = holder.localVariables;
      initializer.synthetic = true;
      A_element.initializer = initializer;
      holder.validate();
    }
    if (A_element is PropertyInducingElementImpl) {
      PropertyInducingElementImpl variable = A_element as PropertyInducingElementImpl;
      if (_inFieldContext) {
        (variable as FieldElementImpl).static = B__matches((node.parent.parent as FieldDeclaration).staticKeyword, Keyword.A_STATIC);
      }
      PropertyAccessorElementImpl getter = new PropertyAccessorElementImpl.forVariable(variable);
      getter.getter = true;
      getter.static = variable.isStatic;
      _currentHolder.addAccessor(getter);
      variable.getter = getter;
      if (!A_isFinal) {
        PropertyAccessorElementImpl setter = new PropertyAccessorElementImpl.forVariable(variable);
        setter.setter = true;
        setter.static = variable.isStatic;
        ParameterElementImpl parameter = new ParameterElementImpl("_${variable.name}", variable.nameOffset);
        parameter.synthetic = true;
        parameter.parameterKind = ParameterKind.REQUIRED;
        setter.parameters = <ParameterElement>[parameter];
        _currentHolder.addAccessor(setter);
        variable.setter = setter;
      }
    }
    return null;
  }
  void _buildFieldMap(List<FieldElement> fields) {
    A__fieldMap = new A_p.HashMap<String,FieldElement>();
    int count = fields.length;
    for (int i = 0; i < count; i++) {
      FieldElement field = fields[i];
      A__fieldMap[field.name] = field;
    }
  }
  List<ConstructorElement> _createDefaultConstructors(InterfaceTypeImpl interfaceType) {
    ConstructorElementImpl constructor = new ConstructorElementImpl.forNode(null);
    constructor.synthetic = true;
    constructor.returnType = interfaceType;
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(constructor);
    _functionTypesToFix.add(A_type);
    constructor.type = A_type;
    return <ConstructorElement>[constructor];
  }
  List<DartType> _createTypeParameterTypes(List<TypeParameterElement> typeParameters) {
    int typeParameterCount = typeParameters.length;
    List<DartType> typeArguments = new List<DartType>(typeParameterCount);
    for (int i = 0; i < typeParameterCount; i++) {
      TypeParameterElementImpl typeParameter = typeParameters[i] as TypeParameterElementImpl;
      TypeParameterTypeImpl typeParameterType = new TypeParameterTypeImpl(typeParameter);
      typeParameter.type = typeParameterType;
      typeArguments[i] = typeParameterType;
    }
    return typeArguments;
  }
  FunctionBody _getFunctionBody(FormalParameter node) {
    AstNode A_parent = node.parent;
    while (A_parent != null) {
      if (A_parent is ConstructorDeclaration) {
        return (A_parent as ConstructorDeclaration).body;
      } else if (A_parent is FunctionExpression) {
        return (A_parent as FunctionExpression).body;
      } else if (A_parent is MethodDeclaration) {
        return (A_parent as MethodDeclaration).body;
      }
      A_parent = A_parent.parent;
    }
    return null;
  }
  bool B__matches(A_Token token, Keyword keyword) => token != null && token.type == A_TokenType.A_KEYWORD && (token as KeywordToken).keyword == keyword;
  void _setParameterVisibleRange(FormalParameter node, ParameterElementImpl A_element) {
    FunctionBody body = _getFunctionBody(node);
    if (body != null) {
      A_element.setVisibleRange(body.offset, body.length);
    }
  }
  void A__visit(ElementHolder holder, AstNode node) {
    if (node != null) {
      ElementHolder previousHolder = _currentHolder;
      _currentHolder = holder;
      try {
        node.accept(this);
      } finally {
        _currentHolder = previousHolder;
      }
    }
  }
  void _visitChildren(ElementHolder holder, AstNode node) {
    if (node != null) {
      ElementHolder previousHolder = _currentHolder;
      _currentHolder = holder;
      try {
        node.visitChildren(this);
      } finally {
        _currentHolder = previousHolder;
      }
    }
  }
}
class ElementHolder {
  List<PropertyAccessorElement> A__accessors;
  List<ConstructorElement> A__constructors;
  List<ClassElement> A__enums;
  List<FieldElement> A__fields;
  List<FunctionElement> A__functions;
  List<LabelElement> B__labels;
  List<VariableElement> A__localVariables;
  List<MethodElement> A__methods;
  List<ParameterElement> C__parameters;
  List<TopLevelVariableElement> _topLevelVariables;
  List<ClassElement> A__types;
  List<FunctionTypeAliasElement> A__typeAliases;
  List<TypeParameterElement> B__typeParameters;
  void addAccessor(PropertyAccessorElement A_element) {
    if (A__accessors == null) {
      A__accessors = new List<PropertyAccessorElement>();
    }
    A__accessors.add(A_element);
  }
  void addConstructor(ConstructorElement A_element) {
    if (A__constructors == null) {
      A__constructors = new List<ConstructorElement>();
    }
    A__constructors.add(A_element);
  }
  void addEnum(ClassElement A_element) {
    if (A__enums == null) {
      A__enums = new List<ClassElement>();
    }
    A__enums.add(A_element);
  }
  void addField(FieldElement A_element) {
    if (A__fields == null) {
      A__fields = new List<FieldElement>();
    }
    A__fields.add(A_element);
  }
  void addFunction(FunctionElement A_element) {
    if (A__functions == null) {
      A__functions = new List<FunctionElement>();
    }
    A__functions.add(A_element);
  }
  void addLabel(LabelElement A_element) {
    if (B__labels == null) {
      B__labels = new List<LabelElement>();
    }
    B__labels.add(A_element);
  }
  void addLocalVariable(LocalVariableElement A_element) {
    if (A__localVariables == null) {
      A__localVariables = new List<VariableElement>();
    }
    A__localVariables.add(A_element);
  }
  void addMethod(MethodElement A_element) {
    if (A__methods == null) {
      A__methods = new List<MethodElement>();
    }
    A__methods.add(A_element);
  }
  void addParameter(ParameterElement A_element) {
    if (C__parameters == null) {
      C__parameters = new List<ParameterElement>();
    }
    C__parameters.add(A_element);
  }
  void addTopLevelVariable(TopLevelVariableElement A_element) {
    if (_topLevelVariables == null) {
      _topLevelVariables = new List<TopLevelVariableElement>();
    }
    _topLevelVariables.add(A_element);
  }
  void addType(ClassElement A_element) {
    if (A__types == null) {
      A__types = new List<ClassElement>();
    }
    A__types.add(A_element);
  }
  void addTypeAlias(FunctionTypeAliasElement A_element) {
    if (A__typeAliases == null) {
      A__typeAliases = new List<FunctionTypeAliasElement>();
    }
    A__typeAliases.add(A_element);
  }
  void addTypeParameter(TypeParameterElement A_element) {
    if (B__typeParameters == null) {
      B__typeParameters = new List<TypeParameterElement>();
    }
    B__typeParameters.add(A_element);
  }
  List<PropertyAccessorElement> get accessors {
    if (A__accessors == null) {
      return PropertyAccessorElementImpl.B_EMPTY_ARRAY;
    }
    List<PropertyAccessorElement> result = new List.from(A__accessors);
    A__accessors = null;
    return result;
  }
  List<ConstructorElement> get constructors {
    if (A__constructors == null) {
      return ConstructorElementImpl.B_EMPTY_ARRAY;
    }
    List<ConstructorElement> result = new List.from(A__constructors);
    A__constructors = null;
    return result;
  }
  List<ClassElement> get enums {
    if (A__enums == null) {
      return ClassElementImpl.B_EMPTY_ARRAY;
    }
    List<ClassElement> result = new List.from(A__enums);
    A__enums = null;
    return result;
  }
  FieldElement getField(String fieldName) {
    if (A__fields == null) {
      return null;
    }
    for (FieldElement field in A__fields) {
      if (field.name == fieldName) {
        return field;
      }
    }
    return null;
  }
  List<FieldElement> get fields {
    if (A__fields == null) {
      return FieldElementImpl.B_EMPTY_ARRAY;
    }
    List<FieldElement> result = new List.from(A__fields);
    A__fields = null;
    return result;
  }
  List<FieldElement> get fieldsWithoutFlushing {
    if (A__fields == null) {
      return FieldElementImpl.B_EMPTY_ARRAY;
    }
    List<FieldElement> result = new List.from(A__fields);
    return result;
  }
  List<FunctionElement> get functions {
    if (A__functions == null) {
      return FunctionElementImpl.B_EMPTY_ARRAY;
    }
    List<FunctionElement> result = new List.from(A__functions);
    A__functions = null;
    return result;
  }
  List<LabelElement> get labels {
    if (B__labels == null) {
      return LabelElementImpl.B_EMPTY_ARRAY;
    }
    List<LabelElement> result = new List.from(B__labels);
    B__labels = null;
    return result;
  }
  List<LocalVariableElement> get localVariables {
    if (A__localVariables == null) {
      return LocalVariableElementImpl.B_EMPTY_ARRAY;
    }
    List<LocalVariableElement> result = new List.from(A__localVariables);
    A__localVariables = null;
    return result;
  }
  List<MethodElement> get methods {
    if (A__methods == null) {
      return MethodElementImpl.B_EMPTY_ARRAY;
    }
    List<MethodElement> result = new List.from(A__methods);
    A__methods = null;
    return result;
  }
  List<ParameterElement> get parameters {
    if (C__parameters == null) {
      return ParameterElementImpl.B_EMPTY_ARRAY;
    }
    List<ParameterElement> result = new List.from(C__parameters);
    C__parameters = null;
    return result;
  }
  TopLevelVariableElement getTopLevelVariable(String A_variableName) {
    if (_topLevelVariables == null) {
      return null;
    }
    for (TopLevelVariableElement variable in _topLevelVariables) {
      if (variable.name == A_variableName) {
        return variable;
      }
    }
    return null;
  }
  List<TopLevelVariableElement> get topLevelVariables {
    if (_topLevelVariables == null) {
      return TopLevelVariableElementImpl.B_EMPTY_ARRAY;
    }
    List<TopLevelVariableElement> result = new List.from(_topLevelVariables);
    _topLevelVariables = null;
    return result;
  }
  List<FunctionTypeAliasElement> get typeAliases {
    if (A__typeAliases == null) {
      return FunctionTypeAliasElementImpl.B_EMPTY_ARRAY;
    }
    List<FunctionTypeAliasElement> result = new List.from(A__typeAliases);
    A__typeAliases = null;
    return result;
  }
  List<TypeParameterElement> get typeParameters {
    if (B__typeParameters == null) {
      return TypeParameterElementImpl.B_EMPTY_ARRAY;
    }
    List<TypeParameterElement> result = new List.from(B__typeParameters);
    B__typeParameters = null;
    return result;
  }
  List<ClassElement> get types {
    if (A__types == null) {
      return ClassElementImpl.B_EMPTY_ARRAY;
    }
    List<ClassElement> result = new List.from(A__types);
    A__types = null;
    return result;
  }
  void validate() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    if (A__accessors != null) {
      A_builder.append(A__accessors.length);
      A_builder.append(" accessors");
    }
    if (A__constructors != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__constructors.length);
      A_builder.append(" constructors");
    }
    if (A__fields != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__fields.length);
      A_builder.append(" fields");
    }
    if (A__functions != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__functions.length);
      A_builder.append(" functions");
    }
    if (B__labels != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(B__labels.length);
      A_builder.append(" labels");
    }
    if (A__localVariables != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__localVariables.length);
      A_builder.append(" local variables");
    }
    if (A__methods != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__methods.length);
      A_builder.append(" methods");
    }
    if (C__parameters != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(C__parameters.length);
      A_builder.append(" parameters");
    }
    if (_topLevelVariables != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(_topLevelVariables.length);
      A_builder.append(" top-level variables");
    }
    if (A__types != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__types.length);
      A_builder.append(" types");
    }
    if (A__typeAliases != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(A__typeAliases.length);
      A_builder.append(" type aliases");
    }
    if (B__typeParameters != null) {
      if (A_builder.length > 0) {
        A_builder.append("; ");
      }
      A_builder.append(B__typeParameters.length);
      A_builder.append(" type parameters");
    }
    if (A_builder.length > 0) {
      AnalysisEngine.A_instance.logger.logError("Failed to capture elements: ${A_builder.toString()}");
    }
  }
}
class ElementResolver extends SimpleAstVisitor<Object> {
  static ClassElementImpl getTypeReference(Expression expression) {
    if (expression is Identifier) {
      A_Element staticElement = expression.staticElement;
      if (staticElement is ClassElementImpl) {
        return staticElement;
      }
    }
    return null;
  }
  static bool _isConstructorReturnType(SimpleIdentifier identifier) {
    AstNode A_parent = identifier.parent;
    if (A_parent is ConstructorDeclaration) {
      return identical(A_parent.returnType, identifier);
    }
    return false;
  }
  static bool _isFactoryConstructorReturnType(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    if (A_parent is ConstructorDeclaration) {
      ConstructorDeclaration constructor = A_parent;
      return identical(constructor.returnType, node) && constructor.factoryKeyword != null;
    }
    return false;
  }
  static bool _isSuperInValidContext(SuperExpression node) {
    for (AstNode n = node; n != null; n = n.parent) {
      if (n is CompilationUnit) {
        return false;
      }
      if (n is ConstructorDeclaration) {
        ConstructorDeclaration constructor = n as ConstructorDeclaration;
        return constructor.factoryKeyword == null;
      }
      if (n is ConstructorFieldInitializer) {
        return false;
      }
      if (n is MethodDeclaration) {
        MethodDeclaration A_method = n as MethodDeclaration;
        return !A_method.isStatic;
      }
    }
    return false;
  }
  final ResolverVisitor A__resolver;
  LibraryElement _definingLibrary;
  bool _enableHints = false;
  DartType _dynamicType;
  DartType _typeType;
  SubtypeManager _subtypeManager;
  TypePromotionManager _promoteManager;
  ElementResolver(this.A__resolver) {
    this._definingLibrary = A__resolver.definingLibrary;
    AnalysisOptions options = _definingLibrary.context.analysisOptions;
    _enableHints = options.hint;
    _dynamicType = A__resolver.typeProvider.dynamicType;
    _typeType = A__resolver.typeProvider.typeType;
    _subtypeManager = new SubtypeManager();
    _promoteManager = A__resolver.promoteManager;
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    A_Token operator = node.operator;
    A_TokenType operatorType = operator.type;
    if (operatorType != A_TokenType.A_EQ) {
      operatorType = _operatorFromCompoundAssignment(operatorType);
      Expression leftHandSide = node.leftHandSide;
      if (leftHandSide != null) {
        String methodName = operatorType.lexeme;
        DartType staticType = _getStaticType(leftHandSide);
        MethodElement staticMethod = _lookUpMethod(leftHandSide, staticType, methodName);
        node.staticElement = staticMethod;
        DartType propagatedType = _getPropagatedType(leftHandSide);
        MethodElement propagatedMethod = _lookUpMethod(leftHandSide, propagatedType, methodName);
        node.propagatedElement = propagatedMethod;
        if (_shouldReportMissingMember(staticType, staticMethod)) {
          if (_doesClassElementHaveProxy(staticType.element)) {
            A__resolver.reportErrorForToken(StaticTypeWarningCode.UNDEFINED_METHOD, operator, [methodName, staticType.displayName]);
          }
        } else if (_enableHints && _shouldReportMissingMember(propagatedType, propagatedMethod) && !_memberFoundInSubclass(propagatedType.element, methodName, true, false)) {
          if (_doesClassElementHaveProxy(propagatedType.element)) {
            A__resolver.reportErrorForToken(HintCode.UNDEFINED_METHOD, operator, [methodName, propagatedType.displayName]);
          }
        }
      }
    }
    return null;
  }
  Object visitBinaryExpression(BinaryExpression node) {
    A_Token operator = node.operator;
    if (operator.isUserDefinableOperator) {
      Expression leftOperand = node.leftOperand;
      if (leftOperand != null) {
        String methodName = operator.lexeme;
        DartType staticType = _getStaticType(leftOperand);
        MethodElement staticMethod = _lookUpMethod(leftOperand, staticType, methodName);
        node.staticElement = staticMethod;
        DartType propagatedType = _getPropagatedType(leftOperand);
        MethodElement propagatedMethod = _lookUpMethod(leftOperand, propagatedType, methodName);
        node.propagatedElement = propagatedMethod;
        if (_shouldReportMissingMember(staticType, staticMethod)) {
          if (_doesClassElementHaveProxy(staticType.element)) {
            A__resolver.reportErrorForToken(StaticTypeWarningCode.UNDEFINED_OPERATOR, operator, [methodName, staticType.displayName]);
          }
        } else if (_enableHints && _shouldReportMissingMember(propagatedType, propagatedMethod) && !_memberFoundInSubclass(propagatedType.element, methodName, true, false)) {
          if (_doesClassElementHaveProxy(propagatedType.element)) {
            A__resolver.reportErrorForToken(HintCode.UNDEFINED_OPERATOR, operator, [methodName, propagatedType.displayName]);
          }
        }
      }
    }
    return null;
  }
  Object visitBreakStatement(BreakStatement node) {
    _lookupLabel(node, node.label);
    return null;
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitCommentReference(CommentReference node) {
    Identifier identifier = node.identifier;
    if (identifier is SimpleIdentifier) {
      SimpleIdentifier simpleIdentifier = identifier;
      A_Element A_element = _resolveSimpleIdentifier(simpleIdentifier);
      if (A_element == null) {
        A_element = _findImportWithoutPrefix(simpleIdentifier);
        if (A_element is MultiplyDefinedElement) {
          A_element = null;
        }
      }
      if (A_element == null) {} else {
        if (A_element.library == null || A_element.library != _definingLibrary) {}
        simpleIdentifier.staticElement = A_element;
        if (node.newKeyword != null) {
          if (A_element is ClassElement) {
            ConstructorElement constructor = (A_element as ClassElement).unnamedConstructor;
            if (constructor == null) {} else {
              simpleIdentifier.staticElement = constructor;
            }
          } else {}
        }
      }
    } else if (identifier is PrefixedIdentifier) {
      PrefixedIdentifier prefixedIdentifier = identifier;
      SimpleIdentifier prefix = prefixedIdentifier.prefix;
      SimpleIdentifier A_name = prefixedIdentifier.identifier;
      A_Element A_element = _resolveSimpleIdentifier(prefix);
      if (A_element == null) {} else {
        if (A_element is PrefixElement) {
          prefix.staticElement = A_element;
          A_element = A__resolver.nameScope.lookup(identifier, _definingLibrary);
          A_name.staticElement = A_element;
          return null;
        }
        LibraryElement library = A_element.library;
        if (library == null) {
          AnalysisEngine.A_instance.logger.logError("Found element with null library: ${A_element.name}");
        } else if (library != _definingLibrary) {}
        A_name.staticElement = A_element;
        if (node.newKeyword == null) {
          if (A_element is ClassElement) {
            A_Element memberElement = _lookupGetterOrMethod((A_element as ClassElement).type, A_name.name);
            if (memberElement == null) {
              memberElement = (A_element as ClassElement).getNamedConstructor(A_name.name);
              if (memberElement == null) {
                memberElement = _lookUpSetter(prefix, (A_element as ClassElement).type, A_name.name);
              }
            }
            if (memberElement == null) {} else {
              A_name.staticElement = memberElement;
            }
          } else {}
        } else {
          if (A_element is ClassElement) {
            ConstructorElement constructor = (A_element as ClassElement).getNamedConstructor(A_name.name);
            if (constructor == null) {} else {
              A_name.staticElement = constructor;
            }
          } else {}
        }
      }
    }
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    super.visitConstructorDeclaration(node);
    ConstructorElement A_element = node.element;
    if (A_element is ConstructorElementImpl) {
      ConstructorElementImpl constructorElement = A_element;
      ConstructorName redirectedNode = node.redirectedConstructor;
      if (redirectedNode != null) {
        ConstructorElement redirectedElement = redirectedNode.staticElement;
        constructorElement.redirectedConstructor = redirectedElement;
      } else {
        for (ConstructorInitializer initializer in node.initializers) {
          if (initializer is RedirectingConstructorInvocation) {
            ConstructorElement redirectedElement = initializer.staticElement;
            constructorElement.redirectedConstructor = redirectedElement;
          }
        }
      }
      _setMetadata(constructorElement, node);
    }
    return null;
  }
  Object visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    SimpleIdentifier fieldName = node.fieldName;
    ClassElement enclosingClass = A__resolver.enclosingClass;
    FieldElement fieldElement = enclosingClass.getField(fieldName.name);
    fieldName.staticElement = fieldElement;
    return null;
  }
  Object visitConstructorName(ConstructorName node) {
    DartType A_type = node.type.type;
    if (A_type != null && A_type.isDynamic) {
      return null;
    } else if (A_type is! InterfaceType) {
      return null;
    }
    ConstructorElement constructor;
    SimpleIdentifier A_name = node.name;
    InterfaceType interfaceType = A_type as InterfaceType;
    if (A_name == null) {
      constructor = interfaceType.lookUpConstructor(null, _definingLibrary);
    } else {
      constructor = interfaceType.lookUpConstructor(A_name.name, _definingLibrary);
      A_name.staticElement = constructor;
    }
    node.staticElement = constructor;
    return null;
  }
  Object visitContinueStatement(ContinueStatement node) {
    _lookupLabel(node, node.label);
    return null;
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitExportDirective(ExportDirective node) {
    ExportElement exportElement = node.element;
    if (exportElement != null) {
      _resolveCombinators(exportElement.exportedLibrary, node.combinators);
      _setMetadata(exportElement, node);
    }
    return null;
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    _setMetadataForParameter(node.element, node);
    return super.visitFieldFormalParameter(node);
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    Expression expression = node.function;
    if (expression is FunctionExpression) {
      FunctionExpression functionExpression = expression;
      ExecutableElement functionElement = functionExpression.element;
      ArgumentList argumentList = node.argumentList;
      List<ParameterElement> A_parameters = _resolveArgumentsToFunction(false, argumentList, functionElement);
      if (A_parameters != null) {
        argumentList.correspondingStaticParameters = A_parameters;
      }
    }
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    _setMetadataForParameter(node.element, node);
    return null;
  }
  Object visitImportDirective(ImportDirective node) {
    SimpleIdentifier prefixNode = node.prefix;
    if (prefixNode != null) {
      String prefixName = prefixNode.name;
      for (PrefixElement prefixElement in _definingLibrary.prefixes) {
        if (prefixElement.displayName == prefixName) {
          prefixNode.staticElement = prefixElement;
          break;
        }
      }
    }
    ImportElement importElement = node.element;
    if (importElement != null) {
      LibraryElement library = importElement.importedLibrary;
      if (library != null) {
        _resolveCombinators(library, node.combinators);
      }
      _setMetadata(importElement, node);
    }
    return null;
  }
  Object visitIndexExpression(IndexExpression node) {
    Expression A_target = node.realTarget;
    DartType staticType = _getStaticType(A_target);
    DartType propagatedType = _getPropagatedType(A_target);
    String getterMethodName = A_TokenType.INDEX.lexeme;
    String setterMethodName = A_TokenType.INDEX_EQ.lexeme;
    bool isInGetterContext = node.inGetterContext();
    bool isInSetterContext = node.inSetterContext();
    if (isInGetterContext && isInSetterContext) {
      MethodElement setterStaticMethod = _lookUpMethod(A_target, staticType, setterMethodName);
      MethodElement setterPropagatedMethod = _lookUpMethod(A_target, propagatedType, setterMethodName);
      node.staticElement = setterStaticMethod;
      node.propagatedElement = setterPropagatedMethod;
      _checkForUndefinedIndexOperator(node, A_target, getterMethodName, setterStaticMethod, setterPropagatedMethod, staticType, propagatedType);
      MethodElement getterStaticMethod = _lookUpMethod(A_target, staticType, getterMethodName);
      MethodElement getterPropagatedMethod = _lookUpMethod(A_target, propagatedType, getterMethodName);
      AuxiliaryElements auxiliaryElements = new AuxiliaryElements(getterStaticMethod, getterPropagatedMethod);
      node.auxiliaryElements = auxiliaryElements;
      _checkForUndefinedIndexOperator(node, A_target, getterMethodName, getterStaticMethod, getterPropagatedMethod, staticType, propagatedType);
    } else if (isInGetterContext) {
      MethodElement staticMethod = _lookUpMethod(A_target, staticType, getterMethodName);
      MethodElement propagatedMethod = _lookUpMethod(A_target, propagatedType, getterMethodName);
      node.staticElement = staticMethod;
      node.propagatedElement = propagatedMethod;
      _checkForUndefinedIndexOperator(node, A_target, getterMethodName, staticMethod, propagatedMethod, staticType, propagatedType);
    } else if (isInSetterContext) {
      MethodElement staticMethod = _lookUpMethod(A_target, staticType, setterMethodName);
      MethodElement propagatedMethod = _lookUpMethod(A_target, propagatedType, setterMethodName);
      node.staticElement = staticMethod;
      node.propagatedElement = propagatedMethod;
      _checkForUndefinedIndexOperator(node, A_target, setterMethodName, staticMethod, propagatedMethod, staticType, propagatedType);
    }
    return null;
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    ConstructorElement invokedConstructor = node.constructorName.staticElement;
    node.staticElement = invokedConstructor;
    ArgumentList argumentList = node.argumentList;
    List<ParameterElement> A_parameters = _resolveArgumentsToFunction(node.isConst, argumentList, invokedConstructor);
    if (A_parameters != null) {
      argumentList.correspondingStaticParameters = A_parameters;
    }
    return null;
  }
  Object visitLibraryDirective(LibraryDirective node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitMethodInvocation(MethodInvocation node) {
    SimpleIdentifier methodName = node.methodName;
    if (methodName.isSynthetic) {
      return null;
    }
    Expression A_target = node.realTarget;
    if (A_target is SuperExpression && !_isSuperInValidContext(A_target)) {
      return null;
    }
    A_Element staticElement;
    A_Element propagatedElement;
    if (A_target == null) {
      staticElement = _resolveInvokedElement(methodName);
      propagatedElement = null;
    } else if (methodName.name == FunctionElement.LOAD_LIBRARY_NAME && _isDeferredPrefix(A_target)) {
      LibraryElement importedLibrary = _getImportedLibrary(A_target);
      methodName.staticElement = importedLibrary.loadLibraryFunction;
      return null;
    } else {
      DartType staticType = _getStaticType(A_target);
      ClassElementImpl typeReference = getTypeReference(A_target);
      if (typeReference != null) {
        staticElement = propagatedElement = _resolveElement(typeReference, methodName);
      } else {
        staticElement = _resolveInvokedElementWithTarget(A_target, staticType, methodName);
        propagatedElement = _resolveInvokedElementWithTarget(A_target, _getPropagatedType(A_target), methodName);
      }
    }
    staticElement = _convertSetterToGetter(staticElement);
    propagatedElement = _convertSetterToGetter(propagatedElement);
    methodName.staticElement = staticElement;
    methodName.propagatedElement = propagatedElement;
    ArgumentList argumentList = node.argumentList;
    if (staticElement != null) {
      List<ParameterElement> A_parameters = _computeCorrespondingParameters(argumentList, staticElement);
      if (A_parameters != null) {
        argumentList.correspondingStaticParameters = A_parameters;
      }
    }
    if (propagatedElement != null) {
      List<ParameterElement> A_parameters = _computeCorrespondingParameters(argumentList, propagatedElement);
      if (A_parameters != null) {
        argumentList.correspondingPropagatedParameters = A_parameters;
      }
    }
    ErrorCode A_errorCode = _checkForInvocationError(A_target, true, staticElement);
    bool generatedWithTypePropagation = false;
    if (_enableHints && A_errorCode == null && staticElement == null) {
      A_errorCode = _checkForInvocationError(A_target, false, propagatedElement);
      if (identical(A_errorCode, StaticTypeWarningCode.UNDEFINED_METHOD)) {
        ClassElement classElementContext = null;
        if (A_target == null) {
          classElementContext = A__resolver.enclosingClass;
        } else {
          DartType A_type = A_target.bestType;
          if (A_type != null) {
            if (A_type.element is ClassElement) {
              classElementContext = A_type.element as ClassElement;
            }
          }
        }
        if (classElementContext != null) {
          _subtypeManager.ensureLibraryVisited(_definingLibrary);
          A_p.HashSet<ClassElement> subtypeElements = _subtypeManager.computeAllSubtypes(classElementContext);
          for (ClassElement subtypeElement in subtypeElements) {
            if (subtypeElement.getMethod(methodName.name) != null) {
              A_errorCode = null;
            }
          }
        }
      }
      generatedWithTypePropagation = true;
    }
    if (A_errorCode == null) {
      return null;
    }
    if (identical(A_errorCode, StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION)) {
      A__resolver.reportErrorForNode(StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION, methodName, [methodName.name]);
    } else if (identical(A_errorCode, StaticTypeWarningCode.UNDEFINED_FUNCTION)) {
      A__resolver.reportErrorForNode(StaticTypeWarningCode.UNDEFINED_FUNCTION, methodName, [methodName.name]);
    } else if (identical(A_errorCode, StaticTypeWarningCode.UNDEFINED_METHOD)) {
      String targetTypeName;
      if (A_target == null) {
        ClassElement enclosingClass = A__resolver.enclosingClass;
        targetTypeName = enclosingClass.displayName;
        ErrorCode proxyErrorCode = (generatedWithTypePropagation ? HintCode.UNDEFINED_METHOD : StaticTypeWarningCode.UNDEFINED_METHOD);
        if (_doesClassElementHaveProxy(A__resolver.enclosingClass)) {
          A__resolver.reportErrorForNode(proxyErrorCode, methodName, [methodName.name, targetTypeName]);
        }
      } else {
        DartType targetType = null;
        if (!generatedWithTypePropagation) {
          targetType = _getStaticType(A_target);
        } else {
          targetType = _getPropagatedType(A_target);
          if (targetType == null) {
            targetType = _getStaticType(A_target);
          }
        }
        if (targetType != null && targetType.isDartCoreFunction && methodName.name == FunctionElement.CALL_METHOD_NAME) {
          return null;
        }
        targetTypeName = targetType == null ? null : targetType.displayName;
        ErrorCode proxyErrorCode = (generatedWithTypePropagation ? HintCode.UNDEFINED_METHOD : StaticTypeWarningCode.UNDEFINED_METHOD);
        if (_doesClassElementHaveProxy(targetType.element)) {
          A__resolver.reportErrorForNode(proxyErrorCode, methodName, [methodName.name, targetTypeName]);
        }
      }
    } else if (identical(A_errorCode, StaticTypeWarningCode.UNDEFINED_SUPER_METHOD)) {
      DartType targetType = _getStaticType(A_target);
      if (targetType is InterfaceType && !targetType.isObject) {
        targetType = (targetType as InterfaceType).superclass;
      }
      String targetTypeName = targetType == null ? null : targetType.name;
      A__resolver.reportErrorForNode(StaticTypeWarningCode.UNDEFINED_SUPER_METHOD, methodName, [methodName.name, targetTypeName]);
    }
    return null;
  }
  Object visitPartDirective(PartDirective node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitPartOfDirective(PartOfDirective node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitPostfixExpression(PostfixExpression node) {
    Expression operand = node.operand;
    String methodName = _getPostfixOperator(node);
    DartType staticType = _getStaticType(operand);
    MethodElement staticMethod = _lookUpMethod(operand, staticType, methodName);
    node.staticElement = staticMethod;
    DartType propagatedType = _getPropagatedType(operand);
    MethodElement propagatedMethod = _lookUpMethod(operand, propagatedType, methodName);
    node.propagatedElement = propagatedMethod;
    if (_shouldReportMissingMember(staticType, staticMethod)) {
      if (_doesClassElementHaveProxy(staticType.element)) {
        A__resolver.reportErrorForToken(StaticTypeWarningCode.UNDEFINED_OPERATOR, node.operator, [methodName, staticType.displayName]);
      }
    } else if (_enableHints && _shouldReportMissingMember(propagatedType, propagatedMethod) && !_memberFoundInSubclass(propagatedType.element, methodName, true, false)) {
      if (_doesClassElementHaveProxy(propagatedType.element)) {
        A__resolver.reportErrorForToken(HintCode.UNDEFINED_OPERATOR, node.operator, [methodName, propagatedType.displayName]);
      }
    }
    return null;
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    SimpleIdentifier prefix = node.prefix;
    SimpleIdentifier identifier = node.identifier;
    if (identifier.name == FunctionElement.LOAD_LIBRARY_NAME && _isDeferredPrefix(prefix)) {
      LibraryElement importedLibrary = _getImportedLibrary(prefix);
      identifier.staticElement = importedLibrary.loadLibraryFunction;
      return null;
    }
    A_Element prefixElement = prefix.staticElement;
    if (prefixElement is PrefixElement) {
      A_Element A_element = A__resolver.nameScope.lookup(node, _definingLibrary);
      if (A_element == null && identifier.inSetterContext()) {
        A_element = A__resolver.nameScope.lookup(new ElementResolver_SyntheticIdentifier("${node.name}="), _definingLibrary);
      }
      if (A_element == null) {
        if (identifier.inSetterContext()) {
          A__resolver.reportErrorForNode(StaticWarningCode.UNDEFINED_SETTER, identifier, [identifier.name, prefixElement.name]);
        } else if (node.parent is Annotation) {
          Annotation annotation = node.parent as Annotation;
          A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION, annotation, []);
          return null;
        } else {
          A__resolver.reportErrorForNode(StaticWarningCode.UNDEFINED_GETTER, identifier, [identifier.name, prefixElement.name]);
        }
        return null;
      }
      if (A_element is PropertyAccessorElement && identifier.inSetterContext()) {
        PropertyInducingElement variable = (A_element as PropertyAccessorElement).variable;
        if (variable != null) {
          PropertyAccessorElement setter = variable.setter;
          if (setter != null) {
            A_element = setter;
          }
        }
      }
      identifier.staticElement = A_element;
      if (node.parent is Annotation) {
        Annotation annotation = node.parent as Annotation;
        _resolveAnnotationElement(annotation);
        return null;
      }
      return null;
    }
    if (node.parent is Annotation) {
      Annotation annotation = node.parent as Annotation;
      _resolveAnnotationElement(annotation);
    }
    _resolvePropertyAccess(prefix, identifier);
    return null;
  }
  Object visitPrefixExpression(PrefixExpression node) {
    A_Token operator = node.operator;
    A_TokenType operatorType = operator.type;
    if (operatorType.isUserDefinableOperator || operatorType == A_TokenType.PLUS_PLUS || operatorType == A_TokenType.MINUS_MINUS) {
      Expression operand = node.operand;
      String methodName = _getPrefixOperator(node);
      DartType staticType = _getStaticType(operand);
      MethodElement staticMethod = _lookUpMethod(operand, staticType, methodName);
      node.staticElement = staticMethod;
      DartType propagatedType = _getPropagatedType(operand);
      MethodElement propagatedMethod = _lookUpMethod(operand, propagatedType, methodName);
      node.propagatedElement = propagatedMethod;
      if (_shouldReportMissingMember(staticType, staticMethod)) {
        if (_doesClassElementHaveProxy(staticType.element)) {
          A__resolver.reportErrorForToken(StaticTypeWarningCode.UNDEFINED_OPERATOR, operator, [methodName, staticType.displayName]);
        }
      } else if (_enableHints && _shouldReportMissingMember(propagatedType, propagatedMethod) && !_memberFoundInSubclass(propagatedType.element, methodName, true, false)) {
        if (_doesClassElementHaveProxy(propagatedType.element)) {
          A__resolver.reportErrorForToken(HintCode.UNDEFINED_OPERATOR, operator, [methodName, propagatedType.displayName]);
        }
      }
    }
    return null;
  }
  Object visitPropertyAccess(PropertyAccess node) {
    Expression A_target = node.realTarget;
    if (A_target is SuperExpression && !_isSuperInValidContext(A_target)) {
      return null;
    }
    SimpleIdentifier propertyName = node.propertyName;
    _resolvePropertyAccess(A_target, propertyName);
    return null;
  }
  Object visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    ClassElement enclosingClass = A__resolver.enclosingClass;
    if (enclosingClass == null) {
      return null;
    }
    SimpleIdentifier A_name = node.constructorName;
    ConstructorElement A_element;
    if (A_name == null) {
      A_element = enclosingClass.unnamedConstructor;
    } else {
      A_element = enclosingClass.getNamedConstructor(A_name.name);
    }
    if (A_element == null) {
      return null;
    }
    if (A_name != null) {
      A_name.staticElement = A_element;
    }
    node.staticElement = A_element;
    ArgumentList argumentList = node.argumentList;
    List<ParameterElement> A_parameters = _resolveArgumentsToFunction(false, argumentList, A_element);
    if (A_parameters != null) {
      argumentList.correspondingStaticParameters = A_parameters;
    }
    return null;
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    _setMetadataForParameter(node.element, node);
    return null;
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    if (node.isSynthetic) {
      return null;
    }
    if (node.staticElement != null) {
      return null;
    }
    if (node.name == _dynamicType.name) {
      node.staticElement = _dynamicType.element;
      node.staticType = _typeType;
      return null;
    }
    A_Element A_element = _resolveSimpleIdentifier(node);
    ClassElement enclosingClass = A__resolver.enclosingClass;
    if (_isFactoryConstructorReturnType(node) && !identical(A_element, enclosingClass)) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_FACTORY_NAME_NOT_A_CLASS, node, []);
    } else if (_isConstructorReturnType(node) && !identical(A_element, enclosingClass)) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_CONSTRUCTOR_NAME, node, []);
      A_element = null;
    } else if (A_element == null || (A_element is PrefixElement && !_isValidAsPrefix(node))) {
      if (_isConstructorReturnType(node)) {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_CONSTRUCTOR_NAME, node, []);
      } else if (node.parent is Annotation) {
        Annotation annotation = node.parent as Annotation;
        A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION, annotation, []);
      } else {
        if (_doesClassElementHaveProxy(A__resolver.enclosingClass)) {
          A__resolver.reportErrorForNode(StaticWarningCode.UNDEFINED_IDENTIFIER, node, [node.name]);
        }
      }
    }
    node.staticElement = A_element;
    if (node.inSetterContext() && node.inGetterContext() && enclosingClass != null) {
      InterfaceType enclosingType = enclosingClass.type;
      AuxiliaryElements auxiliaryElements = new AuxiliaryElements(_lookUpGetter(null, enclosingType, node.name), null);
      node.auxiliaryElements = auxiliaryElements;
    }
    if (node.parent is Annotation) {
      Annotation annotation = node.parent as Annotation;
      _resolveAnnotationElement(annotation);
    }
    return null;
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    ClassElement enclosingClass = A__resolver.enclosingClass;
    if (enclosingClass == null) {
      return null;
    }
    InterfaceType superType = enclosingClass.supertype;
    if (superType == null) {
      return null;
    }
    SimpleIdentifier A_name = node.constructorName;
    String superName = A_name != null ? A_name.name : null;
    ConstructorElement A_element = superType.lookUpConstructor(superName, _definingLibrary);
    if (A_element == null) {
      if (A_name != null) {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER, node, [superType.displayName, A_name]);
      } else {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT, node, [superType.displayName]);
      }
      return null;
    } else {
      if (A_element.isFactory) {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.NON_GENERATIVE_CONSTRUCTOR, node, [A_element]);
      }
    }
    if (A_name != null) {
      A_name.staticElement = A_element;
    }
    node.staticElement = A_element;
    ArgumentList argumentList = node.argumentList;
    List<ParameterElement> A_parameters = _resolveArgumentsToFunction(isInConstConstructor, argumentList, A_element);
    if (A_parameters != null) {
      argumentList.correspondingStaticParameters = A_parameters;
    }
    return null;
  }
  Object visitSuperExpression(SuperExpression node) {
    if (!_isSuperInValidContext(node)) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.SUPER_IN_INVALID_CONTEXT, node, []);
    }
    return super.visitSuperExpression(node);
  }
  Object visitTypeParameter(TypeParameter node) {
    _setMetadata(node.element, node);
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    _setMetadata(node.element, node);
    return null;
  }
  void _addAnnotations(List<ElementAnnotationImpl> annotationList, NodeList<Annotation> annotations) {
    int annotationCount = annotations.length;
    for (int i = 0; i < annotationCount; i++) {
      Annotation annotation = annotations[i];
      A_Element resolvedElement = annotation.element;
      if (resolvedElement != null) {
        ElementAnnotationImpl elementAnnotation = new ElementAnnotationImpl(resolvedElement);
        annotation.elementAnnotation = elementAnnotation;
        annotationList.add(elementAnnotation);
      }
    }
  }
  ErrorCode _checkForInvocationError(Expression A_target, bool useStaticContext, A_Element A_element) {
    if (A_element is PrefixElement) {
      A_element = null;
    }
    if (A_element is PropertyAccessorElement) {
      FunctionType getterType = A_element.type;
      if (getterType != null) {
        DartType A_returnType = getterType.returnType;
        if (!_isExecutableType(A_returnType)) {
          return StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION;
        }
      }
    } else if (A_element is ExecutableElement) {
      return null;
    } else if (A_element is MultiplyDefinedElement) {
      return null;
    } else if (A_element == null && A_target is SuperExpression) {
      return StaticTypeWarningCode.UNDEFINED_SUPER_METHOD;
    } else {
      if (A_element is PropertyInducingElement) {
        PropertyAccessorElement getter = A_element.getter;
        FunctionType getterType = getter.type;
        if (getterType != null) {
          DartType A_returnType = getterType.returnType;
          if (!_isExecutableType(A_returnType)) {
            return StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION;
          }
        }
      } else if (A_element is VariableElement) {
        DartType variableType = A_element.type;
        if (!_isExecutableType(variableType)) {
          return StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION;
        }
      } else {
        if (A_target == null) {
          ClassElement enclosingClass = A__resolver.enclosingClass;
          if (enclosingClass == null) {
            return StaticTypeWarningCode.UNDEFINED_FUNCTION;
          } else if (A_element == null) {
            return StaticTypeWarningCode.UNDEFINED_METHOD;
          } else {
            return StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION;
          }
        } else {
          DartType targetType;
          if (useStaticContext) {
            targetType = _getStaticType(A_target);
          } else {
            targetType = A_target.bestType;
          }
          if (targetType == null) {
            return StaticTypeWarningCode.UNDEFINED_FUNCTION;
          } else if (!targetType.isDynamic && !targetType.isBottom) {
            return StaticTypeWarningCode.UNDEFINED_METHOD;
          }
        }
      }
    }
    return null;
  }
  bool _checkForUndefinedIndexOperator(IndexExpression node, Expression A_target, String methodName, MethodElement staticMethod, MethodElement propagatedMethod, DartType staticType, DartType propagatedType) {
    bool shouldReportMissingMember_static = _shouldReportMissingMember(staticType, staticMethod);
    bool shouldReportMissingMember_propagated = !shouldReportMissingMember_static && _enableHints && _shouldReportMissingMember(propagatedType, propagatedMethod) && !_memberFoundInSubclass(propagatedType.element, methodName, true, false);
    if (shouldReportMissingMember_static || shouldReportMissingMember_propagated) {
      A_Token leftBracket = node.leftBracket;
      A_Token rightBracket = node.rightBracket;
      ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticTypeWarningCode.UNDEFINED_OPERATOR : HintCode.UNDEFINED_OPERATOR);
      if (leftBracket == null || rightBracket == null) {
        if (_doesClassElementHaveProxy(shouldReportMissingMember_static ? staticType.element : propagatedType.element)) {
          A__resolver.reportErrorForNode(A_errorCode, node, [methodName, shouldReportMissingMember_static ? staticType.displayName : propagatedType.displayName]);
        }
      } else {
        int A_offset = leftBracket.offset;
        int A_length = rightBracket.offset - A_offset + 1;
        if (_doesClassElementHaveProxy(shouldReportMissingMember_static ? staticType.element : propagatedType.element)) {
          A__resolver.reportErrorForOffset(A_errorCode, A_offset, A_length, [methodName, shouldReportMissingMember_static ? staticType.displayName : propagatedType.displayName]);
        }
      }
      return true;
    }
    return false;
  }
  List<ParameterElement> _computeCorrespondingParameters(ArgumentList argumentList, A_Element A_element) {
    if (A_element is PropertyAccessorElement) {
      FunctionType getterType = A_element.type;
      if (getterType != null) {
        DartType getterReturnType = getterType.returnType;
        if (getterReturnType is InterfaceType) {
          MethodElement callMethod = getterReturnType.lookUpMethod(FunctionElement.CALL_METHOD_NAME, _definingLibrary);
          if (callMethod != null) {
            return _resolveArgumentsToFunction(false, argumentList, callMethod);
          }
        } else if (getterReturnType is FunctionType) {
          List<ParameterElement> A_parameters = getterReturnType.parameters;
          return _resolveArgumentsToParameters(false, argumentList, A_parameters);
        }
      }
    } else if (A_element is ExecutableElement) {
      return _resolveArgumentsToFunction(false, argumentList, A_element);
    } else if (A_element is VariableElement) {
      VariableElement variable = A_element;
      DartType A_type = _promoteManager.A_getStaticType(variable);
      if (A_type is FunctionType) {
        FunctionType A_functionType = A_type;
        List<ParameterElement> A_parameters = A_functionType.parameters;
        return _resolveArgumentsToParameters(false, argumentList, A_parameters);
      } else if (A_type is InterfaceType) {
        MethodElement callMethod = A_type.lookUpMethod(FunctionElement.CALL_METHOD_NAME, _definingLibrary);
        if (callMethod != null) {
          List<ParameterElement> A_parameters = callMethod.parameters;
          return _resolveArgumentsToParameters(false, argumentList, A_parameters);
        }
      }
    }
    return null;
  }
  A_Element _convertSetterToGetter(A_Element A_element) {
    if (A_element is PropertyAccessorElement) {
      return A_element.variable.getter;
    }
    return A_element;
  }
  bool _doesClassElementHaveProxy(A_Element A_element) {
    if (A_element is ClassElement) {
      return !A_element.isOrInheritsProxy;
    }
    return true;
  }
  A_Element _findImportWithoutPrefix(SimpleIdentifier identifier) {
    A_Element A_element = null;
    Scope nameScope = A__resolver.nameScope;
    for (ImportElement importElement in _definingLibrary.imports) {
      PrefixElement prefixElement = importElement.prefix;
      if (prefixElement != null) {
        Identifier prefixedIdentifier = new ElementResolver_SyntheticIdentifier("${prefixElement.name}.${identifier.name}");
        A_Element importedElement = nameScope.lookup(prefixedIdentifier, _definingLibrary);
        if (importedElement != null) {
          if (A_element == null) {
            A_element = importedElement;
          } else {
            A_element = MultiplyDefinedElementImpl.fromElements(_definingLibrary.context, A_element, importedElement);
          }
        }
      }
    }
    return A_element;
  }
  LibraryElement _getImportedLibrary(Expression expression) {
    PrefixElement prefixElement = (expression as SimpleIdentifier).staticElement as PrefixElement;
    List<ImportElement> imports = prefixElement.enclosingElement.getImportsWithPrefix(prefixElement);
    return imports[0].importedLibrary;
  }
  String _getPostfixOperator(PostfixExpression node) => (node.operator.type == A_TokenType.PLUS_PLUS) ? A_TokenType.PLUS.lexeme : A_TokenType.MINUS.lexeme;
  String _getPrefixOperator(PrefixExpression node) {
    A_Token operator = node.operator;
    A_TokenType operatorType = operator.type;
    if (operatorType == A_TokenType.PLUS_PLUS) {
      return A_TokenType.PLUS.lexeme;
    } else if (operatorType == A_TokenType.MINUS_MINUS) {
      return A_TokenType.MINUS.lexeme;
    } else if (operatorType == A_TokenType.MINUS) {
      return "unary-";
    } else {
      return operator.lexeme;
    }
  }
  DartType _getPropagatedType(Expression expression) {
    DartType propagatedType = _resolveTypeParameter(expression.propagatedType);
    if (propagatedType is FunctionType) {
      propagatedType = A__resolver.typeProvider.functionType;
    }
    return propagatedType;
  }
  DartType _getStaticType(Expression expression) {
    if (expression is NullLiteral) {
      return A__resolver.typeProvider.bottomType;
    }
    DartType staticType = _resolveTypeParameter(expression.staticType);
    if (staticType is FunctionType) {
      staticType = A__resolver.typeProvider.functionType;
    }
    return staticType;
  }
  bool _isDeferredPrefix(Expression expression) {
    if (expression is! SimpleIdentifier) {
      return false;
    }
    A_Element A_element = (expression as SimpleIdentifier).staticElement;
    if (A_element is! PrefixElement) {
      return false;
    }
    PrefixElement prefixElement = A_element as PrefixElement;
    List<ImportElement> imports = prefixElement.enclosingElement.getImportsWithPrefix(prefixElement);
    if (imports.length != 1) {
      return false;
    }
    return imports[0].isDeferred;
  }
  bool _isExecutableType(DartType A_type) {
    if (A_type.isDynamic || (A_type is FunctionType) || A_type.isDartCoreFunction || A_type.isObject) {
      return true;
    } else if (A_type is InterfaceType) {
      ClassElement classElement = A_type.element;
      if (classElement.isProxy && A_type.isSubtypeOf(A__resolver.typeProvider.functionType)) {
        return true;
      }
      MethodElement methodElement = classElement.lookUpMethod(FunctionElement.CALL_METHOD_NAME, _definingLibrary);
      return methodElement != null;
    }
    return false;
  }
  bool get isInConstConstructor {
    ExecutableElement A_function = A__resolver.enclosingFunction;
    if (A_function is ConstructorElement) {
      return A_function.isConst;
    }
    return false;
  }
  bool A__isStatic(A_Element A_element) {
    if (A_element is ExecutableElement) {
      return A_element.isStatic;
    } else if (A_element is PropertyInducingElement) {
      return A_element.isStatic;
    }
    return false;
  }
  bool _isValidAsPrefix(SimpleIdentifier node) {
    AstNode A_parent = node.parent;
    if (A_parent is ImportDirective) {
      return identical(A_parent.prefix, node);
    } else if (A_parent is PrefixedIdentifier) {
      return true;
    } else if (A_parent is MethodInvocation) {
      return identical(A_parent.target, node);
    }
    return false;
  }
  PropertyAccessorElement _lookUpGetter(Expression A_target, DartType A_type, String getterName) {
    A_type = _resolveTypeParameter(A_type);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      PropertyAccessorElement accessor;
      if (A_target is SuperExpression) {
        accessor = interfaceType.lookUpGetterInSuperclass(getterName, _definingLibrary);
      } else {
        accessor = interfaceType.lookUpGetter(getterName, _definingLibrary);
      }
      if (accessor != null) {
        return accessor;
      }
      return _lookUpGetterInInterfaces(interfaceType, false, getterName, new A_p.HashSet<ClassElement>());
    }
    return null;
  }
  PropertyAccessorElement _lookUpGetterInInterfaces(InterfaceType targetType, bool includeTargetType, String getterName, A_p.HashSet<ClassElement> visitedInterfaces) {
    ClassElement targetClass = targetType.element;
    if (visitedInterfaces.contains(targetClass)) {
      return null;
    }
    visitedInterfaces.add(targetClass);
    if (includeTargetType) {
      PropertyAccessorElement getter = targetType.getGetter(getterName);
      if (getter != null && getter.isAccessibleIn(_definingLibrary)) {
        return getter;
      }
    }
    for (InterfaceType interfaceType in targetType.interfaces) {
      PropertyAccessorElement getter = _lookUpGetterInInterfaces(interfaceType, true, getterName, visitedInterfaces);
      if (getter != null) {
        return getter;
      }
    }
    for (InterfaceType mixinType in targetType.mixins) {
      PropertyAccessorElement getter = _lookUpGetterInInterfaces(mixinType, true, getterName, visitedInterfaces);
      if (getter != null) {
        return getter;
      }
    }
    InterfaceType superclass = targetType.superclass;
    if (superclass == null) {
      return null;
    }
    return _lookUpGetterInInterfaces(superclass, true, getterName, visitedInterfaces);
  }
  ExecutableElement _lookupGetterOrMethod(DartType A_type, String A_memberName) {
    A_type = _resolveTypeParameter(A_type);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      ExecutableElement member = interfaceType.lookUpMethod(A_memberName, _definingLibrary);
      if (member != null) {
        return member;
      }
      member = interfaceType.lookUpGetter(A_memberName, _definingLibrary);
      if (member != null) {
        return member;
      }
      return _lookUpGetterOrMethodInInterfaces(interfaceType, false, A_memberName, new A_p.HashSet<ClassElement>());
    }
    return null;
  }
  ExecutableElement _lookUpGetterOrMethodInInterfaces(InterfaceType targetType, bool includeTargetType, String A_memberName, A_p.HashSet<ClassElement> visitedInterfaces) {
    ClassElement targetClass = targetType.element;
    if (visitedInterfaces.contains(targetClass)) {
      return null;
    }
    visitedInterfaces.add(targetClass);
    if (includeTargetType) {
      ExecutableElement member = targetType.getMethod(A_memberName);
      if (member != null) {
        return member;
      }
      member = targetType.getGetter(A_memberName);
      if (member != null) {
        return member;
      }
    }
    for (InterfaceType interfaceType in targetType.interfaces) {
      ExecutableElement member = _lookUpGetterOrMethodInInterfaces(interfaceType, true, A_memberName, visitedInterfaces);
      if (member != null) {
        return member;
      }
    }
    for (InterfaceType mixinType in targetType.mixins) {
      ExecutableElement member = _lookUpGetterOrMethodInInterfaces(mixinType, true, A_memberName, visitedInterfaces);
      if (member != null) {
        return member;
      }
    }
    InterfaceType superclass = targetType.superclass;
    if (superclass == null) {
      return null;
    }
    return _lookUpGetterOrMethodInInterfaces(superclass, true, A_memberName, visitedInterfaces);
  }
  LabelElementImpl _lookupLabel(AstNode parentNode, SimpleIdentifier labelNode) {
    LabelScope labelScope = A__resolver.labelScope;
    LabelElementImpl labelElement = null;
    if (labelNode == null) {
      if (labelScope == null) {} else {
        labelElement = labelScope.lookup(LabelScope.EMPTY_LABEL) as LabelElementImpl;
        if (labelElement == null) {}
        labelElement = null;
      }
    } else {
      if (labelScope == null) {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.LABEL_UNDEFINED, labelNode, [labelNode.name]);
      } else {
        labelElement = labelScope.lookup(labelNode.name) as LabelElementImpl;
        if (labelElement == null) {
          A__resolver.reportErrorForNode(CompileTimeErrorCode.LABEL_UNDEFINED, labelNode, [labelNode.name]);
        } else {
          labelNode.staticElement = labelElement;
        }
      }
    }
    if (labelElement != null) {
      ExecutableElement labelContainer = labelElement.getAncestor((A_element) => A_element is ExecutableElement);
      if (!identical(labelContainer, A__resolver.enclosingFunction)) {
        A__resolver.reportErrorForNode(CompileTimeErrorCode.LABEL_IN_OUTER_SCOPE, labelNode, [labelNode.name]);
        labelElement = null;
      }
    }
    return labelElement;
  }
  MethodElement _lookUpMethod(Expression A_target, DartType A_type, String methodName) {
    A_type = _resolveTypeParameter(A_type);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      MethodElement A_method;
      if (A_target is SuperExpression) {
        A_method = interfaceType.lookUpMethodInSuperclass(methodName, _definingLibrary);
      } else {
        A_method = interfaceType.lookUpMethod(methodName, _definingLibrary);
      }
      if (A_method != null) {
        return A_method;
      }
      return _lookUpMethodInInterfaces(interfaceType, false, methodName, new A_p.HashSet<ClassElement>());
    }
    return null;
  }
  MethodElement _lookUpMethodInInterfaces(InterfaceType targetType, bool includeTargetType, String methodName, A_p.HashSet<ClassElement> visitedInterfaces) {
    ClassElement targetClass = targetType.element;
    if (visitedInterfaces.contains(targetClass)) {
      return null;
    }
    visitedInterfaces.add(targetClass);
    if (includeTargetType) {
      MethodElement A_method = targetType.getMethod(methodName);
      if (A_method != null && A_method.isAccessibleIn(_definingLibrary)) {
        return A_method;
      }
    }
    for (InterfaceType interfaceType in targetType.interfaces) {
      MethodElement A_method = _lookUpMethodInInterfaces(interfaceType, true, methodName, visitedInterfaces);
      if (A_method != null) {
        return A_method;
      }
    }
    for (InterfaceType mixinType in targetType.mixins) {
      MethodElement A_method = _lookUpMethodInInterfaces(mixinType, true, methodName, visitedInterfaces);
      if (A_method != null) {
        return A_method;
      }
    }
    InterfaceType superclass = targetType.superclass;
    if (superclass == null) {
      return null;
    }
    return _lookUpMethodInInterfaces(superclass, true, methodName, visitedInterfaces);
  }
  PropertyAccessorElement _lookUpSetter(Expression A_target, DartType A_type, String setterName) {
    A_type = _resolveTypeParameter(A_type);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      PropertyAccessorElement accessor;
      if (A_target is SuperExpression) {
        accessor = interfaceType.lookUpSetterInSuperclass(setterName, _definingLibrary);
      } else {
        accessor = interfaceType.lookUpSetter(setterName, _definingLibrary);
      }
      if (accessor != null) {
        return accessor;
      }
      return _lookUpSetterInInterfaces(interfaceType, false, setterName, new A_p.HashSet<ClassElement>());
    }
    return null;
  }
  PropertyAccessorElement _lookUpSetterInInterfaces(InterfaceType targetType, bool includeTargetType, String setterName, A_p.HashSet<ClassElement> visitedInterfaces) {
    ClassElement targetClass = targetType.element;
    if (visitedInterfaces.contains(targetClass)) {
      return null;
    }
    visitedInterfaces.add(targetClass);
    if (includeTargetType) {
      PropertyAccessorElement setter = targetType.getSetter(setterName);
      if (setter != null && setter.isAccessibleIn(_definingLibrary)) {
        return setter;
      }
    }
    for (InterfaceType interfaceType in targetType.interfaces) {
      PropertyAccessorElement setter = _lookUpSetterInInterfaces(interfaceType, true, setterName, visitedInterfaces);
      if (setter != null) {
        return setter;
      }
    }
    for (InterfaceType mixinType in targetType.mixins) {
      PropertyAccessorElement setter = _lookUpSetterInInterfaces(mixinType, true, setterName, visitedInterfaces);
      if (setter != null) {
        return setter;
      }
    }
    InterfaceType superclass = targetType.superclass;
    if (superclass == null) {
      return null;
    }
    return _lookUpSetterInInterfaces(superclass, true, setterName, visitedInterfaces);
  }
  bool _memberFoundInSubclass(A_Element A_element, String A_memberName, bool asMethod, bool asAccessor) {
    if (A_element is ClassElement) {
      _subtypeManager.ensureLibraryVisited(_definingLibrary);
      A_p.HashSet<ClassElement> subtypeElements = _subtypeManager.computeAllSubtypes(A_element);
      for (ClassElement subtypeElement in subtypeElements) {
        if (asMethod && subtypeElement.getMethod(A_memberName) != null) {
          return true;
        } else if (asAccessor && (subtypeElement.getGetter(A_memberName) != null || subtypeElement.getSetter(A_memberName) != null)) {
          return true;
        }
      }
    }
    return false;
  }
  A_TokenType _operatorFromCompoundAssignment(A_TokenType operator) {
    while (true) {
      if (operator == A_TokenType.AMPERSAND_EQ) {
        return A_TokenType.A_AMPERSAND;
      } else if (operator == A_TokenType.BAR_EQ) {
        return A_TokenType.BAR;
      } else if (operator == A_TokenType.CARET_EQ) {
        return A_TokenType.CARET;
      } else if (operator == A_TokenType.GT_GT_EQ) {
        return A_TokenType.GT_GT;
      } else if (operator == A_TokenType.LT_LT_EQ) {
        return A_TokenType.LT_LT;
      } else if (operator == A_TokenType.MINUS_EQ) {
        return A_TokenType.MINUS;
      } else if (operator == A_TokenType.PERCENT_EQ) {
        return A_TokenType.PERCENT;
      } else if (operator == A_TokenType.PLUS_EQ) {
        return A_TokenType.PLUS;
      } else if (operator == A_TokenType.SLASH_EQ) {
        return A_TokenType.A_SLASH;
      } else if (operator == A_TokenType.STAR_EQ) {
        return A_TokenType.STAR;
      } else if (operator == A_TokenType.TILDE_SLASH_EQ) {
        return A_TokenType.TILDE_SLASH;
      } else {
        AnalysisEngine.A_instance.logger.logError("Failed to map ${operator.lexeme} to it's corresponding operator");
        return operator;
      }
      break;
    }
  }
  void _resolveAnnotationConstructorInvocationArguments(Annotation annotation, ConstructorElement constructor) {
    ArgumentList argumentList = annotation.arguments;
    if (argumentList == null) {
      return;
    }
    List<ParameterElement> A_parameters = _resolveArgumentsToFunction(true, argumentList, constructor);
    if (A_parameters != null) {
      argumentList.correspondingStaticParameters = A_parameters;
    }
  }
  void _resolveAnnotationElement(Annotation annotation) {
    SimpleIdentifier nameNode1;
    SimpleIdentifier nameNode2;
    {
      Identifier annName = annotation.name;
      if (annName is PrefixedIdentifier) {
        PrefixedIdentifier prefixed = annName;
        nameNode1 = prefixed.prefix;
        nameNode2 = prefixed.identifier;
      } else {
        nameNode1 = annName as SimpleIdentifier;
        nameNode2 = null;
      }
    }
    SimpleIdentifier nameNode3 = annotation.constructorName;
    ConstructorElement constructor = null;
    if (nameNode1 != null && nameNode2 == null && nameNode3 == null) {
      A_Element element1 = nameNode1.staticElement;
      if (element1 is PropertyAccessorElement) {
        _resolveAnnotationElementGetter(annotation, element1);
        return;
      }
      if (element1 is ClassElement) {
        ClassElement classElement = element1;
        constructor = new InterfaceTypeImpl.B_con1(classElement).lookUpConstructor(null, _definingLibrary);
      }
    }
    if (nameNode1 != null && nameNode2 != null && nameNode3 == null) {
      A_Element element1 = nameNode1.staticElement;
      A_Element element2 = nameNode2.staticElement;
      if (element1 is ClassElement) {
        ClassElement classElement = element1;
        element2 = classElement.lookUpGetter(nameNode2.name, _definingLibrary);
      }
      if (element2 is PropertyAccessorElement) {
        nameNode2.staticElement = element2;
        annotation.element = element2;
        _resolveAnnotationElementGetter(annotation, element2 as PropertyAccessorElement);
        return;
      }
      if (element2 is ClassElement) {
        ClassElement classElement = element2 as ClassElement;
        constructor = classElement.unnamedConstructor;
      }
      if (element1 is ClassElement) {
        ClassElement classElement = element1;
        constructor = new InterfaceTypeImpl.B_con1(classElement).lookUpConstructor(nameNode2.name, _definingLibrary);
        nameNode2.staticElement = constructor;
      }
    }
    if (nameNode1 != null && nameNode2 != null && nameNode3 != null) {
      A_Element element2 = nameNode2.staticElement;
      if (element2 is ClassElement) {
        ClassElement classElement = element2;
        String name3 = nameNode3.name;
        PropertyAccessorElement getter = classElement.lookUpGetter(name3, _definingLibrary);
        if (getter != null) {
          nameNode3.staticElement = getter;
          annotation.element = element2;
          _resolveAnnotationElementGetter(annotation, getter);
          return;
        }
        constructor = new InterfaceTypeImpl.B_con1(classElement).lookUpConstructor(name3, _definingLibrary);
        nameNode3.staticElement = constructor;
      }
    }
    if (constructor == null) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION, annotation, []);
      return;
    }
    annotation.element = constructor;
    _resolveAnnotationConstructorInvocationArguments(annotation, constructor);
  }
  void _resolveAnnotationElementGetter(Annotation annotation, PropertyAccessorElement accessorElement) {
    if (!accessorElement.isSynthetic) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION, annotation, []);
      return;
    }
    VariableElement variableElement = accessorElement.variable;
    if (!variableElement.isConst) {
      A__resolver.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION, annotation, []);
    }
    return;
  }
  List<ParameterElement> _resolveArgumentsToFunction(bool reportError, ArgumentList argumentList, ExecutableElement executableElement) {
    if (executableElement == null) {
      return null;
    }
    List<ParameterElement> A_parameters = executableElement.parameters;
    return _resolveArgumentsToParameters(reportError, argumentList, A_parameters);
  }
  List<ParameterElement> _resolveArgumentsToParameters(bool reportError, ArgumentList argumentList, List<ParameterElement> A_parameters) {
    List<ParameterElement> requiredParameters = new List<ParameterElement>();
    List<ParameterElement> positionalParameters = new List<ParameterElement>();
    A_p.HashMap<String, ParameterElement> A_namedParameters = new A_p.HashMap<String,ParameterElement>();
    for (ParameterElement parameter in A_parameters) {
      ParameterKind kind = parameter.parameterKind;
      if (kind == ParameterKind.REQUIRED) {
        requiredParameters.add(parameter);
      } else if (kind == ParameterKind.POSITIONAL) {
        positionalParameters.add(parameter);
      } else {
        A_namedParameters[parameter.name] = parameter;
      }
    }
    List<ParameterElement> unnamedParameters = new List<ParameterElement>.from(requiredParameters);
    unnamedParameters.addAll(positionalParameters);
    int unnamedParameterCount = unnamedParameters.length;
    int unnamedIndex = 0;
    NodeList<Expression> A_arguments = argumentList.arguments;
    int argumentCount = A_arguments.length;
    List<ParameterElement> resolvedParameters = new List<ParameterElement>(argumentCount);
    int positionalArgumentCount = 0;
    A_p.HashSet<String> usedNames = new A_p.HashSet<String>();
    for (int i = 0; i < argumentCount; i++) {
      Expression argument = A_arguments[i];
      if (argument is NamedExpression) {
        SimpleIdentifier nameNode = argument.name.label;
        String A_name = nameNode.name;
        ParameterElement A_element = A_namedParameters[A_name];
        if (A_element == null) {
          ErrorCode A_errorCode = (reportError ? CompileTimeErrorCode.UNDEFINED_NAMED_PARAMETER : StaticWarningCode.UNDEFINED_NAMED_PARAMETER);
          A__resolver.reportErrorForNode(A_errorCode, nameNode, [A_name]);
        } else {
          resolvedParameters[i] = A_element;
          nameNode.staticElement = A_element;
        }
        if (!usedNames.add(A_name)) {
          A__resolver.reportErrorForNode(CompileTimeErrorCode.DUPLICATE_NAMED_ARGUMENT, nameNode, [A_name]);
        }
      } else {
        positionalArgumentCount++;
        if (unnamedIndex < unnamedParameterCount) {
          resolvedParameters[i] = unnamedParameters[unnamedIndex++];
        }
      }
    }
    if (positionalArgumentCount < requiredParameters.length) {
      ErrorCode A_errorCode = (reportError ? CompileTimeErrorCode.NOT_ENOUGH_REQUIRED_ARGUMENTS : StaticWarningCode.NOT_ENOUGH_REQUIRED_ARGUMENTS);
      A__resolver.reportErrorForNode(A_errorCode, argumentList, [requiredParameters.length, positionalArgumentCount]);
    } else if (positionalArgumentCount > unnamedParameterCount) {
      ErrorCode A_errorCode = (reportError ? CompileTimeErrorCode.EXTRA_POSITIONAL_ARGUMENTS : StaticWarningCode.EXTRA_POSITIONAL_ARGUMENTS);
      A__resolver.reportErrorForNode(A_errorCode, argumentList, [unnamedParameterCount, positionalArgumentCount]);
    }
    return resolvedParameters;
  }
  void _resolveCombinators(LibraryElement library, NodeList<Combinator> combinators) {
    if (library == null) {
      return;
    }
    Namespace namespace = new NamespaceBuilder().createExportNamespaceForLibrary(library);
    for (Combinator combinator in combinators) {
      NodeList<SimpleIdentifier> names;
      if (combinator is HideCombinator) {
        names = combinator.hiddenNames;
      } else {
        names = (combinator as ShowCombinator).shownNames;
      }
      for (SimpleIdentifier A_name in names) {
        String nameStr = A_name.name;
        A_Element A_element = namespace.get(nameStr);
        if (A_element == null) {
          A_element = namespace.get("${nameStr}=");
        }
        if (A_element != null) {
          if (A_element is PropertyAccessorElement) {
            A_element = (A_element as PropertyAccessorElement).variable;
          }
          A_name.staticElement = A_element;
        }
      }
    }
  }
  A_Element _resolveElement(ClassElementImpl classElement, SimpleIdentifier nameNode) {
    String A_name = nameNode.name;
    A_Element A_element = classElement.getMethod(A_name);
    if (A_element == null && nameNode.inSetterContext()) {
      A_element = classElement.getSetter(A_name);
    }
    if (A_element == null && nameNode.inGetterContext()) {
      A_element = classElement.getGetter(A_name);
    }
    if (A_element != null && A_element.isAccessibleIn(_definingLibrary)) {
      return A_element;
    }
    return null;
  }
  A_Element _resolveInvokedElement(SimpleIdentifier methodName) {
    A_Element A_element = A__resolver.nameScope.lookup(methodName, _definingLibrary);
    if (A_element == null) {
      ClassElement enclosingClass = A__resolver.enclosingClass;
      if (enclosingClass != null) {
        InterfaceType enclosingType = enclosingClass.type;
        A_element = _lookUpMethod(null, enclosingType, methodName.name);
        if (A_element == null) {
          A_element = _lookUpGetter(null, enclosingType, methodName.name);
        }
      }
    }
    return A_element;
  }
  A_Element _resolveInvokedElementWithTarget(Expression A_target, DartType targetType, SimpleIdentifier methodName) {
    if (targetType is InterfaceType) {
      InterfaceType classType = targetType;
      A_Element A_element = _lookUpMethod(A_target, classType, methodName.name);
      if (A_element == null) {
        A_element = _lookUpGetter(A_target, classType, methodName.name);
      }
      return A_element;
    } else if (A_target is SimpleIdentifier) {
      A_Element targetElement = A_target.staticElement;
      if (targetElement is PrefixElement) {
        String A_name = "${A_target.name}.${methodName}";
        Identifier functionName = new ElementResolver_SyntheticIdentifier(A_name);
        A_Element A_element = A__resolver.nameScope.lookup(functionName, _definingLibrary);
        if (A_element != null) {
          return A_element;
        }
      }
    }
    return null;
  }
  ExecutableElement _resolveProperty(Expression A_target, DartType targetType, SimpleIdentifier propertyName) {
    ExecutableElement memberElement = null;
    if (propertyName.inSetterContext()) {
      memberElement = _lookUpSetter(A_target, targetType, propertyName.name);
    }
    if (memberElement == null) {
      memberElement = _lookUpGetter(A_target, targetType, propertyName.name);
    }
    if (memberElement == null) {
      memberElement = _lookUpMethod(A_target, targetType, propertyName.name);
    }
    return memberElement;
  }
  void _resolvePropertyAccess(Expression A_target, SimpleIdentifier propertyName) {
    DartType staticType = _getStaticType(A_target);
    DartType propagatedType = _getPropagatedType(A_target);
    A_Element staticElement = null;
    A_Element propagatedElement = null;
    ClassElementImpl typeReference = getTypeReference(A_target);
    if (typeReference != null) {
      staticElement = propagatedElement = _resolveElement(typeReference, propertyName);
    } else {
      staticElement = _resolveProperty(A_target, staticType, propertyName);
      propagatedElement = _resolveProperty(A_target, propagatedType, propertyName);
    }
    if (A_target.parent.parent is Annotation) {
      if (staticElement != null) {
        propertyName.staticElement = staticElement;
      }
      return;
    }
    propertyName.staticElement = staticElement;
    propertyName.propagatedElement = propagatedElement;
    bool shouldReportMissingMember_static = _shouldReportMissingMember(staticType, staticElement);
    bool shouldReportMissingMember_propagated = !shouldReportMissingMember_static && _enableHints ? _shouldReportMissingMember(propagatedType, propagatedElement) : false;
    if (shouldReportMissingMember_propagated) {
      if (_memberFoundInSubclass(propagatedType.element, propertyName.name, false, true)) {
        shouldReportMissingMember_propagated = false;
      }
    }
    if (shouldReportMissingMember_static || shouldReportMissingMember_propagated) {
      if (staticType.isVoid) {
        if (propertyName.inSetterContext()) {
          ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticTypeWarningCode.UNDEFINED_SETTER : HintCode.UNDEFINED_SETTER);
          A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticType.displayName]);
        } else if (propertyName.inGetterContext()) {
          ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticTypeWarningCode.UNDEFINED_GETTER : HintCode.UNDEFINED_GETTER);
          A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticType.displayName]);
        } else {
          A__resolver.reportErrorForNode(StaticWarningCode.UNDEFINED_IDENTIFIER, propertyName, [propertyName.name]);
        }
      }
      A_Element staticOrPropagatedEnclosingElt = shouldReportMissingMember_static ? staticType.element : propagatedType.element;
      if (staticOrPropagatedEnclosingElt != null) {
        bool isStaticProperty = A__isStatic(staticOrPropagatedEnclosingElt);
        if (propertyName.inSetterContext()) {
          if (isStaticProperty) {
            ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticWarningCode.UNDEFINED_SETTER : HintCode.UNDEFINED_SETTER);
            if (_doesClassElementHaveProxy(staticOrPropagatedEnclosingElt)) {
              A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticOrPropagatedEnclosingElt.displayName]);
            }
          } else {
            ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticTypeWarningCode.UNDEFINED_SETTER : HintCode.UNDEFINED_SETTER);
            if (_doesClassElementHaveProxy(staticOrPropagatedEnclosingElt)) {
              A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticOrPropagatedEnclosingElt.displayName]);
            }
          }
        } else if (propertyName.inGetterContext()) {
          if (isStaticProperty) {
            ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticWarningCode.UNDEFINED_GETTER : HintCode.UNDEFINED_GETTER);
            if (_doesClassElementHaveProxy(staticOrPropagatedEnclosingElt)) {
              A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticOrPropagatedEnclosingElt.displayName]);
            }
          } else {
            if (staticOrPropagatedEnclosingElt is ClassElement) {
              InterfaceType targetType = staticOrPropagatedEnclosingElt.type;
              if (targetType != null && targetType.isDartCoreFunction && propertyName.name == FunctionElement.CALL_METHOD_NAME) {
                return;
              }
            }
            ErrorCode A_errorCode = (shouldReportMissingMember_static ? StaticTypeWarningCode.UNDEFINED_GETTER : HintCode.UNDEFINED_GETTER);
            if (_doesClassElementHaveProxy(staticOrPropagatedEnclosingElt)) {
              A__resolver.reportErrorForNode(A_errorCode, propertyName, [propertyName.name, staticOrPropagatedEnclosingElt.displayName]);
            }
          }
        } else {
          if (_doesClassElementHaveProxy(staticOrPropagatedEnclosingElt)) {
            A__resolver.reportErrorForNode(StaticWarningCode.UNDEFINED_IDENTIFIER, propertyName, [propertyName.name]);
          }
        }
      }
    }
  }
  A_Element _resolveSimpleIdentifier(SimpleIdentifier node) {
    A_Element A_element = A__resolver.nameScope.lookup(node, _definingLibrary);
    if (A_element is PropertyAccessorElement && node.inSetterContext()) {
      PropertyInducingElement variable = (A_element as PropertyAccessorElement).variable;
      if (variable != null) {
        PropertyAccessorElement setter = variable.setter;
        if (setter == null) {
          ClassElement enclosingClass = A__resolver.enclosingClass;
          if (enclosingClass != null) {
            setter = _lookUpSetter(null, enclosingClass.type, node.name);
          }
        }
        if (setter != null) {
          A_element = setter;
        }
      }
    } else if (A_element == null && (node.inSetterContext() || node.parent is CommentReference)) {
      A_element = A__resolver.nameScope.lookup(new ElementResolver_SyntheticIdentifier("${node.name}="), _definingLibrary);
    }
    ClassElement enclosingClass = A__resolver.enclosingClass;
    if (A_element == null && enclosingClass != null) {
      InterfaceType enclosingType = enclosingClass.type;
      if (A_element == null && (node.inSetterContext() || node.parent is CommentReference)) {
        A_element = _lookUpSetter(null, enclosingType, node.name);
      }
      if (A_element == null && node.inGetterContext()) {
        A_element = _lookUpGetter(null, enclosingType, node.name);
      }
      if (A_element == null) {
        A_element = _lookUpMethod(null, enclosingType, node.name);
      }
    }
    return A_element;
  }
  DartType _resolveTypeParameter(DartType A_type) {
    if (A_type is TypeParameterType) {
      DartType A_bound = A_type.element.bound;
      if (A_bound == null) {
        return A__resolver.typeProvider.objectType;
      }
      return A_bound;
    }
    return A_type;
  }
  void _setMetadata(A_Element A_element, AnnotatedNode node) {
    if (A_element is! ElementImpl) {
      return;
    }
    List<ElementAnnotationImpl> annotationList = new List<ElementAnnotationImpl>();
    _addAnnotations(annotationList, node.metadata);
    if (node is VariableDeclaration && node.parent is VariableDeclarationList) {
      VariableDeclarationList A_list = node.parent as VariableDeclarationList;
      _addAnnotations(annotationList, A_list.metadata);
      if (A_list.parent is FieldDeclaration) {
        FieldDeclaration fieldDeclaration = A_list.parent as FieldDeclaration;
        _addAnnotations(annotationList, fieldDeclaration.metadata);
      } else if (A_list.parent is TopLevelVariableDeclaration) {
        TopLevelVariableDeclaration variableDeclaration = A_list.parent as TopLevelVariableDeclaration;
        _addAnnotations(annotationList, variableDeclaration.metadata);
      }
    }
    if (!annotationList.isEmpty) {
      (A_element as ElementImpl).metadata = new List.from(annotationList);
    }
  }
  void _setMetadataForParameter(A_Element A_element, NormalFormalParameter node) {
    if (A_element is! ElementImpl) {
      return;
    }
    List<ElementAnnotationImpl> annotationList = new List<ElementAnnotationImpl>();
    _addAnnotations(annotationList, node.metadata);
    if (!annotationList.isEmpty) {
      (A_element as ElementImpl).metadata = new List.from(annotationList);
    }
  }
  bool _shouldReportMissingMember(DartType A_type, A_Element member) {
    if (member != null || A_type == null || A_type.isDynamic || A_type.isBottom) {
      return false;
    }
    return true;
  }
}
class ElementResolver_SyntheticIdentifier extends Identifier {
  final String name;
  ElementResolver_SyntheticIdentifier(this.name);
  accept(AstVisitor visitor) => null;
  A_Token get beginToken => null;
  A_Element get bestElement => null;
  A_Token get endToken => null;
  int get precedence => 16;
  A_Element get propagatedElement => null;
  A_Element get staticElement => null;
  void visitChildren(AstVisitor visitor) {}
}
class EnclosedScope extends Scope {
  final Scope enclosingScope;
  A_p.HashMap<String, A_Element> _hiddenElements = new A_p.HashMap<String,A_Element>();
  bool _hasHiddenName = false;
  EnclosedScope(this.enclosingScope);
  AnalysisErrorListener get errorListener => enclosingScope.errorListener;
  void hide(A_Element A_element) {
    if (A_element != null) {
      String A_name = A_element.name;
      if (A_name != null && !A_name.isEmpty) {
        _hiddenElements[A_name] = A_element;
        _hasHiddenName = true;
      }
    }
  }
  A_Element internalLookup(Identifier identifier, String A_name, LibraryElement referencingLibrary) {
    A_Element A_element = localLookup(A_name, referencingLibrary);
    if (A_element != null) {
      return A_element;
    }
    if (_hasHiddenName) {
      A_Element hiddenElement = _hiddenElements[A_name];
      if (hiddenElement != null) {
        errorListener.onError(new A_AnalysisError.D_con2(getSource(identifier), identifier.offset, identifier.length, CompileTimeErrorCode.REFERENCED_BEFORE_DECLARATION, []));
        return hiddenElement;
      }
    }
    return enclosingScope.internalLookup(identifier, A_name, referencingLibrary);
  }
}
class EnumMemberBuilder extends RecursiveAstVisitor<Object> {
  final TypeProvider B__typeProvider;
  EnumMemberBuilder(this.B__typeProvider);
  Object visitEnumDeclaration(EnumDeclaration node) {
    ClassElementImpl enumElement = node.name.staticElement as ClassElementImpl;
    InterfaceType enumType = enumElement.type;
    enumElement.supertype = B__typeProvider.objectType;
    List<FieldElement> fields = new List<FieldElement>();
    InterfaceType intType = B__typeProvider.intType;
    InterfaceType stringType = B__typeProvider.stringType;
    String indexFieldName = "index";
    FieldElementImpl indexField = new FieldElementImpl(indexFieldName, -1);
    indexField.final2 = true;
    indexField.type = intType;
    fields.add(indexField);
    String nameFieldName = "_name";
    FieldElementImpl nameField = new FieldElementImpl(nameFieldName, -1);
    nameField.final2 = true;
    nameField.type = stringType;
    fields.add(nameField);
    FieldElementImpl valuesField = new FieldElementImpl("values", -1);
    valuesField.static = true;
    valuesField.const3 = true;
    valuesField.type = B__typeProvider.listType.substitute4(<DartType>[enumType]);
    fields.add(valuesField);
    NodeList<EnumConstantDeclaration> constants = node.constants;
    int constantCount = constants.length;
    for (int i = 0; i < constantCount; i++) {
      SimpleIdentifier constantName = constants[i].name;
      FieldElementImpl constantElement = new ConstFieldElementImpl.B_con1(constantName);
      constantElement.static = true;
      constantElement.const3 = true;
      constantElement.type = enumType;
      A_p.HashMap<String, DartObjectImpl> fieldMap = new A_p.HashMap<String,DartObjectImpl>();
      fieldMap[indexFieldName] = new DartObjectImpl(intType, new IntState(i));
      fieldMap[nameFieldName] = new DartObjectImpl(stringType, new StringState(constantName.name));
      DartObjectImpl A_value = new DartObjectImpl(enumType, new GenericState(fieldMap));
      constantElement.evaluationResult = new ValidResult(A_value);
      fields.add(constantElement);
      constantName.staticElement = constantElement;
    }
    enumElement.fields = new List.from(fields);
    return super.visitEnumDeclaration(node);
  }
}
class ErrorVerifier extends RecursiveAstVisitor<Object> {
  static DartType getStaticType(Expression expression) {
    DartType A_type = expression.staticType;
    if (A_type == null) {
      return DynamicTypeImpl.instance;
    }
    return A_type;
  }
  static VariableElement getVariableElement(Expression expression) {
    if (expression is Identifier) {
      A_Element A_element = expression.staticElement;
      if (A_element is VariableElement) {
        return A_element;
      }
    }
    return null;
  }
  final ErrorReporter _errorReporter;
  final LibraryElement _currentLibrary;
  InterfaceType _boolType;
  InterfaceType _intType;
  final TypeProvider B__typeProvider;
  final InheritanceManager _inheritanceManager;
  bool _isEnclosingConstructorConst = false;
  bool _isInCatchClause = false;
  bool _isInComment = false;
  bool _isInConstInstanceCreation = false;
  bool _isInNativeClass = false;
  bool _isInStaticVariableDeclaration = false;
  bool _isInInstanceVariableDeclaration = false;
  bool _isInInstanceVariableInitializer = false;
  bool _isInConstructorInitializer = false;
  bool _isInFunctionTypedFormalParameter = false;
  bool _isInStaticMethod = false;
  bool _isInFactory = false;
  bool _isInSystemLibrary = false;
  bool _hasExtUri = false;
  bool _hasReturnWithoutValue = false;
  ClassElement _enclosingClass;
  ExecutableElement _enclosingFunction;
  List<ReturnStatement> _returnsWith = new List<ReturnStatement>();
  List<ReturnStatement> _returnsWithout = new List<ReturnStatement>();
  A_p.HashMap<FieldElement, INIT_STATE> _initialFieldElementsMap;
  A_p.HashMap<String, LibraryElement> _nameToExportElement = new A_p.HashMap<String,LibraryElement>();
  A_p.HashMap<String, LibraryElement> _nameToImportElement = new A_p.HashMap<String,LibraryElement>();
  A_p.HashMap<String, A_Element> _exportedElements = new A_p.HashMap<String,A_Element>();
  A_p.HashSet<String> _namesForReferenceToDeclaredVariableInInitializer = new A_p.HashSet<String>();
  List<InterfaceType> _DISALLOWED_TYPES_TO_EXTEND_OR_IMPLEMENT;
  static String _GETTER_SPACE = "getter ";
  static String _SETTER_SPACE = "setter ";
  ErrorVerifier(this._errorReporter, this._currentLibrary, this.B__typeProvider, this._inheritanceManager) {
    this._isInSystemLibrary = _currentLibrary.source.isInSystemLibrary;
    this._hasExtUri = _currentLibrary.hasExtUri;
    _isEnclosingConstructorConst = false;
    _isInCatchClause = false;
    _isInStaticVariableDeclaration = false;
    _isInInstanceVariableDeclaration = false;
    _isInInstanceVariableInitializer = false;
    _isInConstructorInitializer = false;
    _isInStaticMethod = false;
    _boolType = B__typeProvider.boolType;
    _intType = B__typeProvider.intType;
    _DISALLOWED_TYPES_TO_EXTEND_OR_IMPLEMENT = <InterfaceType>[B__typeProvider.nullType, B__typeProvider.numType, _intType, B__typeProvider.doubleType, _boolType, B__typeProvider.stringType];
  }
  Object visitAnnotation(Annotation node) {
    _checkForInvalidAnnotationFromDeferredLibrary(node);
    return super.visitAnnotation(node);
  }
  Object visitArgumentList(ArgumentList node) {
    _checkForArgumentTypesNotAssignableInList(node);
    return super.visitArgumentList(node);
  }
  Object visitAsExpression(AsExpression node) {
    _checkForTypeAnnotationDeferredClass(node.type);
    return super.visitAsExpression(node);
  }
  Object visitAssertStatement(AssertStatement node) {
    _checkForNonBoolExpression(node);
    return super.visitAssertStatement(node);
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    A_TokenType operatorType = node.operator.type;
    Expression lhs = node.leftHandSide;
    Expression rhs = node.rightHandSide;
    if (operatorType == A_TokenType.A_EQ) {
      _checkForInvalidAssignment(lhs, rhs);
    } else {
      _checkForInvalidCompoundAssignment(node, lhs, rhs);
    }
    _checkForAssignmentToFinal(lhs);
    _checkForArgumentTypeNotAssignableForArgument(rhs);
    return super.visitAssignmentExpression(node);
  }
  Object visitBinaryExpression(BinaryExpression node) {
    A_Token operator = node.operator;
    A_TokenType A_type = operator.type;
    if (A_type == A_TokenType.AMPERSAND_AMPERSAND || A_type == A_TokenType.BAR_BAR) {
      String lexeme = operator.lexeme;
      _checkForAssignability(node.leftOperand, _boolType, StaticTypeWarningCode.NON_BOOL_OPERAND, [lexeme]);
      _checkForAssignability(node.rightOperand, _boolType, StaticTypeWarningCode.NON_BOOL_OPERAND, [lexeme]);
    } else {
      _checkForArgumentTypeNotAssignableForArgument(node.rightOperand);
    }
    return super.visitBinaryExpression(node);
  }
  Object visitBlockFunctionBody(BlockFunctionBody node) {
    bool previousHasReturnWithoutValue = _hasReturnWithoutValue;
    _hasReturnWithoutValue = false;
    List<ReturnStatement> previousReturnsWith = _returnsWith;
    List<ReturnStatement> previousReturnsWithout = _returnsWithout;
    try {
      _returnsWith = new List<ReturnStatement>();
      _returnsWithout = new List<ReturnStatement>();
      super.visitBlockFunctionBody(node);
      _checkForMixedReturns(node);
    } finally {
      _returnsWith = previousReturnsWith;
      _returnsWithout = previousReturnsWithout;
      _hasReturnWithoutValue = previousHasReturnWithoutValue;
    }
    return null;
  }
  Object visitBreakStatement(BreakStatement node) {
    SimpleIdentifier labelNode = node.label;
    if (labelNode != null) {
      A_Element labelElement = labelNode.staticElement;
      if (labelElement is LabelElementImpl && labelElement.isOnSwitchMember) {
        _errorReporter.reportErrorForNode(ResolverErrorCode.BREAK_LABEL_ON_SWITCH_MEMBER, labelNode, []);
      }
    }
    return null;
  }
  Object visitCatchClause(CatchClause node) {
    bool previousIsInCatchClause = _isInCatchClause;
    try {
      _isInCatchClause = true;
      _checkForTypeAnnotationDeferredClass(node.exceptionType);
      return super.visitCatchClause(node);
    } finally {
      _isInCatchClause = previousIsInCatchClause;
    }
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement outerClass = _enclosingClass;
    try {
      _isInNativeClass = node.nativeClause != null;
      _enclosingClass = node.element;
      ExtendsClause extendsClause = node.extendsClause;
      ImplementsClause implementsClause = node.implementsClause;
      WithClause withClause = node.withClause;
      _checkForBuiltInIdentifierAsName(node.name, CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE_NAME);
      _checkForMemberWithClassName();
      _checkForNoDefaultSuperConstructorImplicit(node);
      _checkForConflictingTypeVariableErrorCodes(node);
      if (implementsClause != null || extendsClause != null || withClause != null) {
        if (!_checkForImplementsDisallowedClass(implementsClause) && !_checkForExtendsDisallowedClass(extendsClause) && !_checkForAllMixinErrorCodes(withClause)) {
          _checkForExtendsDeferredClass(extendsClause);
          _checkForImplementsDeferredClass(implementsClause);
          _checkForNonAbstractClassInheritsAbstractMember(node.name);
          _checkForInconsistentMethodInheritance();
          _checkForRecursiveInterfaceInheritance(_enclosingClass);
          _checkForConflictingGetterAndMethod();
          _checkForConflictingInstanceGetterAndSuperclassMember();
          _checkImplementsSuperClass(node);
          _checkImplementsFunctionWithoutCall(node);
        }
      }
      if (_enclosingClass != null) {
        List<FieldElement> fieldElements = _enclosingClass.fields;
        _initialFieldElementsMap = new A_p.HashMap<FieldElement,INIT_STATE>();
        for (FieldElement fieldElement in fieldElements) {
          if (!fieldElement.isSynthetic) {
            _initialFieldElementsMap[fieldElement] = fieldElement.initializer == null ? INIT_STATE.NOT_INIT : INIT_STATE.INIT_IN_DECLARATION;
          }
        }
      }
      _checkForFinalNotInitializedInClass(node);
      _checkForDuplicateDefinitionInheritance();
      _checkForConflictingInstanceMethodSetter(node);
      return super.visitClassDeclaration(node);
    } finally {
      _isInNativeClass = false;
      _initialFieldElementsMap = null;
      _enclosingClass = outerClass;
    }
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    _checkForBuiltInIdentifierAsName(node.name, CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME);
    ClassElement outerClassElement = _enclosingClass;
    try {
      _enclosingClass = node.element;
      ImplementsClause implementsClause = node.implementsClause;
      if (!_checkForExtendsDisallowedClassInTypeAlias(node) && !_checkForImplementsDisallowedClass(implementsClause) && !_checkForAllMixinErrorCodes(node.withClause)) {
        _checkForExtendsDeferredClassInTypeAlias(node);
        _checkForImplementsDeferredClass(implementsClause);
        _checkForRecursiveInterfaceInheritance(_enclosingClass);
        _checkForNonAbstractClassInheritsAbstractMember(node.name);
      }
    } finally {
      _enclosingClass = outerClassElement;
    }
    return super.visitClassTypeAlias(node);
  }
  Object visitComment(Comment node) {
    _isInComment = true;
    try {
      return super.visitComment(node);
    } finally {
      _isInComment = false;
    }
  }
  Object visitCompilationUnit(CompilationUnit node) {
    _checkForDeferredPrefixCollisions(node);
    return super.visitCompilationUnit(node);
  }
  Object visitConditionalExpression(ConditionalExpression node) {
    _checkForNonBoolCondition(node.condition);
    return super.visitConditionalExpression(node);
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      ConstructorElement constructorElement = node.element;
      _enclosingFunction = constructorElement;
      _isEnclosingConstructorConst = node.constKeyword != null;
      _isInFactory = node.factoryKeyword != null;
      _checkForConstConstructorWithNonFinalField(node, constructorElement);
      _checkForConstConstructorWithNonConstSuper(node);
      _checkForConflictingConstructorNameAndMember(node, constructorElement);
      _checkForAllFinalInitializedErrorCodes(node);
      _checkForRedirectingConstructorErrorCodes(node);
      _checkForMultipleSuperInitializers(node);
      _checkForRecursiveConstructorRedirect(node, constructorElement);
      if (!_checkForRecursiveFactoryRedirect(node, constructorElement)) {
        _checkForAllRedirectConstructorErrorCodes(node);
      }
      _checkForUndefinedConstructorInInitializerImplicit(node);
      _checkForRedirectToNonConstConstructor(node, constructorElement);
      _checkForReturnInGenerativeConstructor(node);
      return super.visitConstructorDeclaration(node);
    } finally {
      _isEnclosingConstructorConst = false;
      _isInFactory = false;
      _enclosingFunction = outerFunction;
    }
  }
  Object visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    _isInConstructorInitializer = true;
    try {
      SimpleIdentifier fieldName = node.fieldName;
      A_Element staticElement = fieldName.staticElement;
      _checkForInvalidField(node, fieldName, staticElement);
      _checkForFieldInitializerNotAssignable(node, staticElement);
      return super.visitConstructorFieldInitializer(node);
    } finally {
      _isInConstructorInitializer = false;
    }
  }
  Object visitContinueStatement(ContinueStatement node) {
    SimpleIdentifier labelNode = node.label;
    if (labelNode != null) {
      A_Element labelElement = labelNode.staticElement;
      if (labelElement is LabelElementImpl && labelElement.isOnSwitchStatement) {
        _errorReporter.reportErrorForNode(ResolverErrorCode.CONTINUE_LABEL_ON_SWITCH, labelNode, []);
      }
    }
    return null;
  }
  Object visitDefaultFormalParameter(DefaultFormalParameter node) {
    _checkForInvalidAssignment(node.identifier, node.defaultValue);
    _checkForDefaultValueInFunctionTypedParameter(node);
    return super.visitDefaultFormalParameter(node);
  }
  Object visitDoStatement(DoStatement node) {
    _checkForNonBoolCondition(node.condition);
    return super.visitDoStatement(node);
  }
  Object visitExportDirective(ExportDirective node) {
    ExportElement exportElement = node.element;
    if (exportElement != null) {
      LibraryElement exportedLibrary = exportElement.exportedLibrary;
      _checkForAmbiguousExport(node, exportElement, exportedLibrary);
      _checkForExportDuplicateLibraryName(node, exportElement, exportedLibrary);
      _checkForExportInternalLibrary(node, exportElement);
    }
    return super.visitExportDirective(node);
  }
  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {
    FunctionType A_functionType = _enclosingFunction == null ? null : _enclosingFunction.type;
    DartType expectedReturnType = A_functionType == null ? DynamicTypeImpl.instance : A_functionType.returnType;
    _checkForReturnOfInvalidType(node.expression, expectedReturnType);
    return super.visitExpressionFunctionBody(node);
  }
  Object visitFieldDeclaration(FieldDeclaration node) {
    _isInStaticVariableDeclaration = node.isStatic;
    _isInInstanceVariableDeclaration = !_isInStaticVariableDeclaration;
    if (_isInInstanceVariableDeclaration) {
      VariableDeclarationList variables = node.fields;
      if (variables.isConst) {
        _errorReporter.reportErrorForToken(CompileTimeErrorCode.CONST_INSTANCE_FIELD, variables.keyword, []);
      }
    }
    try {
      _checkForAllInvalidOverrideErrorCodesForField(node);
      return super.visitFieldDeclaration(node);
    } finally {
      _isInStaticVariableDeclaration = false;
      _isInInstanceVariableDeclaration = false;
    }
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    _checkForValidField(node);
    _checkForConstFormalParameter(node);
    _checkForPrivateOptionalParameter(node);
    _checkForFieldInitializingFormalRedirectingConstructor(node);
    _checkForTypeAnnotationDeferredClass(node.type);
    return super.visitFieldFormalParameter(node);
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      SimpleIdentifier identifier = node.name;
      String methodName = "";
      if (identifier != null) {
        methodName = identifier.name;
      }
      _enclosingFunction = node.element;
      TypeName A_returnType = node.returnType;
      if (node.isSetter || node.isGetter) {
        _checkForMismatchedAccessorTypes(node, methodName);
        if (node.isSetter) {
          FunctionExpression functionExpression = node.functionExpression;
          if (functionExpression != null) {
            _checkForWrongNumberOfParametersForSetter(identifier, functionExpression.parameters);
          }
          _checkForNonVoidReturnTypeForSetter(A_returnType);
        }
      }
      _checkForTypeAnnotationDeferredClass(A_returnType);
      return super.visitFunctionDeclaration(node);
    } finally {
      _enclosingFunction = outerFunction;
    }
  }
  Object visitFunctionExpression(FunctionExpression node) {
    if (node.parent is! FunctionDeclaration) {
      ExecutableElement outerFunction = _enclosingFunction;
      try {
        _enclosingFunction = node.element;
        return super.visitFunctionExpression(node);
      } finally {
        _enclosingFunction = outerFunction;
      }
    } else {
      return super.visitFunctionExpression(node);
    }
  }
  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    Expression functionExpression = node.function;
    DartType expressionType = functionExpression.staticType;
    if (!_isFunctionType(expressionType)) {
      _errorReporter.reportErrorForNode(StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION_EXPRESSION, functionExpression, []);
    }
    return super.visitFunctionExpressionInvocation(node);
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    _checkForBuiltInIdentifierAsName(node.name, CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME);
    _checkForDefaultValueInFunctionTypeAlias(node);
    _checkForTypeAliasCannotReferenceItself_function(node);
    return super.visitFunctionTypeAlias(node);
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    bool old = _isInFunctionTypedFormalParameter;
    _isInFunctionTypedFormalParameter = true;
    try {
      _checkForTypeAnnotationDeferredClass(node.returnType);
      return super.visitFunctionTypedFormalParameter(node);
    } finally {
      _isInFunctionTypedFormalParameter = old;
    }
  }
  Object visitIfStatement(IfStatement node) {
    _checkForNonBoolCondition(node.condition);
    return super.visitIfStatement(node);
  }
  Object visitImportDirective(ImportDirective node) {
    ImportElement importElement = node.element;
    if (importElement != null) {
      _checkForImportDuplicateLibraryName(node, importElement);
      _checkForImportInternalLibrary(node, importElement);
    }
    return super.visitImportDirective(node);
  }
  Object visitIndexExpression(IndexExpression node) {
    _checkForArgumentTypeNotAssignableForArgument(node.index);
    return super.visitIndexExpression(node);
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    _isInConstInstanceCreation = node.isConst;
    try {
      ConstructorName constructorName = node.constructorName;
      TypeName typeName = constructorName.type;
      DartType A_type = typeName.type;
      if (A_type is InterfaceType) {
        InterfaceType interfaceType = A_type;
        _checkForConstOrNewWithAbstractClass(node, typeName, interfaceType);
        if (_isInConstInstanceCreation) {
          _checkForConstWithNonConst(node);
          _checkForConstWithUndefinedConstructor(node, constructorName, typeName);
          _checkForConstWithTypeParameters(typeName);
          _checkForConstDeferredClass(node, constructorName, typeName);
        } else {
          _checkForNewWithUndefinedConstructor(node, constructorName, typeName);
        }
      }
      return super.visitInstanceCreationExpression(node);
    } finally {
      _isInConstInstanceCreation = false;
    }
  }
  Object visitIsExpression(IsExpression node) {
    _checkForTypeAnnotationDeferredClass(node.type);
    return super.visitIsExpression(node);
  }
  Object visitListLiteral(ListLiteral node) {
    TypeArgumentList typeArguments = node.typeArguments;
    if (typeArguments != null) {
      if (node.constKeyword != null) {
        NodeList<TypeName> A_arguments = typeArguments.arguments;
        if (A_arguments.length != 0) {
          _checkForInvalidTypeArgumentInConstTypedLiteral(A_arguments, CompileTimeErrorCode.INVALID_TYPE_ARGUMENT_IN_CONST_LIST);
        }
      }
      _checkForExpectedOneListTypeArgument(node, typeArguments);
      _checkForListElementTypeNotAssignable(node, typeArguments);
    }
    return super.visitListLiteral(node);
  }
  Object visitMapLiteral(MapLiteral node) {
    TypeArgumentList typeArguments = node.typeArguments;
    if (typeArguments != null) {
      NodeList<TypeName> A_arguments = typeArguments.arguments;
      if (A_arguments.length != 0) {
        if (node.constKeyword != null) {
          _checkForInvalidTypeArgumentInConstTypedLiteral(A_arguments, CompileTimeErrorCode.INVALID_TYPE_ARGUMENT_IN_CONST_MAP);
        }
      }
      _checkExpectedTwoMapTypeArguments(typeArguments);
      _checkForMapTypeNotAssignable(node, typeArguments);
    }
    _checkForNonConstMapAsExpressionStatement(node);
    return super.visitMapLiteral(node);
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    ExecutableElement previousFunction = _enclosingFunction;
    try {
      _isInStaticMethod = node.isStatic;
      _enclosingFunction = node.element;
      SimpleIdentifier identifier = node.name;
      String methodName = "";
      if (identifier != null) {
        methodName = identifier.name;
      }
      TypeName returnTypeName = node.returnType;
      if (node.isSetter || node.isGetter) {
        _checkForMismatchedAccessorTypes(node, methodName);
      }
      if (node.isGetter) {
        _checkForVoidReturnType(node);
        _checkForConflictingStaticGetterAndInstanceSetter(node);
      } else if (node.isSetter) {
        _checkForWrongNumberOfParametersForSetter(node.name, node.parameters);
        _checkForNonVoidReturnTypeForSetter(returnTypeName);
        _checkForConflictingStaticSetterAndInstanceMember(node);
      } else if (node.isOperator) {
        _checkForOptionalParameterInOperator(node);
        _checkForWrongNumberOfParametersForOperator(node);
        _checkForNonVoidReturnTypeForOperator(node);
      }
      _checkForConcreteClassWithAbstractMember(node);
      _checkForAllInvalidOverrideErrorCodesForMethod(node);
      _checkForTypeAnnotationDeferredClass(returnTypeName);
      return super.visitMethodDeclaration(node);
    } finally {
      _enclosingFunction = previousFunction;
      _isInStaticMethod = false;
    }
  }
  Object visitMethodInvocation(MethodInvocation node) {
    Expression A_target = node.realTarget;
    SimpleIdentifier methodName = node.methodName;
    if (A_target != null) {
      ClassElement typeReference = ElementResolver.getTypeReference(A_target);
      _checkForStaticAccessToInstanceMember(typeReference, methodName);
      _checkForInstanceAccessToStaticMember(typeReference, methodName);
    } else {
      _checkForUnqualifiedReferenceToNonLocalStaticMember(methodName);
    }
    return super.visitMethodInvocation(node);
  }
  Object visitNativeClause(NativeClause node) {
    if (!_isInSystemLibrary) {
      _errorReporter.reportErrorForNode(ParserErrorCode.NATIVE_CLAUSE_IN_NON_SDK_CODE, node, []);
    }
    return super.visitNativeClause(node);
  }
  Object visitNativeFunctionBody(NativeFunctionBody node) {
    _checkForNativeFunctionBodyInNonSDKCode(node);
    return super.visitNativeFunctionBody(node);
  }
  Object visitPostfixExpression(PostfixExpression node) {
    _checkForAssignmentToFinal(node.operand);
    _checkForIntNotAssignable(node.operand);
    return super.visitPostfixExpression(node);
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    if (node.parent is! Annotation) {
      ClassElement typeReference = ElementResolver.getTypeReference(node.prefix);
      SimpleIdentifier A_name = node.identifier;
      _checkForStaticAccessToInstanceMember(typeReference, A_name);
      _checkForInstanceAccessToStaticMember(typeReference, A_name);
    }
    return super.visitPrefixedIdentifier(node);
  }
  Object visitPrefixExpression(PrefixExpression node) {
    A_TokenType operatorType = node.operator.type;
    Expression operand = node.operand;
    if (operatorType == A_TokenType.BANG) {
      _checkForNonBoolNegationExpression(operand);
    } else if (operatorType.isIncrementOperator) {
      _checkForAssignmentToFinal(operand);
    }
    _checkForIntNotAssignable(operand);
    return super.visitPrefixExpression(node);
  }
  Object visitPropertyAccess(PropertyAccess node) {
    ClassElement typeReference = ElementResolver.getTypeReference(node.realTarget);
    SimpleIdentifier propertyName = node.propertyName;
    _checkForStaticAccessToInstanceMember(typeReference, propertyName);
    _checkForInstanceAccessToStaticMember(typeReference, propertyName);
    return super.visitPropertyAccess(node);
  }
  Object visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    _isInConstructorInitializer = true;
    try {
      return super.visitRedirectingConstructorInvocation(node);
    } finally {
      _isInConstructorInitializer = false;
    }
  }
  Object visitRethrowExpression(RethrowExpression node) {
    _checkForRethrowOutsideCatch(node);
    return super.visitRethrowExpression(node);
  }
  Object visitReturnStatement(ReturnStatement node) {
    if (node.expression == null) {
      _returnsWithout.add(node);
    } else {
      _returnsWith.add(node);
    }
    _checkForAllReturnStatementErrorCodes(node);
    return super.visitReturnStatement(node);
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    _checkForConstFormalParameter(node);
    _checkForPrivateOptionalParameter(node);
    _checkForTypeAnnotationDeferredClass(node.type);
    return super.visitSimpleFormalParameter(node);
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    _checkForImplicitThisReferenceInInitializer(node);
    if (!_isUnqualifiedReferenceToNonLocalStaticMemberAllowed(node)) {
      _checkForUnqualifiedReferenceToNonLocalStaticMember(node);
    }
    return super.visitSimpleIdentifier(node);
  }
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    _isInConstructorInitializer = true;
    try {
      return super.visitSuperConstructorInvocation(node);
    } finally {
      _isInConstructorInitializer = false;
    }
  }
  Object visitSwitchStatement(SwitchStatement node) {
    _checkForSwitchExpressionNotAssignable(node);
    _checkForCaseBlocksNotTerminated(node);
    return super.visitSwitchStatement(node);
  }
  Object visitThisExpression(ThisExpression node) {
    _checkForInvalidReferenceToThis(node);
    return super.visitThisExpression(node);
  }
  Object visitThrowExpression(ThrowExpression node) {
    _checkForConstEvalThrowsException(node);
    return super.visitThrowExpression(node);
  }
  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    _checkForFinalNotInitialized(node.variables);
    return super.visitTopLevelVariableDeclaration(node);
  }
  Object visitTypeArgumentList(TypeArgumentList node) {
    NodeList<TypeName> A_list = node.arguments;
    for (TypeName typeName in A_list) {
      _checkForTypeAnnotationDeferredClass(typeName);
    }
    return super.visitTypeArgumentList(node);
  }
  Object visitTypeName(TypeName node) {
    _checkForTypeArgumentNotMatchingBounds(node);
    _checkForTypeParameterReferencedByStatic(node);
    return super.visitTypeName(node);
  }
  Object visitTypeParameter(TypeParameter node) {
    _checkForBuiltInIdentifierAsName(node.name, CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME);
    _checkForTypeParameterSupertypeOfItsBound(node);
    _checkForTypeAnnotationDeferredClass(node.bound);
    return super.visitTypeParameter(node);
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    SimpleIdentifier nameNode = node.name;
    Expression initializerNode = node.initializer;
    _checkForInvalidAssignment(nameNode, initializerNode);
    nameNode.accept(this);
    String A_name = nameNode.name;
    _namesForReferenceToDeclaredVariableInInitializer.add(A_name);
    _isInInstanceVariableInitializer = _isInInstanceVariableDeclaration;
    try {
      if (initializerNode != null) {
        initializerNode.accept(this);
      }
    } finally {
      _isInInstanceVariableInitializer = false;
      _namesForReferenceToDeclaredVariableInInitializer.remove(A_name);
    }
    return null;
  }
  Object visitVariableDeclarationList(VariableDeclarationList node) {
    _checkForTypeAnnotationDeferredClass(node.type);
    return super.visitVariableDeclarationList(node);
  }
  Object visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    _checkForFinalNotInitialized(node.variables);
    return super.visitVariableDeclarationStatement(node);
  }
  Object visitWhileStatement(WhileStatement node) {
    _checkForNonBoolCondition(node.condition);
    return super.visitWhileStatement(node);
  }
  bool _checkExpectedTwoMapTypeArguments(TypeArgumentList typeArguments) {
    int A_num = typeArguments.arguments.length;
    if (A_num == 2) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticTypeWarningCode.EXPECTED_TWO_MAP_TYPE_ARGUMENTS, typeArguments, [A_num]);
    return true;
  }
  bool _checkForAllFinalInitializedErrorCodes(ConstructorDeclaration node) {
    if (node.factoryKeyword != null || node.redirectedConstructor != null || node.externalKeyword != null) {
      return false;
    }
    if (_isInNativeClass) {
      return false;
    }
    bool foundError = false;
    A_p.HashMap<FieldElement, INIT_STATE> fieldElementsMap = new A_p.HashMap<FieldElement,INIT_STATE>.from(_initialFieldElementsMap);
    NodeList<FormalParameter> formalParameters = node.parameters.parameters;
    for (FormalParameter formalParameter in formalParameters) {
      FormalParameter parameter = formalParameter;
      if (parameter is DefaultFormalParameter) {
        parameter = (parameter as DefaultFormalParameter).parameter;
      }
      if (parameter is FieldFormalParameter) {
        FieldElement fieldElement = (parameter.element as FieldFormalParameterElementImpl).field;
        INIT_STATE state = fieldElementsMap[fieldElement];
        if (state == INIT_STATE.NOT_INIT) {
          fieldElementsMap[fieldElement] = INIT_STATE.INIT_IN_FIELD_FORMAL;
        } else if (state == INIT_STATE.INIT_IN_DECLARATION) {
          if (fieldElement.isFinal || fieldElement.isConst) {
            _errorReporter.reportErrorForNode(StaticWarningCode.FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR, formalParameter.identifier, [fieldElement.displayName]);
            foundError = true;
          }
        } else if (state == INIT_STATE.INIT_IN_FIELD_FORMAL) {
          if (fieldElement.isFinal || fieldElement.isConst) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.FINAL_INITIALIZED_MULTIPLE_TIMES, formalParameter.identifier, [fieldElement.displayName]);
            foundError = true;
          }
        }
      }
    }
    NodeList<ConstructorInitializer> initializers = node.initializers;
    for (ConstructorInitializer constructorInitializer in initializers) {
      if (constructorInitializer is RedirectingConstructorInvocation) {
        return false;
      }
      if (constructorInitializer is ConstructorFieldInitializer) {
        ConstructorFieldInitializer constructorFieldInitializer = constructorInitializer;
        SimpleIdentifier fieldName = constructorFieldInitializer.fieldName;
        A_Element A_element = fieldName.staticElement;
        if (A_element is FieldElement) {
          FieldElement fieldElement = A_element;
          INIT_STATE state = fieldElementsMap[fieldElement];
          if (state == INIT_STATE.NOT_INIT) {
            fieldElementsMap[fieldElement] = INIT_STATE.INIT_IN_INITIALIZERS;
          } else if (state == INIT_STATE.INIT_IN_DECLARATION) {
            if (fieldElement.isFinal || fieldElement.isConst) {
              _errorReporter.reportErrorForNode(StaticWarningCode.FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION, fieldName, []);
              foundError = true;
            }
          } else if (state == INIT_STATE.INIT_IN_FIELD_FORMAL) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER, fieldName, []);
            foundError = true;
          } else if (state == INIT_STATE.INIT_IN_INITIALIZERS) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS, fieldName, [fieldElement.displayName]);
            foundError = true;
          }
        }
      }
    }
    for (MapEntry<FieldElement, INIT_STATE> A_entry in getMapEntrySet(fieldElementsMap)) {
      if (A_entry.getValue() == INIT_STATE.NOT_INIT) {
        FieldElement fieldElement = A_entry.getKey();
        if (fieldElement.isConst) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_NOT_INITIALIZED, node.returnType, [fieldElement.name]);
          foundError = true;
        } else if (fieldElement.isFinal) {
          _errorReporter.reportErrorForNode(StaticWarningCode.FINAL_NOT_INITIALIZED, node.returnType, [fieldElement.name]);
          foundError = true;
        }
      }
    }
    return foundError;
  }
  bool _checkForAllInvalidOverrideErrorCodes(ExecutableElement executableElement, ExecutableElement overriddenExecutable, List<ParameterElement> A_parameters, List<AstNode> parameterLocations, SimpleIdentifier errorNameTarget) {
    bool A_isGetter = false;
    bool A_isSetter = false;
    if (executableElement is PropertyAccessorElement) {
      PropertyAccessorElement accessorElement = executableElement;
      A_isGetter = accessorElement.isGetter;
      A_isSetter = accessorElement.isSetter;
    }
    String executableElementName = executableElement.name;
    FunctionType overridingFT = executableElement.type;
    FunctionType overriddenFT = overriddenExecutable.type;
    InterfaceType enclosingType = _enclosingClass.type;
    overriddenFT = _inheritanceManager.substituteTypeArgumentsInMemberFromInheritance(overriddenFT, executableElementName, enclosingType);
    if (overridingFT == null || overriddenFT == null) {
      return false;
    }
    DartType overridingFTReturnType = overridingFT.returnType;
    DartType overriddenFTReturnType = overriddenFT.returnType;
    List<DartType> overridingNormalPT = overridingFT.normalParameterTypes;
    List<DartType> overriddenNormalPT = overriddenFT.normalParameterTypes;
    List<DartType> overridingPositionalPT = overridingFT.optionalParameterTypes;
    List<DartType> overriddenPositionalPT = overriddenFT.optionalParameterTypes;
    Map<String, DartType> overridingNamedPT = overridingFT.namedParameterTypes;
    Map<String, DartType> overriddenNamedPT = overriddenFT.namedParameterTypes;
    if (overridingNormalPT.length > overriddenNormalPT.length) {
      _errorReporter.reportErrorForNode(StaticWarningCode.INVALID_OVERRIDE_REQUIRED, errorNameTarget, [overriddenNormalPT.length, overriddenExecutable.enclosingElement.displayName]);
      return true;
    }
    if (overridingNormalPT.length + overridingPositionalPT.length < overriddenPositionalPT.length + overriddenNormalPT.length) {
      _errorReporter.reportErrorForNode(StaticWarningCode.INVALID_OVERRIDE_POSITIONAL, errorNameTarget, [overriddenPositionalPT.length + overriddenNormalPT.length, overriddenExecutable.enclosingElement.displayName]);
      return true;
    }
    Set<String> overridingParameterNameSet = overridingNamedPT.keys.toSet();
    JavaIterator<String> overriddenParameterNameIterator = new JavaIterator(overriddenNamedPT.keys.toSet());
    while (overriddenParameterNameIterator.hasNext) {
      String overriddenParamName = overriddenParameterNameIterator.next();
      if (!overridingParameterNameSet.contains(overriddenParamName)) {
        _errorReporter.reportErrorForNode(StaticWarningCode.INVALID_OVERRIDE_NAMED, errorNameTarget, [overriddenParamName, overriddenExecutable.enclosingElement.displayName]);
        return true;
      }
    }
    if (overriddenFTReturnType != VoidTypeImpl.instance && !overridingFTReturnType.isAssignableTo(overriddenFTReturnType)) {
      _errorReporter.reportTypeErrorForNode(!A_isGetter ? StaticWarningCode.INVALID_METHOD_OVERRIDE_RETURN_TYPE : StaticWarningCode.INVALID_GETTER_OVERRIDE_RETURN_TYPE, errorNameTarget, [overridingFTReturnType, overriddenFTReturnType, overriddenExecutable.enclosingElement.displayName]);
      return true;
    }
    if (parameterLocations == null) {
      return false;
    }
    int parameterIndex = 0;
    for (int i = 0; i < overridingNormalPT.length; i++) {
      if (!overridingNormalPT[i].isAssignableTo(overriddenNormalPT[i])) {
        _errorReporter.reportTypeErrorForNode(!A_isSetter ? StaticWarningCode.INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE : StaticWarningCode.INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE, parameterLocations[parameterIndex], [overridingNormalPT[i], overriddenNormalPT[i], overriddenExecutable.enclosingElement.displayName]);
        return true;
      }
      parameterIndex++;
    }
    for (int i = 0; i < overriddenPositionalPT.length; i++) {
      if (!overridingPositionalPT[i].isAssignableTo(overriddenPositionalPT[i])) {
        _errorReporter.reportTypeErrorForNode(StaticWarningCode.INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE, parameterLocations[parameterIndex], [overridingPositionalPT[i], overriddenPositionalPT[i], overriddenExecutable.enclosingElement.displayName]);
        return true;
      }
      parameterIndex++;
    }
    JavaIterator<MapEntry<String, DartType>> overriddenNamedPTIterator = new JavaIterator(getMapEntrySet(overriddenNamedPT));
    while (overriddenNamedPTIterator.hasNext) {
      MapEntry<String, DartType> overriddenNamedPTEntry = overriddenNamedPTIterator.next();
      DartType overridingType = overridingNamedPT[overriddenNamedPTEntry.getKey()];
      if (overridingType == null) {
        continue;
      }
      if (!overriddenNamedPTEntry.getValue().isAssignableTo(overridingType)) {
        ParameterElement parameterToSelect = null;
        AstNode parameterLocationToSelect = null;
        for (int i = 0; i < A_parameters.length; i++) {
          ParameterElement parameter = A_parameters[i];
          if (parameter.parameterKind == ParameterKind.NAMED && overriddenNamedPTEntry.getKey() == parameter.name) {
            parameterToSelect = parameter;
            parameterLocationToSelect = parameterLocations[i];
            break;
          }
        }
        if (parameterToSelect != null) {
          _errorReporter.reportTypeErrorForNode(StaticWarningCode.INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE, parameterLocationToSelect, [overridingType, overriddenNamedPTEntry.getValue(), overriddenExecutable.enclosingElement.displayName]);
          return true;
        }
      }
    }
    bool foundError = false;
    List<AstNode> formalParameters = new List<AstNode>();
    List<ParameterElementImpl> parameterElts = new List<ParameterElementImpl>();
    List<ParameterElementImpl> overriddenParameterElts = new List<ParameterElementImpl>();
    List<ParameterElement> overriddenPEs = overriddenExecutable.parameters;
    for (int i = 0; i < A_parameters.length; i++) {
      ParameterElement parameter = A_parameters[i];
      if (parameter.parameterKind.isOptional) {
        formalParameters.add(parameterLocations[i]);
        parameterElts.add(parameter as ParameterElementImpl);
      }
    }
    for (ParameterElement parameterElt in overriddenPEs) {
      if (parameterElt.parameterKind.isOptional) {
        if (parameterElt is ParameterElementImpl) {
          overriddenParameterElts.add(parameterElt);
        }
      }
    }
    if (parameterElts.length > 0) {
      if (parameterElts[0].parameterKind == ParameterKind.NAMED) {
        for (int i = 0; i < parameterElts.length; i++) {
          ParameterElementImpl parameterElt = parameterElts[i];
          EvaluationResultImpl result = parameterElt.evaluationResult;
          if (_isUserDefinedObject(result)) {
            continue;
          }
          String A_parameterName = parameterElt.name;
          for (int j = 0; j < overriddenParameterElts.length; j++) {
            ParameterElementImpl overriddenParameterElt = overriddenParameterElts[j];
            String overriddenParameterName = overriddenParameterElt.name;
            if (A_parameterName != null && A_parameterName == overriddenParameterName) {
              EvaluationResultImpl overriddenResult = overriddenParameterElt.evaluationResult;
              if (_isUserDefinedObject(overriddenResult)) {
                break;
              }
              if (!result.equalValues(B__typeProvider, overriddenResult)) {
                _errorReporter.reportErrorForNode(StaticWarningCode.INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED, formalParameters[i], [overriddenExecutable.enclosingElement.displayName, overriddenExecutable.displayName, A_parameterName]);
                foundError = true;
              }
            }
          }
        }
      } else {
        for (int i = 0; i < parameterElts.length && i < overriddenParameterElts.length; i++) {
          ParameterElementImpl parameterElt = parameterElts[i];
          EvaluationResultImpl result = parameterElt.evaluationResult;
          if (_isUserDefinedObject(result)) {
            continue;
          }
          ParameterElementImpl overriddenParameterElt = overriddenParameterElts[i];
          EvaluationResultImpl overriddenResult = overriddenParameterElt.evaluationResult;
          if (_isUserDefinedObject(overriddenResult)) {
            continue;
          }
          if (!result.equalValues(B__typeProvider, overriddenResult)) {
            _errorReporter.reportErrorForNode(StaticWarningCode.INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL, formalParameters[i], [overriddenExecutable.enclosingElement.displayName, overriddenExecutable.displayName]);
            foundError = true;
          }
        }
      }
    }
    return foundError;
  }
  bool _checkForAllInvalidOverrideErrorCodesForExecutable(ExecutableElement executableElement, List<ParameterElement> A_parameters, List<AstNode> parameterLocations, SimpleIdentifier errorNameTarget) {
    List<ExecutableElement> overriddenExecutables = _inheritanceManager.lookupOverrides(_enclosingClass, executableElement.name);
    if (overriddenExecutables.isEmpty) {
      return _checkForInstanceMethodNameCollidesWithSuperclassStatic(executableElement, errorNameTarget);
    }
    for (ExecutableElement overriddenElement in overriddenExecutables) {
      if (_checkForAllInvalidOverrideErrorCodes(executableElement, overriddenElement, A_parameters, parameterLocations, errorNameTarget)) {
        return true;
      }
    }
    return false;
  }
  bool _checkForAllInvalidOverrideErrorCodesForField(FieldDeclaration node) {
    if (_enclosingClass == null || node.isStatic) {
      return false;
    }
    bool hasProblems = false;
    VariableDeclarationList fields = node.fields;
    for (VariableDeclaration field in fields.variables) {
      FieldElement A_element = field.element as FieldElement;
      if (A_element == null) {
        continue;
      }
      PropertyAccessorElement getter = A_element.getter;
      PropertyAccessorElement setter = A_element.setter;
      SimpleIdentifier fieldName = field.name;
      if (getter != null) {
        hasProblems = javaBooleanOr(hasProblems, _checkForAllInvalidOverrideErrorCodesForExecutable(getter, ParameterElementImpl.B_EMPTY_ARRAY, AstNode.A_EMPTY_ARRAY, fieldName));
      }
      if (setter != null) {
        hasProblems = javaBooleanOr(hasProblems, _checkForAllInvalidOverrideErrorCodesForExecutable(setter, setter.parameters, <AstNode>[fieldName], fieldName));
      }
    }
    return hasProblems;
  }
  bool _checkForAllInvalidOverrideErrorCodesForMethod(MethodDeclaration node) {
    if (_enclosingClass == null || node.isStatic || node.body is NativeFunctionBody) {
      return false;
    }
    ExecutableElement executableElement = node.element;
    if (executableElement == null) {
      return false;
    }
    SimpleIdentifier methodName = node.name;
    if (methodName.isSynthetic) {
      return false;
    }
    FormalParameterList formalParameterList = node.parameters;
    NodeList<FormalParameter> parameterList = formalParameterList != null ? formalParameterList.parameters : null;
    List<AstNode> A_parameters = parameterList != null ? new List.from(parameterList) : null;
    return _checkForAllInvalidOverrideErrorCodesForExecutable(executableElement, executableElement.parameters, A_parameters, methodName);
  }
  bool _checkForAllMixinErrorCodes(WithClause withClause) {
    if (withClause == null) {
      return false;
    }
    bool problemReported = false;
    for (TypeName mixinName in withClause.mixinTypes) {
      DartType mixinType = mixinName.type;
      if (mixinType is! InterfaceType) {
        continue;
      }
      if (_checkForExtendsOrImplementsDisallowedClass(mixinName, CompileTimeErrorCode.MIXIN_OF_DISALLOWED_CLASS)) {
        problemReported = true;
      } else {
        ClassElement mixinElement = (mixinType as InterfaceType).element;
        problemReported = javaBooleanOr(problemReported, _checkForExtendsOrImplementsDeferredClass(mixinName, CompileTimeErrorCode.MIXIN_DEFERRED_CLASS));
        problemReported = javaBooleanOr(problemReported, _checkForMixinDeclaresConstructor(mixinName, mixinElement));
        problemReported = javaBooleanOr(problemReported, _checkForMixinInheritsNotFromObject(mixinName, mixinElement));
        problemReported = javaBooleanOr(problemReported, _checkForMixinReferencesSuper(mixinName, mixinElement));
      }
    }
    return problemReported;
  }
  bool _checkForAllRedirectConstructorErrorCodes(ConstructorDeclaration node) {
    ConstructorName redirectedConstructor = node.redirectedConstructor;
    if (redirectedConstructor == null) {
      return false;
    }
    ConstructorElement redirectedElement = redirectedConstructor.staticElement;
    if (redirectedElement == null) {
      TypeName constructorTypeName = redirectedConstructor.type;
      DartType redirectedType = constructorTypeName.type;
      if (redirectedType != null && redirectedType.element != null && !redirectedType.isDynamic) {
        String constructorStrName = constructorTypeName.name.name;
        if (redirectedConstructor.name != null) {
          constructorStrName += ".${redirectedConstructor.name.name}";
        }
        ErrorCode A_errorCode = (node.constKeyword != null ? CompileTimeErrorCode.REDIRECT_TO_MISSING_CONSTRUCTOR : StaticWarningCode.REDIRECT_TO_MISSING_CONSTRUCTOR);
        _errorReporter.reportErrorForNode(A_errorCode, redirectedConstructor, [constructorStrName, redirectedType.displayName]);
        return true;
      }
      return false;
    }
    FunctionType redirectedType = redirectedElement.type;
    DartType redirectedReturnType = redirectedType.returnType;
    FunctionType constructorType = node.element.type;
    DartType constructorReturnType = constructorType.returnType;
    if (!redirectedReturnType.isAssignableTo(constructorReturnType)) {
      _errorReporter.reportErrorForNode(StaticWarningCode.REDIRECT_TO_INVALID_RETURN_TYPE, redirectedConstructor, [redirectedReturnType, constructorReturnType]);
      return true;
    }
    if (!redirectedType.isSubtypeOf(constructorType)) {
      _errorReporter.reportErrorForNode(StaticWarningCode.REDIRECT_TO_INVALID_FUNCTION_TYPE, redirectedConstructor, [redirectedType, constructorType]);
      return true;
    }
    return false;
  }
  bool _checkForAllReturnStatementErrorCodes(ReturnStatement node) {
    FunctionType A_functionType = _enclosingFunction == null ? null : _enclosingFunction.type;
    DartType expectedReturnType = A_functionType == null ? DynamicTypeImpl.instance : A_functionType.returnType;
    Expression returnExpression = node.expression;
    bool isGenerativeConstructor = _enclosingFunction is ConstructorElement && !(_enclosingFunction as ConstructorElement).isFactory;
    if (isGenerativeConstructor) {
      if (returnExpression == null) {
        return false;
      }
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.RETURN_IN_GENERATIVE_CONSTRUCTOR, returnExpression, []);
      return true;
    }
    if (returnExpression == null) {
      if (VoidTypeImpl.instance.isAssignableTo(expectedReturnType)) {
        return false;
      }
      _hasReturnWithoutValue = true;
      _errorReporter.reportErrorForNode(StaticWarningCode.RETURN_WITHOUT_VALUE, node, []);
      return true;
    }
    return _checkForReturnOfInvalidType(returnExpression, expectedReturnType);
  }
  bool _checkForAmbiguousExport(ExportDirective node, ExportElement exportElement, LibraryElement exportedLibrary) {
    if (exportedLibrary == null) {
      return false;
    }
    Namespace namespace = new NamespaceBuilder().createExportNamespaceForDirective(exportElement);
    Map<String, A_Element> definedNames = namespace.definedNames;
    for (MapEntry<String, A_Element> definedEntry in getMapEntrySet(definedNames)) {
      String A_name = definedEntry.getKey();
      A_Element A_element = definedEntry.getValue();
      A_Element prevElement = _exportedElements[A_name];
      if (A_element != null && prevElement != null && prevElement != A_element) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.AMBIGUOUS_EXPORT, node, [A_name, prevElement.library.definingCompilationUnit.displayName, A_element.library.definingCompilationUnit.displayName]);
        return true;
      } else {
        _exportedElements[A_name] = A_element;
      }
    }
    return false;
  }
  bool _checkForArgumentTypeNotAssignable(Expression expression, DartType expectedStaticType, DartType actualStaticType, ErrorCode A_errorCode) {
    if (actualStaticType != null && expectedStaticType != null) {
      if (!actualStaticType.isAssignableTo(expectedStaticType)) {
        _errorReporter.reportTypeErrorForNode(A_errorCode, expression, [actualStaticType, expectedStaticType]);
        return true;
      }
    }
    return false;
  }
  bool _checkForArgumentTypeNotAssignableForArgument(Expression argument) {
    if (argument == null) {
      return false;
    }
    ParameterElement staticParameterElement = argument.staticParameterElement;
    DartType staticParameterType = staticParameterElement == null ? null : staticParameterElement.type;
    return _checkForArgumentTypeNotAssignableWithExpectedTypes(argument, staticParameterType, StaticWarningCode.ARGUMENT_TYPE_NOT_ASSIGNABLE);
  }
  bool _checkForArgumentTypeNotAssignableWithExpectedTypes(Expression expression, DartType expectedStaticType, ErrorCode A_errorCode) => _checkForArgumentTypeNotAssignable(expression, expectedStaticType, getStaticType(expression), A_errorCode);
  bool _checkForArgumentTypesNotAssignableInList(ArgumentList argumentList) {
    if (argumentList == null) {
      return false;
    }
    bool problemReported = false;
    for (Expression argument in argumentList.arguments) {
      problemReported = javaBooleanOr(problemReported, _checkForArgumentTypeNotAssignableForArgument(argument));
    }
    return problemReported;
  }
  bool _checkForAssignability(Expression expression, InterfaceType A_type, ErrorCode A_errorCode, List<Object> A_arguments) {
    if (expression == null) {
      return false;
    }
    DartType expressionType = expression.staticType;
    if (expressionType == null) {
      return false;
    }
    if (expressionType.isAssignableTo(A_type)) {
      return false;
    }
    _errorReporter.reportErrorForNode(A_errorCode, expression, A_arguments);
    return true;
  }
  bool _checkForAssignmentToFinal(Expression expression) {
    A_Element A_element = null;
    AstNode highlightedNode = expression;
    if (expression is Identifier) {
      A_element = expression.staticElement;
      if (expression is PrefixedIdentifier) {
        highlightedNode = expression.identifier;
      }
    } else if (expression is PropertyAccess) {
      PropertyAccess propertyAccess = expression;
      A_element = propertyAccess.propertyName.staticElement;
      highlightedNode = propertyAccess.propertyName;
    }
    if (A_element is PropertyAccessorElement) {
      PropertyAccessorElement accessor = A_element as PropertyAccessorElement;
      A_element = accessor.variable;
    }
    if (A_element is VariableElement) {
      VariableElement variable = A_element as VariableElement;
      if (variable.isConst) {
        _errorReporter.reportErrorForNode(StaticWarningCode.ASSIGNMENT_TO_CONST, expression, []);
        return true;
      }
      if (variable.isFinal) {
        if (variable is FieldElementImpl && variable.setter == null && variable.isSynthetic) {
          _errorReporter.reportErrorForNode(StaticWarningCode.ASSIGNMENT_TO_FINAL_NO_SETTER, highlightedNode, [variable.name, variable.enclosingElement.displayName]);
          return true;
        }
        _errorReporter.reportErrorForNode(StaticWarningCode.ASSIGNMENT_TO_FINAL, highlightedNode, [variable.name]);
        return true;
      }
      return false;
    }
    if (A_element is FunctionElement) {
      _errorReporter.reportErrorForNode(StaticWarningCode.ASSIGNMENT_TO_FUNCTION, expression, []);
      return true;
    }
    if (A_element is MethodElement) {
      _errorReporter.reportErrorForNode(StaticWarningCode.ASSIGNMENT_TO_METHOD, expression, []);
      return true;
    }
    return false;
  }
  bool _checkForBuiltInIdentifierAsName(SimpleIdentifier identifier, ErrorCode A_errorCode) {
    A_Token token = identifier.token;
    if (token.type == A_TokenType.A_KEYWORD) {
      _errorReporter.reportErrorForNode(A_errorCode, identifier, [identifier.name]);
      return true;
    }
    return false;
  }
  bool _checkForCaseBlockNotTerminated(SwitchCase node) {
    NodeList<Statement> statements = node.statements;
    if (statements.isEmpty) {
      AstNode A_parent = node.parent;
      if (A_parent is SwitchStatement) {
        SwitchStatement switchStatement = A_parent;
        NodeList<SwitchMember> members = switchStatement.members;
        int A_index = members.indexOf(node);
        if (A_index != -1 && A_index < members.length - 1) {
          return false;
        }
      }
    } else {
      Statement statement = statements[statements.length - 1];
      if (statement is BreakStatement || statement is ContinueStatement || statement is ReturnStatement) {
        return false;
      }
      if (statement is ExpressionStatement) {
        Expression expression = statement.expression;
        if (expression is ThrowExpression) {
          return false;
        }
      }
    }
    _errorReporter.reportErrorForToken(StaticWarningCode.CASE_BLOCK_NOT_TERMINATED, node.keyword, []);
    return true;
  }
  bool _checkForCaseBlocksNotTerminated(SwitchStatement node) {
    bool foundError = false;
    NodeList<SwitchMember> members = node.members;
    int lastMember = members.length - 1;
    for (int i = 0; i < lastMember; i++) {
      SwitchMember member = members[i];
      if (member is SwitchCase) {
        foundError = javaBooleanOr(foundError, _checkForCaseBlockNotTerminated(member));
      }
    }
    return foundError;
  }
  bool _checkForConcreteClassWithAbstractMember(MethodDeclaration node) {
    if (node.isAbstract && _enclosingClass != null && !_enclosingClass.isAbstract) {
      SimpleIdentifier nameNode = node.name;
      String A_memberName = nameNode.name;
      ExecutableElement overriddenMember;
      if (node.isGetter) {
        overriddenMember = _enclosingClass.lookUpInheritedConcreteGetter(A_memberName, _currentLibrary);
      } else if (node.isSetter) {
        overriddenMember = _enclosingClass.lookUpInheritedConcreteSetter(A_memberName, _currentLibrary);
      } else {
        overriddenMember = _enclosingClass.lookUpInheritedConcreteMethod(A_memberName, _currentLibrary);
      }
      if (overriddenMember == null) {
        _errorReporter.reportErrorForNode(StaticWarningCode.CONCRETE_CLASS_WITH_ABSTRACT_MEMBER, nameNode, [A_memberName, _enclosingClass.displayName]);
        return true;
      }
    }
    return false;
  }
  bool _checkForConflictingConstructorNameAndMember(ConstructorDeclaration node, ConstructorElement constructorElement) {
    SimpleIdentifier constructorName = node.name;
    String A_name = constructorElement.name;
    ClassElement classElement = constructorElement.enclosingElement;
    List<ConstructorElement> constructors = classElement.constructors;
    for (ConstructorElement otherConstructor in constructors) {
      if (identical(otherConstructor, constructorElement)) {
        continue;
      }
      if (A_name == otherConstructor.name) {
        if (A_name == null || A_name.length == 0) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.DUPLICATE_CONSTRUCTOR_DEFAULT, node, []);
        } else {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.DUPLICATE_CONSTRUCTOR_NAME, node, [A_name]);
        }
        return true;
      }
    }
    if (constructorName != null && constructorElement != null && !constructorName.isSynthetic) {
      FieldElement field = classElement.getField(A_name);
      if (field != null) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD, node, [A_name]);
        return true;
      }
      MethodElement A_method = classElement.getMethod(A_name);
      if (A_method != null) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD, node, [A_name]);
        return true;
      }
    }
    return false;
  }
  bool _checkForConflictingGetterAndMethod() {
    if (_enclosingClass == null) {
      return false;
    }
    bool hasProblem = false;
    for (MethodElement A_method in _enclosingClass.methods) {
      String A_name = A_method.name;
      ExecutableElement inherited = _inheritanceManager.lookupInheritance(_enclosingClass, A_name);
      if (inherited is! PropertyAccessorElement) {
        continue;
      }
      hasProblem = true;
      _errorReporter.reportErrorForOffset(CompileTimeErrorCode.CONFLICTING_GETTER_AND_METHOD, A_method.nameOffset, A_name.length, [_enclosingClass.displayName, inherited.enclosingElement.displayName, A_name]);
    }
    for (PropertyAccessorElement accessor in _enclosingClass.accessors) {
      if (!accessor.isGetter) {
        continue;
      }
      String A_name = accessor.name;
      ExecutableElement inherited = _inheritanceManager.lookupInheritance(_enclosingClass, A_name);
      if (inherited is! MethodElement) {
        continue;
      }
      hasProblem = true;
      _errorReporter.reportErrorForOffset(CompileTimeErrorCode.CONFLICTING_METHOD_AND_GETTER, accessor.nameOffset, A_name.length, [_enclosingClass.displayName, inherited.enclosingElement.displayName, A_name]);
    }
    return hasProblem;
  }
  bool _checkForConflictingInstanceGetterAndSuperclassMember() {
    if (_enclosingClass == null) {
      return false;
    }
    InterfaceType enclosingType = _enclosingClass.type;
    bool hasProblem = false;
    for (PropertyAccessorElement accessor in _enclosingClass.accessors) {
      if (accessor.isStatic) {
        continue;
      }
      String A_name = accessor.displayName;
      bool getter = accessor.isGetter;
      if (accessor.isSetter && accessor.isSynthetic) {
        continue;
      }
      ExecutableElement superElement;
      superElement = enclosingType.lookUpGetterInSuperclass(A_name, _currentLibrary);
      if (superElement == null) {
        superElement = enclosingType.lookUpSetterInSuperclass(A_name, _currentLibrary);
      }
      if (superElement == null) {
        superElement = enclosingType.lookUpMethodInSuperclass(A_name, _currentLibrary);
      }
      if (superElement == null) {
        continue;
      }
      if (!superElement.isStatic) {
        continue;
      }
      ClassElement superElementClass = superElement.enclosingElement as ClassElement;
      InterfaceType superElementType = superElementClass.type;
      hasProblem = true;
      if (getter) {
        _errorReporter.reportErrorForElement(StaticWarningCode.CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER, accessor, [superElementType.displayName]);
      } else {
        _errorReporter.reportErrorForElement(StaticWarningCode.CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER, accessor, [superElementType.displayName]);
      }
    }
    return hasProblem;
  }
  bool _checkForConflictingInstanceMethodSetter(ClassDeclaration node) {
    NodeList<ClassMember> classMembers = node.members;
    if (classMembers.isEmpty) {
      return false;
    }
    bool foundError = false;
    A_p.HashMap<String, ClassMember> memberHashMap = new A_p.HashMap<String,ClassMember>();
    for (ClassMember classMember in classMembers) {
      if (classMember is MethodDeclaration) {
        MethodDeclaration A_method = classMember;
        if (A_method.isStatic) {
          continue;
        }
        SimpleIdentifier A_name = A_method.name;
        if (A_name == null) {
          continue;
        }
        bool addThisMemberToTheMap = true;
        bool A_isGetter = A_method.isGetter;
        bool A_isSetter = A_method.isSetter;
        bool isOperator = A_method.isOperator;
        bool A_isMethod = !A_isGetter && !A_isSetter && !isOperator;
        if (A_isMethod) {
          String setterName = "${A_name.name}=";
          A_Element enclosingElementOfSetter = null;
          ClassMember conflictingSetter = memberHashMap[setterName];
          if (conflictingSetter != null) {
            enclosingElementOfSetter = conflictingSetter.element.enclosingElement;
          } else {
            ExecutableElement elementFromInheritance = _inheritanceManager.lookupInheritance(_enclosingClass, setterName);
            if (elementFromInheritance != null) {
              enclosingElementOfSetter = elementFromInheritance.enclosingElement;
            }
          }
          if (enclosingElementOfSetter != null) {
            _errorReporter.reportErrorForNode(StaticWarningCode.CONFLICTING_INSTANCE_METHOD_SETTER, A_name, [_enclosingClass.displayName, A_name.name, enclosingElementOfSetter.displayName]);
            foundError = javaBooleanOr(foundError, true);
            addThisMemberToTheMap = false;
          }
        } else if (A_isSetter) {
          String methodName = A_name.name;
          ClassMember conflictingMethod = memberHashMap[methodName];
          if (conflictingMethod != null && conflictingMethod is MethodDeclaration && !conflictingMethod.isGetter) {
            _errorReporter.reportErrorForNode(StaticWarningCode.CONFLICTING_INSTANCE_METHOD_SETTER2, A_name, [_enclosingClass.displayName, A_name.name]);
            foundError = javaBooleanOr(foundError, true);
            addThisMemberToTheMap = false;
          }
        }
        if (addThisMemberToTheMap) {
          if (A_method.isSetter) {
            memberHashMap["${A_name.name}="] = A_method;
          } else {
            memberHashMap[A_name.name] = A_method;
          }
        }
      }
    }
    return foundError;
  }
  bool _checkForConflictingStaticGetterAndInstanceSetter(MethodDeclaration node) {
    if (!node.isStatic) {
      return false;
    }
    SimpleIdentifier nameNode = node.name;
    if (nameNode == null) {
      return false;
    }
    String A_name = nameNode.name;
    if (_enclosingClass == null) {
      return false;
    }
    InterfaceType enclosingType = _enclosingClass.type;
    ExecutableElement setter = enclosingType.lookUpSetter(A_name, _currentLibrary);
    if (setter == null) {
      return false;
    }
    if (setter.isStatic) {
      return false;
    }
    ClassElement setterClass = setter.enclosingElement as ClassElement;
    InterfaceType setterType = setterClass.type;
    _errorReporter.reportErrorForNode(StaticWarningCode.CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER, nameNode, [setterType.displayName]);
    return true;
  }
  bool _checkForConflictingStaticSetterAndInstanceMember(MethodDeclaration node) {
    if (!node.isStatic) {
      return false;
    }
    SimpleIdentifier nameNode = node.name;
    if (nameNode == null) {
      return false;
    }
    String A_name = nameNode.name;
    if (_enclosingClass == null) {
      return false;
    }
    InterfaceType enclosingType = _enclosingClass.type;
    ExecutableElement member;
    member = enclosingType.lookUpMethod(A_name, _currentLibrary);
    if (member == null) {
      member = enclosingType.lookUpGetter(A_name, _currentLibrary);
    }
    if (member == null) {
      member = enclosingType.lookUpSetter(A_name, _currentLibrary);
    }
    if (member == null) {
      return false;
    }
    if (member.isStatic) {
      return false;
    }
    ClassElement memberClass = member.enclosingElement as ClassElement;
    InterfaceType memberType = memberClass.type;
    _errorReporter.reportErrorForNode(StaticWarningCode.CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER, nameNode, [memberType.displayName]);
    return true;
  }
  bool _checkForConflictingTypeVariableErrorCodes(ClassDeclaration node) {
    bool problemReported = false;
    for (TypeParameterElement typeParameter in _enclosingClass.typeParameters) {
      String A_name = typeParameter.name;
      if (_enclosingClass.name == A_name) {
        _errorReporter.reportErrorForOffset(CompileTimeErrorCode.CONFLICTING_TYPE_VARIABLE_AND_CLASS, typeParameter.nameOffset, A_name.length, [A_name]);
        problemReported = true;
      }
      if (_enclosingClass.getMethod(A_name) != null || _enclosingClass.getGetter(A_name) != null || _enclosingClass.getSetter(A_name) != null) {
        _errorReporter.reportErrorForOffset(CompileTimeErrorCode.CONFLICTING_TYPE_VARIABLE_AND_MEMBER, typeParameter.nameOffset, A_name.length, [A_name]);
        problemReported = true;
      }
    }
    return problemReported;
  }
  bool _checkForConstConstructorWithNonConstSuper(ConstructorDeclaration node) {
    if (!_isEnclosingConstructorConst) {
      return false;
    }
    if (node.factoryKeyword != null) {
      return false;
    }
    if (_enclosingClass.mixins.length != 0) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_MIXIN, node.returnType, []);
      return true;
    }
    for (ConstructorInitializer initializer in node.initializers) {
      if (initializer is SuperConstructorInvocation) {
        SuperConstructorInvocation superInvocation = initializer;
        ConstructorElement A_element = superInvocation.staticElement;
        if (A_element == null || A_element.isConst) {
          return false;
        }
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER, superInvocation, [A_element.enclosingElement.displayName]);
        return true;
      }
    }
    InterfaceType supertype = _enclosingClass.supertype;
    if (supertype == null) {
      return false;
    }
    if (supertype.isObject) {
      return false;
    }
    ConstructorElement unnamedConstructor = supertype.element.unnamedConstructor;
    if (unnamedConstructor == null) {
      return false;
    }
    if (unnamedConstructor.isConst) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER, node.returnType, [supertype.displayName]);
    return true;
  }
  bool _checkForConstConstructorWithNonFinalField(ConstructorDeclaration node, ConstructorElement constructorElement) {
    if (!_isEnclosingConstructorConst) {
      return false;
    }
    ClassElement classElement = constructorElement.enclosingElement;
    if (!classElement.hasNonFinalField) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD, node, []);
    return true;
  }
  bool _checkForConstDeferredClass(InstanceCreationExpression node, ConstructorName constructorName, TypeName typeName) {
    if (typeName.isDeferred) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_DEFERRED_CLASS, constructorName, [typeName.name.name]);
      return true;
    }
    return false;
  }
  bool _checkForConstEvalThrowsException(ThrowExpression node) {
    if (_isEnclosingConstructorConst) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_CONSTRUCTOR_THROWS_EXCEPTION, node, []);
      return true;
    }
    return false;
  }
  bool _checkForConstFormalParameter(NormalFormalParameter node) {
    if (node.isConst) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_FORMAL_PARAMETER, node, []);
      return true;
    }
    return false;
  }
  bool _checkForConstOrNewWithAbstractClass(InstanceCreationExpression node, TypeName typeName, InterfaceType A_type) {
    if (A_type.element.isAbstract) {
      ConstructorElement A_element = node.staticElement;
      if (A_element != null && !A_element.isFactory) {
        if ((node.keyword as KeywordToken).keyword == Keyword.B_CONST) {
          _errorReporter.reportErrorForNode(StaticWarningCode.CONST_WITH_ABSTRACT_CLASS, typeName, []);
        } else {
          _errorReporter.reportErrorForNode(StaticWarningCode.NEW_WITH_ABSTRACT_CLASS, typeName, []);
        }
        return true;
      }
    }
    return false;
  }
  bool _checkForConstWithNonConst(InstanceCreationExpression node) {
    ConstructorElement constructorElement = node.staticElement;
    if (constructorElement != null && !constructorElement.isConst) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_WITH_NON_CONST, node, []);
      return true;
    }
    return false;
  }
  bool _checkForConstWithTypeParameters(TypeName typeName) {
    if (typeName == null) {
      return false;
    }
    Identifier A_name = typeName.name;
    if (A_name == null) {
      return false;
    }
    if (A_name.staticElement is TypeParameterElement) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_WITH_TYPE_PARAMETERS, A_name, []);
    }
    TypeArgumentList typeArguments = typeName.typeArguments;
    if (typeArguments != null) {
      bool hasError = false;
      for (TypeName argument in typeArguments.arguments) {
        hasError = javaBooleanOr(hasError, _checkForConstWithTypeParameters(argument));
      }
      return hasError;
    }
    return false;
  }
  bool _checkForConstWithUndefinedConstructor(InstanceCreationExpression node, ConstructorName constructorName, TypeName typeName) {
    if (node.staticElement != null) {
      return false;
    }
    Identifier className = typeName.name;
    SimpleIdentifier A_name = constructorName.name;
    if (A_name != null) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_WITH_UNDEFINED_CONSTRUCTOR, A_name, [className, A_name]);
    } else {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT, constructorName, [className]);
    }
    return true;
  }
  bool _checkForDefaultValueInFunctionTypeAlias(FunctionTypeAlias node) {
    bool result = false;
    FormalParameterList formalParameterList = node.parameters;
    NodeList<FormalParameter> A_parameters = formalParameterList.parameters;
    for (FormalParameter formalParameter in A_parameters) {
      if (formalParameter is DefaultFormalParameter) {
        DefaultFormalParameter defaultFormalParameter = formalParameter;
        if (defaultFormalParameter.defaultValue != null) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS, node, []);
          result = true;
        }
      }
    }
    return result;
  }
  bool _checkForDefaultValueInFunctionTypedParameter(DefaultFormalParameter node) {
    if (!_isInFunctionTypedFormalParameter) {
      return false;
    }
    if (node.defaultValue == null) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER, node, []);
    return true;
  }
  bool _checkForDeferredPrefixCollisions(CompilationUnit node) {
    bool foundError = false;
    NodeList<Directive> directives = node.directives;
    int count = directives.length;
    if (count > 0) {
      A_p.HashMap<PrefixElement, List<ImportDirective>> prefixToDirectivesMap = new A_p.HashMap<PrefixElement,List<ImportDirective>>();
      for (int i = 0; i < count; i++) {
        Directive directive = directives[i];
        if (directive is ImportDirective) {
          ImportDirective importDirective = directive;
          SimpleIdentifier prefix = importDirective.prefix;
          if (prefix != null) {
            A_Element A_element = prefix.staticElement;
            if (A_element is PrefixElement) {
              PrefixElement prefixElement = A_element;
              List<ImportDirective> elements = prefixToDirectivesMap[prefixElement];
              if (elements == null) {
                elements = new List<ImportDirective>();
                prefixToDirectivesMap[prefixElement] = elements;
              }
              elements.add(importDirective);
            }
          }
        }
      }
      for (List<ImportDirective> imports in prefixToDirectivesMap.values) {
        if (_hasDeferredPrefixCollision(imports)) {
          foundError = true;
        }
      }
    }
    return foundError;
  }
  bool _checkForDuplicateDefinitionInheritance() {
    if (_enclosingClass == null) {
      return false;
    }
    bool hasProblem = false;
    for (ExecutableElement member in _enclosingClass.methods) {
      if (!member.isStatic) {
        continue;
      }
      hasProblem = javaBooleanOr(hasProblem, _checkForDuplicateDefinitionOfMember(member));
    }
    for (ExecutableElement member in _enclosingClass.accessors) {
      if (!member.isStatic) {
        continue;
      }
      hasProblem = javaBooleanOr(hasProblem, _checkForDuplicateDefinitionOfMember(member));
    }
    return hasProblem;
  }
  bool _checkForDuplicateDefinitionOfMember(ExecutableElement staticMember) {
    String A_name = staticMember.name;
    if (A_name == null) {
      return false;
    }
    ExecutableElement inheritedMember = _inheritanceManager.lookupInheritance(_enclosingClass, A_name);
    if (inheritedMember == null) {
      return false;
    }
    if (inheritedMember.isStatic) {
      return false;
    }
    String displayName;
    A_Element enclosingElement = inheritedMember.enclosingElement;
    if (enclosingElement.source == _enclosingClass.source) {
      displayName = enclosingElement.displayName;
    } else {
      displayName = enclosingElement.getExtendedDisplayName(null);
    }
    _errorReporter.reportErrorForOffset(CompileTimeErrorCode.DUPLICATE_DEFINITION_INHERITANCE, staticMember.nameOffset, A_name.length, [A_name, displayName]);
    return true;
  }
  bool _checkForExpectedOneListTypeArgument(ListLiteral node, TypeArgumentList typeArguments) {
    int A_num = typeArguments.arguments.length;
    if (A_num == 1) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticTypeWarningCode.EXPECTED_ONE_LIST_TYPE_ARGUMENTS, typeArguments, [A_num]);
    return true;
  }
  bool _checkForExportDuplicateLibraryName(ExportDirective node, ExportElement exportElement, LibraryElement exportedLibrary) {
    if (exportedLibrary == null) {
      return false;
    }
    String A_name = exportedLibrary.name;
    LibraryElement prevLibrary = _nameToExportElement[A_name];
    if (prevLibrary != null) {
      if (prevLibrary != exportedLibrary) {
        _errorReporter.reportErrorForNode(StaticWarningCode.EXPORT_DUPLICATED_LIBRARY_NAME, node, [prevLibrary.definingCompilationUnit.displayName, exportedLibrary.definingCompilationUnit.displayName, A_name]);
        return true;
      }
    } else {
      _nameToExportElement[A_name] = exportedLibrary;
    }
    return false;
  }
  bool _checkForExportInternalLibrary(ExportDirective node, ExportElement exportElement) {
    if (_isInSystemLibrary) {
      return false;
    }
    DartSdk sdk = _currentLibrary.context.sourceFactory.dartSdk;
    String A_uri = exportElement.uri;
    SdkLibrary sdkLibrary = sdk.getSdkLibrary(A_uri);
    if (sdkLibrary == null) {
      return false;
    }
    if (!sdkLibrary.isInternal) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.EXPORT_INTERNAL_LIBRARY, node, [node.uri]);
    return true;
  }
  bool _checkForExtendsDeferredClass(ExtendsClause node) {
    if (node == null) {
      return false;
    }
    return _checkForExtendsOrImplementsDeferredClass(node.superclass, CompileTimeErrorCode.EXTENDS_DEFERRED_CLASS);
  }
  bool _checkForExtendsDeferredClassInTypeAlias(ClassTypeAlias node) {
    if (node == null) {
      return false;
    }
    return _checkForExtendsOrImplementsDeferredClass(node.superclass, CompileTimeErrorCode.EXTENDS_DEFERRED_CLASS);
  }
  bool _checkForExtendsDisallowedClass(ExtendsClause node) {
    if (node == null) {
      return false;
    }
    return _checkForExtendsOrImplementsDisallowedClass(node.superclass, CompileTimeErrorCode.EXTENDS_DISALLOWED_CLASS);
  }
  bool _checkForExtendsDisallowedClassInTypeAlias(ClassTypeAlias node) {
    if (node == null) {
      return false;
    }
    return _checkForExtendsOrImplementsDisallowedClass(node.superclass, CompileTimeErrorCode.EXTENDS_DISALLOWED_CLASS);
  }
  bool _checkForExtendsOrImplementsDeferredClass(TypeName typeName, ErrorCode A_errorCode) {
    if (typeName.isSynthetic) {
      return false;
    }
    if (typeName.isDeferred) {
      _errorReporter.reportErrorForNode(A_errorCode, typeName, [typeName.name.name]);
      return true;
    }
    return false;
  }
  bool _checkForExtendsOrImplementsDisallowedClass(TypeName typeName, ErrorCode A_errorCode) {
    if (typeName.isSynthetic) {
      return false;
    }
    DartType superType = typeName.type;
    for (InterfaceType disallowedType in _DISALLOWED_TYPES_TO_EXTEND_OR_IMPLEMENT) {
      if (superType != null && superType == disallowedType) {
        if (superType == B__typeProvider.numType) {
          AstNode grandParent = typeName.parent.parent;
          if (grandParent is ClassDeclaration) {
            ClassElement classElement = grandParent.element;
            DartType classType = classElement.type;
            if (classType != null && (classType == _intType || classType == B__typeProvider.doubleType)) {
              return false;
            }
          }
        }
        _errorReporter.reportErrorForNode(A_errorCode, typeName, [disallowedType.displayName]);
        return true;
      }
    }
    return false;
  }
  bool _checkForFieldInitializerNotAssignable(ConstructorFieldInitializer node, A_Element staticElement) {
    if (staticElement is! FieldElement) {
      return false;
    }
    FieldElement fieldElement = staticElement as FieldElement;
    DartType fieldType = fieldElement.type;
    Expression expression = node.expression;
    if (expression == null) {
      return false;
    }
    DartType staticType = getStaticType(expression);
    if (staticType == null) {
      return false;
    }
    if (staticType.isAssignableTo(fieldType)) {
      return false;
    }
    if (_isEnclosingConstructorConst) {
      _errorReporter.reportTypeErrorForNode(CompileTimeErrorCode.CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE, expression, [staticType, fieldType]);
    } else {
      _errorReporter.reportTypeErrorForNode(StaticWarningCode.FIELD_INITIALIZER_NOT_ASSIGNABLE, expression, [staticType, fieldType]);
    }
    return true;
  }
  bool _checkForFieldInitializingFormalRedirectingConstructor(FieldFormalParameter node) {
    ConstructorDeclaration constructor = node.getAncestor((node) => node is ConstructorDeclaration);
    if (constructor == null) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR, node, []);
      return true;
    }
    if (constructor.factoryKeyword != null) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZER_FACTORY_CONSTRUCTOR, node, []);
      return true;
    }
    for (ConstructorInitializer initializer in constructor.initializers) {
      if (initializer is RedirectingConstructorInvocation) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR, node, []);
        return true;
      }
    }
    return false;
  }
  bool _checkForFinalNotInitialized(VariableDeclarationList node) {
    if (_isInNativeClass) {
      return false;
    }
    bool foundError = false;
    if (!node.isSynthetic) {
      NodeList<VariableDeclaration> variables = node.variables;
      for (VariableDeclaration variable in variables) {
        if (variable.initializer == null) {
          if (node.isConst) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.CONST_NOT_INITIALIZED, variable.name, [variable.name.name]);
          } else if (node.isFinal) {
            _errorReporter.reportErrorForNode(StaticWarningCode.FINAL_NOT_INITIALIZED, variable.name, [variable.name.name]);
          }
          foundError = true;
        }
      }
    }
    return foundError;
  }
  bool _checkForFinalNotInitializedInClass(ClassDeclaration node) {
    NodeList<ClassMember> classMembers = node.members;
    for (ClassMember classMember in classMembers) {
      if (classMember is ConstructorDeclaration) {
        return false;
      }
    }
    bool foundError = false;
    for (ClassMember classMember in classMembers) {
      if (classMember is FieldDeclaration) {
        FieldDeclaration field = classMember;
        foundError = javaBooleanOr(foundError, _checkForFinalNotInitialized(field.fields));
      }
    }
    return foundError;
  }
  bool _checkForImplementsDeferredClass(ImplementsClause node) {
    if (node == null) {
      return false;
    }
    bool foundError = false;
    for (TypeName A_type in node.interfaces) {
      foundError = javaBooleanOr(foundError, _checkForExtendsOrImplementsDeferredClass(A_type, CompileTimeErrorCode.IMPLEMENTS_DEFERRED_CLASS));
    }
    return foundError;
  }
  bool _checkForImplementsDisallowedClass(ImplementsClause node) {
    if (node == null) {
      return false;
    }
    bool foundError = false;
    for (TypeName A_type in node.interfaces) {
      foundError = javaBooleanOr(foundError, _checkForExtendsOrImplementsDisallowedClass(A_type, CompileTimeErrorCode.IMPLEMENTS_DISALLOWED_CLASS));
    }
    return foundError;
  }
  bool _checkForImplicitThisReferenceInInitializer(SimpleIdentifier node) {
    if (!_isInConstructorInitializer && !_isInStaticMethod && !_isInFactory && !_isInInstanceVariableInitializer && !_isInStaticVariableDeclaration) {
      return false;
    }
    A_Element A_element = node.staticElement;
    if (!(A_element is MethodElement || A_element is PropertyAccessorElement)) {
      return false;
    }
    ExecutableElement executableElement = A_element as ExecutableElement;
    if (executableElement.isStatic) {
      return false;
    }
    A_Element enclosingElement = A_element.enclosingElement;
    if (enclosingElement is! ClassElement) {
      return false;
    }
    AstNode A_parent = node.parent;
    if (A_parent is CommentReference) {
      return false;
    }
    if (A_parent is MethodInvocation) {
      MethodInvocation invocation = A_parent;
      if (identical(invocation.methodName, node) && invocation.realTarget != null) {
        return false;
      }
    }
    if (A_parent is PropertyAccess) {
      PropertyAccess access = A_parent;
      if (identical(access.propertyName, node) && access.realTarget != null) {
        return false;
      }
    }
    if (A_parent is PrefixedIdentifier) {
      PrefixedIdentifier prefixed = A_parent;
      if (identical(prefixed.identifier, node)) {
        return false;
      }
    }
    if (_isInStaticMethod) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.INSTANCE_MEMBER_ACCESS_FROM_STATIC, node, []);
    } else if (_isInFactory) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.INSTANCE_MEMBER_ACCESS_FROM_FACTORY, node, []);
    } else {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.IMPLICIT_THIS_REFERENCE_IN_INITIALIZER, node, []);
    }
    return true;
  }
  bool _checkForImportDuplicateLibraryName(ImportDirective node, ImportElement importElement) {
    LibraryElement nodeLibrary = importElement.importedLibrary;
    if (nodeLibrary == null) {
      return false;
    }
    String A_name = nodeLibrary.name;
    LibraryElement prevLibrary = _nameToImportElement[A_name];
    if (prevLibrary != null) {
      if (prevLibrary != nodeLibrary) {
        _errorReporter.reportErrorForNode(StaticWarningCode.IMPORT_DUPLICATED_LIBRARY_NAME, node, [prevLibrary.definingCompilationUnit.displayName, nodeLibrary.definingCompilationUnit.displayName, A_name]);
        return true;
      }
    } else {
      _nameToImportElement[A_name] = nodeLibrary;
    }
    return false;
  }
  bool _checkForImportInternalLibrary(ImportDirective node, ImportElement importElement) {
    if (_isInSystemLibrary) {
      return false;
    }
    DartSdk sdk = _currentLibrary.context.sourceFactory.dartSdk;
    String A_uri = importElement.uri;
    SdkLibrary sdkLibrary = sdk.getSdkLibrary(A_uri);
    if (sdkLibrary == null) {
      return false;
    }
    if (!sdkLibrary.isInternal) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.IMPORT_INTERNAL_LIBRARY, node, [node.uri]);
    return true;
  }
  bool _checkForInconsistentMethodInheritance() {
    _inheritanceManager.getMapOfMembersInheritedFromInterfaces(_enclosingClass);
    A_p.HashSet<A_AnalysisError> B_errors = _inheritanceManager.getErrors(_enclosingClass);
    if (B_errors == null || B_errors.isEmpty) {
      return false;
    }
    for (A_AnalysisError A_error in B_errors) {
      _errorReporter.reportError(A_error);
    }
    return true;
  }
  bool _checkForInstanceAccessToStaticMember(ClassElement typeReference, SimpleIdentifier A_name) {
    if (_isInComment) {
      return false;
    }
    if (typeReference != null) {
      return false;
    }
    A_Element A_element = A_name.staticElement;
    if (A_element is! ExecutableElement) {
      return false;
    }
    ExecutableElement executableElement = A_element as ExecutableElement;
    if (executableElement.enclosingElement is! ClassElement) {
      return false;
    }
    if (!executableElement.isStatic) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticTypeWarningCode.INSTANCE_ACCESS_TO_STATIC_MEMBER, A_name, [A_name.name]);
    return true;
  }
  bool _checkForInstanceMethodNameCollidesWithSuperclassStatic(ExecutableElement executableElement, SimpleIdentifier errorNameTarget) {
    String executableElementName = executableElement.name;
    if (executableElement is! PropertyAccessorElement && !executableElement.isOperator) {
      A_p.HashSet<ClassElement> visitedClasses = new A_p.HashSet<ClassElement>();
      InterfaceType superclassType = _enclosingClass.supertype;
      ClassElement superclassElement = superclassType == null ? null : superclassType.element;
      bool executableElementPrivate = Identifier.isPrivateName(executableElementName);
      while (superclassElement != null && !visitedClasses.contains(superclassElement)) {
        visitedClasses.add(superclassElement);
        LibraryElement superclassLibrary = superclassElement.library;
        List<FieldElement> fieldElts = superclassElement.fields;
        for (FieldElement fieldElt in fieldElts) {
          if (fieldElt.name != executableElementName) {
            continue;
          }
          if (executableElementPrivate && _currentLibrary != superclassLibrary) {
            continue;
          }
          if (fieldElt.isStatic) {
            _errorReporter.reportErrorForNode(StaticWarningCode.INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC, errorNameTarget, [executableElementName, fieldElt.enclosingElement.displayName]);
            return true;
          }
        }
        List<MethodElement> methodElements = superclassElement.methods;
        for (MethodElement methodElement in methodElements) {
          if (methodElement.name != executableElementName) {
            continue;
          }
          if (executableElementPrivate && _currentLibrary != superclassLibrary) {
            continue;
          }
          if (methodElement.isStatic) {
            _errorReporter.reportErrorForNode(StaticWarningCode.INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC, errorNameTarget, [executableElementName, methodElement.enclosingElement.displayName]);
            return true;
          }
        }
        superclassType = superclassElement.supertype;
        superclassElement = superclassType == null ? null : superclassType.element;
      }
    }
    return false;
  }
  bool _checkForIntNotAssignable(Expression argument) {
    if (argument == null) {
      return false;
    }
    ParameterElement staticParameterElement = argument.staticParameterElement;
    DartType staticParameterType = staticParameterElement == null ? null : staticParameterElement.type;
    return _checkForArgumentTypeNotAssignable(argument, staticParameterType, _intType, StaticWarningCode.ARGUMENT_TYPE_NOT_ASSIGNABLE);
  }
  bool _checkForInvalidAnnotationFromDeferredLibrary(Annotation node) {
    Identifier nameIdentifier = node.name;
    if (nameIdentifier is PrefixedIdentifier) {
      if (nameIdentifier.isDeferred) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.INVALID_ANNOTATION_FROM_DEFERRED_LIBRARY, node.name, []);
        return true;
      }
    }
    return false;
  }
  bool _checkForInvalidAssignment(Expression lhs, Expression rhs) {
    if (lhs == null || rhs == null) {
      return false;
    }
    VariableElement leftVariableElement = getVariableElement(lhs);
    DartType leftType = (leftVariableElement == null) ? getStaticType(lhs) : leftVariableElement.type;
    DartType staticRightType = getStaticType(rhs);
    if (!staticRightType.isAssignableTo(leftType)) {
      _errorReporter.reportTypeErrorForNode(StaticTypeWarningCode.INVALID_ASSIGNMENT, rhs, [staticRightType, leftType]);
      return true;
    }
    return false;
  }
  bool _checkForInvalidCompoundAssignment(AssignmentExpression node, Expression lhs, Expression rhs) {
    if (lhs == null) {
      return false;
    }
    VariableElement leftVariableElement = getVariableElement(lhs);
    DartType leftType = (leftVariableElement == null) ? getStaticType(lhs) : leftVariableElement.type;
    MethodElement invokedMethod = node.staticElement;
    if (invokedMethod == null) {
      return false;
    }
    DartType rightType = invokedMethod.type.returnType;
    if (leftType == null || rightType == null) {
      return false;
    }
    if (!rightType.isAssignableTo(leftType)) {
      _errorReporter.reportTypeErrorForNode(StaticTypeWarningCode.INVALID_ASSIGNMENT, rhs, [rightType, leftType]);
      return true;
    }
    return false;
  }
  void _checkForInvalidField(ConstructorFieldInitializer node, SimpleIdentifier fieldName, A_Element staticElement) {
    if (staticElement is FieldElement) {
      FieldElement fieldElement = staticElement;
      if (fieldElement.isSynthetic) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZER_FOR_NON_EXISTANT_FIELD, node, [fieldName]);
      } else if (fieldElement.isStatic) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZER_FOR_STATIC_FIELD, node, [fieldName]);
      }
    } else {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZER_FOR_NON_EXISTANT_FIELD, node, [fieldName]);
      return;
    }
  }
  bool _checkForInvalidReferenceToThis(ThisExpression node) {
    if (!_isThisInValidContext(node)) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.INVALID_REFERENCE_TO_THIS, node, []);
      return true;
    }
    return false;
  }
  bool _checkForInvalidTypeArgumentInConstTypedLiteral(NodeList<TypeName> A_arguments, ErrorCode A_errorCode) {
    bool foundError = false;
    for (TypeName typeName in A_arguments) {
      if (typeName.type is TypeParameterType) {
        _errorReporter.reportErrorForNode(A_errorCode, typeName, [typeName.name]);
        foundError = true;
      }
    }
    return foundError;
  }
  bool _checkForListElementTypeNotAssignable(ListLiteral node, TypeArgumentList typeArguments) {
    NodeList<TypeName> typeNames = typeArguments.arguments;
    if (typeNames.length < 1) {
      return false;
    }
    DartType listElementType = typeNames[0].type;
    ErrorCode A_errorCode;
    if (node.constKeyword != null) {
      A_errorCode = CompileTimeErrorCode.LIST_ELEMENT_TYPE_NOT_ASSIGNABLE;
    } else {
      A_errorCode = StaticWarningCode.LIST_ELEMENT_TYPE_NOT_ASSIGNABLE;
    }
    bool hasProblems = false;
    for (Expression A_element in node.elements) {
      hasProblems = javaBooleanOr(hasProblems, _checkForArgumentTypeNotAssignableWithExpectedTypes(A_element, listElementType, A_errorCode));
    }
    return hasProblems;
  }
  bool _checkForMapTypeNotAssignable(MapLiteral node, TypeArgumentList typeArguments) {
    NodeList<TypeName> typeNames = typeArguments.arguments;
    if (typeNames.length < 2) {
      return false;
    }
    DartType keyType = typeNames[0].type;
    DartType valueType = typeNames[1].type;
    ErrorCode keyErrorCode;
    ErrorCode valueErrorCode;
    if (node.constKeyword != null) {
      keyErrorCode = CompileTimeErrorCode.MAP_KEY_TYPE_NOT_ASSIGNABLE;
      valueErrorCode = CompileTimeErrorCode.MAP_VALUE_TYPE_NOT_ASSIGNABLE;
    } else {
      keyErrorCode = StaticWarningCode.MAP_KEY_TYPE_NOT_ASSIGNABLE;
      valueErrorCode = StaticWarningCode.MAP_VALUE_TYPE_NOT_ASSIGNABLE;
    }
    bool hasProblems = false;
    NodeList<MapLiteralEntry> entries = node.entries;
    for (MapLiteralEntry A_entry in entries) {
      Expression A_key = A_entry.key;
      Expression A_value = A_entry.value;
      hasProblems = javaBooleanOr(hasProblems, _checkForArgumentTypeNotAssignableWithExpectedTypes(A_key, keyType, keyErrorCode));
      hasProblems = javaBooleanOr(hasProblems, _checkForArgumentTypeNotAssignableWithExpectedTypes(A_value, valueType, valueErrorCode));
    }
    return hasProblems;
  }
  bool _checkForMemberWithClassName() {
    if (_enclosingClass == null) {
      return false;
    }
    String className = _enclosingClass.name;
    if (className == null) {
      return false;
    }
    bool problemReported = false;
    for (PropertyAccessorElement accessor in _enclosingClass.accessors) {
      if (className == accessor.name) {
        _errorReporter.reportErrorForOffset(CompileTimeErrorCode.MEMBER_WITH_CLASS_NAME, accessor.nameOffset, className.length, []);
        problemReported = true;
      }
    }
    return problemReported;
  }
  bool _checkForMismatchedAccessorTypes(Declaration accessorDeclaration, String accessorTextName) {
    ExecutableElement accessorElement = accessorDeclaration.element as ExecutableElement;
    if (accessorElement is! PropertyAccessorElement) {
      return false;
    }
    PropertyAccessorElement propertyAccessorElement = accessorElement as PropertyAccessorElement;
    PropertyAccessorElement counterpartAccessor = null;
    ClassElement enclosingClassForCounterpart = null;
    if (propertyAccessorElement.isGetter) {
      counterpartAccessor = propertyAccessorElement.correspondingSetter;
    } else {
      counterpartAccessor = propertyAccessorElement.correspondingGetter;
      if (counterpartAccessor != null && identical(counterpartAccessor.enclosingElement, propertyAccessorElement.enclosingElement)) {
        return false;
      }
    }
    if (counterpartAccessor == null) {
      if (_enclosingClass != null) {
        String lookupIdentifier = propertyAccessorElement.name;
        if (StringUtilities.endsWithChar(lookupIdentifier, 0x3D)) {
          lookupIdentifier = lookupIdentifier.substring(0, lookupIdentifier.length - 1);
        } else {
          lookupIdentifier += "=";
        }
        ExecutableElement elementFromInheritance = _inheritanceManager.lookupInheritance(_enclosingClass, lookupIdentifier);
        if (elementFromInheritance != null && elementFromInheritance is PropertyAccessorElement) {
          enclosingClassForCounterpart = elementFromInheritance.enclosingElement as ClassElement;
          counterpartAccessor = elementFromInheritance;
        }
      }
      if (counterpartAccessor == null) {
        return false;
      }
    }
    DartType getterType = null;
    DartType setterType = null;
    if (propertyAccessorElement.isGetter) {
      getterType = _getGetterType(propertyAccessorElement);
      setterType = _getSetterType(counterpartAccessor);
    } else if (propertyAccessorElement.isSetter) {
      setterType = _getSetterType(propertyAccessorElement);
      getterType = _getGetterType(counterpartAccessor);
    }
    if (setterType != null && getterType != null && !getterType.isAssignableTo(setterType)) {
      if (enclosingClassForCounterpart == null) {
        _errorReporter.reportTypeErrorForNode(StaticWarningCode.MISMATCHED_GETTER_AND_SETTER_TYPES, accessorDeclaration, [accessorTextName, setterType, getterType]);
        return true;
      } else {
        _errorReporter.reportTypeErrorForNode(StaticWarningCode.MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE, accessorDeclaration, [accessorTextName, setterType, getterType, enclosingClassForCounterpart.displayName]);
      }
    }
    return false;
  }
  bool _checkForMixedReturns(BlockFunctionBody node) {
    if (_hasReturnWithoutValue) {
      return false;
    }
    int withCount = _returnsWith.length;
    int withoutCount = _returnsWithout.length;
    if (withCount > 0 && withoutCount > 0) {
      for (int i = 0; i < withCount; i++) {
        _errorReporter.reportErrorForToken(StaticWarningCode.MIXED_RETURN_TYPES, _returnsWith[i].keyword, []);
      }
      for (int i = 0; i < withoutCount; i++) {
        _errorReporter.reportErrorForToken(StaticWarningCode.MIXED_RETURN_TYPES, _returnsWithout[i].keyword, []);
      }
      return true;
    }
    return false;
  }
  bool _checkForMixinDeclaresConstructor(TypeName mixinName, ClassElement mixinElement) {
    for (ConstructorElement constructor in mixinElement.constructors) {
      if (!constructor.isSynthetic && !constructor.isFactory) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.MIXIN_DECLARES_CONSTRUCTOR, mixinName, [mixinElement.name]);
        return true;
      }
    }
    return false;
  }
  bool _checkForMixinInheritsNotFromObject(TypeName mixinName, ClassElement mixinElement) {
    InterfaceType mixinSupertype = mixinElement.supertype;
    if (mixinSupertype != null) {
      if (!mixinSupertype.isObject || !mixinElement.isTypedef && mixinElement.mixins.length != 0) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.MIXIN_INHERITS_FROM_NOT_OBJECT, mixinName, [mixinElement.name]);
        return true;
      }
    }
    return false;
  }
  bool _checkForMixinReferencesSuper(TypeName mixinName, ClassElement mixinElement) {
    if (mixinElement.hasReferenceToSuper) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.MIXIN_REFERENCES_SUPER, mixinName, [mixinElement.name]);
    }
    return false;
  }
  bool _checkForMultipleSuperInitializers(ConstructorDeclaration node) {
    int numSuperInitializers = 0;
    for (ConstructorInitializer initializer in node.initializers) {
      if (initializer is SuperConstructorInvocation) {
        numSuperInitializers++;
        if (numSuperInitializers > 1) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.MULTIPLE_SUPER_INITIALIZERS, initializer, []);
        }
      }
    }
    return numSuperInitializers > 0;
  }
  bool _checkForNativeFunctionBodyInNonSDKCode(NativeFunctionBody node) {
    if (!_isInSystemLibrary && !_hasExtUri) {
      _errorReporter.reportErrorForNode(ParserErrorCode.NATIVE_FUNCTION_BODY_IN_NON_SDK_CODE, node, []);
      return true;
    }
    return false;
  }
  bool _checkForNewWithUndefinedConstructor(InstanceCreationExpression node, ConstructorName constructorName, TypeName typeName) {
    if (node.staticElement != null) {
      return false;
    }
    Identifier className = typeName.name;
    SimpleIdentifier A_name = constructorName.name;
    if (A_name != null) {
      _errorReporter.reportErrorForNode(StaticWarningCode.NEW_WITH_UNDEFINED_CONSTRUCTOR, A_name, [className, A_name]);
    } else {
      _errorReporter.reportErrorForNode(StaticWarningCode.NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT, constructorName, [className]);
    }
    return true;
  }
  bool _checkForNoDefaultSuperConstructorImplicit(ClassDeclaration node) {
    List<ConstructorElement> constructors = _enclosingClass.constructors;
    if (!constructors[0].isSynthetic) {
      return false;
    }
    InterfaceType superType = _enclosingClass.supertype;
    if (superType == null) {
      return false;
    }
    ClassElement superElement = superType.element;
    ConstructorElement superUnnamedConstructor = superElement.unnamedConstructor;
    if (superUnnamedConstructor != null) {
      if (superUnnamedConstructor.isFactory) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.NON_GENERATIVE_CONSTRUCTOR, node.name, [superUnnamedConstructor]);
        return true;
      }
      if (superUnnamedConstructor.isDefaultConstructor) {
        return true;
      }
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT, node.name, [superType.displayName]);
    return true;
  }
  bool _checkForNonAbstractClassInheritsAbstractMember(SimpleIdentifier classNameNode) {
    if (_enclosingClass.isAbstract) {
      return false;
    }
    List<MethodElement> methods = _enclosingClass.methods;
    for (MethodElement A_method in methods) {
      String methodName = A_method.name;
      if (methodName == FunctionElement.NO_SUCH_METHOD_METHOD_NAME) {
        return false;
      }
    }
    A_p.HashSet<ExecutableElement> missingOverrides = new A_p.HashSet<ExecutableElement>();
    MemberMap membersInheritedFromInterfaces = _inheritanceManager.getMapOfMembersInheritedFromInterfaces(_enclosingClass);
    MemberMap membersInheritedFromSuperclasses = _inheritanceManager.getMapOfMembersInheritedFromClasses(_enclosingClass);
    for (int i = 0; i < membersInheritedFromInterfaces.size; i++) {
      String A_memberName = membersInheritedFromInterfaces.getKey(i);
      ExecutableElement executableElt = membersInheritedFromInterfaces.getValue(i);
      if (A_memberName == null) {
        break;
      }
      if (executableElt.enclosingElement != null && (executableElt.enclosingElement as ClassElement).type.isObject) {
        continue;
      }
      if (_isMemberInClassOrMixin(executableElt, _enclosingClass)) {
        continue;
      }
      ExecutableElement elt = membersInheritedFromSuperclasses.get(A_memberName);
      if (elt != null) {
        InterfaceType enclosingType = _enclosingClass.type;
        FunctionType concreteType = elt.type;
        FunctionType requiredMemberType = executableElt.type;
        if (enclosingType == null || concreteType == null || requiredMemberType == null) {
          continue;
        }
        if ((elt is MethodElement && !elt.isAbstract) || (elt is PropertyAccessorElement && !elt.isAbstract)) {
          FunctionType foundConcreteFT = _inheritanceManager.substituteTypeArgumentsInMemberFromInheritance(concreteType, A_memberName, enclosingType);
          FunctionType requiredMemberFT = _inheritanceManager.substituteTypeArgumentsInMemberFromInheritance(requiredMemberType, A_memberName, enclosingType);
          if (foundConcreteFT.isSubtypeOf(requiredMemberFT)) {
            continue;
          }
        }
      }
      missingOverrides.add(executableElt);
    }
    int missingOverridesSize = missingOverrides.length;
    if (missingOverridesSize == 0) {
      return false;
    }
    List<ExecutableElement> missingOverridesArray = new List.from(missingOverrides);
    List<String> stringMembersArrayListSet = new List<String>();
    for (int i = 0; i < missingOverridesArray.length; i++) {
      String newStrMember;
      A_Element enclosingElement = missingOverridesArray[i].enclosingElement;
      String prefix = StringUtilities.EMPTY;
      if (missingOverridesArray[i] is PropertyAccessorElement) {
        PropertyAccessorElement propertyAccessorElement = missingOverridesArray[i] as PropertyAccessorElement;
        if (propertyAccessorElement.isGetter) {
          prefix = _GETTER_SPACE;
        } else {
          prefix = _SETTER_SPACE;
        }
      }
      if (enclosingElement != null) {
        newStrMember = "${prefix}'${enclosingElement.displayName}.${missingOverridesArray[i].displayName}'";
      } else {
        newStrMember = "${prefix}'${missingOverridesArray[i].displayName}'";
      }
      stringMembersArrayListSet.add(newStrMember);
    }
    List<String> stringMembersArray = new List.from(stringMembersArrayListSet);
    AnalysisErrorWithProperties analysisError;
    if (stringMembersArray.length == 1) {
      analysisError = _errorReporter.newErrorWithProperties(StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE, classNameNode, [stringMembersArray[0]]);
    } else if (stringMembersArray.length == 2) {
      analysisError = _errorReporter.newErrorWithProperties(StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO, classNameNode, [stringMembersArray[0], stringMembersArray[1]]);
    } else if (stringMembersArray.length == 3) {
      analysisError = _errorReporter.newErrorWithProperties(StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE, classNameNode, [stringMembersArray[0], stringMembersArray[1], stringMembersArray[2]]);
    } else if (stringMembersArray.length == 4) {
      analysisError = _errorReporter.newErrorWithProperties(StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR, classNameNode, [stringMembersArray[0], stringMembersArray[1], stringMembersArray[2], stringMembersArray[3]]);
    } else {
      analysisError = _errorReporter.newErrorWithProperties(StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS, classNameNode, [stringMembersArray[0], stringMembersArray[1], stringMembersArray[2], stringMembersArray[3], stringMembersArray.length - 4]);
    }
    analysisError.setProperty(ErrorProperty.UNIMPLEMENTED_METHODS, missingOverridesArray);
    _errorReporter.reportError(analysisError);
    return true;
  }
  bool _checkForNonBoolCondition(Expression condition) {
    DartType conditionType = getStaticType(condition);
    if (conditionType != null && !conditionType.isAssignableTo(_boolType)) {
      _errorReporter.reportErrorForNode(StaticTypeWarningCode.NON_BOOL_CONDITION, condition, []);
      return true;
    }
    return false;
  }
  bool _checkForNonBoolExpression(AssertStatement node) {
    Expression expression = node.condition;
    DartType A_type = getStaticType(expression);
    if (A_type is InterfaceType) {
      if (!A_type.isAssignableTo(_boolType)) {
        _errorReporter.reportErrorForNode(StaticTypeWarningCode.NON_BOOL_EXPRESSION, expression, []);
        return true;
      }
    } else if (A_type is FunctionType) {
      FunctionType A_functionType = A_type;
      if (A_functionType.typeArguments.length == 0 && !A_functionType.returnType.isAssignableTo(_boolType)) {
        _errorReporter.reportErrorForNode(StaticTypeWarningCode.NON_BOOL_EXPRESSION, expression, []);
        return true;
      }
    }
    return false;
  }
  bool _checkForNonBoolNegationExpression(Expression expression) {
    DartType conditionType = getStaticType(expression);
    if (conditionType != null && !conditionType.isAssignableTo(_boolType)) {
      _errorReporter.reportErrorForNode(StaticTypeWarningCode.NON_BOOL_NEGATION_EXPRESSION, expression, []);
      return true;
    }
    return false;
  }
  bool _checkForNonConstMapAsExpressionStatement(MapLiteral node) {
    if (node.constKeyword != null) {
      return false;
    }
    if (node.typeArguments != null) {
      return false;
    }
    Statement statement = node.getAncestor((node) => node is ExpressionStatement);
    if (statement == null) {
      return false;
    }
    if (!identical(statement.beginToken, node.beginToken)) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.NON_CONST_MAP_AS_EXPRESSION_STATEMENT, node, []);
    return true;
  }
  bool _checkForNonVoidReturnTypeForOperator(MethodDeclaration node) {
    SimpleIdentifier A_name = node.name;
    if (A_name.name != "[]=") {
      return false;
    }
    TypeName typeName = node.returnType;
    if (typeName != null) {
      DartType A_type = typeName.type;
      if (A_type != null && !A_type.isVoid) {
        _errorReporter.reportErrorForNode(StaticWarningCode.NON_VOID_RETURN_FOR_OPERATOR, typeName, []);
      }
    }
    return false;
  }
  bool _checkForNonVoidReturnTypeForSetter(TypeName typeName) {
    if (typeName != null) {
      DartType A_type = typeName.type;
      if (A_type != null && !A_type.isVoid) {
        _errorReporter.reportErrorForNode(StaticWarningCode.NON_VOID_RETURN_FOR_SETTER, typeName, []);
      }
    }
    return false;
  }
  bool _checkForOptionalParameterInOperator(MethodDeclaration node) {
    FormalParameterList parameterList = node.parameters;
    if (parameterList == null) {
      return false;
    }
    bool foundError = false;
    NodeList<FormalParameter> formalParameters = parameterList.parameters;
    for (FormalParameter formalParameter in formalParameters) {
      if (formalParameter.kind.isOptional) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.OPTIONAL_PARAMETER_IN_OPERATOR, formalParameter, []);
        foundError = true;
      }
    }
    return foundError;
  }
  bool _checkForPrivateOptionalParameter(FormalParameter node) {
    if (node.kind != ParameterKind.NAMED) {
      return false;
    }
    SimpleIdentifier A_name = node.identifier;
    if (A_name.isSynthetic || !StringUtilities.startsWithChar(A_name.name, 0x5F)) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.PRIVATE_OPTIONAL_PARAMETER, node, []);
    return true;
  }
  bool _checkForRecursiveConstructorRedirect(ConstructorDeclaration node, ConstructorElement constructorElement) {
    if (node.factoryKeyword != null) {
      return false;
    }
    for (ConstructorInitializer initializer in node.initializers) {
      if (initializer is RedirectingConstructorInvocation) {
        if (!_hasRedirectingFactoryConstructorCycle(constructorElement)) {
          return false;
        }
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.RECURSIVE_CONSTRUCTOR_REDIRECT, initializer, []);
        return true;
      }
    }
    return false;
  }
  bool _checkForRecursiveFactoryRedirect(ConstructorDeclaration node, ConstructorElement constructorElement) {
    ConstructorName redirectedConstructorNode = node.redirectedConstructor;
    if (redirectedConstructorNode == null) {
      return false;
    }
    if (!_hasRedirectingFactoryConstructorCycle(constructorElement)) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.RECURSIVE_FACTORY_REDIRECT, redirectedConstructorNode, []);
    return true;
  }
  bool _checkForRecursiveInterfaceInheritance(ClassElement classElt) {
    if (classElt == null) {
      return false;
    }
    return _safeCheckForRecursiveInterfaceInheritance(classElt, new List<ClassElement>());
  }
  bool _checkForRedirectingConstructorErrorCodes(ConstructorDeclaration node) {
    bool errorReported = false;
    ConstructorName redirectedConstructor = node.redirectedConstructor;
    if (redirectedConstructor != null) {
      for (FormalParameter parameter in node.parameters.parameters) {
        if (parameter is DefaultFormalParameter && parameter.defaultValue != null) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR, parameter.identifier, []);
          errorReported = true;
        }
      }
    }
    int numRedirections = 0;
    for (ConstructorInitializer initializer in node.initializers) {
      if (initializer is RedirectingConstructorInvocation) {
        if (numRedirections > 0) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS, initializer, []);
          errorReported = true;
        }
        if (node.factoryKeyword == null) {
          RedirectingConstructorInvocation invocation = initializer;
          ConstructorElement redirectingElement = invocation.staticElement;
          if (redirectingElement == null) {
            String enclosingTypeName = _enclosingClass.displayName;
            String constructorStrName = enclosingTypeName;
            if (invocation.constructorName != null) {
              constructorStrName += ".${invocation.constructorName.name}";
            }
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.REDIRECT_GENERATIVE_TO_MISSING_CONSTRUCTOR, invocation, [constructorStrName, enclosingTypeName]);
          } else {
            if (redirectingElement.isFactory) {
              _errorReporter.reportErrorForNode(CompileTimeErrorCode.REDIRECT_GENERATIVE_TO_NON_GENERATIVE_CONSTRUCTOR, initializer, []);
            }
          }
        }
        numRedirections++;
      }
    }
    if (numRedirections > 0) {
      for (ConstructorInitializer initializer in node.initializers) {
        if (initializer is SuperConstructorInvocation) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.SUPER_IN_REDIRECTING_CONSTRUCTOR, initializer, []);
          errorReported = true;
        }
        if (initializer is ConstructorFieldInitializer) {
          _errorReporter.reportErrorForNode(CompileTimeErrorCode.FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR, initializer, []);
          errorReported = true;
        }
      }
    }
    return errorReported;
  }
  bool _checkForRedirectToNonConstConstructor(ConstructorDeclaration node, ConstructorElement constructorElement) {
    ConstructorName redirectedConstructorNode = node.redirectedConstructor;
    if (redirectedConstructorNode == null) {
      return false;
    }
    if (constructorElement == null) {
      return false;
    }
    if (!constructorElement.isConst) {
      return false;
    }
    ConstructorElement redirectedConstructor = constructorElement.redirectedConstructor;
    if (redirectedConstructor == null) {
      return false;
    }
    if (redirectedConstructor.isConst) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.REDIRECT_TO_NON_CONST_CONSTRUCTOR, redirectedConstructorNode, []);
    return true;
  }
  bool _checkForRethrowOutsideCatch(RethrowExpression node) {
    if (!_isInCatchClause) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.RETHROW_OUTSIDE_CATCH, node, []);
      return true;
    }
    return false;
  }
  bool _checkForReturnInGenerativeConstructor(ConstructorDeclaration node) {
    if (node.factoryKeyword != null) {
      return false;
    }
    FunctionBody body = node.body;
    if (body is! ExpressionFunctionBody) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.RETURN_IN_GENERATIVE_CONSTRUCTOR, body, []);
    return true;
  }
  bool _checkForReturnOfInvalidType(Expression returnExpression, DartType expectedReturnType) {
    DartType staticReturnType = getStaticType(returnExpression);
    if (expectedReturnType.isVoid) {
      if (staticReturnType.isVoid || staticReturnType.isDynamic || staticReturnType.isBottom) {
        return false;
      }
      _errorReporter.reportTypeErrorForNode(StaticTypeWarningCode.RETURN_OF_INVALID_TYPE, returnExpression, [staticReturnType, expectedReturnType, _enclosingFunction.displayName]);
      return true;
    }
    bool isStaticAssignable = staticReturnType.isAssignableTo(expectedReturnType);
    if (isStaticAssignable) {
      return false;
    }
    _errorReporter.reportTypeErrorForNode(StaticTypeWarningCode.RETURN_OF_INVALID_TYPE, returnExpression, [staticReturnType, expectedReturnType, _enclosingFunction.displayName]);
    return true;
  }
  bool _checkForStaticAccessToInstanceMember(ClassElement typeReference, SimpleIdentifier A_name) {
    if (typeReference == null) {
      return false;
    }
    A_Element A_element = A_name.staticElement;
    if (A_element is! ExecutableElement) {
      return false;
    }
    ExecutableElement memberElement = A_element as ExecutableElement;
    if (memberElement.isStatic) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticWarningCode.STATIC_ACCESS_TO_INSTANCE_MEMBER, A_name, [A_name.name]);
    return true;
  }
  bool _checkForSwitchExpressionNotAssignable(SwitchStatement node) {
    Expression expression = node.expression;
    DartType expressionType = getStaticType(expression);
    if (expressionType == null) {
      return false;
    }
    NodeList<SwitchMember> members = node.members;
    for (SwitchMember switchMember in members) {
      if (switchMember is! SwitchCase) {
        continue;
      }
      SwitchCase switchCase = switchMember as SwitchCase;
      Expression caseExpression = switchCase.expression;
      DartType caseType = getStaticType(caseExpression);
      if (expressionType.isAssignableTo(caseType)) {
        return false;
      }
      _errorReporter.reportErrorForNode(StaticWarningCode.SWITCH_EXPRESSION_NOT_ASSIGNABLE, expression, [expressionType, caseType]);
      return true;
    }
    return false;
  }
  bool _checkForTypeAliasCannotReferenceItself_function(FunctionTypeAlias node) {
    FunctionTypeAliasElement A_element = node.element;
    if (!_hasTypedefSelfReference(A_element)) {
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.TYPE_ALIAS_CANNOT_REFERENCE_ITSELF, node, []);
    return true;
  }
  bool _checkForTypeAnnotationDeferredClass(TypeName node) {
    if (node != null && node.isDeferred) {
      _errorReporter.reportErrorForNode(StaticWarningCode.TYPE_ANNOTATION_DEFERRED_CLASS, node, [node.name]);
    }
    return false;
  }
  bool _checkForTypeArgumentNotMatchingBounds(TypeName node) {
    if (node.typeArguments == null) {
      return false;
    }
    DartType A_type = node.type;
    if (A_type == null) {
      return false;
    }
    A_Element A_element = A_type.element;
    if (A_element is! ClassElement) {
      return false;
    }
    ClassElement classElement = A_element as ClassElement;
    List<DartType> typeParameters = classElement.type.typeArguments;
    List<TypeParameterElement> boundingElts = classElement.typeParameters;
    NodeList<TypeName> typeNameArgList = node.typeArguments.arguments;
    List<DartType> typeArguments = (A_type as InterfaceType).typeArguments;
    int loopThroughIndex = Math.A_min(typeNameArgList.length, boundingElts.length);
    bool foundError = false;
    for (int i = 0; i < loopThroughIndex; i++) {
      TypeName argTypeName = typeNameArgList[i];
      DartType argType = argTypeName.type;
      DartType boundType = boundingElts[i].bound;
      if (argType != null && boundType != null) {
        if (typeArguments.length != 0 && typeArguments.length == typeParameters.length) {
          boundType = boundType.substitute2(typeArguments, typeParameters);
        }
        if (!argType.isSubtypeOf(boundType)) {
          ErrorCode A_errorCode;
          if (_isInConstInstanceCreation) {
            A_errorCode = CompileTimeErrorCode.TYPE_ARGUMENT_NOT_MATCHING_BOUNDS;
          } else {
            A_errorCode = StaticTypeWarningCode.TYPE_ARGUMENT_NOT_MATCHING_BOUNDS;
          }
          _errorReporter.reportTypeErrorForNode(A_errorCode, argTypeName, [argType, boundType]);
          foundError = true;
        }
      }
    }
    return foundError;
  }
  bool _checkForTypeParameterReferencedByStatic(TypeName node) {
    if (_isInStaticMethod || _isInStaticVariableDeclaration) {
      DartType A_type = node.type;
      if (A_type is TypeParameterType) {
        _errorReporter.reportErrorForNode(StaticWarningCode.TYPE_PARAMETER_REFERENCED_BY_STATIC, node, []);
        return true;
      }
    }
    return false;
  }
  bool _checkForTypeParameterSupertypeOfItsBound(TypeParameter node) {
    TypeParameterElement A_element = node.element;
    DartType A_bound = A_element.bound;
    if (A_bound == null) {
      return false;
    }
    if (!A_bound.isMoreSpecificThan(A_element.type)) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticTypeWarningCode.TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND, node, [A_element.displayName]);
    return true;
  }
  bool _checkForUndefinedConstructorInInitializerImplicit(ConstructorDeclaration node) {
    if (node.factoryKeyword != null) {
      return false;
    }
    for (ConstructorInitializer constructorInitializer in node.initializers) {
      if (constructorInitializer is SuperConstructorInvocation || constructorInitializer is RedirectingConstructorInvocation) {
        return false;
      }
    }
    if (_enclosingClass == null) {
      return false;
    }
    InterfaceType superType = _enclosingClass.supertype;
    if (superType == null) {
      return false;
    }
    ClassElement superElement = superType.element;
    ConstructorElement superUnnamedConstructor = superElement.unnamedConstructor;
    if (superUnnamedConstructor != null) {
      if (superUnnamedConstructor.isFactory) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.NON_GENERATIVE_CONSTRUCTOR, node.returnType, [superUnnamedConstructor]);
        return true;
      }
      if (!superUnnamedConstructor.isDefaultConstructor) {
        int A_offset;
        int A_length;
        {
          Identifier A_returnType = node.returnType;
          SimpleIdentifier A_name = node.name;
          A_offset = A_returnType.offset;
          A_length = (A_name != null ? A_name.end : A_returnType.end) - A_offset;
        }
        _errorReporter.reportErrorForOffset(CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT, A_offset, A_length, [superType.displayName]);
      }
      return false;
    }
    _errorReporter.reportErrorForNode(CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT, node.returnType, [superElement.name]);
    return true;
  }
  bool _checkForUnqualifiedReferenceToNonLocalStaticMember(SimpleIdentifier A_name) {
    A_Element A_element = A_name.staticElement;
    if (A_element == null || A_element is TypeParameterElement) {
      return false;
    }
    A_Element enclosingElement = A_element.enclosingElement;
    if (enclosingElement is! ClassElement) {
      return false;
    }
    if ((A_element is MethodElement && !A_element.isStatic) || (A_element is PropertyAccessorElement && !A_element.isStatic)) {
      return false;
    }
    if (identical(enclosingElement, _enclosingClass)) {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticTypeWarningCode.UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER, A_name, [A_name.name]);
    return true;
  }
  void _checkForValidField(FieldFormalParameter node) {
    ParameterElement A_element = node.element;
    if (A_element is FieldFormalParameterElement) {
      FieldElement fieldElement = A_element.field;
      if (fieldElement == null || fieldElement.isSynthetic) {
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD, node, [node.identifier.name]);
      } else {
        ParameterElement parameterElement = node.element;
        if (parameterElement is FieldFormalParameterElementImpl) {
          FieldFormalParameterElementImpl fieldFormal = parameterElement;
          DartType declaredType = fieldFormal.type;
          DartType fieldType = fieldElement.type;
          if (fieldElement.isSynthetic) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD, node, [node.identifier.name]);
          } else if (fieldElement.isStatic) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_STATIC_FIELD, node, [node.identifier.name]);
          } else if (declaredType != null && fieldType != null && !declaredType.isAssignableTo(fieldType)) {
            _errorReporter.reportTypeErrorForNode(StaticWarningCode.FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE, node, [declaredType, fieldType]);
          }
        } else {
          if (fieldElement.isSynthetic) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD, node, [node.identifier.name]);
          } else if (fieldElement.isStatic) {
            _errorReporter.reportErrorForNode(CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_STATIC_FIELD, node, [node.identifier.name]);
          }
        }
      }
    }
  }
  bool _checkForVoidReturnType(MethodDeclaration node) {
    TypeName A_returnType = node.returnType;
    if (A_returnType == null || A_returnType.name.name != "void") {
      return false;
    }
    _errorReporter.reportErrorForNode(StaticWarningCode.VOID_RETURN_FOR_GETTER, A_returnType, []);
    return true;
  }
  bool _checkForWrongNumberOfParametersForOperator(MethodDeclaration node) {
    FormalParameterList parameterList = node.parameters;
    if (parameterList == null) {
      return false;
    }
    int numParameters = parameterList.parameters.length;
    SimpleIdentifier nameNode = node.name;
    if (nameNode == null) {
      return false;
    }
    String A_name = nameNode.name;
    int expected = -1;
    if ("[]=" == A_name) {
      expected = 2;
    } else if ("<" == A_name || ">" == A_name || "<=" == A_name || ">=" == A_name || "==" == A_name || "+" == A_name || "/" == A_name || "~/" == A_name || "*" == A_name || "%" == A_name || "|" == A_name || "^" == A_name || "&" == A_name || "<<" == A_name || ">>" == A_name || "[]" == A_name) {
      expected = 1;
    } else if ("~" == A_name) {
      expected = 0;
    }
    if (expected != -1 && numParameters != expected) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR, nameNode, [A_name, expected, numParameters]);
      return true;
    }
    if ("-" == A_name && numParameters > 1) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS, nameNode, [numParameters]);
      return true;
    }
    return false;
  }
  bool _checkForWrongNumberOfParametersForSetter(SimpleIdentifier setterName, FormalParameterList parameterList) {
    if (setterName == null) {
      return false;
    }
    if (parameterList == null) {
      return false;
    }
    NodeList<FormalParameter> A_parameters = parameterList.parameters;
    if (A_parameters.length != 1 || A_parameters[0].kind != ParameterKind.REQUIRED) {
      _errorReporter.reportErrorForNode(CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER, setterName, []);
      return true;
    }
    return false;
  }
  bool _checkImplementsFunctionWithoutCall(ClassDeclaration node) {
    if (node.isAbstract) {
      return false;
    }
    ClassElement classElement = node.element;
    if (classElement == null) {
      return false;
    }
    if (!classElement.type.isSubtypeOf(B__typeProvider.functionType)) {
      return false;
    }
    if (classElement.getMethod(FunctionElement.NO_SUCH_METHOD_METHOD_NAME) != null) {
      return false;
    }
    ExecutableElement callMethod = _inheritanceManager.lookupMember(classElement, "call");
    if (callMethod == null || callMethod is! MethodElement || (callMethod as MethodElement).isAbstract) {
      _errorReporter.reportErrorForNode(StaticWarningCode.FUNCTION_WITHOUT_CALL, node.name, []);
      return true;
    }
    return false;
  }
  bool _checkImplementsSuperClass(ClassDeclaration node) {
    InterfaceType superType = _enclosingClass.supertype;
    if (superType == null) {
      return false;
    }
    ImplementsClause implementsClause = node.implementsClause;
    if (implementsClause == null) {
      return false;
    }
    bool hasProblem = false;
    for (TypeName interfaceNode in implementsClause.interfaces) {
      if (interfaceNode.type == superType) {
        hasProblem = true;
        _errorReporter.reportErrorForNode(CompileTimeErrorCode.IMPLEMENTS_SUPER_CLASS, interfaceNode, [superType.displayName]);
      }
    }
    return hasProblem;
  }
  ErrorCode _getBaseCaseErrorCode(ClassElement classElt) {
    InterfaceType supertype = classElt.supertype;
    if (supertype != null && _enclosingClass == supertype.element) {
      return CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS;
    }
    List<InterfaceType> mixins = classElt.mixins;
    for (int i = 0; i < mixins.length; i++) {
      if (_enclosingClass == mixins[i].element) {
        return CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_WITH;
      }
    }
    return CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS;
  }
  DartType _getGetterType(PropertyAccessorElement propertyAccessorElement) {
    FunctionType A_functionType = propertyAccessorElement.type;
    if (A_functionType != null) {
      return A_functionType.returnType;
    } else {
      return null;
    }
  }
  DartType _getSetterType(PropertyAccessorElement propertyAccessorElement) {
    List<ParameterElement> setterParameters = propertyAccessorElement.parameters;
    if (setterParameters.length == 0) {
      return null;
    }
    return setterParameters[0].type;
  }
  bool _hasDeferredPrefixCollision(List<ImportDirective> directives) {
    bool foundError = false;
    int count = directives.length;
    if (count > 1) {
      for (int i = 0; i < count; i++) {
        A_Token deferredToken = directives[i].deferredToken;
        if (deferredToken != null) {
          _errorReporter.reportErrorForToken(CompileTimeErrorCode.SHARED_DEFERRED_PREFIX, deferredToken, []);
          foundError = true;
        }
      }
    }
    return foundError;
  }
  bool _hasRedirectingFactoryConstructorCycle(ConstructorElement A_element) {
    Set<ConstructorElement> constructors = new A_p.HashSet<ConstructorElement>();
    ConstructorElement B_current = A_element;
    while (B_current != null) {
      if (constructors.contains(B_current)) {
        return identical(B_current, A_element);
      }
      constructors.add(B_current);
      B_current = B_current.redirectedConstructor;
      if (B_current is ConstructorMember) {
        B_current = (B_current as ConstructorMember).baseElement;
      }
    }
    return false;
  }
  bool _hasTypedefSelfReference(A_Element A_target) {
    Set<A_Element> checked = new A_p.HashSet<A_Element>();
    List<A_Element> toCheck = new List<A_Element>();
    toCheck.add(A_target);
    bool firstIteration = true;
    while (true) {
      A_Element B_current;
      while (true) {
        if (toCheck.isEmpty) {
          return false;
        }
        B_current = toCheck.removeAt(toCheck.length - 1);
        if (A_target == B_current) {
          if (firstIteration) {
            firstIteration = false;
            break;
          } else {
            return true;
          }
        }
        if (B_current != null && !checked.contains(B_current)) {
          break;
        }
      }
      B_current.accept(new GeneralizingElementVisitor_ErrorVerifier_hasTypedefSelfReference(A_target, toCheck));
      checked.add(B_current);
    }
  }
  bool _isFunctionType(DartType A_type) {
    if (A_type.isDynamic || A_type.isBottom) {
      return true;
    } else if (A_type is FunctionType || A_type.isDartCoreFunction) {
      return true;
    } else if (A_type is InterfaceType) {
      MethodElement callMethod = A_type.lookUpMethod(FunctionElement.CALL_METHOD_NAME, _currentLibrary);
      return callMethod != null;
    }
    return false;
  }
  bool _isMemberInClassOrMixin(ExecutableElement executableElt, ClassElement classElt) {
    ExecutableElement foundElt = null;
    String executableName = executableElt.name;
    if (executableElt is MethodElement) {
      foundElt = classElt.getMethod(executableName);
      if (foundElt != null && !(foundElt as MethodElement).isAbstract) {
        return true;
      }
      List<InterfaceType> mixins = classElt.mixins;
      for (int i = 0; i < mixins.length && foundElt == null; i++) {
        foundElt = mixins[i].getMethod(executableName);
      }
      if (foundElt != null && !(foundElt as MethodElement).isAbstract) {
        return true;
      }
    } else if (executableElt is PropertyAccessorElement) {
      PropertyAccessorElement propertyAccessorElement = executableElt;
      if (propertyAccessorElement.isGetter) {
        foundElt = classElt.getGetter(executableName);
      }
      if (foundElt == null && propertyAccessorElement.isSetter) {
        foundElt = classElt.getSetter(executableName);
      }
      if (foundElt != null && !(foundElt as PropertyAccessorElement).isAbstract) {
        return true;
      }
      List<InterfaceType> mixins = classElt.mixins;
      for (int i = 0; i < mixins.length && foundElt == null; i++) {
        foundElt = mixins[i].getGetter(executableName);
        if (foundElt == null) {
          foundElt = mixins[i].getSetter(executableName);
        }
      }
      if (foundElt != null && !(foundElt as PropertyAccessorElement).isAbstract) {
        return true;
      }
    }
    return false;
  }
  bool _isThisInValidContext(ThisExpression node) {
    for (AstNode n = node; n != null; n = n.parent) {
      if (n is CompilationUnit) {
        return false;
      }
      if (n is ConstructorDeclaration) {
        ConstructorDeclaration constructor = n as ConstructorDeclaration;
        return constructor.factoryKeyword == null;
      }
      if (n is ConstructorInitializer) {
        return false;
      }
      if (n is MethodDeclaration) {
        MethodDeclaration A_method = n as MethodDeclaration;
        return !A_method.isStatic;
      }
    }
    return false;
  }
  bool _isUnqualifiedReferenceToNonLocalStaticMemberAllowed(SimpleIdentifier node) {
    if (node.inDeclarationContext()) {
      return true;
    }
    AstNode A_parent = node.parent;
    if (A_parent is ConstructorName || A_parent is MethodInvocation || A_parent is PropertyAccess || A_parent is SuperConstructorInvocation) {
      return true;
    }
    if (A_parent is PrefixedIdentifier && identical(A_parent.identifier, node)) {
      return true;
    }
    if (A_parent is Annotation && identical(A_parent.constructorName, node)) {
      return true;
    }
    if (A_parent is CommentReference) {
      CommentReference commentReference = A_parent;
      if (commentReference.newKeyword != null) {
        return true;
      }
    }
    return false;
  }
  bool _isUserDefinedObject(EvaluationResultImpl result) => result == null || (result is ValidResult && result.isUserDefinedObject);
  bool _safeCheckForRecursiveInterfaceInheritance(ClassElement classElt, List<ClassElement> A_path) {
    int A_size = A_path.length;
    if (A_size > 0 && _enclosingClass == classElt) {
      String enclosingClassName = _enclosingClass.displayName;
      if (A_size > 1) {
        String A_separator = ", ";
        JavaStringBuilder A_builder = new JavaStringBuilder();
        for (int i = 0; i < A_size; i++) {
          A_builder.append(A_path[i].displayName);
          A_builder.append(A_separator);
        }
        A_builder.append(classElt.displayName);
        _errorReporter.reportErrorForOffset(CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE, _enclosingClass.nameOffset, enclosingClassName.length, [enclosingClassName, A_builder.toString()]);
        return true;
      } else {
        _errorReporter.reportErrorForOffset(_getBaseCaseErrorCode(classElt), _enclosingClass.nameOffset, enclosingClassName.length, [enclosingClassName]);
        return true;
      }
    }
    if (A_path.indexOf(classElt) > 0) {
      return false;
    }
    A_path.add(classElt);
    InterfaceType supertype = classElt.supertype;
    if (supertype != null && _safeCheckForRecursiveInterfaceInheritance(supertype.element, A_path)) {
      return true;
    }
    List<InterfaceType> interfaceTypes = classElt.interfaces;
    for (InterfaceType interfaceType in interfaceTypes) {
      if (_safeCheckForRecursiveInterfaceInheritance(interfaceType.element, A_path)) {
        return true;
      }
    }
    List<InterfaceType> mixinTypes = classElt.mixins;
    for (InterfaceType mixinType in mixinTypes) {
      if (_safeCheckForRecursiveInterfaceInheritance(mixinType.element, A_path)) {
        return true;
      }
    }
    A_path.removeAt(A_path.length - 1);
    return false;
  }
}
class ExitDetector extends GeneralizingAstVisitor<bool> {
  bool _enclosingBlockContainsBreak = false;
  bool visitArgumentList(ArgumentList node) => A__visitExpressions(node.arguments);
  bool visitAsExpression(AsExpression node) => _nodeExits(node.expression);
  bool visitAssertStatement(AssertStatement node) => _nodeExits(node.condition);
  bool visitAssignmentExpression(AssignmentExpression node) => _nodeExits(node.leftHandSide) || _nodeExits(node.rightHandSide);
  bool visitBinaryExpression(BinaryExpression node) {
    Expression lhsExpression = node.leftOperand;
    A_TokenType operatorType = node.operator.type;
    if (operatorType == A_TokenType.BAR_BAR) {
      if (lhsExpression is BooleanLiteral) {
        BooleanLiteral booleanLiteral = lhsExpression;
        if (!booleanLiteral.value) {
          return false;
        }
      }
    }
    if (operatorType == A_TokenType.AMPERSAND_AMPERSAND) {
      if (lhsExpression is BooleanLiteral) {
        BooleanLiteral booleanLiteral = lhsExpression;
        if (booleanLiteral.value) {
          return false;
        }
      }
    }
    Expression rhsExpression = node.rightOperand;
    return _nodeExits(lhsExpression) || _nodeExits(rhsExpression);
  }
  bool visitBlock(Block node) => _visitStatements(node.statements);
  bool visitBlockFunctionBody(BlockFunctionBody node) => _nodeExits(node.block);
  bool visitBreakStatement(BreakStatement node) {
    _enclosingBlockContainsBreak = true;
    return false;
  }
  bool visitCascadeExpression(CascadeExpression node) => _nodeExits(node.target) || A__visitExpressions(node.cascadeSections);
  bool visitConditionalExpression(ConditionalExpression node) {
    Expression conditionExpression = node.condition;
    Expression thenStatement = node.thenExpression;
    Expression elseStatement = node.elseExpression;
    if (_nodeExits(conditionExpression)) {
      return true;
    }
    if (thenStatement == null || elseStatement == null) {
      return false;
    }
    return thenStatement.accept(this) && elseStatement.accept(this);
  }
  bool visitContinueStatement(ContinueStatement node) => false;
  bool visitDoStatement(DoStatement node) {
    bool outerBreakValue = _enclosingBlockContainsBreak;
    _enclosingBlockContainsBreak = false;
    try {
      Expression conditionExpression = node.condition;
      if (_nodeExits(conditionExpression)) {
        return true;
      }
      if (conditionExpression is BooleanLiteral) {
        BooleanLiteral booleanLiteral = conditionExpression;
        bool blockReturns = _nodeExits(node.body);
        if (booleanLiteral.value && (blockReturns || !_enclosingBlockContainsBreak)) {
          return true;
        }
      }
      return false;
    } finally {
      _enclosingBlockContainsBreak = outerBreakValue;
    }
  }
  bool visitEmptyStatement(EmptyStatement node) => false;
  bool visitExpressionStatement(ExpressionStatement node) => _nodeExits(node.expression);
  bool visitForEachStatement(ForEachStatement node) {
    bool outerBreakValue = _enclosingBlockContainsBreak;
    _enclosingBlockContainsBreak = false;
    try {
      return _nodeExits(node.iterator);
    } finally {
      _enclosingBlockContainsBreak = outerBreakValue;
    }
  }
  bool visitForStatement(ForStatement node) {
    bool outerBreakValue = _enclosingBlockContainsBreak;
    _enclosingBlockContainsBreak = false;
    try {
      if (node.variables != null && _visitVariableDeclarations(node.variables.variables)) {
        return true;
      }
      if (node.initialization != null && _nodeExits(node.initialization)) {
        return true;
      }
      Expression conditionExpression = node.condition;
      if (conditionExpression != null && _nodeExits(conditionExpression)) {
        return true;
      }
      if (A__visitExpressions(node.updaters)) {
        return true;
      }
      bool implicitOrExplictTrue = conditionExpression == null || (conditionExpression is BooleanLiteral && conditionExpression.value);
      if (implicitOrExplictTrue) {
        bool blockReturns = _nodeExits(node.body);
        if (blockReturns || !_enclosingBlockContainsBreak) {
          return true;
        }
      }
      return false;
    } finally {
      _enclosingBlockContainsBreak = outerBreakValue;
    }
  }
  bool visitFunctionDeclarationStatement(FunctionDeclarationStatement node) => false;
  bool visitFunctionExpression(FunctionExpression node) => false;
  bool visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    if (_nodeExits(node.function)) {
      return true;
    }
    return node.argumentList.accept(this);
  }
  bool visitIdentifier(Identifier node) => false;
  bool visitIfStatement(IfStatement node) {
    Expression conditionExpression = node.condition;
    Statement thenStatement = node.thenStatement;
    Statement elseStatement = node.elseStatement;
    if (_nodeExits(conditionExpression)) {
      return true;
    }
    if (conditionExpression is BooleanLiteral) {
      BooleanLiteral booleanLiteral = conditionExpression;
      if (booleanLiteral.value) {
        return _nodeExits(thenStatement);
      } else if (elseStatement != null) {
        return _nodeExits(elseStatement);
      }
    }
    if (thenStatement == null || elseStatement == null) {
      return false;
    }
    return _nodeExits(thenStatement) && _nodeExits(elseStatement);
  }
  bool visitIndexExpression(IndexExpression node) {
    Expression A_target = node.realTarget;
    if (_nodeExits(A_target)) {
      return true;
    }
    if (_nodeExits(node.index)) {
      return true;
    }
    return false;
  }
  bool visitInstanceCreationExpression(InstanceCreationExpression node) => _nodeExits(node.argumentList);
  bool visitIsExpression(IsExpression node) => node.expression.accept(this);
  bool visitLabel(Label node) => false;
  bool visitLabeledStatement(LabeledStatement node) => node.statement.accept(this);
  bool visitLiteral(Literal node) => false;
  bool visitMethodInvocation(MethodInvocation node) {
    Expression A_target = node.realTarget;
    if (A_target != null && A_target.accept(this)) {
      return true;
    }
    return _nodeExits(node.argumentList);
  }
  bool visitNamedExpression(NamedExpression node) => node.expression.accept(this);
  bool visitParenthesizedExpression(ParenthesizedExpression node) => node.expression.accept(this);
  bool visitPostfixExpression(PostfixExpression node) => false;
  bool visitPrefixExpression(PrefixExpression node) => false;
  bool visitPropertyAccess(PropertyAccess node) {
    Expression A_target = node.realTarget;
    if (A_target != null && A_target.accept(this)) {
      return true;
    }
    return false;
  }
  bool visitRethrowExpression(RethrowExpression node) => true;
  bool visitReturnStatement(ReturnStatement node) => true;
  bool visitSuperExpression(SuperExpression node) => false;
  bool visitSwitchCase(SwitchCase node) => _visitStatements(node.statements);
  bool visitSwitchDefault(SwitchDefault node) => _visitStatements(node.statements);
  bool visitSwitchStatement(SwitchStatement node) {
    bool outerBreakValue = _enclosingBlockContainsBreak;
    _enclosingBlockContainsBreak = false;
    try {
      bool hasDefault = false;
      NodeList<SwitchMember> memberList = node.members;
      List<SwitchMember> members = new List.from(memberList);
      for (int i = 0; i < members.length; i++) {
        SwitchMember switchMember = members[i];
        if (switchMember is SwitchDefault) {
          hasDefault = true;
          if (switchMember.statements.isEmpty && i + 1 == members.length) {
            return false;
          }
        }
        if (!switchMember.statements.isEmpty && !switchMember.accept(this)) {
          return false;
        }
      }
      return hasDefault;
    } finally {
      _enclosingBlockContainsBreak = outerBreakValue;
    }
  }
  bool visitThisExpression(ThisExpression node) => false;
  bool visitThrowExpression(ThrowExpression node) => true;
  bool visitTryStatement(TryStatement node) {
    if (_nodeExits(node.body)) {
      return true;
    }
    Block finallyBlock = node.finallyBlock;
    if (_nodeExits(finallyBlock)) {
      return true;
    }
    return false;
  }
  bool visitTypeName(TypeName node) => false;
  bool visitVariableDeclaration(VariableDeclaration node) {
    Expression initializer = node.initializer;
    if (initializer != null) {
      return initializer.accept(this);
    }
    return false;
  }
  bool visitVariableDeclarationList(VariableDeclarationList node) => _visitVariableDeclarations(node.variables);
  bool visitVariableDeclarationStatement(VariableDeclarationStatement node) {
    NodeList<VariableDeclaration> variables = node.variables.variables;
    for (int i = 0; i < variables.length; i++) {
      if (variables[i].accept(this)) {
        return true;
      }
    }
    return false;
  }
  bool visitWhileStatement(WhileStatement node) {
    bool outerBreakValue = _enclosingBlockContainsBreak;
    _enclosingBlockContainsBreak = false;
    try {
      Expression conditionExpression = node.condition;
      if (conditionExpression.accept(this)) {
        return true;
      }
      if (conditionExpression is BooleanLiteral) {
        BooleanLiteral booleanLiteral = conditionExpression;
        bool blockReturns = node.body.accept(this);
        if (booleanLiteral.value && (blockReturns || !_enclosingBlockContainsBreak)) {
          return true;
        }
      }
      return false;
    } finally {
      _enclosingBlockContainsBreak = outerBreakValue;
    }
  }
  bool _nodeExits(AstNode node) {
    if (node == null) {
      return false;
    }
    return node.accept(this);
  }
  bool A__visitExpressions(NodeList<Expression> expressions) {
    for (int i = expressions.length - 1; i >= 0; i--) {
      if (expressions[i].accept(this)) {
        return true;
      }
    }
    return false;
  }
  bool _visitStatements(NodeList<Statement> statements) {
    for (int i = statements.length - 1; i >= 0; i--) {
      if (statements[i].accept(this)) {
        return true;
      }
    }
    return false;
  }
  bool _visitVariableDeclarations(NodeList<VariableDeclaration> variableDeclarations) {
    for (int i = variableDeclarations.length - 1; i >= 0; i--) {
      if (variableDeclarations[i].accept(this)) {
        return true;
      }
    }
    return false;
  }
}
class FunctionScope extends EnclosedScope {
  final ExecutableElement A__functionElement;
  bool _parametersDefined = false;
  FunctionScope(Scope enclosingScope, this.A__functionElement) : super(new EnclosedScope(enclosingScope)) {
    if (A__functionElement == null) {
      throw new IllegalArgumentException("function element cannot be null");
    }
  }
  void defineParameters() {
    if (_parametersDefined) {
      return;
    }
    _parametersDefined = true;
    Scope parameterScope = enclosingScope;
    if (A__functionElement.enclosingElement is ExecutableElement) {
      String A_name = A__functionElement.name;
      if (A_name != null && !A_name.isEmpty) {
        parameterScope.define(A__functionElement);
      }
    }
    for (ParameterElement parameter in A__functionElement.parameters) {
      if (!parameter.isInitializingFormal) {
        parameterScope.define(parameter);
      }
    }
  }
}
class FunctionTypeScope extends EnclosedScope {
  final FunctionTypeAliasElement _typeElement;
  bool _parametersDefined = false;
  FunctionTypeScope(Scope enclosingScope, this._typeElement) : super(new EnclosedScope(enclosingScope)) {
    _defineTypeParameters();
  }
  void defineParameters() {
    if (_parametersDefined) {
      return;
    }
    _parametersDefined = true;
    for (ParameterElement parameter in _typeElement.parameters) {
      define(parameter);
    }
  }
  void _defineTypeParameters() {
    Scope typeParameterScope = enclosingScope;
    for (TypeParameterElement typeParameter in _typeElement.typeParameters) {
      typeParameterScope.define(typeParameter);
    }
  }
}
class GeneralizingAstVisitor_StaticTypeAnalyzer_computePropagatedReturnTypeOfFunction extends GeneralizingAstVisitor<Object> {
  List<DartType> result;
  GeneralizingAstVisitor_StaticTypeAnalyzer_computePropagatedReturnTypeOfFunction(this.result) : super();
  Object visitExpression(Expression node) => null;
  Object visitReturnStatement(ReturnStatement node) {
    DartType A_type;
    Expression expression = node.expression;
    if (expression != null) {
      A_type = expression.bestType;
    } else {
      A_type = BottomTypeImpl.instance;
    }
    if (result[0] == null) {
      result[0] = A_type;
    } else {
      result[0] = result[0].getLeastUpperBound(A_type);
    }
    return null;
  }
}
class GeneralizingElementVisitor_DeclarationMatcher_gatherElements extends GeneralizingElementVisitor<Object> {
  final DeclarationMatcher DeclarationMatcher_this;
  GeneralizingElementVisitor_DeclarationMatcher_gatherElements(this.DeclarationMatcher_this) : super();
  Object visitElement(A_Element A_element) {
    DeclarationMatcher_this._allElements.add(A_element);
    DeclarationMatcher_this._unmatchedElements.add(A_element);
    return super.visitElement(A_element);
  }
}
class GeneralizingElementVisitor_ErrorVerifier_hasTypedefSelfReference extends GeneralizingElementVisitor<Object> {
  A_Element target;
  List<A_Element> toCheck;
  GeneralizingElementVisitor_ErrorVerifier_hasTypedefSelfReference(this.target, this.toCheck) : super();
  bool _inClass = false;
  Object visitClassElement(ClassElement A_element) {
    _addTypeToCheck(A_element.supertype);
    for (InterfaceType mixin in A_element.mixins) {
      _addTypeToCheck(mixin);
    }
    _inClass = !A_element.isTypedef;
    try {
      return super.visitClassElement(A_element);
    } finally {
      _inClass = false;
    }
  }
  Object visitExecutableElement(ExecutableElement A_element) {
    if (A_element.isSynthetic) {
      return null;
    }
    _addTypeToCheck(A_element.returnType);
    return super.visitExecutableElement(A_element);
  }
  Object visitFunctionTypeAliasElement(FunctionTypeAliasElement A_element) {
    _addTypeToCheck(A_element.returnType);
    return super.visitFunctionTypeAliasElement(A_element);
  }
  Object visitParameterElement(ParameterElement A_element) {
    _addTypeToCheck(A_element.type);
    return super.visitParameterElement(A_element);
  }
  Object visitTypeParameterElement(TypeParameterElement A_element) {
    _addTypeToCheck(A_element.bound);
    return super.visitTypeParameterElement(A_element);
  }
  Object visitVariableElement(VariableElement A_element) {
    _addTypeToCheck(A_element.type);
    return super.visitVariableElement(A_element);
  }
  void _addTypeToCheck(DartType A_type) {
    if (A_type == null) {
      return;
    }
    A_Element A_element = A_type.element;
    if (_inClass && target == A_element) {
      return;
    }
    toCheck.add(A_element);
    if (A_type is InterfaceType) {
      InterfaceType interfaceType = A_type;
      for (DartType typeArgument in interfaceType.typeArguments) {
        _addTypeToCheck(typeArgument);
      }
    }
  }
}
class HintGenerator {
  final List<CompilationUnit> _compilationUnits;
  final AnalysisContext B__context;
  final AnalysisErrorListener D__errorListener;
  ImportsVerifier _importsVerifier;
  bool _enableDart2JSHints = false;
  InheritanceManager _manager;
  HintGenerator(this._compilationUnits, this.B__context, this.D__errorListener) {
    LibraryElement library = _compilationUnits[0].element.library;
    _importsVerifier = new ImportsVerifier(library);
    _enableDart2JSHints = B__context.analysisOptions.dart2jsHint;
    _manager = new InheritanceManager(_compilationUnits[0].element.library);
  }
  void generateForLibrary() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.hints.start();
    try {
      for (int i = 0; i < _compilationUnits.length; i++) {
        CompilationUnitElement A_element = _compilationUnits[i].element;
        if (A_element != null) {
          if (i == 0) {
            _importsVerifier.inDefiningCompilationUnit = true;
            _generateForCompilationUnit(_compilationUnits[i], A_element.source);
            _importsVerifier.inDefiningCompilationUnit = false;
          } else {
            _generateForCompilationUnit(_compilationUnits[i], A_element.source);
          }
        }
      }
      ErrorReporter definingCompilationUnitErrorReporter = new ErrorReporter(D__errorListener, _compilationUnits[0].element.source);
      _importsVerifier.generateDuplicateImportHints(definingCompilationUnitErrorReporter);
      _importsVerifier.generateUnusedImportHints(definingCompilationUnitErrorReporter);
    } finally {
      timeCounter.stop();
    }
  }
  void _generateForCompilationUnit(CompilationUnit unit, Source A_source) {
    ErrorReporter errorReporter = new ErrorReporter(D__errorListener, A_source);
    unit.accept(_importsVerifier);
    unit.accept(new DeadCodeVerifier(errorReporter));
    if (_enableDart2JSHints) {
      unit.accept(new Dart2JSVerifier(errorReporter));
    }
    unit.accept(new BestPracticesVerifier(errorReporter));
    unit.accept(new OverrideVerifier(_manager, errorReporter));
    new ToDoFinder(errorReporter).findIn(unit);
  }
}
class HtmlUnitBuilder implements XmlVisitor<Object> {
  static String _SRC = "src";
  final InternalAnalysisContext B__context;
  RecordingErrorListener D__errorListener;
  int _modificationStamp = 0;
  HtmlElementImpl A__htmlElement;
  List<XmlTagNode> _parentNodes;
  List<HtmlScriptElement> A__scripts;
  Set<Library> _resolvedLibraries = new A_p.HashSet<Library>();
  HtmlUnitBuilder(this.B__context) {
    this.D__errorListener = new RecordingErrorListener();
  }
  HtmlElementImpl buildHtmlElement(Source A_source, int modificationStamp, HtmlUnit unit) {
    this._modificationStamp = modificationStamp;
    HtmlElementImpl result = new HtmlElementImpl(B__context, A_source.shortName);
    result.source = A_source;
    A__htmlElement = result;
    unit.accept(this);
    A__htmlElement = null;
    unit.element = result;
    return result;
  }
  RecordingErrorListener get errorListener => D__errorListener;
  Set<Library> get resolvedLibraries => _resolvedLibraries;
  Object visitHtmlScriptTagNode(HtmlScriptTagNode node) {
    if (_parentNodes.contains(node)) {
      return _reportCircularity(node);
    }
    _parentNodes.add(node);
    try {
      Source htmlSource = A__htmlElement.source;
      XmlAttributeNode scriptAttribute = _getScriptSourcePath(node);
      String scriptSourcePath = scriptAttribute == null ? null : scriptAttribute.text;
      if (node.attributeEnd.type == TokenType.GT && scriptSourcePath == null) {
        EmbeddedHtmlScriptElementImpl A_script = new EmbeddedHtmlScriptElementImpl(node);
        try {
          LibraryResolver resolver = new LibraryResolver(B__context);
          LibraryElementImpl library = resolver.resolveEmbeddedLibrary(htmlSource, _modificationStamp, node.script, true) as LibraryElementImpl;
          A_script.scriptLibrary = library;
          _resolvedLibraries.addAll(resolver.resolvedLibraries);
          D__errorListener.addAll(resolver.errorListener);
        }on AnalysisException  catch (exception, A_stackTrace) {
          AnalysisEngine.A_instance.logger.logError2("Could not resolve script tag", new CaughtException(exception, A_stackTrace));
        }
        node.scriptElement = A_script;
        A__scripts.add(A_script);
      } else {
        ExternalHtmlScriptElementImpl A_script = new ExternalHtmlScriptElementImpl(node);
        if (scriptSourcePath != null) {
          try {
            scriptSourcePath = Uri.encodeFull(scriptSourcePath);
            parseUriWithException(scriptSourcePath);
            Source scriptSource = B__context.sourceFactory.resolveUri(htmlSource, scriptSourcePath);
            A_script.scriptSource = scriptSource;
            if (!B__context.exists(scriptSource)) {
              _reportValueError(HtmlWarningCode.URI_DOES_NOT_EXIST, scriptAttribute, [scriptSourcePath]);
            }
          }on URISyntaxException  catch (exception) {
            _reportValueError(HtmlWarningCode.A_INVALID_URI, scriptAttribute, [scriptSourcePath]);
          }
        }
        node.scriptElement = A_script;
        A__scripts.add(A_script);
      }
    } finally {
      _parentNodes.remove(node);
    }
    return null;
  }
  Object visitHtmlUnit(HtmlUnit node) {
    _parentNodes = new List<XmlTagNode>();
    A__scripts = new List<HtmlScriptElement>();
    try {
      node.visitChildren(this);
      A__htmlElement.scripts = new List.from(A__scripts);
    } finally {
      A__scripts = null;
      _parentNodes = null;
    }
    return null;
  }
  Object visitXmlAttributeNode(XmlAttributeNode node) => null;
  Object visitXmlTagNode(XmlTagNode node) {
    if (_parentNodes.contains(node)) {
      return _reportCircularity(node);
    }
    _parentNodes.add(node);
    try {
      node.visitChildren(this);
    } finally {
      _parentNodes.remove(node);
    }
    return null;
  }
  XmlAttributeNode _getScriptSourcePath(XmlTagNode node) {
    for (XmlAttributeNode attribute in node.attributes) {
      if (attribute.name == _SRC) {
        return attribute;
      }
    }
    return null;
  }
  Object _reportCircularity(XmlTagNode node) {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("Found circularity in XML nodes: ");
    bool A_first = true;
    for (XmlTagNode pathNode in _parentNodes) {
      if (A_first) {
        A_first = false;
      } else {
        A_builder.append(", ");
      }
      String tagName = pathNode.tag;
      if (identical(pathNode, node)) {
        A_builder.append("*");
        A_builder.append(tagName);
        A_builder.append("*");
      } else {
        A_builder.append(tagName);
      }
    }
    AnalysisEngine.A_instance.logger.logError(A_builder.toString());
    return null;
  }
  void A__reportErrorForOffset(ErrorCode A_errorCode, int A_offset, int A_length, List<Object> A_arguments) {
    D__errorListener.onError(new A_AnalysisError.D_con2(A__htmlElement.source, A_offset, A_length, A_errorCode, A_arguments));
  }
  void _reportValueError(ErrorCode A_errorCode, XmlAttributeNode attribute, List<Object> A_arguments) {
    int A_offset = attribute.valueToken.offset + 1;
    int A_length = attribute.valueToken.length - 2;
    A__reportErrorForOffset(A_errorCode, A_offset, A_length, A_arguments);
  }
}
class INIT_STATE extends Enum<INIT_STATE> {
  static const INIT_STATE NOT_INIT = const INIT_STATE('NOT_INIT', 0);
  static const INIT_STATE INIT_IN_DECLARATION = const INIT_STATE('INIT_IN_DECLARATION', 1);
  static const INIT_STATE INIT_IN_FIELD_FORMAL = const INIT_STATE('INIT_IN_FIELD_FORMAL', 2);
  static const INIT_STATE INIT_IN_INITIALIZERS = const INIT_STATE('INIT_IN_INITIALIZERS', 3);
  const INIT_STATE(String A_name, int ordinal) : super(A_name, ordinal);
}
class ImportsVerifier extends RecursiveAstVisitor<Object> {
  bool _inDefiningCompilationUnit = false;
  LibraryElement _currentLibrary;
  List<ImportDirective> _unusedImports;
  List<ImportDirective> _duplicateImports;
  A_p.HashMap<LibraryElement, List<ImportDirective>> A__libraryMap;
  A_p.HashMap<ImportDirective, Namespace> _namespaceMap;
  A_p.HashMap<PrefixElement, List<ImportDirective>> _prefixElementMap;
  ImportsVerifier(LibraryElement library) {
    this._currentLibrary = library;
    this._unusedImports = new List<ImportDirective>();
    this._duplicateImports = new List<ImportDirective>();
    this.A__libraryMap = new A_p.HashMap<LibraryElement,List<ImportDirective>>();
    this._namespaceMap = new A_p.HashMap<ImportDirective,Namespace>();
    this._prefixElementMap = new A_p.HashMap<PrefixElement,List<ImportDirective>>();
  }
  void generateDuplicateImportHints(ErrorReporter errorReporter) {
    for (ImportDirective duplicateImport in _duplicateImports) {
      errorReporter.reportErrorForNode(HintCode.DUPLICATE_IMPORT, duplicateImport.uri, []);
    }
  }
  void generateUnusedImportHints(ErrorReporter errorReporter) {
    for (ImportDirective unusedImport in _unusedImports) {
      ImportElement importElement = unusedImport.element;
      if (importElement != null) {
        LibraryElement libraryElement = importElement.importedLibrary;
        if (libraryElement != null && libraryElement.isDartCore) {
          continue;
        }
      }
      errorReporter.reportErrorForNode(HintCode.UNUSED_IMPORT, unusedImport.uri, []);
    }
  }
  Object visitCompilationUnit(CompilationUnit node) {
    if (_inDefiningCompilationUnit) {
      NodeList<Directive> directives = node.directives;
      for (Directive directive in directives) {
        if (directive is ImportDirective) {
          ImportDirective importDirective = directive;
          LibraryElement libraryElement = importDirective.uriElement;
          if (libraryElement != null) {
            _unusedImports.add(importDirective);
            if (importDirective.asToken != null) {
              SimpleIdentifier prefixIdentifier = importDirective.prefix;
              if (prefixIdentifier != null) {
                A_Element A_element = prefixIdentifier.staticElement;
                if (A_element is PrefixElement) {
                  PrefixElement prefixElementKey = A_element;
                  List<ImportDirective> A_list = _prefixElementMap[prefixElementKey];
                  if (A_list == null) {
                    A_list = new List<ImportDirective>();
                    _prefixElementMap[prefixElementKey] = A_list;
                  }
                  A_list.add(importDirective);
                }
              }
            }
            _putIntoLibraryMap(libraryElement, importDirective);
            _addAdditionalLibrariesForExports(libraryElement, importDirective, new List<LibraryElement>());
          }
        }
      }
    }
    if (_unusedImports.isEmpty) {
      return null;
    }
    if (_unusedImports.length > 1) {
      List<ImportDirective> importDirectiveArray = new List.from(_unusedImports);
      importDirectiveArray.sort(ImportDirective.COMPARATOR);
      ImportDirective currentDirective = importDirectiveArray[0];
      for (int i = 1; i < importDirectiveArray.length; i++) {
        ImportDirective nextDirective = importDirectiveArray[i];
        if (ImportDirective.COMPARATOR(currentDirective, nextDirective) == 0) {
          if (currentDirective.offset < nextDirective.offset) {
            _duplicateImports.add(nextDirective);
          } else {
            _duplicateImports.add(currentDirective);
          }
        }
        currentDirective = nextDirective;
      }
    }
    return super.visitCompilationUnit(node);
  }
  Object visitExportDirective(ExportDirective node) {
    _visitMetadata(node.metadata);
    return null;
  }
  Object visitImportDirective(ImportDirective node) {
    _visitMetadata(node.metadata);
    return null;
  }
  Object visitLibraryDirective(LibraryDirective node) {
    _visitMetadata(node.metadata);
    return null;
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    if (_unusedImports.isEmpty) {
      return null;
    }
    SimpleIdentifier prefixIdentifier = node.prefix;
    A_Element A_element = prefixIdentifier.staticElement;
    if (A_element is PrefixElement) {
      List<ImportDirective> importDirectives = _prefixElementMap[A_element];
      if (importDirectives != null) {
        for (ImportDirective importDirective in importDirectives) {
          _unusedImports.remove(importDirective);
        }
      }
      return null;
    }
    return _visitIdentifier(A_element, prefixIdentifier.name);
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    if (_unusedImports.isEmpty) {
      return null;
    }
    return _visitIdentifier(node.staticElement, node.name);
  }
  void set inDefiningCompilationUnit(bool A_inDefiningCompilationUnit) {
    this._inDefiningCompilationUnit = A_inDefiningCompilationUnit;
  }
  void _addAdditionalLibrariesForExports(LibraryElement library, ImportDirective importDirective, List<LibraryElement> exportPath) {
    if (exportPath.contains(library)) {
      return;
    }
    exportPath.add(library);
    for (LibraryElement exportedLibraryElt in library.exportedLibraries) {
      _putIntoLibraryMap(exportedLibraryElt, importDirective);
      _addAdditionalLibrariesForExports(exportedLibraryElt, importDirective, exportPath);
    }
  }
  Namespace _computeNamespace(ImportDirective importDirective) {
    Namespace namespace = _namespaceMap[importDirective];
    if (namespace == null) {
      ImportElement importElement = importDirective.element;
      if (importElement != null) {
        NamespaceBuilder A_builder = new NamespaceBuilder();
        namespace = A_builder.createImportNamespaceForDirective(importElement);
        _namespaceMap[importDirective] = namespace;
      }
    }
    return namespace;
  }
  void _putIntoLibraryMap(LibraryElement libraryElement, ImportDirective importDirective) {
    List<ImportDirective> importList = A__libraryMap[libraryElement];
    if (importList == null) {
      importList = new List<ImportDirective>();
      A__libraryMap[libraryElement] = importList;
    }
    importList.add(importDirective);
  }
  Object _visitIdentifier(A_Element A_element, String A_name) {
    if (A_element == null) {
      return null;
    }
    if (A_element is MultiplyDefinedElement) {
      MultiplyDefinedElement multiplyDefinedElement = A_element;
      for (A_Element elt in multiplyDefinedElement.conflictingElements) {
        _visitIdentifier(elt, A_name);
      }
      return null;
    } else if (A_element is PrefixElement) {
      List<ImportDirective> importDirectives = _prefixElementMap[A_element];
      if (importDirectives != null) {
        for (ImportDirective importDirective in importDirectives) {
          _unusedImports.remove(importDirective);
        }
      }
      return null;
    } else if (A_element.enclosingElement is! CompilationUnitElement) {
      return null;
    }
    LibraryElement containingLibrary = A_element.library;
    if (containingLibrary == null) {
      return null;
    }
    if (_currentLibrary == containingLibrary) {
      return null;
    }
    List<ImportDirective> importsFromSameLibrary = A__libraryMap[containingLibrary];
    if (importsFromSameLibrary == null) {
      return null;
    }
    if (importsFromSameLibrary.length == 1) {
      ImportDirective usedImportDirective = importsFromSameLibrary[0];
      _unusedImports.remove(usedImportDirective);
    } else {
      for (ImportDirective importDirective in importsFromSameLibrary) {
        Namespace namespace = _computeNamespace(importDirective);
        if (namespace != null && namespace.get(A_name) != null) {
          _unusedImports.remove(importDirective);
        }
      }
    }
    return null;
  }
  void _visitMetadata(NodeList<Annotation> annotations) {
    int count = annotations.length;
    for (int i = 0; i < count; i++) {
      annotations[i].accept(this);
    }
  }
}
class IncrementalResolver {
  final LibraryElement _definingLibrary;
  final Source E__source;
  final TypeProvider B__typeProvider;
  final AnalysisErrorListener D__errorListener;
  IncrementalResolver(this._definingLibrary, this.E__source, this.B__typeProvider, this.D__errorListener);
  void resolve(AstNode node) {
    AstNode rootNode = _findResolutionRoot(node);
    Scope scope = ScopeBuilder.scopeFor(rootNode, D__errorListener);
    if (_elementModelChanged(rootNode.parent)) {
      throw new AnalysisException("Cannot resolve node: element model changed");
    }
    _resolveTypes(node, scope);
    _resolveVariables(node, scope);
    _resolveReferences(node, scope);
  }
  bool _canBeResolved(AstNode node) => node is ClassDeclaration || node is ClassTypeAlias || node is CompilationUnit || node is ConstructorDeclaration || node is FunctionDeclaration || node is FunctionTypeAlias || node is MethodDeclaration;
  bool _elementModelChanged(AstNode node) {
    A_Element A_element = _getElement(node);
    if (A_element == null) {
      throw new AnalysisException("Cannot resolve node: a ${node.runtimeType.toString()} does not define an element");
    }
    DeclarationMatcher matcher = new DeclarationMatcher();
    return !matcher.matches(node, A_element);
  }
  AstNode _findResolutionRoot(AstNode node) {
    AstNode result = node;
    AstNode A_parent = result.parent;
    while (A_parent != null && !_canBeResolved(A_parent)) {
      result = A_parent;
      A_parent = result.parent;
    }
    if (A_parent == null) {
      throw new AnalysisException("Cannot resolve node: no resolvable node");
    }
    return result;
  }
  A_Element _getElement(AstNode node) {
    if (node is Declaration) {
      return node.element;
    } else if (node is CompilationUnit) {
      return node.element;
    }
    return null;
  }
  void _resolveReferences(AstNode node, Scope scope) {
    ResolverVisitor visitor = new ResolverVisitor.B_con3(_definingLibrary, E__source, B__typeProvider, scope, D__errorListener);
    node.accept(visitor);
  }
  void _resolveTypes(AstNode node, Scope scope) {
    TypeResolverVisitor visitor = new TypeResolverVisitor.B_con3(_definingLibrary, E__source, B__typeProvider, scope, D__errorListener);
    node.accept(visitor);
  }
  void _resolveVariables(AstNode node, Scope scope) {
    VariableResolverVisitor visitor = new VariableResolverVisitor.G_con2(_definingLibrary, E__source, B__typeProvider, scope, D__errorListener);
    node.accept(visitor);
  }
}
class InheritanceManager {
  static ExecutableElement _computeMergedExecutableElement(List<ExecutableElement> elementArrayToMerge) {
    int h = _getNumOfPositionalParameters(elementArrayToMerge[0]);
    int r = _getNumOfRequiredParameters(elementArrayToMerge[0]);
    Set<String> namedParametersList = new A_p.HashSet<String>();
    for (int i = 1; i < elementArrayToMerge.length; i++) {
      ExecutableElement A_element = elementArrayToMerge[i];
      int numOfPositionalParams = _getNumOfPositionalParameters(A_element);
      if (h < numOfPositionalParams) {
        h = numOfPositionalParams;
      }
      int numOfRequiredParams = _getNumOfRequiredParameters(A_element);
      if (r > numOfRequiredParams) {
        r = numOfRequiredParams;
      }
      namedParametersList.addAll(_getNamedParameterNames(A_element));
    }
    return _createSyntheticExecutableElement(elementArrayToMerge, elementArrayToMerge[0].displayName, r, h - r, new List.from(namedParametersList));
  }
  static ExecutableElement _createSyntheticExecutableElement(List<ExecutableElement> elementArrayToMerge, String A_name, int numOfRequiredParameters, int numOfPositionalParameters, List<String> A_namedParameters) {
    DynamicTypeImpl dynamicType = DynamicTypeImpl.instance;
    SimpleIdentifier nameIdentifier = new SimpleIdentifier(new StringToken(A_TokenType.IDENTIFIER, A_name, 0));
    ExecutableElementImpl A_executable;
    if (elementArrayToMerge[0] is MethodElement) {
      MultiplyInheritedMethodElementImpl unionedMethod = new MultiplyInheritedMethodElementImpl(nameIdentifier);
      unionedMethod.inheritedElements = elementArrayToMerge;
      A_executable = unionedMethod;
    } else {
      MultiplyInheritedPropertyAccessorElementImpl unionedPropertyAccessor = new MultiplyInheritedPropertyAccessorElementImpl(nameIdentifier);
      unionedPropertyAccessor.getter = (elementArrayToMerge[0] as PropertyAccessorElement).isGetter;
      unionedPropertyAccessor.setter = (elementArrayToMerge[0] as PropertyAccessorElement).isSetter;
      unionedPropertyAccessor.inheritedElements = elementArrayToMerge;
      A_executable = unionedPropertyAccessor;
    }
    int numOfParameters = numOfRequiredParameters + numOfPositionalParameters + A_namedParameters.length;
    List<ParameterElement> A_parameters = new List<ParameterElement>(numOfParameters);
    int i = 0;
    for (int j = 0; j < numOfRequiredParameters; j++, i++) {
      ParameterElementImpl parameter = new ParameterElementImpl("", 0);
      parameter.type = dynamicType;
      parameter.parameterKind = ParameterKind.REQUIRED;
      A_parameters[i] = parameter;
    }
    for (int k = 0; k < numOfPositionalParameters; k++, i++) {
      ParameterElementImpl parameter = new ParameterElementImpl("", 0);
      parameter.type = dynamicType;
      parameter.parameterKind = ParameterKind.POSITIONAL;
      A_parameters[i] = parameter;
    }
    for (int m = 0; m < A_namedParameters.length; m++, i++) {
      ParameterElementImpl parameter = new ParameterElementImpl(A_namedParameters[m], 0);
      parameter.type = dynamicType;
      parameter.parameterKind = ParameterKind.NAMED;
      A_parameters[i] = parameter;
    }
    A_executable.returnType = dynamicType;
    A_executable.parameters = A_parameters;
    FunctionTypeImpl methodType = new FunctionTypeImpl.B_con1(A_executable);
    A_executable.type = methodType;
    return A_executable;
  }
  static List<String> _getNamedParameterNames(ExecutableElement executableElement) {
    List<String> namedParameterNames = new List<String>();
    List<ParameterElement> A_parameters = executableElement.parameters;
    for (int i = 0; i < A_parameters.length; i++) {
      ParameterElement parameterElement = A_parameters[i];
      if (parameterElement.parameterKind == ParameterKind.NAMED) {
        namedParameterNames.add(parameterElement.name);
      }
    }
    return namedParameterNames;
  }
  static int _getNumOfParameters(ExecutableElement executableElement, ParameterKind parameterKind) {
    int parameterCount = 0;
    List<ParameterElement> A_parameters = executableElement.parameters;
    for (int i = 0; i < A_parameters.length; i++) {
      ParameterElement parameterElement = A_parameters[i];
      if (parameterElement.parameterKind == parameterKind) {
        parameterCount++;
      }
    }
    return parameterCount;
  }
  static int _getNumOfPositionalParameters(ExecutableElement executableElement) => _getNumOfParameters(executableElement, ParameterKind.REQUIRED) + _getNumOfParameters(executableElement, ParameterKind.POSITIONAL);
  static int _getNumOfRequiredParameters(ExecutableElement executableElement) => _getNumOfParameters(executableElement, ParameterKind.REQUIRED);
  static bool A__isAbstract(ExecutableElement executableElement) {
    if (executableElement is MethodElement) {
      return executableElement.isAbstract;
    } else if (executableElement is PropertyAccessorElement) {
      return executableElement.isAbstract;
    }
    return false;
  }
  LibraryElement A__library;
  A_p.HashMap<ClassElement, MemberMap> _classLookup;
  A_p.HashMap<ClassElement, MemberMap> _interfaceLookup;
  A_p.HashMap<ClassElement, A_p.HashSet<A_AnalysisError>> _errorsInClassElement = new A_p.HashMap<ClassElement,A_p.HashSet<A_AnalysisError>>();
  InheritanceManager(LibraryElement library) {
    this.A__library = library;
    _classLookup = new A_p.HashMap<ClassElement,MemberMap>();
    _interfaceLookup = new A_p.HashMap<ClassElement,MemberMap>();
  }
  A_p.HashSet<A_AnalysisError> getErrors(ClassElement classElt) => _errorsInClassElement[classElt];
  MemberMap getMapOfMembersInheritedFromClasses(ClassElement classElt) => _computeClassChainLookupMap(classElt, new A_p.HashSet<ClassElement>());
  MemberMap getMapOfMembersInheritedFromInterfaces(ClassElement classElt) => _computeInterfaceLookupMap(classElt, new A_p.HashSet<ClassElement>());
  ExecutableElement lookupInheritance(ClassElement classElt, String A_memberName) {
    if (A_memberName == null || A_memberName.isEmpty) {
      return null;
    }
    ExecutableElement A_executable = _computeClassChainLookupMap(classElt, new A_p.HashSet<ClassElement>()).get(A_memberName);
    if (A_executable == null) {
      return _computeInterfaceLookupMap(classElt, new A_p.HashSet<ClassElement>()).get(A_memberName);
    }
    return A_executable;
  }
  ExecutableElement lookupMember(ClassElement classElt, String A_memberName) {
    ExecutableElement A_element = _lookupMemberInClass(classElt, A_memberName);
    if (A_element != null) {
      return A_element;
    }
    return lookupInheritance(classElt, A_memberName);
  }
  FunctionType lookupMemberType(InterfaceType interfaceType, String A_memberName) {
    ExecutableElement iteratorMember = lookupMember(interfaceType.element, A_memberName);
    if (iteratorMember == null) {
      return null;
    }
    return substituteTypeArgumentsInMemberFromInheritance(iteratorMember.type, A_memberName, interfaceType);
  }
  List<ExecutableElement> lookupOverrides(ClassElement classElt, String A_memberName) {
    List<ExecutableElement> result = new List<ExecutableElement>();
    if (A_memberName == null || A_memberName.isEmpty) {
      return result;
    }
    List<MemberMap> interfaceMaps = _gatherInterfaceLookupMaps(classElt, new A_p.HashSet<ClassElement>());
    if (interfaceMaps != null) {
      for (MemberMap interfaceMap in interfaceMaps) {
        ExecutableElement overriddenElement = interfaceMap.get(A_memberName);
        if (overriddenElement != null) {
          if (overriddenElement is MultiplyInheritedExecutableElement) {
            MultiplyInheritedExecutableElement multiplyInheritedElement = overriddenElement;
            for (ExecutableElement A_element in multiplyInheritedElement.inheritedElements) {
              result.add(A_element);
            }
          } else {
            result.add(overriddenElement);
          }
        }
      }
    }
    return result;
  }
  void set libraryElement(LibraryElement library) {
    this.A__library = library;
  }
  FunctionType substituteTypeArgumentsInMemberFromInheritance(FunctionType baseFunctionType, String A_memberName, InterfaceType definingType) {
    if (baseFunctionType == null || baseFunctionType.typeArguments.length == 0) {
      return baseFunctionType;
    }
    A_p.Queue<InterfaceType> inheritancePath = new A_p.Queue<InterfaceType>();
    _computeInheritancePath(inheritancePath, definingType, A_memberName);
    if (inheritancePath == null || inheritancePath.isEmpty) {
      return baseFunctionType;
    }
    FunctionType functionTypeToReturn = baseFunctionType;
    while (!inheritancePath.isEmpty) {
      InterfaceType lastType = inheritancePath.removeLast();
      List<DartType> A_parameterTypes = lastType.element.type.typeArguments;
      List<DartType> argumentTypes = lastType.typeArguments;
      functionTypeToReturn = functionTypeToReturn.substitute2(argumentTypes, A_parameterTypes);
    }
    return functionTypeToReturn;
  }
  MemberMap _computeClassChainLookupMap(ClassElement classElt, A_p.HashSet<ClassElement> visitedClasses) {
    MemberMap resultMap = _classLookup[classElt];
    if (resultMap != null) {
      return resultMap;
    } else {
      resultMap = new MemberMap();
    }
    ClassElement superclassElt = null;
    InterfaceType supertype = classElt.supertype;
    if (supertype != null) {
      superclassElt = supertype.element;
    } else {
      _classLookup[classElt] = resultMap;
      return resultMap;
    }
    if (superclassElt != null) {
      if (!visitedClasses.contains(superclassElt)) {
        visitedClasses.add(superclassElt);
        try {
          resultMap = new MemberMap.G_con2(_computeClassChainLookupMap(superclassElt, visitedClasses));
          _substituteTypeParametersDownHierarchy(supertype, resultMap);
          _recordMapWithClassMembers(resultMap, supertype, false);
        } finally {
          visitedClasses.remove(superclassElt);
        }
      } else {
        _classLookup[superclassElt] = resultMap;
        return resultMap;
      }
    }
    List<InterfaceType> mixins = classElt.mixins;
    for (int i = mixins.length - 1; i >= 0; i--) {
      ClassElement mixinElement = mixins[i].element;
      if (mixinElement != null) {
        if (!visitedClasses.contains(mixinElement)) {
          visitedClasses.add(mixinElement);
          try {
            MemberMap A_map = new MemberMap.G_con2(_computeClassChainLookupMap(mixinElement, visitedClasses));
            _substituteTypeParametersDownHierarchy(mixins[i], A_map);
            _recordMapWithClassMembers(A_map, mixins[i], false);
            for (int j = 0; j < A_map.size; j++) {
              String A_key = A_map.getKey(j);
              ExecutableElement A_value = A_map.getValue(j);
              if (A_key != null) {
                if (resultMap.get(A_key) == null || (resultMap.get(A_key) != null && !A__isAbstract(A_value))) {
                  resultMap.put(A_key, A_value);
                }
              }
            }
          } finally {
            visitedClasses.remove(mixinElement);
          }
        } else {
          _classLookup[mixinElement] = resultMap;
          return resultMap;
        }
      }
    }
    _classLookup[classElt] = resultMap;
    return resultMap;
  }
  void _computeInheritancePath(A_p.Queue<InterfaceType> chain, InterfaceType currentType, String A_memberName) {
    chain.add(currentType);
    ClassElement classElt = currentType.element;
    InterfaceType supertype = classElt.supertype;
    if (supertype == null) {
      return;
    }
    if (chain.length != 1) {
      if (_lookupMemberInClass(classElt, A_memberName) != null) {
        return;
      }
    }
    List<InterfaceType> mixins = classElt.mixins;
    for (int i = mixins.length - 1; i >= 0; i--) {
      ClassElement mixinElement = mixins[i].element;
      if (mixinElement != null) {
        ExecutableElement elt = _lookupMemberInClass(mixinElement, A_memberName);
        if (elt != null) {
          chain.add(mixins[i]);
          return;
        }
      }
    }
    ClassElement superclassElt = supertype.element;
    if (lookupMember(superclassElt, A_memberName) != null) {
      _computeInheritancePath(chain, supertype, A_memberName);
      return;
    }
    List<InterfaceType> interfaces = classElt.interfaces;
    for (InterfaceType interfaceType in interfaces) {
      ClassElement interfaceElement = interfaceType.element;
      if (interfaceElement != null && lookupMember(interfaceElement, A_memberName) != null) {
        _computeInheritancePath(chain, interfaceType, A_memberName);
        return;
      }
    }
  }
  MemberMap _computeInterfaceLookupMap(ClassElement classElt, A_p.HashSet<ClassElement> visitedInterfaces) {
    MemberMap resultMap = _interfaceLookup[classElt];
    if (resultMap != null) {
      return resultMap;
    }
    List<MemberMap> lookupMaps = _gatherInterfaceLookupMaps(classElt, visitedInterfaces);
    if (lookupMaps == null) {
      resultMap = new MemberMap();
    } else {
      A_p.HashMap<String, List<ExecutableElement>> unionMap = _unionInterfaceLookupMaps(lookupMaps);
      resultMap = _resolveInheritanceLookup(classElt, unionMap);
    }
    _interfaceLookup[classElt] = resultMap;
    return resultMap;
  }
  List<MemberMap> _gatherInterfaceLookupMaps(ClassElement classElt, A_p.HashSet<ClassElement> visitedInterfaces) {
    InterfaceType supertype = classElt.supertype;
    ClassElement superclassElement = supertype != null ? supertype.element : null;
    List<InterfaceType> mixins = classElt.mixins;
    List<InterfaceType> interfaces = classElt.interfaces;
    List<MemberMap> lookupMaps = new List<MemberMap>();
    if (superclassElement != null) {
      if (!visitedInterfaces.contains(superclassElement)) {
        try {
          visitedInterfaces.add(superclassElement);
          MemberMap A_map = _computeInterfaceLookupMap(superclassElement, visitedInterfaces);
          A_map = new MemberMap.G_con2(A_map);
          _substituteTypeParametersDownHierarchy(supertype, A_map);
          _recordMapWithClassMembers(A_map, supertype, true);
          lookupMaps.add(A_map);
        } finally {
          visitedInterfaces.remove(superclassElement);
        }
      } else {
        return null;
      }
    }
    for (int i = mixins.length - 1; i >= 0; i--) {
      InterfaceType mixinType = mixins[i];
      ClassElement mixinElement = mixinType.element;
      if (mixinElement != null) {
        if (!visitedInterfaces.contains(mixinElement)) {
          try {
            visitedInterfaces.add(mixinElement);
            MemberMap A_map = _computeInterfaceLookupMap(mixinElement, visitedInterfaces);
            A_map = new MemberMap.G_con2(A_map);
            _substituteTypeParametersDownHierarchy(mixinType, A_map);
            _recordMapWithClassMembers(A_map, mixinType, true);
            lookupMaps.add(A_map);
          } finally {
            visitedInterfaces.remove(mixinElement);
          }
        } else {
          return null;
        }
      }
    }
    for (InterfaceType interfaceType in interfaces) {
      ClassElement interfaceElement = interfaceType.element;
      if (interfaceElement != null) {
        if (!visitedInterfaces.contains(interfaceElement)) {
          try {
            visitedInterfaces.add(interfaceElement);
            MemberMap A_map = _computeInterfaceLookupMap(interfaceElement, visitedInterfaces);
            A_map = new MemberMap.G_con2(A_map);
            _substituteTypeParametersDownHierarchy(interfaceType, A_map);
            _recordMapWithClassMembers(A_map, interfaceType, true);
            lookupMaps.add(A_map);
          } finally {
            visitedInterfaces.remove(interfaceElement);
          }
        } else {
          return null;
        }
      }
    }
    if (lookupMaps.length == 0) {
      return null;
    }
    return lookupMaps;
  }
  ExecutableElement _lookupMemberInClass(ClassElement classElt, String A_memberName) {
    List<MethodElement> methods = classElt.methods;
    for (MethodElement A_method in methods) {
      if (A_memberName == A_method.name && A_method.isAccessibleIn(A__library) && !A_method.isStatic) {
        return A_method;
      }
    }
    List<PropertyAccessorElement> accessors = classElt.accessors;
    for (PropertyAccessorElement accessor in accessors) {
      if (A_memberName == accessor.name && accessor.isAccessibleIn(A__library) && !accessor.isStatic) {
        return accessor;
      }
    }
    return null;
  }
  void _recordMapWithClassMembers(MemberMap A_map, InterfaceType A_type, bool doIncludeAbstract) {
    List<MethodElement> methods = A_type.methods;
    for (MethodElement A_method in methods) {
      if (A_method.isAccessibleIn(A__library) && !A_method.isStatic && (doIncludeAbstract || !A_method.isAbstract)) {
        A_map.put(A_method.name, A_method);
      }
    }
    List<PropertyAccessorElement> accessors = A_type.accessors;
    for (PropertyAccessorElement accessor in accessors) {
      if (accessor.isAccessibleIn(A__library) && !accessor.isStatic && (doIncludeAbstract || !accessor.isAbstract)) {
        A_map.put(accessor.name, accessor);
      }
    }
  }
  void B__reportError(ClassElement classElt, int A_offset, int A_length, ErrorCode A_errorCode, List<Object> A_arguments) {
    A_p.HashSet<A_AnalysisError> errorSet = _errorsInClassElement[classElt];
    if (errorSet == null) {
      errorSet = new A_p.HashSet<A_AnalysisError>();
      _errorsInClassElement[classElt] = errorSet;
    }
    errorSet.add(new A_AnalysisError.D_con2(classElt.source, A_offset, A_length, A_errorCode, A_arguments));
  }
  MemberMap _resolveInheritanceLookup(ClassElement classElt, A_p.HashMap<String, List<ExecutableElement>> unionMap) {
    MemberMap resultMap = new MemberMap();
    for (MapEntry<String, List<ExecutableElement>> A_entry in getMapEntrySet(unionMap)) {
      String A_key = A_entry.getKey();
      List<ExecutableElement> A_list = A_entry.getValue();
      int numOfEltsWithMatchingNames = A_list.length;
      if (numOfEltsWithMatchingNames == 1) {
        resultMap.put(A_key, A_list[0]);
      } else {
        bool allMethods = true;
        bool allSetters = true;
        bool allGetters = true;
        for (ExecutableElement executableElement in A_list) {
          if (executableElement is PropertyAccessorElement) {
            allMethods = false;
            if (executableElement.isSetter) {
              allGetters = false;
            } else {
              allSetters = false;
            }
          } else {
            allGetters = false;
            allSetters = false;
          }
        }
        if (allMethods || allGetters || allSetters) {
          List<ExecutableElement> elements = new List.from(A_list);
          List<FunctionType> executableElementTypes = new List<FunctionType>(numOfEltsWithMatchingNames);
          for (int i = 0; i < numOfEltsWithMatchingNames; i++) {
            executableElementTypes[i] = elements[i].type;
          }
          List<int> subtypesOfAllOtherTypesIndexes = new List<int>();
          for (int i = 0; i < numOfEltsWithMatchingNames; i++) {
            FunctionType subtype = executableElementTypes[i];
            if (subtype == null) {
              continue;
            }
            bool subtypeOfAllTypes = true;
            for (int j = 0; j < numOfEltsWithMatchingNames && subtypeOfAllTypes; j++) {
              if (i != j) {
                if (!subtype.isSubtypeOf(executableElementTypes[j])) {
                  subtypeOfAllTypes = false;
                  break;
                }
              }
            }
            if (subtypeOfAllTypes) {
              subtypesOfAllOtherTypesIndexes.add(i);
            }
          }
          if (subtypesOfAllOtherTypesIndexes.length == 1) {
            resultMap.put(A_key, elements[subtypesOfAllOtherTypesIndexes[0]]);
          } else {
            if (subtypesOfAllOtherTypesIndexes.isEmpty) {
              bool classHasMember = false;
              if (allMethods) {
                classHasMember = classElt.getMethod(A_key) != null;
              } else {
                List<PropertyAccessorElement> accessors = classElt.accessors;
                for (int i = 0; i < accessors.length; i++) {
                  if (accessors[i].name == A_key) {
                    classHasMember = true;
                  }
                }
              }
              if (!classHasMember) {
                String firstTwoFuntionTypesStr = "${executableElementTypes[0].toString()}, ${executableElementTypes[1].toString()}";
                B__reportError(classElt, classElt.nameOffset, classElt.displayName.length, StaticTypeWarningCode.INCONSISTENT_METHOD_INHERITANCE, [A_key, firstTwoFuntionTypesStr]);
              }
            } else {
              List<ExecutableElement> elementArrayToMerge = new List<ExecutableElement>(subtypesOfAllOtherTypesIndexes.length);
              for (int i = 0; i < elementArrayToMerge.length; i++) {
                elementArrayToMerge[i] = elements[subtypesOfAllOtherTypesIndexes[i]];
              }
              ExecutableElement mergedExecutableElement = _computeMergedExecutableElement(elementArrayToMerge);
              resultMap.put(A_key, mergedExecutableElement);
            }
          }
        } else {
          B__reportError(classElt, classElt.nameOffset, classElt.displayName.length, StaticWarningCode.INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD, [A_key]);
        }
      }
    }
    return resultMap;
  }
  void _substituteTypeParametersDownHierarchy(InterfaceType superType, MemberMap A_map) {
    for (int i = 0; i < A_map.size; i++) {
      ExecutableElement executableElement = A_map.getValue(i);
      if (executableElement is MethodMember) {
        executableElement = MethodMember.B_from(executableElement as MethodMember, superType);
        A_map.setValue(i, executableElement);
      } else if (executableElement is PropertyAccessorMember) {
        executableElement = PropertyAccessorMember.B_from(executableElement as PropertyAccessorMember, superType);
        A_map.setValue(i, executableElement);
      }
    }
  }
  A_p.HashMap<String, List<ExecutableElement>> _unionInterfaceLookupMaps(List<MemberMap> lookupMaps) {
    A_p.HashMap<String, List<ExecutableElement>> unionMap = new A_p.HashMap<String,List<ExecutableElement>>();
    for (MemberMap lookupMap in lookupMaps) {
      int lookupMapSize = lookupMap.size;
      for (int i = 0; i < lookupMapSize; i++) {
        String A_key = lookupMap.getKey(i);
        if (A_key == null) {
          break;
        }
        List<ExecutableElement> A_list = unionMap[A_key];
        if (A_list == null) {
          A_list = new List<ExecutableElement>();
          unionMap[A_key] = A_list;
        }
        ExecutableElement newExecutableElementEntry = lookupMap.getValue(i);
        if (A_list.isEmpty) {
          A_list.add(newExecutableElementEntry);
        } else {
          bool alreadyInList = false;
          bool isMethod1 = newExecutableElementEntry is MethodElement;
          for (ExecutableElement executableElementInList in A_list) {
            bool isMethod2 = executableElementInList is MethodElement;
            if (isMethod1 == isMethod2 && executableElementInList.type == newExecutableElementEntry.type) {
              alreadyInList = true;
              break;
            }
          }
          if (!alreadyInList) {
            A_list.add(newExecutableElementEntry);
          }
        }
      }
    }
    return unionMap;
  }
}
class LabelScope {
  final LabelScope _outerScope;
  final String A__label;
  final LabelElement H__element;
  static String EMPTY_LABEL = "";
  static SimpleIdentifier _EMPTY_LABEL_IDENTIFIER = new SimpleIdentifier(new StringToken(A_TokenType.IDENTIFIER, "", 0));
  LabelScope.G_con1(LabelScope outerScope, bool onSwitchStatement, bool onSwitchMember) : this.G_con2(outerScope, EMPTY_LABEL, new LabelElementImpl(_EMPTY_LABEL_IDENTIFIER, onSwitchStatement, onSwitchMember));
  LabelScope.G_con2(this._outerScope, this.A__label, this.H__element);
  LabelElement lookup(String targetLabel) {
    if (A__label == targetLabel) {
      return H__element;
    } else if (_outerScope != null) {
      return _outerScope.lookup(targetLabel);
    } else {
      return null;
    }
  }
}
class Library {
  final InternalAnalysisContext _analysisContext;
  InheritanceManager _inheritanceManager;
  final AnalysisErrorListener D__errorListener;
  final Source librarySource;
  LibraryElementImpl B__libraryElement;
  List<Library> B__importedLibraries = _EMPTY_ARRAY;
  A_p.HashMap<UriBasedDirective, String> _directiveUris = new A_p.HashMap<UriBasedDirective,String>();
  bool explicitlyImportsCore = false;
  List<Library> A__exportedLibraries = _EMPTY_ARRAY;
  A_p.HashMap<Source, ResolvableCompilationUnit> _astMap = new A_p.HashMap<Source,ResolvableCompilationUnit>();
  LibraryScope _libraryScope;
  static List<Library> _EMPTY_ARRAY = new List<Library>(0);
  static String A__DART_EXT_SCHEME = "dart-ext:";
  Library(this._analysisContext, this.D__errorListener, this.librarySource) {
    this.B__libraryElement = _analysisContext.getLibraryElement(librarySource) as LibraryElementImpl;
  }
  CompilationUnit getAST(Source A_source) {
    ResolvableCompilationUnit holder = _astMap[A_source];
    if (holder == null) {
      holder = _analysisContext.computeResolvableCompilationUnit(A_source);
      _astMap[A_source] = holder;
    }
    return holder.compilationUnit;
  }
  Set<Source> get compilationUnitSources => _astMap.keys.toSet();
  CompilationUnit get definingCompilationUnit => getAST(librarySource);
  List<Library> get exports => A__exportedLibraries;
  List<Library> get imports => B__importedLibraries;
  List<Library> get importsAndExports {
    A_p.HashSet<Library> libraries = new A_p.HashSet<Library>();
    for (Library library in B__importedLibraries) {
      libraries.add(library);
    }
    for (Library library in A__exportedLibraries) {
      libraries.add(library);
    }
    return new List.from(libraries);
  }
  InheritanceManager get inheritanceManager {
    if (_inheritanceManager == null) {
      return _inheritanceManager = new InheritanceManager(B__libraryElement);
    }
    return _inheritanceManager;
  }
  LibraryElementImpl get libraryElement {
    if (B__libraryElement == null) {
      try {
        B__libraryElement = _analysisContext.computeLibraryElement(librarySource) as LibraryElementImpl;
      }on AnalysisException  catch (exception, A_stackTrace) {
        AnalysisEngine.A_instance.logger.logError2("Could not compute library element for ${librarySource.fullName}", new CaughtException(exception, A_stackTrace));
      }
    }
    return B__libraryElement;
  }
  LibraryScope get libraryScope {
    if (_libraryScope == null) {
      _libraryScope = new LibraryScope(B__libraryElement, D__errorListener);
    }
    return _libraryScope;
  }
  int A_getModificationTime(Source A_source) {
    ResolvableCompilationUnit holder = _astMap[A_source];
    if (holder == null) {
      holder = _analysisContext.computeResolvableCompilationUnit(A_source);
      _astMap[A_source] = holder;
    }
    return holder.modificationTime;
  }
  Source getSource(UriBasedDirective directive) {
    StringLiteral uriLiteral = directive.uri;
    if (uriLiteral is StringInterpolation) {
      D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.A_URI_WITH_INTERPOLATION, []));
      return null;
    }
    String uriContent = uriLiteral.stringValue.trim();
    _directiveUris[directive] = uriContent;
    uriContent = Uri.encodeFull(uriContent);
    if (directive is ImportDirective && uriContent.startsWith(A__DART_EXT_SCHEME)) {
      B__libraryElement.hasExtUri = true;
      return null;
    }
    try {
      parseUriWithException(uriContent);
      Source A_source = _analysisContext.sourceFactory.resolveUri(librarySource, uriContent);
      if (!_analysisContext.exists(A_source)) {
        D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.URI_DOES_NOT_EXIST, [uriContent]));
      }
      return A_source;
    }on URISyntaxException  catch (exception) {
      D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.A_INVALID_URI, [uriContent]));
    }
    return null;
  }
  void setDefiningCompilationUnit(int modificationStamp, CompilationUnit unit) {
    _astMap[librarySource] = new ResolvableCompilationUnit.C_con1(modificationStamp, unit);
  }
  void set exportedLibraries(List<Library> A_exportedLibraries) {
    this.A__exportedLibraries = A_exportedLibraries;
  }
  void set importedLibraries(List<Library> A_importedLibraries) {
    this.B__importedLibraries = A_importedLibraries;
  }
  void set libraryElement(LibraryElementImpl A_libraryElement) {
    this.B__libraryElement = A_libraryElement;
    if (_inheritanceManager != null) {
      _inheritanceManager.libraryElement = A_libraryElement;
    }
  }
  String toString() => librarySource.shortName;
}
class LibraryElementBuilder {
  final InternalAnalysisContext _analysisContext;
  final AnalysisErrorListener D__errorListener;
  static String ENTRY_POINT_NAME = "main";
  LibraryElementBuilder(this._analysisContext, this.D__errorListener);
  LibraryElementImpl buildLibrary(Library library) {
    CompilationUnitBuilder A_builder = new CompilationUnitBuilder();
    Source librarySource = library.librarySource;
    CompilationUnit definingCompilationUnit = library.definingCompilationUnit;
    CompilationUnitElementImpl definingCompilationUnitElement = A_builder.buildCompilationUnit(librarySource, definingCompilationUnit);
    NodeList<Directive> directives = definingCompilationUnit.directives;
    LibraryIdentifier libraryNameNode = null;
    bool hasPartDirective = false;
    FunctionElement entryPoint = _findEntryPoint(definingCompilationUnitElement);
    List<Directive> directivesToResolve = new List<Directive>();
    List<CompilationUnitElementImpl> sourcedCompilationUnits = new List<CompilationUnitElementImpl>();
    for (Directive directive in directives) {
      if (directive is LibraryDirective) {
        if (libraryNameNode == null) {
          libraryNameNode = directive.name;
          directivesToResolve.add(directive);
        }
      } else if (directive is PartDirective) {
        PartDirective partDirective = directive;
        StringLiteral partUri = partDirective.uri;
        Source partSource = partDirective.source;
        if (_analysisContext.exists(partSource)) {
          hasPartDirective = true;
          CompilationUnit partUnit = library.getAST(partSource);
          CompilationUnitElementImpl part = A_builder.buildCompilationUnit(partSource, partUnit);
          part.uriOffset = partUri.offset;
          part.uriEnd = partUri.end;
          part.uri = partDirective.uriContent;
          String partLibraryName = _getPartLibraryName(partSource, partUnit, directivesToResolve);
          if (partLibraryName == null) {
            D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, partUri.offset, partUri.length, CompileTimeErrorCode.PART_OF_NON_PART, [partUri.toSource()]));
          } else if (libraryNameNode == null) {} else if (libraryNameNode.name != partLibraryName) {
            D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, partUri.offset, partUri.length, StaticWarningCode.PART_OF_DIFFERENT_LIBRARY, [libraryNameNode.name, partLibraryName]));
          }
          if (entryPoint == null) {
            entryPoint = _findEntryPoint(part);
          }
          directive.element = part;
          sourcedCompilationUnits.add(part);
        }
      }
    }
    if (hasPartDirective && libraryNameNode == null) {
      D__errorListener.onError(new A_AnalysisError.D_con1(librarySource, ResolverErrorCode.MISSING_LIBRARY_DIRECTIVE_WITH_PART, []));
    }
    LibraryElementImpl libraryElement = new LibraryElementImpl.forNode(_analysisContext, libraryNameNode);
    libraryElement.definingCompilationUnit = definingCompilationUnitElement;
    if (entryPoint != null) {
      libraryElement.entryPoint = entryPoint;
    }
    int sourcedUnitCount = sourcedCompilationUnits.length;
    libraryElement.parts = new List.from(sourcedCompilationUnits);
    for (Directive directive in directivesToResolve) {
      directive.element = libraryElement;
    }
    library.libraryElement = libraryElement;
    if (sourcedUnitCount > 0) {
      _patchTopLevelAccessors(libraryElement);
    }
    return libraryElement;
  }
  LibraryElementImpl buildLibrary2(ResolvableLibrary library) {
    CompilationUnitBuilder A_builder = new CompilationUnitBuilder();
    Source librarySource = library.librarySource;
    CompilationUnit definingCompilationUnit = library.definingCompilationUnit;
    CompilationUnitElementImpl definingCompilationUnitElement = A_builder.buildCompilationUnit(librarySource, definingCompilationUnit);
    NodeList<Directive> directives = definingCompilationUnit.directives;
    LibraryIdentifier libraryNameNode = null;
    bool hasPartDirective = false;
    FunctionElement entryPoint = _findEntryPoint(definingCompilationUnitElement);
    List<Directive> directivesToResolve = new List<Directive>();
    List<CompilationUnitElementImpl> sourcedCompilationUnits = new List<CompilationUnitElementImpl>();
    for (Directive directive in directives) {
      if (directive is LibraryDirective) {
        if (libraryNameNode == null) {
          libraryNameNode = directive.name;
          directivesToResolve.add(directive);
        }
      } else if (directive is PartDirective) {
        PartDirective partDirective = directive;
        StringLiteral partUri = partDirective.uri;
        Source partSource = partDirective.source;
        if (_analysisContext.exists(partSource)) {
          hasPartDirective = true;
          CompilationUnit partUnit = library.getAST(partSource);
          if (partUnit != null) {
            CompilationUnitElementImpl part = A_builder.buildCompilationUnit(partSource, partUnit);
            part.uriOffset = partUri.offset;
            part.uriEnd = partUri.end;
            part.uri = partDirective.uriContent;
            String partLibraryName = _getPartLibraryName(partSource, partUnit, directivesToResolve);
            if (partLibraryName == null) {
              D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, partUri.offset, partUri.length, CompileTimeErrorCode.PART_OF_NON_PART, [partUri.toSource()]));
            } else if (libraryNameNode == null) {} else if (libraryNameNode.name != partLibraryName) {
              D__errorListener.onError(new A_AnalysisError.D_con2(librarySource, partUri.offset, partUri.length, StaticWarningCode.PART_OF_DIFFERENT_LIBRARY, [libraryNameNode.name, partLibraryName]));
            }
            if (entryPoint == null) {
              entryPoint = _findEntryPoint(part);
            }
            directive.element = part;
            sourcedCompilationUnits.add(part);
          }
        }
      }
    }
    if (hasPartDirective && libraryNameNode == null) {
      D__errorListener.onError(new A_AnalysisError.D_con1(librarySource, ResolverErrorCode.MISSING_LIBRARY_DIRECTIVE_WITH_PART, []));
    }
    LibraryElementImpl libraryElement = new LibraryElementImpl.forNode(_analysisContext, libraryNameNode);
    libraryElement.definingCompilationUnit = definingCompilationUnitElement;
    if (entryPoint != null) {
      libraryElement.entryPoint = entryPoint;
    }
    int sourcedUnitCount = sourcedCompilationUnits.length;
    libraryElement.parts = new List.from(sourcedCompilationUnits);
    for (Directive directive in directivesToResolve) {
      directive.element = libraryElement;
    }
    library.libraryElement = libraryElement;
    if (sourcedUnitCount > 0) {
      _patchTopLevelAccessors(libraryElement);
    }
    return libraryElement;
  }
  void _collectAccessors(A_p.HashMap<String, PropertyAccessorElement> getters, List<PropertyAccessorElement> setters, CompilationUnitElement unit) {
    for (PropertyAccessorElement accessor in unit.accessors) {
      if (accessor.isGetter) {
        if (!accessor.isSynthetic && accessor.correspondingSetter == null) {
          getters[accessor.displayName] = accessor;
        }
      } else {
        if (!accessor.isSynthetic && accessor.correspondingGetter == null) {
          setters.add(accessor);
        }
      }
    }
  }
  FunctionElement _findEntryPoint(CompilationUnitElementImpl A_element) {
    for (FunctionElement A_function in A_element.functions) {
      if (A_function.name == ENTRY_POINT_NAME) {
        return A_function;
      }
    }
    return null;
  }
  String _getPartLibraryName(Source partSource, CompilationUnit partUnit, List<Directive> directivesToResolve) {
    for (Directive directive in partUnit.directives) {
      if (directive is PartOfDirective) {
        directivesToResolve.add(directive);
        LibraryIdentifier A_libraryName = directive.libraryName;
        if (A_libraryName != null) {
          return A_libraryName.name;
        }
      }
    }
    return null;
  }
  void _patchTopLevelAccessors(LibraryElementImpl libraryElement) {
    A_p.HashMap<String, PropertyAccessorElement> getters = new A_p.HashMap<String,PropertyAccessorElement>();
    List<PropertyAccessorElement> setters = new List<PropertyAccessorElement>();
    _collectAccessors(getters, setters, libraryElement.definingCompilationUnit);
    for (CompilationUnitElement unit in libraryElement.parts) {
      _collectAccessors(getters, setters, unit);
    }
    for (PropertyAccessorElement setter in setters) {
      PropertyAccessorElement getter = getters[setter.displayName];
      if (getter != null) {
        PropertyInducingElementImpl variable = getter.variable as PropertyInducingElementImpl;
        variable.setter = setter;
        (setter as PropertyAccessorElementImpl).variable = variable;
      }
    }
  }
}
class LibraryImportScope extends Scope {
  final LibraryElement _definingLibrary;
  final AnalysisErrorListener errorListener;
  List<Namespace> _importedNamespaces;
  LibraryImportScope(this._definingLibrary, this.errorListener) {
    _createImportedNamespaces();
  }
  void define(A_Element A_element) {
    if (!Scope.A_isPrivateName(A_element.displayName)) {
      super.define(A_element);
    }
  }
  A_Element internalLookup(Identifier identifier, String A_name, LibraryElement referencingLibrary) {
    A_Element foundElement = localLookup(A_name, referencingLibrary);
    if (foundElement != null) {
      return foundElement;
    }
    for (int i = 0; i < _importedNamespaces.length; i++) {
      Namespace nameSpace = _importedNamespaces[i];
      A_Element A_element = nameSpace.get(A_name);
      if (A_element != null) {
        if (foundElement == null) {
          foundElement = A_element;
        } else if (!identical(foundElement, A_element)) {
          foundElement = MultiplyDefinedElementImpl.fromElements(_definingLibrary.context, foundElement, A_element);
        }
      }
    }
    if (foundElement is MultiplyDefinedElementImpl) {
      foundElement = _removeSdkElements(identifier, A_name, foundElement as MultiplyDefinedElementImpl);
    }
    if (foundElement is MultiplyDefinedElementImpl) {
      String foundEltName = foundElement.displayName;
      List<A_Element> conflictingMembers = (foundElement as MultiplyDefinedElementImpl).conflictingElements;
      int count = conflictingMembers.length;
      List<String> libraryNames = new List<String>(count);
      for (int i = 0; i < count; i++) {
        libraryNames[i] = _getLibraryName(conflictingMembers[i]);
      }
      libraryNames.sort();
      errorListener.onError(new A_AnalysisError.D_con2(getSource(identifier), identifier.offset, identifier.length, StaticWarningCode.AMBIGUOUS_IMPORT, [foundEltName, StringUtilities.printListOfQuotedNames(libraryNames)]));
      return foundElement;
    }
    if (foundElement != null) {
      defineNameWithoutChecking(A_name, foundElement);
    }
    return foundElement;
  }
  void _createImportedNamespaces() {
    NamespaceBuilder A_builder = new NamespaceBuilder();
    List<ImportElement> imports = _definingLibrary.imports;
    int count = imports.length;
    _importedNamespaces = new List<Namespace>(count);
    for (int i = 0; i < count; i++) {
      _importedNamespaces[i] = A_builder.createImportNamespaceForDirective(imports[i]);
    }
  }
  String _getLibraryName(A_Element A_element) {
    if (A_element == null) {
      return StringUtilities.EMPTY;
    }
    LibraryElement library = A_element.library;
    if (library == null) {
      return StringUtilities.EMPTY;
    }
    List<ImportElement> imports = _definingLibrary.imports;
    int count = imports.length;
    for (int i = 0; i < count; i++) {
      if (identical(imports[i].importedLibrary, library)) {
        return library.definingCompilationUnit.displayName;
      }
    }
    List<String> indirectSources = new List<String>();
    for (int i = 0; i < count; i++) {
      LibraryElement importedLibrary = imports[i].importedLibrary;
      for (LibraryElement exportedLibrary in importedLibrary.exportedLibraries) {
        if (identical(exportedLibrary, library)) {
          indirectSources.add(importedLibrary.definingCompilationUnit.displayName);
        }
      }
    }
    int indirectCount = indirectSources.length;
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append(library.definingCompilationUnit.displayName);
    if (indirectCount > 0) {
      A_builder.append(" (via ");
      if (indirectCount > 1) {
        List<String> indirectNames = new List.from(indirectSources);
        indirectNames.sort();
        A_builder.append(StringUtilities.printListOfQuotedNames(indirectNames));
      } else {
        A_builder.append(indirectSources[0]);
      }
      A_builder.append(")");
    }
    return A_builder.toString();
  }
  A_Element _removeSdkElements(Identifier identifier, String A_name, MultiplyDefinedElementImpl foundElement) {
    List<A_Element> conflictingMembers = foundElement.conflictingElements;
    int A_length = conflictingMembers.length;
    int to = 0;
    A_Element sdkElement = null;
    for (A_Element member in conflictingMembers) {
      if (member.library.isInSdk) {
        sdkElement = member;
      } else {
        conflictingMembers[to++] = member;
      }
    }
    if (sdkElement != null && to > 0) {
      String sdkLibName = _getLibraryName(sdkElement);
      String otherLibName = _getLibraryName(conflictingMembers[0]);
      errorListener.onError(new A_AnalysisError.D_con2(getSource(identifier), identifier.offset, identifier.length, StaticWarningCode.CONFLICTING_DART_IMPORT, [A_name, sdkLibName, otherLibName]));
    }
    if (to == A_length) {
      return foundElement;
    } else if (to == 1) {
      return conflictingMembers[0];
    } else if (to == 0) {
      AnalysisEngine.A_instance.logger.logInformation("Multiply defined SDK element: ${foundElement}");
      return foundElement;
    }
    List<A_Element> remaining = new List<A_Element>(to);
    JavaSystem.arraycopy(conflictingMembers, 0, remaining, 0, to);
    return new MultiplyDefinedElementImpl(_definingLibrary.context, remaining);
  }
}
class LibraryResolver {
  final InternalAnalysisContext analysisContext;
  RecordingErrorListener D__errorListener;
  Source A__coreLibrarySource;
  Library _coreLibrary;
  TypeProvider B__typeProvider;
  A_p.HashMap<Source, Library> A__libraryMap = new A_p.HashMap<Source,Library>();
  Set<Library> _librariesInCycles;
  LibraryResolver(this.analysisContext) {
    this.D__errorListener = new RecordingErrorListener();
    A__coreLibrarySource = analysisContext.sourceFactory.forUri(DartSdk.DART_CORE);
  }
  RecordingErrorListener get errorListener => D__errorListener;
  Set<Library> get resolvedLibraries => _librariesInCycles;
  LibraryElement resolveEmbeddedLibrary(Source librarySource, int modificationStamp, CompilationUnit unit, bool fullAnalysis) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.LibraryResolver.resolveEmbeddedLibrary");
    try {
      instrumentation.metric("fullAnalysis", fullAnalysis);
      instrumentation.data3("fullName", librarySource.fullName);
      Library targetLibrary = _createLibraryWithUnit(librarySource, modificationStamp, unit);
      _coreLibrary = A__libraryMap[A__coreLibrarySource];
      if (_coreLibrary == null) {
        _coreLibrary = createLibrary(A__coreLibrarySource);
        if (_coreLibrary == null) {
          LibraryResolver2.missingCoreLibrary(analysisContext, A__coreLibrarySource);
        }
      }
      instrumentation.metric3("createLibrary", "complete");
      _computeEmbeddedLibraryDependencies(targetLibrary, unit);
      _librariesInCycles = _computeLibrariesInCycles(targetLibrary);
      _buildElementModels();
      instrumentation.metric3("buildElementModels", "complete");
      LibraryElement coreElement = _coreLibrary.libraryElement;
      if (coreElement == null) {
        throw new AnalysisException("Could not resolve dart:core");
      }
      _buildDirectiveModels();
      instrumentation.metric3("buildDirectiveModels", "complete");
      B__typeProvider = new TypeProviderImpl(coreElement);
      _buildTypeHierarchies();
      instrumentation.metric3("buildTypeHierarchies", "complete");
      _resolveReferencesAndTypes();
      instrumentation.metric3("resolveReferencesAndTypes", "complete");
      _performConstantEvaluation();
      instrumentation.metric3("performConstantEvaluation", "complete");
      return targetLibrary.libraryElement;
    } finally {
      instrumentation.log();
    }
  }
  LibraryElement resolveLibrary(Source librarySource, bool fullAnalysis) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.LibraryResolver.resolveLibrary");
    try {
      instrumentation.metric("fullAnalysis", fullAnalysis);
      instrumentation.data3("fullName", librarySource.fullName);
      Library targetLibrary = createLibrary(librarySource);
      _coreLibrary = A__libraryMap[A__coreLibrarySource];
      if (_coreLibrary == null) {
        _coreLibrary = A__createLibraryOrNull(A__coreLibrarySource);
        if (_coreLibrary == null) {
          LibraryResolver2.missingCoreLibrary(analysisContext, A__coreLibrarySource);
        }
      }
      instrumentation.metric3("createLibrary", "complete");
      A__computeLibraryDependencies(targetLibrary);
      _librariesInCycles = _computeLibrariesInCycles(targetLibrary);
      _buildElementModels();
      instrumentation.metric3("buildElementModels", "complete");
      LibraryElement coreElement = _coreLibrary.libraryElement;
      if (coreElement == null) {
        throw new AnalysisException("Could not resolve dart:core");
      }
      _buildDirectiveModels();
      instrumentation.metric3("buildDirectiveModels", "complete");
      B__typeProvider = new TypeProviderImpl(coreElement);
      _buildEnumMembers();
      _buildTypeHierarchies();
      instrumentation.metric3("buildTypeHierarchies", "complete");
      _resolveReferencesAndTypes();
      instrumentation.metric3("resolveReferencesAndTypes", "complete");
      _performConstantEvaluation();
      instrumentation.metric3("performConstantEvaluation", "complete");
      instrumentation.metric2("librariesInCycles", _librariesInCycles.length);
      for (Library lib in _librariesInCycles) {
        instrumentation.metric2("librariesInCycles-CompilationUnitSources-Size", lib.compilationUnitSources.length);
      }
      return targetLibrary.libraryElement;
    } finally {
      instrumentation.log();
    }
  }
  Library createLibrary(Source librarySource) {
    Library library = new Library(analysisContext, D__errorListener, librarySource);
    A__libraryMap[librarySource] = library;
    return library;
  }
  void _addDependencyToMap(A_p.HashMap<Library, List<Library>> dependencyMap, Library referencingLibrary, Library referencedLibrary) {
    List<Library> dependentLibraries = dependencyMap[referencedLibrary];
    if (dependentLibraries == null) {
      dependentLibraries = new List<Library>();
      dependencyMap[referencedLibrary] = dependentLibraries;
    }
    dependentLibraries.add(referencingLibrary);
  }
  void _addLibrariesInCycle(Library library, Set<Library> librariesInCycle, A_p.HashMap<Library, List<Library>> dependencyMap) {
    if (librariesInCycle.add(library)) {
      List<Library> dependentLibraries = dependencyMap[library];
      if (dependentLibraries != null) {
        for (Library dependentLibrary in dependentLibraries) {
          _addLibrariesInCycle(dependentLibrary, librariesInCycle, dependencyMap);
        }
      }
    }
  }
  void _addToDependencyMap(Library library, A_p.HashMap<Library, List<Library>> dependencyMap, Set<Library> visitedLibraries) {
    if (visitedLibraries.add(library)) {
      for (Library referencedLibrary in library.importsAndExports) {
        _addDependencyToMap(dependencyMap, library, referencedLibrary);
        _addToDependencyMap(referencedLibrary, dependencyMap, visitedLibraries);
      }
      if (!library.explicitlyImportsCore && !identical(library, _coreLibrary)) {
        _addDependencyToMap(dependencyMap, library, _coreLibrary);
      }
    }
  }
  List<NamespaceCombinator> _buildCombinators(NamespaceDirective directive) {
    List<NamespaceCombinator> combinators = new List<NamespaceCombinator>();
    for (Combinator combinator in directive.combinators) {
      if (combinator is HideCombinator) {
        HideElementCombinatorImpl A_hide = new HideElementCombinatorImpl();
        A_hide.hiddenNames = _getIdentifiers(combinator.hiddenNames);
        combinators.add(A_hide);
      } else {
        ShowElementCombinatorImpl show = new ShowElementCombinatorImpl();
        show.offset = combinator.offset;
        show.end = combinator.end;
        show.shownNames = _getIdentifiers((combinator as ShowCombinator).shownNames);
        combinators.add(show);
      }
    }
    return new List.from(combinators);
  }
  void _buildDirectiveModels() {
    for (Library library in _librariesInCycles) {
      A_p.HashMap<String, PrefixElementImpl> nameToPrefixMap = new A_p.HashMap<String,PrefixElementImpl>();
      List<ImportElement> imports = new List<ImportElement>();
      List<ExportElement> exports = new List<ExportElement>();
      for (Directive directive in library.definingCompilationUnit.directives) {
        if (directive is ImportDirective) {
          ImportDirective importDirective = directive;
          String uriContent = importDirective.uriContent;
          if (DartUriResolver.isDartExtUri(uriContent)) {
            library.libraryElement.hasExtUri = true;
          }
          Source importedSource = importDirective.source;
          if (importedSource != null) {
            Library importedLibrary = A__libraryMap[importedSource];
            if (importedLibrary != null) {
              ImportElementImpl importElement = new ImportElementImpl(directive.offset);
              StringLiteral uriLiteral = importDirective.uri;
              importElement.uriOffset = uriLiteral.offset;
              importElement.uriEnd = uriLiteral.end;
              importElement.uri = uriContent;
              importElement.deferred = importDirective.deferredToken != null;
              importElement.combinators = _buildCombinators(importDirective);
              LibraryElement importedLibraryElement = importedLibrary.libraryElement;
              if (importedLibraryElement != null) {
                importElement.importedLibrary = importedLibraryElement;
              }
              SimpleIdentifier prefixNode = directive.prefix;
              if (prefixNode != null) {
                importElement.prefixOffset = prefixNode.offset;
                String prefixName = prefixNode.name;
                PrefixElementImpl prefix = nameToPrefixMap[prefixName];
                if (prefix == null) {
                  prefix = new PrefixElementImpl.forNode(prefixNode);
                  nameToPrefixMap[prefixName] = prefix;
                }
                importElement.prefix = prefix;
                prefixNode.staticElement = prefix;
              }
              directive.element = importElement;
              imports.add(importElement);
              if (analysisContext.computeKindOf(importedSource) != SourceKind.D_LIBRARY) {
                ErrorCode A_errorCode = (importElement.isDeferred ? StaticWarningCode.IMPORT_OF_NON_LIBRARY : CompileTimeErrorCode.IMPORT_OF_NON_LIBRARY);
                D__errorListener.onError(new A_AnalysisError.D_con2(library.librarySource, uriLiteral.offset, uriLiteral.length, A_errorCode, [uriLiteral.toSource()]));
              }
            }
          }
        } else if (directive is ExportDirective) {
          ExportDirective exportDirective = directive;
          Source exportedSource = exportDirective.source;
          if (exportedSource != null) {
            Library exportedLibrary = A__libraryMap[exportedSource];
            if (exportedLibrary != null) {
              ExportElementImpl exportElement = new ExportElementImpl();
              StringLiteral uriLiteral = exportDirective.uri;
              exportElement.uriOffset = uriLiteral.offset;
              exportElement.uriEnd = uriLiteral.end;
              exportElement.uri = exportDirective.uriContent;
              exportElement.combinators = _buildCombinators(exportDirective);
              LibraryElement exportedLibraryElement = exportedLibrary.libraryElement;
              if (exportedLibraryElement != null) {
                exportElement.exportedLibrary = exportedLibraryElement;
              }
              directive.element = exportElement;
              exports.add(exportElement);
              if (analysisContext.computeKindOf(exportedSource) != SourceKind.D_LIBRARY) {
                D__errorListener.onError(new A_AnalysisError.D_con2(library.librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.EXPORT_OF_NON_LIBRARY, [uriLiteral.toSource()]));
              }
            }
          }
        }
      }
      Source librarySource = library.librarySource;
      if (!library.explicitlyImportsCore && A__coreLibrarySource != librarySource) {
        ImportElementImpl importElement = new ImportElementImpl(-1);
        importElement.importedLibrary = _coreLibrary.libraryElement;
        importElement.synthetic = true;
        imports.add(importElement);
      }
      LibraryElementImpl libraryElement = library.libraryElement;
      libraryElement.imports = new List.from(imports);
      libraryElement.exports = new List.from(exports);
      if (libraryElement.entryPoint == null) {
        Namespace namespace = new NamespaceBuilder().createExportNamespaceForLibrary(libraryElement);
        A_Element A_element = namespace.get(LibraryElementBuilder.ENTRY_POINT_NAME);
        if (A_element is FunctionElement) {
          libraryElement.entryPoint = A_element;
        }
      }
    }
  }
  void _buildElementModels() {
    for (Library library in _librariesInCycles) {
      LibraryElementBuilder A_builder = new LibraryElementBuilder(analysisContext, errorListener);
      LibraryElementImpl libraryElement = A_builder.buildLibrary(library);
      library.libraryElement = libraryElement;
    }
  }
  void _buildEnumMembers() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (Library library in _librariesInCycles) {
        for (Source A_source in library.compilationUnitSources) {
          EnumMemberBuilder A_builder = new EnumMemberBuilder(B__typeProvider);
          library.getAST(A_source).accept(A_builder);
        }
      }
    } finally {
      timeCounter.stop();
    }
  }
  void _buildTypeHierarchies() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (Library library in _librariesInCycles) {
        for (Source A_source in library.compilationUnitSources) {
          TypeResolverVisitor visitor = new TypeResolverVisitor.G_con1(library, A_source, B__typeProvider);
          library.getAST(A_source).accept(visitor);
        }
      }
    } finally {
      timeCounter.stop();
    }
  }
  A_p.HashMap<Library, List<Library>> _computeDependencyMap(Library library) {
    A_p.HashMap<Library, List<Library>> dependencyMap = new A_p.HashMap<Library,List<Library>>();
    _addToDependencyMap(library, dependencyMap, new A_p.HashSet<Library>());
    return dependencyMap;
  }
  void _computeEmbeddedLibraryDependencies(Library library, CompilationUnit unit) {
    Source librarySource = library.librarySource;
    A_p.HashSet<Source> exportedSources = new A_p.HashSet<Source>();
    A_p.HashSet<Source> importedSources = new A_p.HashSet<Source>();
    for (Directive directive in unit.directives) {
      if (directive is ExportDirective) {
        Source exportSource = _resolveSource(librarySource, directive);
        if (exportSource != null) {
          exportedSources.add(exportSource);
        }
      } else if (directive is ImportDirective) {
        Source importSource = _resolveSource(librarySource, directive);
        if (importSource != null) {
          importedSources.add(importSource);
        }
      }
    }
    A__computeLibraryDependenciesFromDirectives(library, new List.from(importedSources), new List.from(exportedSources));
  }
  Set<Library> _computeLibrariesInCycles(Library library) {
    A_p.HashMap<Library, List<Library>> dependencyMap = _computeDependencyMap(library);
    Set<Library> librariesInCycle = new A_p.HashSet<Library>();
    _addLibrariesInCycle(library, librariesInCycle, dependencyMap);
    return librariesInCycle;
  }
  void A__computeLibraryDependencies(Library library) {
    Source librarySource = library.librarySource;
    A__computeLibraryDependenciesFromDirectives(library, analysisContext.computeImportedLibraries(librarySource), analysisContext.computeExportedLibraries(librarySource));
  }
  void A__computeLibraryDependenciesFromDirectives(Library library, List<Source> importedSources, List<Source> exportedSources) {
    List<Library> importedLibraries = new List<Library>();
    bool explicitlyImportsCore = false;
    for (Source importedSource in importedSources) {
      if (importedSource == A__coreLibrarySource) {
        explicitlyImportsCore = true;
      }
      Library importedLibrary = A__libraryMap[importedSource];
      if (importedLibrary == null) {
        importedLibrary = A__createLibraryOrNull(importedSource);
        if (importedLibrary != null) {
          A__computeLibraryDependencies(importedLibrary);
        }
      }
      if (importedLibrary != null) {
        importedLibraries.add(importedLibrary);
      }
    }
    library.importedLibraries = new List.from(importedLibraries);
    List<Library> exportedLibraries = new List<Library>();
    for (Source exportedSource in exportedSources) {
      Library exportedLibrary = A__libraryMap[exportedSource];
      if (exportedLibrary == null) {
        exportedLibrary = A__createLibraryOrNull(exportedSource);
        if (exportedLibrary != null) {
          A__computeLibraryDependencies(exportedLibrary);
        }
      }
      if (exportedLibrary != null) {
        exportedLibraries.add(exportedLibrary);
      }
    }
    library.exportedLibraries = new List.from(exportedLibraries);
    library.explicitlyImportsCore = explicitlyImportsCore;
    if (!explicitlyImportsCore && A__coreLibrarySource != library.librarySource) {
      Library importedLibrary = A__libraryMap[A__coreLibrarySource];
      if (importedLibrary == null) {
        importedLibrary = A__createLibraryOrNull(A__coreLibrarySource);
        if (importedLibrary != null) {
          A__computeLibraryDependencies(importedLibrary);
        }
      }
    }
  }
  Library A__createLibraryOrNull(Source librarySource) {
    if (!analysisContext.exists(librarySource)) {
      return null;
    }
    Library library = new Library(analysisContext, D__errorListener, librarySource);
    A__libraryMap[librarySource] = library;
    return library;
  }
  Library _createLibraryWithUnit(Source librarySource, int modificationStamp, CompilationUnit unit) {
    Library library = new Library(analysisContext, D__errorListener, librarySource);
    library.setDefiningCompilationUnit(modificationStamp, unit);
    A__libraryMap[librarySource] = library;
    return library;
  }
  List<String> _getIdentifiers(NodeList<SimpleIdentifier> names) {
    int count = names.length;
    List<String> identifiers = new List<String>(count);
    for (int i = 0; i < count; i++) {
      identifiers[i] = names[i].name;
    }
    return identifiers;
  }
  void _performConstantEvaluation() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      ConstantValueComputer computer = new ConstantValueComputer(B__typeProvider, analysisContext.declaredVariables);
      for (Library library in _librariesInCycles) {
        for (Source A_source in library.compilationUnitSources) {
          try {
            CompilationUnit unit = library.getAST(A_source);
            if (unit != null) {
              computer.add(unit);
            }
          }on AnalysisException  catch (exception, A_stackTrace) {
            AnalysisEngine.A_instance.logger.logError2("Internal Error: Could not access AST for ${A_source.fullName} during constant evaluation", new CaughtException(exception, A_stackTrace));
          }
        }
      }
      computer.computeValues();
    } finally {
      timeCounter.stop();
    }
  }
  void _resolveReferencesAndTypes() {
    for (Library library in _librariesInCycles) {
      _resolveReferencesAndTypesInLibrary(library);
    }
  }
  void _resolveReferencesAndTypesInLibrary(Library library) {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (Source A_source in library.compilationUnitSources) {
        CompilationUnit ast = library.getAST(A_source);
        ast.accept(new VariableResolverVisitor.G_con1(library, A_source, B__typeProvider));
        ResolverVisitor visitor = new ResolverVisitor.G_con1(library, A_source, B__typeProvider);
        ast.accept(visitor);
      }
    } finally {
      timeCounter.stop();
    }
    timeCounter = PerformanceStatistics.angular.start();
    try {
      for (Source A_source in library.compilationUnitSources) {
        CompilationUnit ast = library.getAST(A_source);
        new AngularCompilationUnitBuilder(D__errorListener, A_source, ast).build();
      }
    } finally {
      timeCounter.stop();
    }
    timeCounter = PerformanceStatistics.polymer.start();
    try {
      for (Source A_source in library.compilationUnitSources) {
        CompilationUnit ast = library.getAST(A_source);
        new PolymerCompilationUnitBuilder(ast).build();
      }
    } finally {
      timeCounter.stop();
    }
  }
  Source _resolveSource(Source librarySource, UriBasedDirective directive) {
    StringLiteral uriLiteral = directive.uri;
    if (uriLiteral is StringInterpolation) {
      return null;
    }
    String uriContent = uriLiteral.stringValue.trim();
    if (uriContent == null || uriContent.isEmpty) {
      return null;
    }
    uriContent = Uri.encodeFull(uriContent);
    return analysisContext.sourceFactory.resolveUri(librarySource, uriContent);
  }
}
class LibraryResolver2 {
  static void missingCoreLibrary(AnalysisContext A_analysisContext, Source coreLibrarySource) {
    throw new AnalysisException("Could not resolve dart:core");
  }
  final InternalAnalysisContext analysisContext;
  RecordingErrorListener D__errorListener;
  Source A__coreLibrarySource;
  ResolvableLibrary _coreLibrary;
  TypeProvider B__typeProvider;
  A_p.HashMap<Source, ResolvableLibrary> A__libraryMap = new A_p.HashMap<Source,ResolvableLibrary>();
  List<ResolvableLibrary> A__librariesInCycle;
  LibraryResolver2(this.analysisContext) {
    this.D__errorListener = new RecordingErrorListener();
    A__coreLibrarySource = analysisContext.sourceFactory.forUri(DartSdk.DART_CORE);
  }
  RecordingErrorListener get errorListener => D__errorListener;
  List<ResolvableLibrary> get resolvedLibraries => A__librariesInCycle;
  LibraryElement resolveLibrary(Source librarySource, List<ResolvableLibrary> librariesInCycle) {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.LibraryResolver.resolveLibrary");
    try {
      instrumentation.data3("fullName", librarySource.fullName);
      this.A__librariesInCycle = librariesInCycle;
      A__libraryMap = _buildLibraryMap();
      ResolvableLibrary targetLibrary = A__libraryMap[librarySource];
      _coreLibrary = A__libraryMap[A__coreLibrarySource];
      instrumentation.metric3("buildLibraryMap", "complete");
      _buildElementModels();
      instrumentation.metric3("buildElementModels", "complete");
      LibraryElement coreElement = _coreLibrary.libraryElement;
      if (coreElement == null) {
        missingCoreLibrary(analysisContext, A__coreLibrarySource);
      }
      _buildDirectiveModels();
      instrumentation.metric3("buildDirectiveModels", "complete");
      B__typeProvider = new TypeProviderImpl(coreElement);
      _buildEnumMembers();
      _buildTypeHierarchies();
      instrumentation.metric3("buildTypeHierarchies", "complete");
      _resolveReferencesAndTypes();
      instrumentation.metric3("resolveReferencesAndTypes", "complete");
      _performConstantEvaluation();
      instrumentation.metric3("performConstantEvaluation", "complete");
      instrumentation.metric2("librariesInCycles", librariesInCycle.length);
      for (ResolvableLibrary lib in librariesInCycle) {
        instrumentation.metric2("librariesInCycles-CompilationUnitSources-Size", lib.compilationUnitSources.length);
      }
      return targetLibrary.libraryElement;
    } finally {
      instrumentation.log();
    }
  }
  List<NamespaceCombinator> _buildCombinators(NamespaceDirective directive) {
    List<NamespaceCombinator> combinators = new List<NamespaceCombinator>();
    for (Combinator combinator in directive.combinators) {
      if (combinator is HideCombinator) {
        HideElementCombinatorImpl A_hide = new HideElementCombinatorImpl();
        A_hide.hiddenNames = _getIdentifiers(combinator.hiddenNames);
        combinators.add(A_hide);
      } else {
        ShowElementCombinatorImpl show = new ShowElementCombinatorImpl();
        show.offset = combinator.offset;
        show.end = combinator.end;
        show.shownNames = _getIdentifiers((combinator as ShowCombinator).shownNames);
        combinators.add(show);
      }
    }
    return new List.from(combinators);
  }
  void _buildDirectiveModels() {
    for (ResolvableLibrary library in A__librariesInCycle) {
      A_p.HashMap<String, PrefixElementImpl> nameToPrefixMap = new A_p.HashMap<String,PrefixElementImpl>();
      List<ImportElement> imports = new List<ImportElement>();
      List<ExportElement> exports = new List<ExportElement>();
      for (Directive directive in library.definingCompilationUnit.directives) {
        if (directive is ImportDirective) {
          ImportDirective importDirective = directive;
          String uriContent = importDirective.uriContent;
          if (DartUriResolver.isDartExtUri(uriContent)) {
            library.libraryElement.hasExtUri = true;
          }
          Source importedSource = importDirective.source;
          if (importedSource != null && analysisContext.exists(importedSource)) {
            ResolvableLibrary importedLibrary = A__libraryMap[importedSource];
            if (importedLibrary != null) {
              ImportElementImpl importElement = new ImportElementImpl(directive.offset);
              StringLiteral uriLiteral = importDirective.uri;
              if (uriLiteral != null) {
                importElement.uriOffset = uriLiteral.offset;
                importElement.uriEnd = uriLiteral.end;
              }
              importElement.uri = uriContent;
              importElement.deferred = importDirective.deferredToken != null;
              importElement.combinators = _buildCombinators(importDirective);
              LibraryElement importedLibraryElement = importedLibrary.libraryElement;
              if (importedLibraryElement != null) {
                importElement.importedLibrary = importedLibraryElement;
              }
              SimpleIdentifier prefixNode = directive.prefix;
              if (prefixNode != null) {
                importElement.prefixOffset = prefixNode.offset;
                String prefixName = prefixNode.name;
                PrefixElementImpl prefix = nameToPrefixMap[prefixName];
                if (prefix == null) {
                  prefix = new PrefixElementImpl.forNode(prefixNode);
                  nameToPrefixMap[prefixName] = prefix;
                }
                importElement.prefix = prefix;
                prefixNode.staticElement = prefix;
              }
              directive.element = importElement;
              imports.add(importElement);
              if (analysisContext.computeKindOf(importedSource) != SourceKind.D_LIBRARY) {
                ErrorCode A_errorCode = (importElement.isDeferred ? StaticWarningCode.IMPORT_OF_NON_LIBRARY : CompileTimeErrorCode.IMPORT_OF_NON_LIBRARY);
                D__errorListener.onError(new A_AnalysisError.D_con2(library.librarySource, uriLiteral.offset, uriLiteral.length, A_errorCode, [uriLiteral.toSource()]));
              }
            }
          }
        } else if (directive is ExportDirective) {
          ExportDirective exportDirective = directive;
          Source exportedSource = exportDirective.source;
          if (exportedSource != null && analysisContext.exists(exportedSource)) {
            ResolvableLibrary exportedLibrary = A__libraryMap[exportedSource];
            if (exportedLibrary != null) {
              ExportElementImpl exportElement = new ExportElementImpl();
              StringLiteral uriLiteral = exportDirective.uri;
              if (uriLiteral != null) {
                exportElement.uriOffset = uriLiteral.offset;
                exportElement.uriEnd = uriLiteral.end;
              }
              exportElement.uri = exportDirective.uriContent;
              exportElement.combinators = _buildCombinators(exportDirective);
              LibraryElement exportedLibraryElement = exportedLibrary.libraryElement;
              if (exportedLibraryElement != null) {
                exportElement.exportedLibrary = exportedLibraryElement;
              }
              directive.element = exportElement;
              exports.add(exportElement);
              if (analysisContext.computeKindOf(exportedSource) != SourceKind.D_LIBRARY) {
                D__errorListener.onError(new A_AnalysisError.D_con2(library.librarySource, uriLiteral.offset, uriLiteral.length, CompileTimeErrorCode.EXPORT_OF_NON_LIBRARY, [uriLiteral.toSource()]));
              }
            }
          }
        }
      }
      Source librarySource = library.librarySource;
      if (!library.explicitlyImportsCore && A__coreLibrarySource != librarySource) {
        ImportElementImpl importElement = new ImportElementImpl(-1);
        importElement.importedLibrary = _coreLibrary.libraryElement;
        importElement.synthetic = true;
        imports.add(importElement);
      }
      LibraryElementImpl libraryElement = library.libraryElement;
      libraryElement.imports = new List.from(imports);
      libraryElement.exports = new List.from(exports);
      if (libraryElement.entryPoint == null) {
        Namespace namespace = new NamespaceBuilder().createExportNamespaceForLibrary(libraryElement);
        A_Element A_element = namespace.get(LibraryElementBuilder.ENTRY_POINT_NAME);
        if (A_element is FunctionElement) {
          libraryElement.entryPoint = A_element;
        }
      }
    }
  }
  void _buildElementModels() {
    for (ResolvableLibrary library in A__librariesInCycle) {
      LibraryElementBuilder A_builder = new LibraryElementBuilder(analysisContext, errorListener);
      LibraryElementImpl libraryElement = A_builder.buildLibrary2(library);
      library.libraryElement = libraryElement;
    }
  }
  void _buildEnumMembers() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (ResolvableLibrary library in A__librariesInCycle) {
        for (Source A_source in library.compilationUnitSources) {
          EnumMemberBuilder A_builder = new EnumMemberBuilder(B__typeProvider);
          library.getAST(A_source).accept(A_builder);
        }
      }
    } finally {
      timeCounter.stop();
    }
  }
  A_p.HashMap<Source, ResolvableLibrary> _buildLibraryMap() {
    A_p.HashMap<Source, ResolvableLibrary> libraryMap = new A_p.HashMap<Source,ResolvableLibrary>();
    int libraryCount = A__librariesInCycle.length;
    for (int i = 0; i < libraryCount; i++) {
      ResolvableLibrary library = A__librariesInCycle[i];
      library.errorListener = D__errorListener;
      libraryMap[library.librarySource] = library;
      List<ResolvableLibrary> dependencies = library.importsAndExports;
      int dependencyCount = dependencies.length;
      for (int j = 0; j < dependencyCount; j++) {
        ResolvableLibrary dependency = dependencies[j];
        libraryMap[dependency.librarySource] = dependency;
      }
    }
    return libraryMap;
  }
  void _buildTypeHierarchies() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (ResolvableLibrary library in A__librariesInCycle) {
        for (ResolvableCompilationUnit unit in library.resolvableCompilationUnits) {
          Source A_source = unit.source;
          CompilationUnit ast = unit.compilationUnit;
          TypeResolverVisitor visitor = new TypeResolverVisitor.A_con4(library, A_source, B__typeProvider);
          ast.accept(visitor);
        }
      }
    } finally {
      timeCounter.stop();
    }
  }
  List<String> _getIdentifiers(NodeList<SimpleIdentifier> names) {
    int count = names.length;
    List<String> identifiers = new List<String>(count);
    for (int i = 0; i < count; i++) {
      identifiers[i] = names[i].name;
    }
    return identifiers;
  }
  void _performConstantEvaluation() {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      ConstantValueComputer computer = new ConstantValueComputer(B__typeProvider, analysisContext.declaredVariables);
      for (ResolvableLibrary library in A__librariesInCycle) {
        for (ResolvableCompilationUnit unit in library.resolvableCompilationUnits) {
          CompilationUnit ast = unit.compilationUnit;
          if (ast != null) {
            computer.add(ast);
          }
        }
      }
      computer.computeValues();
    } finally {
      timeCounter.stop();
    }
  }
  void _resolveReferencesAndTypes() {
    for (ResolvableLibrary library in A__librariesInCycle) {
      _resolveReferencesAndTypesInLibrary(library);
    }
  }
  void _resolveReferencesAndTypesInLibrary(ResolvableLibrary library) {
    TimeCounter_TimeCounterHandle timeCounter = PerformanceStatistics.A_resolve.start();
    try {
      for (ResolvableCompilationUnit unit in library.resolvableCompilationUnits) {
        Source A_source = unit.source;
        CompilationUnit ast = unit.compilationUnit;
        ast.accept(new VariableResolverVisitor.B_con3(library, A_source, B__typeProvider));
        ResolverVisitor visitor = new ResolverVisitor.A_con4(library, A_source, B__typeProvider);
        ast.accept(visitor);
      }
    } finally {
      timeCounter.stop();
    }
    timeCounter = PerformanceStatistics.angular.start();
    try {
      for (ResolvableCompilationUnit unit in library.resolvableCompilationUnits) {
        Source A_source = unit.source;
        CompilationUnit ast = unit.compilationUnit;
        new AngularCompilationUnitBuilder(D__errorListener, A_source, ast).build();
      }
    } finally {
      timeCounter.stop();
    }
    timeCounter = PerformanceStatistics.polymer.start();
    try {
      for (Source A_source in library.compilationUnitSources) {
        CompilationUnit ast = library.getAST(A_source);
        new PolymerCompilationUnitBuilder(ast).build();
      }
    } finally {
      timeCounter.stop();
    }
  }
}
class LibraryScope extends EnclosedScope {
  LibraryScope(LibraryElement definingLibrary, AnalysisErrorListener errorListener) : super(new LibraryImportScope(definingLibrary, errorListener)) {
    _defineTopLevelNames(definingLibrary);
  }
  A_AnalysisError getErrorForDuplicate(A_Element existing, A_Element duplicate) {
    if (existing is PrefixElement) {
      int A_offset = duplicate.nameOffset;
      if (duplicate is PropertyAccessorElement) {
        PropertyAccessorElement accessor = duplicate;
        if (accessor.isSynthetic) {
          A_offset = accessor.variable.nameOffset;
        }
      }
      return new A_AnalysisError.D_con2(duplicate.source, A_offset, duplicate.displayName.length, CompileTimeErrorCode.PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER, [existing.displayName]);
    }
    return super.getErrorForDuplicate(existing, duplicate);
  }
  void _defineLocalNames(CompilationUnitElement compilationUnit) {
    for (PropertyAccessorElement A_element in compilationUnit.accessors) {
      define(A_element);
    }
    for (ClassElement A_element in compilationUnit.enums) {
      define(A_element);
    }
    for (FunctionElement A_element in compilationUnit.functions) {
      define(A_element);
    }
    for (FunctionTypeAliasElement A_element in compilationUnit.functionTypeAliases) {
      define(A_element);
    }
    for (ClassElement A_element in compilationUnit.types) {
      define(A_element);
    }
  }
  void _defineTopLevelNames(LibraryElement definingLibrary) {
    for (PrefixElement prefix in definingLibrary.prefixes) {
      define(prefix);
    }
    _defineLocalNames(definingLibrary.definingCompilationUnit);
    for (CompilationUnitElement compilationUnit in definingLibrary.parts) {
      _defineLocalNames(compilationUnit);
    }
  }
}
class MemberMap {
  int A__size = 0;
  List<String> A__keys;
  List<ExecutableElement> A__values;
  MemberMap() : this.G_con1(10);
  MemberMap.G_con1(int initialCapacity) {
    _initArrays(initialCapacity);
  }
  MemberMap.G_con2(MemberMap memberMap) {
    _initArrays(memberMap.A__size + 5);
    for (int i = 0; i < memberMap.A__size; i++) {
      A__keys[i] = memberMap.A__keys[i];
      A__values[i] = memberMap.A__values[i];
    }
    A__size = memberMap.A__size;
  }
  ExecutableElement get(String A_key) {
    for (int i = 0; i < A__size; i++) {
      if (A__keys[i] != null && A__keys[i] == A_key) {
        return A__values[i];
      }
    }
    return null;
  }
  String getKey(int i) => A__keys[i];
  int get size => A__size;
  ExecutableElement getValue(int i) => A__values[i];
  void put(String A_key, ExecutableElement A_value) {
    for (int i = 0; i < A__size; i++) {
      if (A__keys[i] != null && A__keys[i] == A_key) {
        A__values[i] = A_value;
        return;
      }
    }
    if (A__size == A__keys.length) {
      int newArrayLength = A__size * 2;
      List<String> keys_new_array = new List<String>(newArrayLength);
      List<ExecutableElement> values_new_array = new List<ExecutableElement>(newArrayLength);
      for (int i = 0; i < A__size; i++) {
        keys_new_array[i] = A__keys[i];
      }
      for (int i = 0; i < A__size; i++) {
        values_new_array[i] = A__values[i];
      }
      A__keys = keys_new_array;
      A__values = values_new_array;
    }
    A__keys[A__size] = A_key;
    A__values[A__size] = A_value;
    A__size++;
  }
  void remove(String A_key) {
    for (int i = 0; i < A__size; i++) {
      if (A__keys[i] == A_key) {
        A__keys[i] = null;
        A__values[i] = null;
        return;
      }
    }
  }
  void setValue(int i, ExecutableElement A_value) {
    A__values[i] = A_value;
  }
  void _initArrays(int initialCapacity) {
    A__keys = new List<String>(initialCapacity);
    A__values = new List<ExecutableElement>(initialCapacity);
  }
}
class Namespace {
  final A_p.HashMap<String, A_Element> _definedNames;
  static Namespace A_EMPTY = new Namespace(new A_p.HashMap<String,A_Element>());
  Namespace(this._definedNames);
  A_Element get(String A_name) => _definedNames[A_name];
  Map<String, A_Element> get definedNames => new A_p.HashMap<String,A_Element>.from(_definedNames);
}
class NamespaceBuilder {
  Namespace createExportNamespaceForDirective(ExportElement A_element) {
    LibraryElement exportedLibrary = A_element.exportedLibrary;
    if (exportedLibrary == null) {
      return Namespace.A_EMPTY;
    }
    A_p.HashMap<String, A_Element> definedNames = _createExportMapping(exportedLibrary, new A_p.HashSet<LibraryElement>());
    definedNames = _applyCombinators(definedNames, A_element.combinators);
    return new Namespace(definedNames);
  }
  Namespace createExportNamespaceForLibrary(LibraryElement library) => new Namespace(_createExportMapping(library, new A_p.HashSet<LibraryElement>()));
  Namespace createImportNamespaceForDirective(ImportElement A_element) {
    LibraryElement importedLibrary = A_element.importedLibrary;
    if (importedLibrary == null) {
      return Namespace.A_EMPTY;
    }
    A_p.HashMap<String, A_Element> definedNames = _createExportMapping(importedLibrary, new A_p.HashSet<LibraryElement>());
    definedNames = _applyCombinators(definedNames, A_element.combinators);
    definedNames = _applyPrefix(definedNames, A_element.prefix);
    return new Namespace(definedNames);
  }
  Namespace createPublicNamespaceForLibrary(LibraryElement library) {
    A_p.HashMap<String, A_Element> definedNames = new A_p.HashMap<String,A_Element>();
    _addPublicNames(definedNames, library.definingCompilationUnit);
    for (CompilationUnitElement compilationUnit in library.parts) {
      _addPublicNames(definedNames, compilationUnit);
    }
    return new Namespace(definedNames);
  }
  void _addAllFromMap(Map<String, A_Element> definedNames, Map<String, A_Element> newNames) {
    for (MapEntry<String, A_Element> A_entry in getMapEntrySet(newNames)) {
      definedNames[A_entry.getKey()] = A_entry.getValue();
    }
  }
  void _addAllFromNamespace(Map<String, A_Element> definedNames, Namespace namespace) {
    if (namespace != null) {
      _addAllFromMap(definedNames, namespace.definedNames);
    }
  }
  void _addIfPublic(Map<String, A_Element> definedNames, A_Element A_element) {
    String A_name = A_element.name;
    if (A_name != null && !Scope.A_isPrivateName(A_name)) {
      definedNames[A_name] = A_element;
    }
  }
  void _addPublicNames(Map<String, A_Element> definedNames, CompilationUnitElement compilationUnit) {
    for (PropertyAccessorElement A_element in compilationUnit.accessors) {
      _addIfPublic(definedNames, A_element);
    }
    for (FunctionElement A_element in compilationUnit.functions) {
      _addIfPublic(definedNames, A_element);
    }
    for (FunctionTypeAliasElement A_element in compilationUnit.functionTypeAliases) {
      _addIfPublic(definedNames, A_element);
    }
    for (ClassElement A_element in compilationUnit.types) {
      _addIfPublic(definedNames, A_element);
    }
  }
  A_p.HashMap<String, A_Element> _applyCombinators(A_p.HashMap<String, A_Element> definedNames, List<NamespaceCombinator> combinators) {
    for (NamespaceCombinator combinator in combinators) {
      if (combinator is HideElementCombinator) {
        _hide(definedNames, combinator.hiddenNames);
      } else if (combinator is ShowElementCombinator) {
        definedNames = _show(definedNames, combinator.shownNames);
      } else {
        AnalysisEngine.A_instance.logger.logError("Unknown type of combinator: ${combinator.runtimeType.toString()}");
      }
    }
    return definedNames;
  }
  A_p.HashMap<String, A_Element> _applyPrefix(A_p.HashMap<String, A_Element> definedNames, PrefixElement prefixElement) {
    if (prefixElement != null) {
      String prefix = prefixElement.name;
      A_p.HashMap<String, A_Element> newNames = new A_p.HashMap<String,A_Element>();
      for (MapEntry<String, A_Element> A_entry in getMapEntrySet(definedNames)) {
        newNames["${prefix}.${A_entry.getKey()}"] = A_entry.getValue();
      }
      return newNames;
    } else {
      return definedNames;
    }
  }
  A_p.HashMap<String, A_Element> _createExportMapping(LibraryElement library, A_p.HashSet<LibraryElement> visitedElements) {
    visitedElements.add(library);
    try {
      A_p.HashMap<String, A_Element> definedNames = new A_p.HashMap<String,A_Element>();
      for (ExportElement A_element in library.exports) {
        LibraryElement exportedLibrary = A_element.exportedLibrary;
        if (exportedLibrary != null && !visitedElements.contains(exportedLibrary)) {
          A_p.HashMap<String, A_Element> exportedNames = _createExportMapping(exportedLibrary, visitedElements);
          exportedNames = _applyCombinators(exportedNames, A_element.combinators);
          _addAllFromMap(definedNames, exportedNames);
        }
      }
      _addAllFromNamespace(definedNames, (library.context as InternalAnalysisContext).getPublicNamespace(library));
      return definedNames;
    } finally {
      visitedElements.remove(library);
    }
  }
  void _hide(A_p.HashMap<String, A_Element> definedNames, List<String> hiddenNames) {
    for (String A_name in hiddenNames) {
      definedNames.remove(A_name);
      definedNames.remove("${A_name}=");
    }
  }
  A_p.HashMap<String, A_Element> _show(A_p.HashMap<String, A_Element> definedNames, List<String> shownNames) {
    A_p.HashMap<String, A_Element> newNames = new A_p.HashMap<String,A_Element>();
    for (String A_name in shownNames) {
      A_Element A_element = definedNames[A_name];
      if (A_element != null) {
        newNames[A_name] = A_element;
      }
      String setterName = "${A_name}=";
      A_element = definedNames[setterName];
      if (A_element != null) {
        newNames[setterName] = A_element;
      }
    }
    return newNames;
  }
}
class OverrideVerifier extends RecursiveAstVisitor<Object> {
  final InheritanceManager _manager;
  final ErrorReporter _errorReporter;
  OverrideVerifier(this._manager, this._errorReporter);
  Object visitMethodDeclaration(MethodDeclaration node) {
    ExecutableElement A_element = node.element;
    if (_isOverride(A_element)) {
      if (_getOverriddenMember(A_element) == null) {
        if (A_element is MethodElement) {
          _errorReporter.reportErrorForNode(HintCode.OVERRIDE_ON_NON_OVERRIDING_METHOD, node.name, []);
        } else if (A_element is PropertyAccessorElement) {
          if (A_element.isGetter) {
            _errorReporter.reportErrorForNode(HintCode.OVERRIDE_ON_NON_OVERRIDING_GETTER, node.name, []);
          } else {
            _errorReporter.reportErrorForNode(HintCode.OVERRIDE_ON_NON_OVERRIDING_SETTER, node.name, []);
          }
        }
      }
    }
    return super.visitMethodDeclaration(node);
  }
  ExecutableElement _getOverriddenMember(ExecutableElement member) {
    LibraryElement library = member.library;
    if (library == null) {
      return null;
    }
    ClassElement classElement = member.getAncestor((A_element) => A_element is ClassElement);
    if (classElement == null) {
      return null;
    }
    return _manager.lookupInheritance(classElement, member.name);
  }
  bool _isOverride(A_Element A_element) => A_element != null && A_element.isOverride;
}
class PolymerCompilationUnitBuilder {
  static String _CUSTOM_TAG = "CustomTag";
  final CompilationUnit G__unit;
  ClassDeclaration _classDeclaration;
  ClassElementImpl _classElement;
  Annotation _annotation;
  PolymerCompilationUnitBuilder(this.G__unit);
  void build() {
    for (CompilationUnitMember unitMember in G__unit.declarations) {
      if (unitMember is ClassDeclaration) {
        this._classDeclaration = unitMember;
        this._classElement = _classDeclaration.element as ClassElementImpl;
        NodeList<Annotation> annotations = _classDeclaration.metadata;
        for (Annotation annotation in annotations) {
          if (annotation.arguments == null) {
            continue;
          }
          this._annotation = annotation;
          if (_isAnnotation(annotation, _CUSTOM_TAG)) {
            _parseCustomTag();
            continue;
          }
        }
      }
    }
  }
  bool _isAnnotation(Annotation annotation, String A_name) {
    A_Element A_element = annotation.element;
    if (A_element is ConstructorElement) {
      ConstructorElement constructorElement = A_element;
      return constructorElement.returnType.displayName == A_name;
    }
    return false;
  }
  void _parseCustomTag() {
    List<Expression> A_arguments = _annotation.arguments.arguments;
    if (A_arguments.length == 1) {
      Expression nameExpression = A_arguments[0];
      if (nameExpression is SimpleStringLiteral) {
        SimpleStringLiteral nameLiteral = nameExpression;
        String A_name = nameLiteral.value;
        int nameOffset = nameLiteral.valueOffset;
        PolymerTagDartElementImpl A_element = new PolymerTagDartElementImpl(A_name, nameOffset, _classElement);
        _classElement.addToolkitObjects(A_element);
        nameLiteral.toolkitElement = A_element;
      }
    }
  }
}
class RecursiveAstVisitor_AngularCompilationUnitBuilder_parseScopeProperties extends RecursiveAstVisitor<Object> {
  List<AngularScopePropertyElement> properties;
  RecursiveAstVisitor_AngularCompilationUnitBuilder_parseScopeProperties(this.properties) : super();
  Object visitAssignmentExpression(AssignmentExpression node) {
    _addProperty(node);
    return super.visitAssignmentExpression(node);
  }
  void _addProperty(AssignmentExpression node) {
    SimpleStringLiteral nameNode = _getNameNode(node.leftHandSide);
    if (nameNode == null) {
      return;
    }
    String A_name = nameNode.stringValue;
    if (_hasPropertyWithName(A_name)) {
      return;
    }
    int nameOffset = nameNode.valueOffset;
    AngularScopePropertyElement property = new AngularScopePropertyElementImpl(A_name, nameOffset, node.rightHandSide.bestType);
    nameNode.toolkitElement = property;
    properties.add(property);
  }
  SimpleStringLiteral _getNameNode(Expression node) {
    if (node is IndexExpression) {
      IndexExpression indexExpression = node;
      Expression A_target = indexExpression.target;
      Expression A_index = indexExpression.index;
      if (A_index is SimpleStringLiteral && _isContext(A_target)) {
        return A_index;
      }
    }
    return null;
  }
  bool _hasPropertyWithName(String A_name) {
    for (AngularScopePropertyElement property in properties) {
      if (property.name == A_name) {
        return true;
      }
    }
    return false;
  }
  bool _isContext(Expression A_target) {
    if (A_target is PrefixedIdentifier) {
      PrefixedIdentifier prefixed = A_target;
      SimpleIdentifier prefix = prefixed.prefix;
      SimpleIdentifier identifier = prefixed.identifier;
      return (identifier.name == "context") && _isScope(prefix);
    }
    return false;
  }
  bool _isScope(Expression A_target) {
    if (A_target != null) {
      DartType A_type = A_target.bestType;
      if (A_type is InterfaceType) {
        InterfaceType interfaceType = A_type;
        return interfaceType.name == "Scope";
      }
    }
    return false;
  }
}
class RecursiveAstVisitor_AngularCompilationUnitBuilder_parseViews extends RecursiveAstVisitor<Object> {
  List<AngularViewElement> views;
  RecursiveAstVisitor_AngularCompilationUnitBuilder_parseViews(this.views) : super();
  Object visitMethodInvocation(MethodInvocation node) {
    _addView(node);
    return super.visitMethodInvocation(node);
  }
  void _addView(MethodInvocation node) {
    List<Expression> A_arguments = node.argumentList.arguments;
    if (A_arguments.length != 1) {
      return;
    }
    Expression argument = A_arguments[0];
    if (argument is! SimpleStringLiteral) {
      return;
    }
    SimpleStringLiteral literal = argument as SimpleStringLiteral;
    if (node.realTarget != null) {
      return;
    }
    if (!_isViewFactory(node.methodName)) {
      return;
    }
    String templateUri = literal.stringValue;
    int templateUriOffset = literal.valueOffset;
    views.add(new AngularViewElementImpl(templateUri, templateUriOffset));
  }
  bool _isViewFactory(Expression A_target) {
    if (A_target is SimpleIdentifier) {
      SimpleIdentifier identifier = A_target;
      A_Element A_element = identifier.staticElement;
      if (A_element is VariableElement) {
        VariableElement variable = A_element;
        DartType A_type = variable.type;
        if (A_type is InterfaceType) {
          InterfaceType interfaceType = A_type;
          return interfaceType.name == "ViewFactory";
        }
      }
    }
    return false;
  }
}
class RecursiveAstVisitor_ResolverVisitor_isVariableAccessedInClosure extends RecursiveAstVisitor<Object> {
  List<bool> result;
  A_Element variable;
  RecursiveAstVisitor_ResolverVisitor_isVariableAccessedInClosure(this.result, this.variable) : super();
  bool _inClosure = false;
  Object visitFunctionExpression(FunctionExpression node) {
    bool inClosure = this._inClosure;
    try {
      this._inClosure = true;
      return super.visitFunctionExpression(node);
    } finally {
      this._inClosure = inClosure;
    }
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    if (result[0]) {
      return null;
    }
    if (_inClosure && identical(node.staticElement, variable)) {
      result[0] = javaBooleanOr(result[0], true);
    }
    return null;
  }
}
class RecursiveAstVisitor_ResolverVisitor_isVariablePotentiallyMutatedIn extends RecursiveAstVisitor<Object> {
  List<bool> result;
  A_Element variable;
  RecursiveAstVisitor_ResolverVisitor_isVariablePotentiallyMutatedIn(this.result, this.variable) : super();
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    if (result[0]) {
      return null;
    }
    if (identical(node.staticElement, variable)) {
      if (node.inSetterContext()) {
        result[0] = javaBooleanOr(result[0], true);
      }
    }
    return null;
  }
}
class RedirectingConstructorKind extends Enum<RedirectingConstructorKind> {
  static const RedirectingConstructorKind A_CONST = const RedirectingConstructorKind('CONST', 0);
  static const RedirectingConstructorKind NORMAL = const RedirectingConstructorKind('NORMAL', 1);
  const RedirectingConstructorKind(String A_name, int ordinal) : super(A_name, ordinal);
}
class ResolvableLibrary {
  final Source librarySource;
  List<ResolvableLibrary> B__importedLibraries = _EMPTY_ARRAY;
  bool explicitlyImportsCore = false;
  List<ResolvableLibrary> A__exportedLibraries = _EMPTY_ARRAY;
  List<ResolvableCompilationUnit> _compilationUnits;
  LibraryElementImpl B__libraryElement;
  AnalysisErrorListener D__errorListener;
  InheritanceManager _inheritanceManager;
  static List<ResolvableLibrary> _EMPTY_ARRAY = new List<ResolvableLibrary>(0);
  LibraryScope _libraryScope;
  ResolvableLibrary(this.librarySource);
  CompilationUnit getAST(Source A_source) {
    int count = _compilationUnits.length;
    for (int i = 0; i < count; i++) {
      if (_compilationUnits[i].source == A_source) {
        return _compilationUnits[i].compilationUnit;
      }
    }
    return null;
  }
  List<Source> get compilationUnitSources {
    int count = _compilationUnits.length;
    List<Source> sources = new List<Source>(count);
    for (int i = 0; i < count; i++) {
      sources[i] = _compilationUnits[i].source;
    }
    return sources;
  }
  CompilationUnit get definingCompilationUnit => _compilationUnits[0].compilationUnit;
  List<ResolvableLibrary> get exports => A__exportedLibraries;
  List<ResolvableLibrary> get imports => B__importedLibraries;
  List<ResolvableLibrary> get importsAndExports {
    A_p.HashSet<ResolvableLibrary> libraries = new A_p.HashSet<ResolvableLibrary>();
    for (ResolvableLibrary library in B__importedLibraries) {
      libraries.add(library);
    }
    for (ResolvableLibrary library in A__exportedLibraries) {
      libraries.add(library);
    }
    return new List.from(libraries);
  }
  InheritanceManager get inheritanceManager {
    if (_inheritanceManager == null) {
      return _inheritanceManager = new InheritanceManager(B__libraryElement);
    }
    return _inheritanceManager;
  }
  LibraryElementImpl get libraryElement => B__libraryElement;
  LibraryScope get libraryScope {
    if (_libraryScope == null) {
      _libraryScope = new LibraryScope(B__libraryElement, D__errorListener);
    }
    return _libraryScope;
  }
  int A_getModificationTime(Source A_source) {
    int count = _compilationUnits.length;
    for (int i = 0; i < count; i++) {
      if (A_source == _compilationUnits[i].source) {
        return _compilationUnits[i].modificationTime;
      }
    }
    return -1;
  }
  List<ResolvableCompilationUnit> get resolvableCompilationUnits => _compilationUnits;
  void set resolvableCompilationUnits(List<ResolvableCompilationUnit> units) {
    _compilationUnits = units;
  }
  void set errorListener(AnalysisErrorListener A_errorListener) {
    this.D__errorListener = A_errorListener;
  }
  void set exportedLibraries(List<ResolvableLibrary> A_exportedLibraries) {
    this.A__exportedLibraries = A_exportedLibraries;
  }
  void set importedLibraries(List<ResolvableLibrary> A_importedLibraries) {
    this.B__importedLibraries = A_importedLibraries;
  }
  void set libraryElement(LibraryElementImpl A_libraryElement) {
    this.B__libraryElement = A_libraryElement;
    if (_inheritanceManager != null) {
      _inheritanceManager.libraryElement = A_libraryElement;
    }
  }
  String toString() => librarySource.shortName;
}
class ResolverErrorCode extends Enum<ResolverErrorCode> implements ErrorCode {
  static const ResolverErrorCode BREAK_LABEL_ON_SWITCH_MEMBER = const ResolverErrorCode.G_con1('BREAK_LABEL_ON_SWITCH_MEMBER', 0, ErrorType.COMPILE_TIME_ERROR, "Break label resolves to case or default statement");
  static const ResolverErrorCode CONTINUE_LABEL_ON_SWITCH = const ResolverErrorCode.G_con1('CONTINUE_LABEL_ON_SWITCH', 1, ErrorType.COMPILE_TIME_ERROR, "A continue label resolves to switch, must be loop or switch member");
  static const ResolverErrorCode MISSING_LIBRARY_DIRECTIVE_WITH_PART = const ResolverErrorCode.G_con1('MISSING_LIBRARY_DIRECTIVE_WITH_PART', 2, ErrorType.COMPILE_TIME_ERROR, "Libraries that have parts must have a library directive");
  final ErrorType type;
  final String message;
  final String correction;
  const ResolverErrorCode.G_con1(String A_name, int ordinal, ErrorType A_type, String A_message) : this.G_con2(A_name, ordinal, A_type, A_message, null);
  const ResolverErrorCode.G_con2(String A_name, int ordinal, this.type, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => type.severity;
}
class ResolverVisitor extends ScopedVisitor {
  InheritanceManager _inheritanceManager;
  ElementResolver _elementResolver;
  StaticTypeAnalyzer _typeAnalyzer;
  ClassElement _enclosingClass = null;
  ClassDeclaration _enclosingClassDeclaration = null;
  FunctionTypeAlias _enclosingFunctionTypeAlias = null;
  ExecutableElement _enclosingFunction = null;
  Comment _commentBeforeFunction = null;
  TypeOverrideManager _overrideManager = new TypeOverrideManager();
  TypePromotionManager _promoteManager = new TypePromotionManager();
  ResolverVisitor.G_con1(Library library, Source A_source, TypeProvider typeProvider) : super.G_con1(library, A_source, typeProvider) {
    this._inheritanceManager = library.inheritanceManager;
    this._elementResolver = new ElementResolver(this);
    this._typeAnalyzer = new StaticTypeAnalyzer(this);
  }
  ResolverVisitor.G_con2(LibraryElement definingLibrary, Source A_source, TypeProvider typeProvider, InheritanceManager inheritanceManager, AnalysisErrorListener errorListener) : super.G_con2(definingLibrary, A_source, typeProvider, errorListener) {
    this._inheritanceManager = inheritanceManager;
    this._elementResolver = new ElementResolver(this);
    this._typeAnalyzer = new StaticTypeAnalyzer(this);
  }
  ResolverVisitor.B_con3(LibraryElement definingLibrary, Source A_source, TypeProvider typeProvider, Scope nameScope, AnalysisErrorListener errorListener) : super.B_con3(definingLibrary, A_source, typeProvider, nameScope, errorListener) {
    this._inheritanceManager = new InheritanceManager(definingLibrary);
    this._elementResolver = new ElementResolver(this);
    this._typeAnalyzer = new StaticTypeAnalyzer(this);
  }
  ResolverVisitor.A_con4(ResolvableLibrary library, Source A_source, TypeProvider typeProvider) : super.A_con4(library, A_source, typeProvider) {
    this._inheritanceManager = library.inheritanceManager;
    this._elementResolver = new ElementResolver(this);
    this._typeAnalyzer = new StaticTypeAnalyzer(this);
  }
  TypeOverrideManager get overrideManager => _overrideManager;
  TypePromotionManager get promoteManager => _promoteManager;
  Object visitAnnotation(Annotation node) {
    AstNode A_parent = node.parent;
    if (identical(A_parent, _enclosingClassDeclaration) || identical(A_parent, _enclosingFunctionTypeAlias)) {
      return null;
    }
    return super.visitAnnotation(node);
  }
  Object visitAsExpression(AsExpression node) {
    super.visitAsExpression(node);
    overrideExpression(node.expression, node.type.type);
    return null;
  }
  Object visitAssertStatement(AssertStatement node) {
    super.visitAssertStatement(node);
    _propagateTrueState(node.condition);
    return null;
  }
  Object visitBinaryExpression(BinaryExpression node) {
    A_TokenType operatorType = node.operator.type;
    Expression leftOperand = node.leftOperand;
    Expression rightOperand = node.rightOperand;
    if (operatorType == A_TokenType.AMPERSAND_AMPERSAND) {
      safelyVisit(leftOperand);
      if (rightOperand != null) {
        _overrideManager.enterScope();
        try {
          _promoteManager.enterScope();
          try {
            _propagateTrueState(leftOperand);
            _promoteTypes(leftOperand);
            _clearTypePromotionsIfPotentiallyMutatedIn(leftOperand);
            _clearTypePromotionsIfPotentiallyMutatedIn(rightOperand);
            _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(rightOperand);
            rightOperand.accept(this);
          } finally {
            _promoteManager.exitScope();
          }
        } finally {
          _overrideManager.exitScope();
        }
      }
    } else if (operatorType == A_TokenType.BAR_BAR) {
      safelyVisit(leftOperand);
      if (rightOperand != null) {
        _overrideManager.enterScope();
        try {
          _propagateFalseState(leftOperand);
          rightOperand.accept(this);
        } finally {
          _overrideManager.exitScope();
        }
      }
    } else {
      safelyVisit(leftOperand);
      safelyVisit(rightOperand);
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitBlockFunctionBody(BlockFunctionBody node) {
    safelyVisit(_commentBeforeFunction);
    _overrideManager.enterScope();
    try {
      super.visitBlockFunctionBody(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitBreakStatement(BreakStatement node) {
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    if (node.metadata != null) {
      node.metadata.accept(this);
    }
    _enclosingClassDeclaration = node;
    ClassElement outerType = _enclosingClass;
    try {
      _enclosingClass = node.element;
      _typeAnalyzer.thisType = _enclosingClass == null ? null : _enclosingClass.type;
      super.visitClassDeclaration(node);
      node.accept(_elementResolver);
      node.accept(_typeAnalyzer);
    } finally {
      _typeAnalyzer.thisType = outerType == null ? null : outerType.type;
      _enclosingClass = outerType;
      _enclosingClassDeclaration = null;
    }
    return null;
  }
  Object visitComment(Comment node) {
    if (node.parent is FunctionDeclaration || node.parent is ConstructorDeclaration || node.parent is MethodDeclaration) {
      if (!identical(node, _commentBeforeFunction)) {
        _commentBeforeFunction = node;
        return null;
      }
    }
    super.visitComment(node);
    _commentBeforeFunction = null;
    return null;
  }
  Object visitCommentReference(CommentReference node) {
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitCompilationUnit(CompilationUnit node) {
    _overrideManager.enterScope();
    try {
      NodeList<Directive> directives = node.directives;
      int directiveCount = directives.length;
      for (int i = 0; i < directiveCount; i++) {
        directives[i].accept(this);
      }
      NodeList<CompilationUnitMember> declarations = node.declarations;
      int declarationCount = declarations.length;
      for (int i = 0; i < declarationCount; i++) {
        CompilationUnitMember declaration = declarations[i];
        if (declaration is! ClassDeclaration) {
          declaration.accept(this);
        }
      }
      for (int i = 0; i < declarationCount; i++) {
        CompilationUnitMember declaration = declarations[i];
        if (declaration is ClassDeclaration) {
          declaration.accept(this);
        }
      }
    } finally {
      _overrideManager.exitScope();
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitConditionalExpression(ConditionalExpression node) {
    Expression condition = node.condition;
    safelyVisit(condition);
    Expression thenExpression = node.thenExpression;
    if (thenExpression != null) {
      _overrideManager.enterScope();
      try {
        _promoteManager.enterScope();
        try {
          _propagateTrueState(condition);
          _promoteTypes(condition);
          _clearTypePromotionsIfPotentiallyMutatedIn(thenExpression);
          _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(thenExpression);
          thenExpression.accept(this);
        } finally {
          _promoteManager.exitScope();
        }
      } finally {
        _overrideManager.exitScope();
      }
    }
    Expression elseExpression = node.elseExpression;
    if (elseExpression != null) {
      _overrideManager.enterScope();
      try {
        _propagateFalseState(condition);
        elseExpression.accept(this);
      } finally {
        _overrideManager.exitScope();
      }
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    bool thenIsAbrupt = _isAbruptTerminationExpression(thenExpression);
    bool elseIsAbrupt = _isAbruptTerminationExpression(elseExpression);
    if (elseIsAbrupt && !thenIsAbrupt) {
      _propagateTrueState(condition);
      _propagateState(thenExpression);
    } else if (thenIsAbrupt && !elseIsAbrupt) {
      _propagateFalseState(condition);
      _propagateState(elseExpression);
    }
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      _enclosingFunction = node.element;
      super.visitConstructorDeclaration(node);
    } finally {
      _enclosingFunction = outerFunction;
    }
    return null;
  }
  Object visitConstructorFieldInitializer(ConstructorFieldInitializer node) {
    safelyVisit(node.expression);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitConstructorName(ConstructorName node) {
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitContinueStatement(ContinueStatement node) {
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitDoStatement(DoStatement node) {
    _overrideManager.enterScope();
    try {
      super.visitDoStatement(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitEmptyFunctionBody(EmptyFunctionBody node) {
    safelyVisit(_commentBeforeFunction);
    return super.visitEmptyFunctionBody(node);
  }
  Object visitEnumDeclaration(EnumDeclaration node) {
    if (node.metadata != null) {
      node.metadata.accept(this);
    }
    return null;
  }
  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {
    safelyVisit(_commentBeforeFunction);
    _overrideManager.enterScope();
    try {
      super.visitExpressionFunctionBody(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitFieldDeclaration(FieldDeclaration node) {
    _overrideManager.enterScope();
    try {
      super.visitFieldDeclaration(node);
    } finally {
      A_p.HashMap<A_Element, DartType> overrides = _overrideManager.captureOverrides(node.fields);
      _overrideManager.exitScope();
      _overrideManager.applyOverrides(overrides);
    }
    return null;
  }
  Object visitForEachStatement(ForEachStatement node) {
    _overrideManager.enterScope();
    try {
      super.visitForEachStatement(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitForStatement(ForStatement node) {
    _overrideManager.enterScope();
    try {
      super.visitForStatement(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      SimpleIdentifier functionName = node.name;
      _enclosingFunction = functionName.staticElement as ExecutableElement;
      super.visitFunctionDeclaration(node);
    } finally {
      _enclosingFunction = outerFunction;
    }
    return null;
  }
  Object visitFunctionExpression(FunctionExpression node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      _enclosingFunction = node.element;
      _overrideManager.enterScope();
      try {
        super.visitFunctionExpression(node);
      } finally {
        _overrideManager.exitScope();
      }
    } finally {
      _enclosingFunction = outerFunction;
    }
    return null;
  }
  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    safelyVisit(node.function);
    node.accept(_elementResolver);
    _inferFunctionExpressionsParametersTypes(node.argumentList);
    safelyVisit(node.argumentList);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    if (node.metadata != null) {
      node.metadata.accept(this);
    }
    FunctionTypeAlias outerAlias = _enclosingFunctionTypeAlias;
    _enclosingFunctionTypeAlias = node;
    try {
      super.visitFunctionTypeAlias(node);
    } finally {
      _enclosingFunctionTypeAlias = outerAlias;
    }
    return null;
  }
  Object visitHideCombinator(HideCombinator node) => null;
  Object visitIfStatement(IfStatement node) {
    Expression condition = node.condition;
    safelyVisit(condition);
    A_p.HashMap<A_Element, DartType> thenOverrides = null;
    Statement thenStatement = node.thenStatement;
    if (thenStatement != null) {
      _overrideManager.enterScope();
      try {
        _promoteManager.enterScope();
        try {
          _propagateTrueState(condition);
          _promoteTypes(condition);
          _clearTypePromotionsIfPotentiallyMutatedIn(thenStatement);
          _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(thenStatement);
          visitStatementInScope(thenStatement);
        } finally {
          _promoteManager.exitScope();
        }
      } finally {
        thenOverrides = _overrideManager.captureLocalOverrides();
        _overrideManager.exitScope();
      }
    }
    A_p.HashMap<A_Element, DartType> elseOverrides = null;
    Statement elseStatement = node.elseStatement;
    if (elseStatement != null) {
      _overrideManager.enterScope();
      try {
        _propagateFalseState(condition);
        visitStatementInScope(elseStatement);
      } finally {
        elseOverrides = _overrideManager.captureLocalOverrides();
        _overrideManager.exitScope();
      }
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    bool thenIsAbrupt = _isAbruptTerminationStatement(thenStatement);
    bool elseIsAbrupt = _isAbruptTerminationStatement(elseStatement);
    if (elseIsAbrupt && !thenIsAbrupt) {
      _propagateTrueState(condition);
      if (thenOverrides != null) {
        _overrideManager.applyOverrides(thenOverrides);
      }
    } else if (thenIsAbrupt && !elseIsAbrupt) {
      _propagateFalseState(condition);
      if (elseOverrides != null) {
        _overrideManager.applyOverrides(elseOverrides);
      }
    }
    return null;
  }
  Object visitLabel(Label node) => null;
  Object visitLibraryIdentifier(LibraryIdentifier node) => null;
  Object visitMethodDeclaration(MethodDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      _enclosingFunction = node.element;
      super.visitMethodDeclaration(node);
    } finally {
      _enclosingFunction = outerFunction;
    }
    return null;
  }
  Object visitMethodInvocation(MethodInvocation node) {
    safelyVisit(node.target);
    node.accept(_elementResolver);
    _inferFunctionExpressionsParametersTypes(node.argumentList);
    safelyVisit(node.argumentList);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitNode(AstNode node) {
    node.visitChildren(this);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    safelyVisit(node.prefix);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitPropertyAccess(PropertyAccess node) {
    safelyVisit(node.target);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitRedirectingConstructorInvocation(RedirectingConstructorInvocation node) {
    safelyVisit(node.argumentList);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitShowCombinator(ShowCombinator node) => null;
  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {
    safelyVisit(node.argumentList);
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  Object visitSwitchCase(SwitchCase node) {
    _overrideManager.enterScope();
    try {
      super.visitSwitchCase(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitSwitchDefault(SwitchDefault node) {
    _overrideManager.enterScope();
    try {
      super.visitSwitchDefault(node);
    } finally {
      _overrideManager.exitScope();
    }
    return null;
  }
  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    _overrideManager.enterScope();
    try {
      super.visitTopLevelVariableDeclaration(node);
    } finally {
      A_p.HashMap<A_Element, DartType> overrides = _overrideManager.captureOverrides(node.variables);
      _overrideManager.exitScope();
      _overrideManager.applyOverrides(overrides);
    }
    return null;
  }
  Object visitTypeName(TypeName node) => null;
  Object visitWhileStatement(WhileStatement node) {
    Expression condition = node.condition;
    safelyVisit(condition);
    Statement body = node.body;
    if (body != null) {
      _overrideManager.enterScope();
      try {
        _propagateTrueState(condition);
        visitStatementInScope(body);
      } finally {
        _overrideManager.exitScope();
      }
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
    return null;
  }
  ClassElement get enclosingClass => _enclosingClass;
  ExecutableElement get enclosingFunction => _enclosingFunction;
  VariableElement getOverridablePropagatedElement(Expression expression) {
    A_Element A_element = null;
    if (expression is SimpleIdentifier) {
      A_element = expression.propagatedElement;
    } else if (expression is PrefixedIdentifier) {
      A_element = expression.propagatedElement;
    } else if (expression is PropertyAccess) {
      A_element = expression.propertyName.propagatedElement;
    }
    if (A_element is VariableElement) {
      return A_element as VariableElement;
    }
    return null;
  }
  VariableElement getOverridableStaticElement(Expression expression) {
    A_Element A_element = null;
    if (expression is SimpleIdentifier) {
      A_element = expression.staticElement;
    } else if (expression is PrefixedIdentifier) {
      A_element = expression.staticElement;
    } else if (expression is PropertyAccess) {
      A_element = expression.propertyName.staticElement;
    }
    if (A_element is VariableElement) {
      return A_element as VariableElement;
    }
    return null;
  }
  VariableElement getPromotionStaticElement(Expression expression) {
    while (expression is ParenthesizedExpression) {
      expression = (expression as ParenthesizedExpression).expression;
    }
    if (expression is! SimpleIdentifier) {
      return null;
    }
    SimpleIdentifier identifier = expression as SimpleIdentifier;
    A_Element A_element = identifier.staticElement;
    if (A_element is! VariableElement) {
      return null;
    }
    A_ElementKind kind = A_element.kind;
    if (kind == A_ElementKind.B_LOCAL_VARIABLE) {
      return A_element as VariableElement;
    }
    if (kind == A_ElementKind.E_PARAMETER) {
      return A_element as VariableElement;
    }
    return null;
  }
  void overrideExpression(Expression expression, DartType potentialType) {
    VariableElement A_element = getOverridableStaticElement(expression);
    if (A_element != null) {
      overrideVariable(A_element, potentialType);
    }
    A_element = getOverridablePropagatedElement(expression);
    if (A_element != null) {
      overrideVariable(A_element, potentialType);
    }
  }
  void overrideVariable(VariableElement A_element, DartType potentialType) {
    if (potentialType == null || potentialType.isBottom) {
      return;
    }
    DartType currentType = _getBestType(A_element);
    if (currentType == null || !currentType.isMoreSpecificThan(potentialType)) {
      if (A_element is PropertyInducingElement) {
        PropertyInducingElement variable = A_element;
        if (!variable.isConst && !variable.isFinal) {
          return;
        }
        (variable as PropertyInducingElementImpl).propagatedType = potentialType;
      }
      _overrideManager.setType(A_element, potentialType);
    }
  }
  void visitForEachStatementInScope(ForEachStatement node) {
    Expression A_iterator = node.iterator;
    safelyVisit(A_iterator);
    DeclaredIdentifier loopVariable = node.loopVariable;
    SimpleIdentifier identifier = node.identifier;
    safelyVisit(loopVariable);
    safelyVisit(identifier);
    Statement body = node.body;
    if (body != null) {
      _overrideManager.enterScope();
      try {
        if (loopVariable != null && A_iterator != null) {
          LocalVariableElement loopElement = loopVariable.element;
          if (loopElement != null) {
            DartType iteratorElementType = _getIteratorElementType(A_iterator);
            overrideVariable(loopElement, iteratorElementType);
            _recordPropagatedType(loopVariable.identifier, iteratorElementType);
          }
        } else if (identifier != null && A_iterator != null) {
          A_Element identifierElement = identifier.staticElement;
          if (identifierElement is VariableElement) {
            DartType iteratorElementType = _getIteratorElementType(A_iterator);
            overrideVariable(identifierElement, iteratorElementType);
            _recordPropagatedType(identifier, iteratorElementType);
          }
        }
        visitStatementInScope(body);
      } finally {
        _overrideManager.exitScope();
      }
    }
    node.accept(_elementResolver);
    node.accept(_typeAnalyzer);
  }
  void visitForStatementInScope(ForStatement node) {
    safelyVisit(node.variables);
    safelyVisit(node.initialization);
    safelyVisit(node.condition);
    _overrideManager.enterScope();
    try {
      _propagateTrueState(node.condition);
      visitStatementInScope(node.body);
      node.updaters.accept(this);
    } finally {
      _overrideManager.exitScope();
    }
  }
  void _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(AstNode A_target) {
    for (A_Element A_element in _promoteManager.promotedElements) {
      if ((A_element as VariableElementImpl).isPotentiallyMutatedInScope) {
        if (_isVariableAccessedInClosure(A_element, A_target)) {
          _promoteManager.setType(A_element, null);
        }
      }
    }
  }
  void _clearTypePromotionsIfPotentiallyMutatedIn(AstNode A_target) {
    for (A_Element A_element in _promoteManager.promotedElements) {
      if (_isVariablePotentiallyMutatedIn(A_element, A_target)) {
        _promoteManager.setType(A_element, null);
      }
    }
  }
  DartType _getBestType(A_Element A_element) {
    DartType bestType = _overrideManager.getType(A_element);
    if (bestType == null) {
      if (A_element is LocalVariableElement) {
        bestType = A_element.type;
      } else if (A_element is ParameterElement) {
        bestType = A_element.type;
      }
    }
    return bestType;
  }
  DartType _getIteratorElementType(Expression iteratorExpression) {
    DartType expressionType = iteratorExpression.bestType;
    if (expressionType is InterfaceType) {
      InterfaceType interfaceType = expressionType;
      FunctionType iteratorFunction = _inheritanceManager.lookupMemberType(interfaceType, "iterator");
      if (iteratorFunction == null) {
        return null;
      }
      DartType iteratorType = iteratorFunction.returnType;
      if (iteratorType is InterfaceType) {
        InterfaceType iteratorInterfaceType = iteratorType;
        FunctionType currentFunction = _inheritanceManager.lookupMemberType(iteratorInterfaceType, "current");
        if (currentFunction == null) {
          return null;
        }
        return currentFunction.returnType;
      }
    }
    return null;
  }
  void _inferFunctionExpressionParametersTypes(Expression mayBeClosure, DartType mayByFunctionType) {
    if (mayBeClosure is! FunctionExpression) {
      return;
    }
    FunctionExpression closure = mayBeClosure as FunctionExpression;
    if (mayByFunctionType is! FunctionType) {
      return;
    }
    FunctionType expectedClosureType = mayByFunctionType as FunctionType;
    DartType staticClosureType = (closure.element != null ? closure.element.type : null) as DartType;
    if (staticClosureType != null && !expectedClosureType.isMoreSpecificThan(staticClosureType)) {
      return;
    }
    closure.propagatedType = expectedClosureType;
    NodeList<FormalParameter> A_parameters = closure.parameters.parameters;
    List<ParameterElement> expectedParameters = expectedClosureType.parameters;
    for (int i = 0; i < A_parameters.length && i < expectedParameters.length; i++) {
      FormalParameter parameter = A_parameters[i];
      ParameterElement A_element = parameter.element;
      DartType currentType = _getBestType(A_element);
      DartType expectedType = expectedParameters[i].type;
      if (currentType == null || expectedType.isMoreSpecificThan(currentType)) {
        _overrideManager.setType(A_element, expectedType);
      }
    }
  }
  void _inferFunctionExpressionsParametersTypes(ArgumentList argumentList) {
    for (Expression argument in argumentList.arguments) {
      ParameterElement parameter = argument.propagatedParameterElement;
      if (parameter == null) {
        parameter = argument.staticParameterElement;
      }
      if (parameter != null) {
        _inferFunctionExpressionParametersTypes(argument, parameter.type);
      }
    }
  }
  bool _isAbruptTerminationExpression(Expression expression) {
    while (expression is ParenthesizedExpression) {
      expression = (expression as ParenthesizedExpression).expression;
    }
    return expression is ThrowExpression || expression is RethrowExpression;
  }
  bool _isAbruptTerminationStatement(Statement statement) {
    if (statement is ReturnStatement) {
      return true;
    } else if (statement is ExpressionStatement) {
      return _isAbruptTerminationExpression(statement.expression);
    } else if (statement is Block) {
      NodeList<Statement> statements = statement.statements;
      int A_size = statements.length;
      if (A_size == 0) {
        return false;
      }
      return _isAbruptTerminationStatement(statements[A_size - 1]);
    }
    return false;
  }
  bool _isVariableAccessedInClosure(A_Element variable, AstNode A_target) {
    List<bool> result = [false];
    A_target.accept(new RecursiveAstVisitor_ResolverVisitor_isVariableAccessedInClosure(result, variable));
    return result[0];
  }
  bool _isVariablePotentiallyMutatedIn(A_Element variable, AstNode A_target) {
    List<bool> result = [false];
    A_target.accept(new RecursiveAstVisitor_ResolverVisitor_isVariablePotentiallyMutatedIn(result, variable));
    return result[0];
  }
  void _promote(Expression expression, DartType potentialType) {
    VariableElement A_element = getPromotionStaticElement(expression);
    if (A_element != null) {
      if ((A_element as VariableElementImpl).isPotentiallyMutatedInClosure) {
        return;
      }
      DartType A_type = _promoteManager.getType(A_element);
      if (A_type == null) {
        A_type = expression.staticType;
      }
      if (A_type == null || A_type.isDynamic) {
        return;
      }
      if (potentialType == null || potentialType.isDynamic) {
        return;
      }
      if (!potentialType.isMoreSpecificThan(A_type)) {
        return;
      }
      _promoteManager.setType(A_element, potentialType);
    }
  }
  void _promoteTypes(Expression condition) {
    if (condition is BinaryExpression) {
      BinaryExpression binary = condition;
      if (binary.operator.type == A_TokenType.AMPERSAND_AMPERSAND) {
        Expression A_left = binary.leftOperand;
        Expression A_right = binary.rightOperand;
        _promoteTypes(A_left);
        _promoteTypes(A_right);
        _clearTypePromotionsIfPotentiallyMutatedIn(A_right);
      }
    } else if (condition is IsExpression) {
      IsExpression is2 = condition;
      if (is2.notOperator == null) {
        _promote(is2.expression, is2.type.type);
      }
    } else if (condition is ParenthesizedExpression) {
      _promoteTypes(condition.expression);
    }
  }
  void _propagateFalseState(Expression condition) {
    if (condition is BinaryExpression) {
      BinaryExpression binary = condition;
      if (binary.operator.type == A_TokenType.BAR_BAR) {
        _propagateFalseState(binary.leftOperand);
        _propagateFalseState(binary.rightOperand);
      }
    } else if (condition is IsExpression) {
      IsExpression is2 = condition;
      if (is2.notOperator != null) {
        overrideExpression(is2.expression, is2.type.type);
      }
    } else if (condition is PrefixExpression) {
      PrefixExpression prefix = condition;
      if (prefix.operator.type == A_TokenType.BANG) {
        _propagateTrueState(prefix.operand);
      }
    } else if (condition is ParenthesizedExpression) {
      _propagateFalseState(condition.expression);
    }
  }
  void _propagateState(Expression expression) {}
  void _propagateTrueState(Expression condition) {
    if (condition is BinaryExpression) {
      BinaryExpression binary = condition;
      if (binary.operator.type == A_TokenType.AMPERSAND_AMPERSAND) {
        _propagateTrueState(binary.leftOperand);
        _propagateTrueState(binary.rightOperand);
      }
    } else if (condition is IsExpression) {
      IsExpression is2 = condition;
      if (is2.notOperator == null) {
        overrideExpression(is2.expression, is2.type.type);
      }
    } else if (condition is PrefixExpression) {
      PrefixExpression prefix = condition;
      if (prefix.operator.type == A_TokenType.BANG) {
        _propagateFalseState(prefix.operand);
      }
    } else if (condition is ParenthesizedExpression) {
      _propagateTrueState(condition.expression);
    }
  }
  void _recordPropagatedType(Expression expression, DartType A_type) {
    if (A_type != null && !A_type.isDynamic) {
      expression.propagatedType = A_type;
    }
  }
}
abstract class Scope {
  static int PRIVATE_NAME_PREFIX = 0x5F;
  static String UNARY_MINUS = "unary-";
  static bool A_isPrivateName(String A_name) => A_name != null && StringUtilities.startsWithChar(A_name, PRIVATE_NAME_PREFIX);
  A_p.HashMap<String, A_Element> _definedNames = new A_p.HashMap<String,A_Element>();
  bool _hasName = false;
  void define(A_Element A_element) {
    String A_name = _getName(A_element);
    if (A_name != null && !A_name.isEmpty) {
      if (_definedNames.containsKey(A_name)) {
        errorListener.onError(getErrorForDuplicate(_definedNames[A_name], A_element));
      } else {
        _definedNames[A_name] = A_element;
        _hasName = true;
      }
    }
  }
  Scope get enclosingScope => null;
  A_Element lookup(Identifier identifier, LibraryElement referencingLibrary) => internalLookup(identifier, identifier.name, referencingLibrary);
  void defineNameWithoutChecking(String A_name, A_Element A_element) {
    _definedNames[A_name] = A_element;
    _hasName = true;
  }
  A_AnalysisError getErrorForDuplicate(A_Element existing, A_Element duplicate) {
    Source A_source = duplicate.source;
    return new A_AnalysisError.D_con2(A_source, duplicate.nameOffset, duplicate.displayName.length, CompileTimeErrorCode.DUPLICATE_DEFINITION, [existing.displayName]);
  }
  AnalysisErrorListener get errorListener;
  Source getSource(AstNode node) {
    CompilationUnit unit = node.getAncestor((node) => node is CompilationUnit);
    if (unit != null) {
      CompilationUnitElement unitElement = unit.element;
      if (unitElement != null) {
        return unitElement.source;
      }
    }
    return null;
  }
  A_Element internalLookup(Identifier identifier, String A_name, LibraryElement referencingLibrary);
  A_Element localLookup(String A_name, LibraryElement referencingLibrary) {
    if (_hasName) {
      return _definedNames[A_name];
    }
    return null;
  }
  String _getName(A_Element A_element) {
    if (A_element is MethodElement) {
      MethodElement A_method = A_element;
      if (A_method.name == "-" && A_method.parameters.length == 0) {
        return UNARY_MINUS;
      }
    }
    return A_element.name;
  }
}
class ScopeBuilder {
  static Scope scopeFor(AstNode node, AnalysisErrorListener errorListener) {
    if (node == null) {
      throw new AnalysisException("Cannot create scope: node is null");
    } else if (node is CompilationUnit) {
      ScopeBuilder A_builder = new ScopeBuilder(errorListener);
      return A_builder._scopeForAstNode(node);
    }
    AstNode A_parent = node.parent;
    if (A_parent == null) {
      throw new AnalysisException("Cannot create scope: node is not part of a CompilationUnit");
    }
    ScopeBuilder A_builder = new ScopeBuilder(errorListener);
    return A_builder._scopeForAstNode(A_parent);
  }
  final AnalysisErrorListener D__errorListener;
  ScopeBuilder(this.D__errorListener);
  Scope _scopeForAstNode(AstNode node) {
    if (node is CompilationUnit) {
      return _scopeForCompilationUnit(node);
    }
    AstNode A_parent = node.parent;
    if (A_parent == null) {
      throw new AnalysisException("Cannot create scope: node is not part of a CompilationUnit");
    }
    Scope scope = _scopeForAstNode(A_parent);
    if (node is ClassDeclaration) {
      ClassElement A_element = node.element;
      if (A_element == null) {
        throw new AnalysisException("Cannot build a scope for an unresolved class");
      }
      scope = new ClassScope(new TypeParameterScope(scope, A_element), A_element);
    } else if (node is ClassTypeAlias) {
      ClassElement A_element = node.element;
      if (A_element == null) {
        throw new AnalysisException("Cannot build a scope for an unresolved class type alias");
      }
      scope = new ClassScope(new TypeParameterScope(scope, A_element), A_element);
    } else if (node is ConstructorDeclaration) {
      ConstructorElement A_element = node.element;
      if (A_element == null) {
        throw new AnalysisException("Cannot build a scope for an unresolved constructor");
      }
      FunctionScope functionScope = new FunctionScope(scope, A_element);
      functionScope.defineParameters();
      scope = functionScope;
    } else if (node is FunctionDeclaration) {
      ExecutableElement A_element = node.element;
      if (A_element == null) {
        throw new AnalysisException("Cannot build a scope for an unresolved function");
      }
      FunctionScope functionScope = new FunctionScope(scope, A_element);
      functionScope.defineParameters();
      scope = functionScope;
    } else if (node is FunctionTypeAlias) {
      scope = new FunctionTypeScope(scope, node.element);
    } else if (node is MethodDeclaration) {
      ExecutableElement A_element = node.element;
      if (A_element == null) {
        throw new AnalysisException("Cannot build a scope for an unresolved method");
      }
      FunctionScope functionScope = new FunctionScope(scope, A_element);
      functionScope.defineParameters();
      scope = functionScope;
    }
    return scope;
  }
  Scope _scopeForCompilationUnit(CompilationUnit node) {
    CompilationUnitElement unitElement = node.element;
    if (unitElement == null) {
      throw new AnalysisException("Cannot create scope: compilation unit is not resolved");
    }
    LibraryElement libraryElement = unitElement.library;
    if (libraryElement == null) {
      throw new AnalysisException("Cannot create scope: compilation unit is not part of a library");
    }
    return new LibraryScope(libraryElement, D__errorListener);
  }
}
abstract class ScopedVisitor extends UnifyingAstVisitor<Object> {
  LibraryElement _definingLibrary;
  final Source source;
  AnalysisErrorListener D__errorListener;
  Scope A__nameScope;
  final TypeProvider typeProvider;
  LabelScope _labelScope;
  ScopedVisitor.G_con1(Library library, this.source, this.typeProvider) {
    this._definingLibrary = library.libraryElement;
    LibraryScope libraryScope = library.libraryScope;
    this.D__errorListener = libraryScope.errorListener;
    this.A__nameScope = libraryScope;
  }
  ScopedVisitor.G_con2(LibraryElement A_definingLibrary, this.source, this.typeProvider, AnalysisErrorListener errorListener) {
    this._definingLibrary = A_definingLibrary;
    this.D__errorListener = errorListener;
    this.A__nameScope = new LibraryScope(A_definingLibrary, errorListener);
  }
  ScopedVisitor.B_con3(LibraryElement A_definingLibrary, this.source, this.typeProvider, Scope A_nameScope, AnalysisErrorListener errorListener) {
    this._definingLibrary = A_definingLibrary;
    this.D__errorListener = errorListener;
    this.A__nameScope = A_nameScope;
  }
  ScopedVisitor.A_con4(ResolvableLibrary library, this.source, this.typeProvider) {
    this._definingLibrary = library.libraryElement;
    LibraryScope libraryScope = library.libraryScope;
    this.D__errorListener = libraryScope.errorListener;
    this.A__nameScope = libraryScope;
  }
  LibraryElement get definingLibrary => _definingLibrary;
  Scope popNameScope() {
    A__nameScope = A__nameScope.enclosingScope;
    return A__nameScope;
  }
  Scope pushNameScope() {
    Scope newScope = new EnclosedScope(A__nameScope);
    A__nameScope = newScope;
    return A__nameScope;
  }
  Object visitBlock(Block node) {
    Scope outerScope = A__nameScope;
    try {
      EnclosedScope enclosedScope = new EnclosedScope(A__nameScope);
      _hideNamesDefinedInBlock(enclosedScope, node);
      A__nameScope = enclosedScope;
      super.visitBlock(node);
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitCatchClause(CatchClause node) {
    SimpleIdentifier exception = node.exceptionParameter;
    if (exception != null) {
      Scope outerScope = A__nameScope;
      try {
        A__nameScope = new EnclosedScope(A__nameScope);
        A__nameScope.define(exception.staticElement);
        SimpleIdentifier A_stackTrace = node.stackTraceParameter;
        if (A_stackTrace != null) {
          A__nameScope.define(A_stackTrace.staticElement);
        }
        super.visitCatchClause(node);
      } finally {
        A__nameScope = outerScope;
      }
    } else {
      super.visitCatchClause(node);
    }
    return null;
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ClassElement classElement = node.element;
    Scope outerScope = A__nameScope;
    try {
      if (classElement == null) {
        AnalysisEngine.A_instance.logger.logInformation2("Missing element for class declaration ${node.name.name} in ${definingLibrary.source.fullName}", new JavaException());
        super.visitClassDeclaration(node);
      } else {
        A__nameScope = new TypeParameterScope(A__nameScope, classElement);
        visitClassDeclarationInScope(node);
        A__nameScope = new ClassScope(A__nameScope, classElement);
        visitClassMembersInScope(node);
      }
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    Scope outerScope = A__nameScope;
    try {
      ClassElement A_element = node.element;
      A__nameScope = new ClassScope(new TypeParameterScope(A__nameScope, A_element), A_element);
      super.visitClassTypeAlias(node);
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    ConstructorElement constructorElement = node.element;
    Scope outerScope = A__nameScope;
    try {
      if (constructorElement == null) {
        JavaStringBuilder A_builder = new JavaStringBuilder();
        A_builder.append("Missing element for constructor ");
        A_builder.append(node.returnType.name);
        if (node.name != null) {
          A_builder.append(".");
          A_builder.append(node.name.name);
        }
        A_builder.append(" in ");
        A_builder.append(definingLibrary.source.fullName);
        AnalysisEngine.A_instance.logger.logInformation2(A_builder.toString(), new JavaException());
      } else {
        A__nameScope = new FunctionScope(A__nameScope, constructorElement);
      }
      super.visitConstructorDeclaration(node);
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    VariableElement A_element = node.element;
    if (A_element != null) {
      A__nameScope.define(A_element);
    }
    super.visitDeclaredIdentifier(node);
    return null;
  }
  Object visitDoStatement(DoStatement node) {
    LabelScope outerLabelScope = _labelScope;
    try {
      _labelScope = new LabelScope.G_con1(_labelScope, false, false);
      visitStatementInScope(node.body);
      safelyVisit(node.condition);
    } finally {
      _labelScope = outerLabelScope;
    }
    return null;
  }
  Object visitForEachStatement(ForEachStatement node) {
    Scope outerNameScope = A__nameScope;
    LabelScope outerLabelScope = _labelScope;
    try {
      A__nameScope = new EnclosedScope(A__nameScope);
      _labelScope = new LabelScope.G_con1(outerLabelScope, false, false);
      visitForEachStatementInScope(node);
    } finally {
      _labelScope = outerLabelScope;
      A__nameScope = outerNameScope;
    }
    return null;
  }
  Object visitFormalParameterList(FormalParameterList node) {
    super.visitFormalParameterList(node);
    if (A__nameScope is FunctionScope) {
      (A__nameScope as FunctionScope).defineParameters();
    }
    if (A__nameScope is FunctionTypeScope) {
      (A__nameScope as FunctionTypeScope).defineParameters();
    }
    return null;
  }
  Object visitForStatement(ForStatement node) {
    Scope outerNameScope = A__nameScope;
    LabelScope outerLabelScope = _labelScope;
    try {
      A__nameScope = new EnclosedScope(A__nameScope);
      _labelScope = new LabelScope.G_con1(outerLabelScope, false, false);
      visitForStatementInScope(node);
    } finally {
      _labelScope = outerLabelScope;
      A__nameScope = outerNameScope;
    }
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    ExecutableElement functionElement = node.element;
    Scope outerScope = A__nameScope;
    try {
      if (functionElement == null) {
        AnalysisEngine.A_instance.logger.logInformation2("Missing element for top-level function ${node.name.name} in ${definingLibrary.source.fullName}", new JavaException());
      } else {
        A__nameScope = new FunctionScope(A__nameScope, functionElement);
      }
      super.visitFunctionDeclaration(node);
    } finally {
      A__nameScope = outerScope;
    }
    if (functionElement != null && functionElement.enclosingElement is! CompilationUnitElement) {
      A__nameScope.define(functionElement);
    }
    return null;
  }
  Object visitFunctionExpression(FunctionExpression node) {
    if (node.parent is FunctionDeclaration) {
      super.visitFunctionExpression(node);
    } else {
      Scope outerScope = A__nameScope;
      try {
        ExecutableElement functionElement = node.element;
        if (functionElement == null) {
          JavaStringBuilder A_builder = new JavaStringBuilder();
          A_builder.append("Missing element for function ");
          AstNode A_parent = node.parent;
          while (A_parent != null) {
            if (A_parent is Declaration) {
              A_Element parentElement = (A_parent as Declaration).element;
              A_builder.append(parentElement == null ? "<unknown> " : ("${parentElement.name} "));
            }
            A_parent = A_parent.parent;
          }
          A_builder.append("in ");
          A_builder.append(definingLibrary.source.fullName);
          AnalysisEngine.A_instance.logger.logInformation2(A_builder.toString(), new JavaException());
        } else {
          A__nameScope = new FunctionScope(A__nameScope, functionElement);
        }
        super.visitFunctionExpression(node);
      } finally {
        A__nameScope = outerScope;
      }
    }
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    Scope outerScope = A__nameScope;
    try {
      A__nameScope = new FunctionTypeScope(A__nameScope, node.element);
      super.visitFunctionTypeAlias(node);
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitIfStatement(IfStatement node) {
    safelyVisit(node.condition);
    visitStatementInScope(node.thenStatement);
    visitStatementInScope(node.elseStatement);
    return null;
  }
  Object visitLabeledStatement(LabeledStatement node) {
    LabelScope outerScope = _addScopesFor(node.labels);
    try {
      super.visitLabeledStatement(node);
    } finally {
      _labelScope = outerScope;
    }
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    Scope outerScope = A__nameScope;
    try {
      ExecutableElement methodElement = node.element;
      if (methodElement == null) {
        AnalysisEngine.A_instance.logger.logInformation2("Missing element for method ${node.name.name} in ${definingLibrary.source.fullName}", new JavaException());
      } else {
        A__nameScope = new FunctionScope(A__nameScope, methodElement);
      }
      super.visitMethodDeclaration(node);
    } finally {
      A__nameScope = outerScope;
    }
    return null;
  }
  Object visitSwitchCase(SwitchCase node) {
    node.expression.accept(this);
    Scope outerNameScope = A__nameScope;
    try {
      A__nameScope = new EnclosedScope(A__nameScope);
      node.statements.accept(this);
    } finally {
      A__nameScope = outerNameScope;
    }
    return null;
  }
  Object visitSwitchDefault(SwitchDefault node) {
    Scope outerNameScope = A__nameScope;
    try {
      A__nameScope = new EnclosedScope(A__nameScope);
      node.statements.accept(this);
    } finally {
      A__nameScope = outerNameScope;
    }
    return null;
  }
  Object visitSwitchStatement(SwitchStatement node) {
    LabelScope outerScope = _labelScope;
    try {
      _labelScope = new LabelScope.G_con1(outerScope, true, false);
      for (SwitchMember member in node.members) {
        for (Label label in member.labels) {
          SimpleIdentifier labelName = label.label;
          LabelElement labelElement = labelName.staticElement as LabelElement;
          _labelScope = new LabelScope.G_con2(_labelScope, labelName.name, labelElement);
        }
      }
      super.visitSwitchStatement(node);
    } finally {
      _labelScope = outerScope;
    }
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    super.visitVariableDeclaration(node);
    if (node.parent.parent is! TopLevelVariableDeclaration && node.parent.parent is! FieldDeclaration) {
      VariableElement A_element = node.element;
      if (A_element != null) {
        A__nameScope.define(A_element);
      }
    }
    return null;
  }
  Object visitWhileStatement(WhileStatement node) {
    LabelScope outerScope = _labelScope;
    try {
      _labelScope = new LabelScope.G_con1(outerScope, false, false);
      safelyVisit(node.condition);
      visitStatementInScope(node.body);
    } finally {
      _labelScope = outerScope;
    }
    return null;
  }
  LabelScope get labelScope => _labelScope;
  Scope get nameScope => A__nameScope;
  void reportErrorForNode(ErrorCode A_errorCode, AstNode node, List<Object> A_arguments) {
    D__errorListener.onError(new A_AnalysisError.D_con2(source, node.offset, node.length, A_errorCode, A_arguments));
  }
  void reportErrorForOffset(ErrorCode A_errorCode, int A_offset, int A_length, List<Object> A_arguments) {
    D__errorListener.onError(new A_AnalysisError.D_con2(source, A_offset, A_length, A_errorCode, A_arguments));
  }
  void reportErrorForToken(ErrorCode A_errorCode, A_Token token, List<Object> A_arguments) {
    D__errorListener.onError(new A_AnalysisError.D_con2(source, token.offset, token.length, A_errorCode, A_arguments));
  }
  void safelyVisit(AstNode node) {
    if (node != null) {
      node.accept(this);
    }
  }
  void visitClassDeclarationInScope(ClassDeclaration node) {
    safelyVisit(node.name);
    safelyVisit(node.typeParameters);
    safelyVisit(node.extendsClause);
    safelyVisit(node.withClause);
    safelyVisit(node.implementsClause);
    safelyVisit(node.nativeClause);
  }
  void visitClassMembersInScope(ClassDeclaration node) {
    safelyVisit(node.documentationComment);
    node.metadata.accept(this);
    node.members.accept(this);
  }
  void visitForEachStatementInScope(ForEachStatement node) {
    safelyVisit(node.identifier);
    safelyVisit(node.iterator);
    safelyVisit(node.loopVariable);
    visitStatementInScope(node.body);
  }
  void visitForStatementInScope(ForStatement node) {
    safelyVisit(node.variables);
    safelyVisit(node.initialization);
    safelyVisit(node.condition);
    node.updaters.accept(this);
    visitStatementInScope(node.body);
  }
  void visitStatementInScope(Statement node) {
    if (node is Block) {
      visitBlock(node);
    } else if (node != null) {
      Scope outerNameScope = A__nameScope;
      try {
        A__nameScope = new EnclosedScope(A__nameScope);
        node.accept(this);
      } finally {
        A__nameScope = outerNameScope;
      }
    }
  }
  LabelScope _addScopesFor(NodeList<Label> labels) {
    LabelScope outerScope = _labelScope;
    for (Label label in labels) {
      SimpleIdentifier labelNameNode = label.label;
      String labelName = labelNameNode.name;
      LabelElement labelElement = labelNameNode.staticElement as LabelElement;
      _labelScope = new LabelScope.G_con2(_labelScope, labelName, labelElement);
    }
    return outerScope;
  }
  void _hideNamesDefinedInBlock(EnclosedScope scope, Block block) {
    NodeList<Statement> statements = block.statements;
    int statementCount = statements.length;
    for (int i = 0; i < statementCount; i++) {
      Statement statement = statements[i];
      if (statement is VariableDeclarationStatement) {
        VariableDeclarationStatement vds = statement;
        NodeList<VariableDeclaration> variables = vds.variables.variables;
        int variableCount = variables.length;
        for (int j = 0; j < variableCount; j++) {
          scope.hide(variables[j].element);
        }
      } else if (statement is FunctionDeclarationStatement) {
        FunctionDeclarationStatement fds = statement;
        scope.hide(fds.functionDeclaration.element);
      }
    }
  }
}
class StaticTypeAnalyzer extends SimpleAstVisitor<Object> {
  static A_p.HashMap<String, String> _createHtmlTagToClassMap() {
    A_p.HashMap<String, String> A_map = new A_p.HashMap<String,String>();
    A_map["a"] = "AnchorElement";
    A_map["area"] = "AreaElement";
    A_map["br"] = "BRElement";
    A_map["base"] = "BaseElement";
    A_map["body"] = "BodyElement";
    A_map["button"] = "ButtonElement";
    A_map["canvas"] = "CanvasElement";
    A_map["content"] = "ContentElement";
    A_map["dl"] = "DListElement";
    A_map["datalist"] = "DataListElement";
    A_map["details"] = "DetailsElement";
    A_map["div"] = "DivElement";
    A_map["embed"] = "EmbedElement";
    A_map["fieldset"] = "FieldSetElement";
    A_map["form"] = "FormElement";
    A_map["hr"] = "HRElement";
    A_map["head"] = "HeadElement";
    A_map["h1"] = "HeadingElement";
    A_map["h2"] = "HeadingElement";
    A_map["h3"] = "HeadingElement";
    A_map["h4"] = "HeadingElement";
    A_map["h5"] = "HeadingElement";
    A_map["h6"] = "HeadingElement";
    A_map["html"] = "HtmlElement";
    A_map["iframe"] = "IFrameElement";
    A_map["img"] = "ImageElement";
    A_map["input"] = "InputElement";
    A_map["keygen"] = "KeygenElement";
    A_map["li"] = "LIElement";
    A_map["label"] = "LabelElement";
    A_map["legend"] = "LegendElement";
    A_map["link"] = "LinkElement";
    A_map["map"] = "MapElement";
    A_map["menu"] = "MenuElement";
    A_map["meter"] = "MeterElement";
    A_map["ol"] = "OListElement";
    A_map["object"] = "ObjectElement";
    A_map["optgroup"] = "OptGroupElement";
    A_map["output"] = "OutputElement";
    A_map["p"] = "ParagraphElement";
    A_map["param"] = "ParamElement";
    A_map["pre"] = "PreElement";
    A_map["progress"] = "ProgressElement";
    A_map["script"] = "ScriptElement";
    A_map["select"] = "SelectElement";
    A_map["source"] = "SourceElement";
    A_map["span"] = "SpanElement";
    A_map["style"] = "StyleElement";
    A_map["caption"] = "TableCaptionElement";
    A_map["td"] = "TableCellElement";
    A_map["col"] = "TableColElement";
    A_map["table"] = "TableElement";
    A_map["tr"] = "TableRowElement";
    A_map["textarea"] = "TextAreaElement";
    A_map["title"] = "TitleElement";
    A_map["track"] = "TrackElement";
    A_map["ul"] = "UListElement";
    A_map["video"] = "VideoElement";
    return A_map;
  }
  final ResolverVisitor A__resolver;
  TypeProvider B__typeProvider;
  DartType _dynamicType;
  InterfaceType _thisType;
  TypeOverrideManager _overrideManager;
  TypePromotionManager _promoteManager;
  A_p.HashMap<ExecutableElement, DartType> _propagatedReturnTypes = new A_p.HashMap<ExecutableElement,DartType>();
  static A_p.HashMap<String, String> _HTML_ELEMENT_TO_CLASS_MAP = _createHtmlTagToClassMap();
  StaticTypeAnalyzer(this.A__resolver) {
    B__typeProvider = A__resolver.typeProvider;
    _dynamicType = B__typeProvider.dynamicType;
    _overrideManager = A__resolver.overrideManager;
    _promoteManager = A__resolver.promoteManager;
  }
  void set thisType(InterfaceType A_thisType) {
    this._thisType = A_thisType;
  }
  Object visitAdjacentStrings(AdjacentStrings node) {
    _recordStaticType(node, B__typeProvider.stringType);
    return null;
  }
  Object visitAsExpression(AsExpression node) {
    _recordStaticType(node, A__getType(node.type));
    return null;
  }
  Object visitAssignmentExpression(AssignmentExpression node) {
    A_TokenType operator = node.operator.type;
    if (operator == A_TokenType.A_EQ) {
      Expression rightHandSide = node.rightHandSide;
      DartType staticType = _getStaticType(rightHandSide);
      _recordStaticType(node, staticType);
      DartType overrideType = staticType;
      DartType propagatedType = rightHandSide.propagatedType;
      if (propagatedType != null) {
        if (propagatedType.isMoreSpecificThan(staticType)) {
          _recordPropagatedType(node, propagatedType);
        }
        overrideType = propagatedType;
      }
      A__resolver.overrideExpression(node.leftHandSide, overrideType);
    } else {
      ExecutableElement staticMethodElement = node.staticElement;
      DartType staticType = _computeStaticReturnType(staticMethodElement);
      _recordStaticType(node, staticType);
      MethodElement propagatedMethodElement = node.propagatedElement;
      if (!identical(propagatedMethodElement, staticMethodElement)) {
        DartType propagatedType = _computeStaticReturnType(propagatedMethodElement);
        if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
          _recordPropagatedType(node, propagatedType);
        }
      }
    }
    return null;
  }
  Object visitBinaryExpression(BinaryExpression node) {
    ExecutableElement staticMethodElement = node.staticElement;
    DartType staticType = _computeStaticReturnType(staticMethodElement);
    staticType = _refineBinaryExpressionType(node, staticType);
    _recordStaticType(node, staticType);
    MethodElement propagatedMethodElement = node.propagatedElement;
    if (!identical(propagatedMethodElement, staticMethodElement)) {
      DartType propagatedType = _computeStaticReturnType(propagatedMethodElement);
      if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
        _recordPropagatedType(node, propagatedType);
      }
    }
    return null;
  }
  Object visitBooleanLiteral(BooleanLiteral node) {
    _recordStaticType(node, B__typeProvider.boolType);
    return null;
  }
  Object visitCascadeExpression(CascadeExpression node) {
    _recordStaticType(node, _getStaticType(node.target));
    _recordPropagatedType(node, node.target.propagatedType);
    return null;
  }
  Object visitConditionalExpression(ConditionalExpression node) {
    DartType staticThenType = _getStaticType(node.thenExpression);
    DartType staticElseType = _getStaticType(node.elseExpression);
    if (staticThenType == null) {
      staticThenType = _dynamicType;
    }
    if (staticElseType == null) {
      staticElseType = _dynamicType;
    }
    DartType staticType = staticThenType.getLeastUpperBound(staticElseType);
    if (staticType == null) {
      staticType = _dynamicType;
    }
    _recordStaticType(node, staticType);
    DartType propagatedThenType = node.thenExpression.propagatedType;
    DartType propagatedElseType = node.elseExpression.propagatedType;
    if (propagatedThenType != null || propagatedElseType != null) {
      if (propagatedThenType == null) {
        propagatedThenType = staticThenType;
      }
      if (propagatedElseType == null) {
        propagatedElseType = staticElseType;
      }
      DartType propagatedType = propagatedThenType.getLeastUpperBound(propagatedElseType);
      if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
        _recordPropagatedType(node, propagatedType);
      }
    }
    return null;
  }
  Object visitDoubleLiteral(DoubleLiteral node) {
    _recordStaticType(node, B__typeProvider.doubleType);
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    FunctionExpression A_function = node.functionExpression;
    ExecutableElementImpl functionElement = node.element as ExecutableElementImpl;
    functionElement.returnType = _computeStaticReturnTypeOfFunctionDeclaration(node);
    _recordPropagatedTypeOfFunction(functionElement, A_function.body);
    _recordStaticType(A_function, functionElement.type);
    return null;
  }
  Object visitFunctionExpression(FunctionExpression node) {
    if (node.parent is FunctionDeclaration) {
      return null;
    }
    ExecutableElementImpl functionElement = node.element as ExecutableElementImpl;
    functionElement.returnType = _computeStaticReturnTypeOfFunctionExpression(node);
    _recordPropagatedTypeOfFunction(functionElement, node.body);
    _recordStaticType(node, node.element.type);
    return null;
  }
  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {
    ExecutableElement staticMethodElement = node.staticElement;
    DartType staticStaticType = _computeStaticReturnType(staticMethodElement);
    _recordStaticType(node, staticStaticType);
    DartType staticPropagatedType = _computePropagatedReturnType(staticMethodElement);
    if (staticPropagatedType != null && (staticStaticType == null || staticPropagatedType.isMoreSpecificThan(staticStaticType))) {
      _recordPropagatedType(node, staticPropagatedType);
    }
    ExecutableElement propagatedMethodElement = node.propagatedElement;
    if (!identical(propagatedMethodElement, staticMethodElement)) {
      DartType propagatedStaticType = _computeStaticReturnType(propagatedMethodElement);
      if (propagatedStaticType != null && (staticStaticType == null || propagatedStaticType.isMoreSpecificThan(staticStaticType)) && (staticPropagatedType == null || propagatedStaticType.isMoreSpecificThan(staticPropagatedType))) {
        _recordPropagatedType(node, propagatedStaticType);
      }
      DartType propagatedPropagatedType = _computePropagatedReturnType(propagatedMethodElement);
      if (propagatedPropagatedType != null && (staticStaticType == null || propagatedPropagatedType.isMoreSpecificThan(staticStaticType)) && (staticPropagatedType == null || propagatedPropagatedType.isMoreSpecificThan(staticPropagatedType)) && (propagatedStaticType == null || propagatedPropagatedType.isMoreSpecificThan(propagatedStaticType))) {
        _recordPropagatedType(node, propagatedPropagatedType);
      }
    }
    return null;
  }
  Object visitIndexExpression(IndexExpression node) {
    if (node.inSetterContext()) {
      ExecutableElement staticMethodElement = node.staticElement;
      DartType staticType = _computeArgumentType(staticMethodElement);
      _recordStaticType(node, staticType);
      MethodElement propagatedMethodElement = node.propagatedElement;
      if (!identical(propagatedMethodElement, staticMethodElement)) {
        DartType propagatedType = _computeArgumentType(propagatedMethodElement);
        if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
          _recordPropagatedType(node, propagatedType);
        }
      }
    } else {
      ExecutableElement staticMethodElement = node.staticElement;
      DartType staticType = _computeStaticReturnType(staticMethodElement);
      _recordStaticType(node, staticType);
      MethodElement propagatedMethodElement = node.propagatedElement;
      if (!identical(propagatedMethodElement, staticMethodElement)) {
        DartType propagatedType = _computeStaticReturnType(propagatedMethodElement);
        if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
          _recordPropagatedType(node, propagatedType);
        }
      }
    }
    return null;
  }
  Object visitInstanceCreationExpression(InstanceCreationExpression node) {
    _recordStaticType(node, node.constructorName.type.type);
    ConstructorElement A_element = node.staticElement;
    if (A_element != null && "Element" == A_element.enclosingElement.name) {
      LibraryElement library = A_element.library;
      if (_isHtmlLibrary(library)) {
        String constructorName = A_element.name;
        if ("tag" == constructorName) {
          DartType A_returnType = _getFirstArgumentAsTypeWithMap(library, node.argumentList, _HTML_ELEMENT_TO_CLASS_MAP);
          if (A_returnType != null) {
            _recordPropagatedType(node, A_returnType);
          }
        } else {
          DartType A_returnType = _getElementNameAsType(library, constructorName, _HTML_ELEMENT_TO_CLASS_MAP);
          if (A_returnType != null) {
            _recordPropagatedType(node, A_returnType);
          }
        }
      }
    }
    return null;
  }
  Object visitIntegerLiteral(IntegerLiteral node) {
    _recordStaticType(node, B__typeProvider.intType);
    return null;
  }
  Object visitIsExpression(IsExpression node) {
    _recordStaticType(node, B__typeProvider.boolType);
    return null;
  }
  Object visitListLiteral(ListLiteral node) {
    DartType staticType = _dynamicType;
    TypeArgumentList typeArguments = node.typeArguments;
    if (typeArguments != null) {
      NodeList<TypeName> A_arguments = typeArguments.arguments;
      if (A_arguments != null && A_arguments.length == 1) {
        TypeName argumentTypeName = A_arguments[0];
        DartType argumentType = A__getType(argumentTypeName);
        if (argumentType != null) {
          staticType = argumentType;
        }
      }
    }
    _recordStaticType(node, B__typeProvider.listType.substitute4(<DartType>[staticType]));
    return null;
  }
  Object visitMapLiteral(MapLiteral node) {
    DartType staticKeyType = _dynamicType;
    DartType staticValueType = _dynamicType;
    TypeArgumentList typeArguments = node.typeArguments;
    if (typeArguments != null) {
      NodeList<TypeName> A_arguments = typeArguments.arguments;
      if (A_arguments != null && A_arguments.length == 2) {
        TypeName entryKeyTypeName = A_arguments[0];
        DartType entryKeyType = A__getType(entryKeyTypeName);
        if (entryKeyType != null) {
          staticKeyType = entryKeyType;
        }
        TypeName entryValueTypeName = A_arguments[1];
        DartType entryValueType = A__getType(entryValueTypeName);
        if (entryValueType != null) {
          staticValueType = entryValueType;
        }
      }
    }
    _recordStaticType(node, B__typeProvider.mapType.substitute4(<DartType>[staticKeyType, staticValueType]));
    return null;
  }
  Object visitMethodInvocation(MethodInvocation node) {
    SimpleIdentifier methodNameNode = node.methodName;
    A_Element staticMethodElement = methodNameNode.staticElement;
    if (staticMethodElement is LocalVariableElement) {
      LocalVariableElement variable = staticMethodElement;
      DartType staticType = variable.type;
      _recordStaticType(methodNameNode, staticType);
      DartType propagatedType = _overrideManager.getType(variable);
      if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
        _recordPropagatedType(methodNameNode, propagatedType);
      }
    }
    DartType staticStaticType = _computeStaticReturnType(staticMethodElement);
    _recordStaticType(node, staticStaticType);
    DartType staticPropagatedType = _computePropagatedReturnType(staticMethodElement);
    if (staticPropagatedType != null && (staticStaticType == null || staticPropagatedType.isMoreSpecificThan(staticStaticType))) {
      _recordPropagatedType(node, staticPropagatedType);
    }
    bool needPropagatedType = true;
    String methodName = methodNameNode.name;
    if (methodName == "then") {
      Expression A_target = node.realTarget;
      if (A_target != null) {
        DartType targetType = A_target.bestType;
        if (_isAsyncFutureType(targetType)) {
          NodeList<Expression> A_arguments = node.argumentList.arguments;
          if (A_arguments.length == 1) {
            Expression closureArg = A_arguments[0];
            if (closureArg is FunctionExpression) {
              FunctionExpression closureExpr = closureArg;
              DartType A_returnType = _computePropagatedReturnType(closureExpr.element);
              if (A_returnType != null) {
                InterfaceTypeImpl newFutureType;
                if (_isAsyncFutureType(A_returnType)) {
                  newFutureType = A_returnType as InterfaceTypeImpl;
                } else {
                  InterfaceType futureType = targetType as InterfaceType;
                  newFutureType = new InterfaceTypeImpl.B_con1(futureType.element);
                  newFutureType.typeArguments = <DartType>[A_returnType];
                }
                _recordPropagatedType(node, newFutureType);
                needPropagatedType = false;
                return null;
              }
            }
          }
        }
      }
    } else if (methodName == "\$dom_createEvent") {
      Expression A_target = node.realTarget;
      if (A_target != null) {
        DartType targetType = A_target.bestType;
        if (targetType is InterfaceType && (targetType.name == "HtmlDocument" || targetType.name == "Document")) {
          LibraryElement library = targetType.element.library;
          if (_isHtmlLibrary(library)) {
            DartType A_returnType = _getFirstArgumentAsType(library, node.argumentList);
            if (A_returnType != null) {
              _recordPropagatedType(node, A_returnType);
              needPropagatedType = false;
            }
          }
        }
      }
    } else if (methodName == "query") {
      Expression A_target = node.realTarget;
      if (A_target == null) {
        A_Element methodElement = methodNameNode.bestElement;
        if (methodElement != null) {
          LibraryElement library = methodElement.library;
          if (_isHtmlLibrary(library)) {
            DartType A_returnType = _getFirstArgumentAsQuery(library, node.argumentList);
            if (A_returnType != null) {
              _recordPropagatedType(node, A_returnType);
              needPropagatedType = false;
            }
          }
        }
      } else {
        DartType targetType = A_target.bestType;
        if (targetType is InterfaceType && (targetType.name == "HtmlDocument" || targetType.name == "Document")) {
          LibraryElement library = targetType.element.library;
          if (_isHtmlLibrary(library)) {
            DartType A_returnType = _getFirstArgumentAsQuery(library, node.argumentList);
            if (A_returnType != null) {
              _recordPropagatedType(node, A_returnType);
              needPropagatedType = false;
            }
          }
        }
      }
    } else if (methodName == "\$dom_createElement") {
      Expression A_target = node.realTarget;
      if (A_target != null) {
        DartType targetType = A_target.bestType;
        if (targetType is InterfaceType && (targetType.name == "HtmlDocument" || targetType.name == "Document")) {
          LibraryElement library = targetType.element.library;
          if (_isHtmlLibrary(library)) {
            DartType A_returnType = _getFirstArgumentAsQuery(library, node.argumentList);
            if (A_returnType != null) {
              _recordPropagatedType(node, A_returnType);
              needPropagatedType = false;
            }
          }
        }
      }
    } else if (methodName == "JS") {
      DartType A_returnType = _getFirstArgumentAsType(B__typeProvider.objectType.element.library, node.argumentList);
      if (A_returnType != null) {
        _recordPropagatedType(node, A_returnType);
        needPropagatedType = false;
      }
    } else if (methodName == "getContext") {
      Expression A_target = node.realTarget;
      if (A_target != null) {
        DartType targetType = A_target.bestType;
        if (targetType is InterfaceType && (targetType.name == "CanvasElement")) {
          NodeList<Expression> A_arguments = node.argumentList.arguments;
          if (A_arguments.length == 1) {
            Expression argument = A_arguments[0];
            if (argument is StringLiteral) {
              String A_value = argument.stringValue;
              if ("2d" == A_value) {
                PropertyAccessorElement getter = targetType.element.getGetter("context2D");
                if (getter != null) {
                  DartType A_returnType = getter.returnType;
                  if (A_returnType != null) {
                    _recordPropagatedType(node, A_returnType);
                    needPropagatedType = false;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (needPropagatedType) {
      A_Element propagatedElement = methodNameNode.propagatedElement;
      if (!identical(propagatedElement, staticMethodElement)) {
        DartType propagatedStaticType = _computeStaticReturnType(propagatedElement);
        if (propagatedStaticType != null && (staticStaticType == null || propagatedStaticType.isMoreSpecificThan(staticStaticType)) && (staticPropagatedType == null || propagatedStaticType.isMoreSpecificThan(staticPropagatedType))) {
          _recordPropagatedType(node, propagatedStaticType);
        }
        DartType propagatedPropagatedType = _computePropagatedReturnType(propagatedElement);
        if (propagatedPropagatedType != null && (staticStaticType == null || propagatedPropagatedType.isMoreSpecificThan(staticStaticType)) && (staticPropagatedType == null || propagatedPropagatedType.isMoreSpecificThan(staticPropagatedType)) && (propagatedStaticType == null || propagatedPropagatedType.isMoreSpecificThan(propagatedStaticType))) {
          _recordPropagatedType(node, propagatedPropagatedType);
        }
      }
    }
    return null;
  }
  Object visitNamedExpression(NamedExpression node) {
    Expression expression = node.expression;
    _recordStaticType(node, _getStaticType(expression));
    _recordPropagatedType(node, expression.propagatedType);
    return null;
  }
  Object visitNullLiteral(NullLiteral node) {
    _recordStaticType(node, B__typeProvider.bottomType);
    return null;
  }
  Object visitParenthesizedExpression(ParenthesizedExpression node) {
    Expression expression = node.expression;
    _recordStaticType(node, _getStaticType(expression));
    _recordPropagatedType(node, expression.propagatedType);
    return null;
  }
  Object visitPostfixExpression(PostfixExpression node) {
    Expression operand = node.operand;
    DartType staticType = _getStaticType(operand);
    A_TokenType operator = node.operator.type;
    if (operator == A_TokenType.MINUS_MINUS || operator == A_TokenType.PLUS_PLUS) {
      DartType intType = B__typeProvider.intType;
      if (identical(_getStaticType(node.operand), intType)) {
        staticType = intType;
      }
    }
    _recordStaticType(node, staticType);
    _recordPropagatedType(node, operand.propagatedType);
    return null;
  }
  Object visitPrefixedIdentifier(PrefixedIdentifier node) {
    SimpleIdentifier prefixedIdentifier = node.identifier;
    A_Element staticElement = prefixedIdentifier.staticElement;
    DartType staticType = _dynamicType;
    DartType propagatedType = null;
    if (staticElement is ClassElement) {
      if (_isNotTypeLiteral(node)) {
        staticType = staticElement.type;
      } else {
        staticType = B__typeProvider.typeType;
      }
    } else if (staticElement is FunctionTypeAliasElement) {
      if (_isNotTypeLiteral(node)) {
        staticType = staticElement.type;
      } else {
        staticType = B__typeProvider.typeType;
      }
    } else if (staticElement is MethodElement) {
      staticType = staticElement.type;
    } else if (staticElement is PropertyAccessorElement) {
      staticType = _getTypeOfProperty(staticElement, node.prefix.staticType);
      propagatedType = _getPropertyPropagatedType(staticElement, propagatedType);
    } else if (staticElement is ExecutableElement) {
      staticType = staticElement.type;
    } else if (staticElement is TypeParameterElement) {
      staticType = staticElement.type;
    } else if (staticElement is VariableElement) {
      staticType = staticElement.type;
    }
    _recordStaticType(prefixedIdentifier, staticType);
    _recordStaticType(node, staticType);
    A_Element propagatedElement = prefixedIdentifier.propagatedElement;
    if (propagatedElement is ClassElement) {
      if (_isNotTypeLiteral(node)) {
        propagatedType = propagatedElement.type;
      } else {
        propagatedType = B__typeProvider.typeType;
      }
    } else if (propagatedElement is FunctionTypeAliasElement) {
      propagatedType = propagatedElement.type;
    } else if (propagatedElement is MethodElement) {
      propagatedType = propagatedElement.type;
    } else if (propagatedElement is PropertyAccessorElement) {
      propagatedType = _getTypeOfProperty(propagatedElement, node.prefix.staticType);
      propagatedType = _getPropertyPropagatedType(propagatedElement, propagatedType);
    } else if (propagatedElement is ExecutableElement) {
      propagatedType = propagatedElement.type;
    } else if (propagatedElement is TypeParameterElement) {
      propagatedType = propagatedElement.type;
    } else if (propagatedElement is VariableElement) {
      propagatedType = propagatedElement.type;
    }
    DartType overriddenType = _overrideManager.getType(propagatedElement);
    if (propagatedType == null || (overriddenType != null && overriddenType.isMoreSpecificThan(propagatedType))) {
      propagatedType = overriddenType;
    }
    if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
      _recordPropagatedType(prefixedIdentifier, propagatedType);
      _recordPropagatedType(node, propagatedType);
    }
    return null;
  }
  Object visitPrefixExpression(PrefixExpression node) {
    A_TokenType operator = node.operator.type;
    if (operator == A_TokenType.BANG) {
      _recordStaticType(node, B__typeProvider.boolType);
    } else {
      ExecutableElement staticMethodElement = node.staticElement;
      DartType staticType = _computeStaticReturnType(staticMethodElement);
      if (operator == A_TokenType.MINUS_MINUS || operator == A_TokenType.PLUS_PLUS) {
        DartType intType = B__typeProvider.intType;
        if (identical(_getStaticType(node.operand), intType)) {
          staticType = intType;
        }
      }
      _recordStaticType(node, staticType);
      MethodElement propagatedMethodElement = node.propagatedElement;
      if (!identical(propagatedMethodElement, staticMethodElement)) {
        DartType propagatedType = _computeStaticReturnType(propagatedMethodElement);
        if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
          _recordPropagatedType(node, propagatedType);
        }
      }
    }
    return null;
  }
  Object visitPropertyAccess(PropertyAccess node) {
    SimpleIdentifier propertyName = node.propertyName;
    A_Element staticElement = propertyName.staticElement;
    DartType staticType = _dynamicType;
    if (staticElement is MethodElement) {
      staticType = staticElement.type;
    } else if (staticElement is PropertyAccessorElement) {
      Expression realTarget = node.realTarget;
      staticType = _getTypeOfProperty(staticElement, realTarget != null ? _getStaticType(realTarget) : null);
    } else {}
    _recordStaticType(propertyName, staticType);
    _recordStaticType(node, staticType);
    A_Element propagatedElement = propertyName.propagatedElement;
    DartType propagatedType = _overrideManager.getType(propagatedElement);
    if (propagatedElement is MethodElement) {
      propagatedType = propagatedElement.type;
    } else if (propagatedElement is PropertyAccessorElement) {
      Expression realTarget = node.realTarget;
      propagatedType = _getTypeOfProperty(propagatedElement, realTarget != null ? realTarget.bestType : null);
    } else {}
    if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
      _recordPropagatedType(propertyName, propagatedType);
      _recordPropagatedType(node, propagatedType);
    }
    return null;
  }
  Object visitRethrowExpression(RethrowExpression node) {
    _recordStaticType(node, B__typeProvider.bottomType);
    return null;
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    A_Element A_element = node.staticElement;
    DartType staticType = _dynamicType;
    if (A_element is ClassElement) {
      if (_isNotTypeLiteral(node)) {
        staticType = A_element.type;
      } else {
        staticType = B__typeProvider.typeType;
      }
    } else if (A_element is FunctionTypeAliasElement) {
      if (_isNotTypeLiteral(node)) {
        staticType = A_element.type;
      } else {
        staticType = B__typeProvider.typeType;
      }
    } else if (A_element is MethodElement) {
      staticType = A_element.type;
    } else if (A_element is PropertyAccessorElement) {
      staticType = _getTypeOfProperty(A_element, null);
    } else if (A_element is ExecutableElement) {
      staticType = A_element.type;
    } else if (A_element is TypeParameterElement) {
      staticType = A_element.type;
    } else if (A_element is VariableElement) {
      VariableElement variable = A_element;
      staticType = _promoteManager.A_getStaticType(variable);
    } else if (A_element is PrefixElement) {
      return null;
    } else {
      staticType = _dynamicType;
    }
    _recordStaticType(node, staticType);
    DartType propagatedType = _getPropertyPropagatedType(A_element, null);
    if (propagatedType == null) {
      DartType overriddenType = _overrideManager.getType(A_element);
      if (propagatedType == null || overriddenType != null && overriddenType.isMoreSpecificThan(propagatedType)) {
        propagatedType = overriddenType;
      }
    }
    if (propagatedType != null && propagatedType.isMoreSpecificThan(staticType)) {
      _recordPropagatedType(node, propagatedType);
    }
    return null;
  }
  Object visitSimpleStringLiteral(SimpleStringLiteral node) {
    _recordStaticType(node, B__typeProvider.stringType);
    return null;
  }
  Object visitStringInterpolation(StringInterpolation node) {
    _recordStaticType(node, B__typeProvider.stringType);
    return null;
  }
  Object visitSuperExpression(SuperExpression node) {
    if (_thisType == null) {
      _recordStaticType(node, _dynamicType);
    } else {
      _recordStaticType(node, _thisType);
    }
    return null;
  }
  Object visitSymbolLiteral(SymbolLiteral node) {
    _recordStaticType(node, B__typeProvider.symbolType);
    return null;
  }
  Object visitThisExpression(ThisExpression node) {
    if (_thisType == null) {
      _recordStaticType(node, _dynamicType);
    } else {
      _recordStaticType(node, _thisType);
    }
    return null;
  }
  Object visitThrowExpression(ThrowExpression node) {
    _recordStaticType(node, B__typeProvider.bottomType);
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    Expression initializer = node.initializer;
    if (initializer != null) {
      DartType rightType = initializer.bestType;
      SimpleIdentifier A_name = node.name;
      _recordPropagatedType(A_name, rightType);
      VariableElement A_element = A_name.staticElement as VariableElement;
      if (A_element != null) {
        A__resolver.overrideVariable(A_element, rightType);
      }
    }
    return null;
  }
  DartType _computeArgumentType(ExecutableElement A_element) {
    if (A_element != null) {
      List<ParameterElement> A_parameters = A_element.parameters;
      if (A_parameters != null && A_parameters.length == 2) {
        return A_parameters[1].type;
      }
    }
    return _dynamicType;
  }
  DartType _computePropagatedReturnType(A_Element A_element) {
    if (A_element is ExecutableElement) {
      return _propagatedReturnTypes[A_element];
    }
    return null;
  }
  DartType _computePropagatedReturnTypeOfFunction(FunctionBody body) {
    if (body is ExpressionFunctionBody) {
      ExpressionFunctionBody expressionBody = body;
      return expressionBody.expression.bestType;
    }
    if (body is BlockFunctionBody) {
      List<DartType> result = [null];
      body.accept(new GeneralizingAstVisitor_StaticTypeAnalyzer_computePropagatedReturnTypeOfFunction(result));
      return result[0];
    }
    return null;
  }
  DartType _computeStaticReturnType(A_Element A_element) {
    if (A_element is PropertyAccessorElement) {
      FunctionType propertyType = A_element.type;
      if (propertyType != null) {
        DartType A_returnType = propertyType.returnType;
        if (A_returnType.isDartCoreFunction) {
          return _dynamicType;
        } else if (A_returnType is InterfaceType) {
          MethodElement callMethod = A_returnType.lookUpMethod(FunctionElement.CALL_METHOD_NAME, A__resolver.definingLibrary);
          if (callMethod != null) {
            return callMethod.type.returnType;
          }
        } else if (A_returnType is FunctionType) {
          DartType innerReturnType = A_returnType.returnType;
          if (innerReturnType != null) {
            return innerReturnType;
          }
        }
        if (A_returnType != null) {
          return A_returnType;
        }
      }
    } else if (A_element is ExecutableElement) {
      FunctionType A_type = A_element.type;
      if (A_type != null) {
        return A_type.returnType;
      }
    } else if (A_element is VariableElement) {
      VariableElement variable = A_element;
      DartType variableType = _promoteManager.A_getStaticType(variable);
      if (variableType is FunctionType) {
        return variableType.returnType;
      }
    }
    return _dynamicType;
  }
  DartType _computeStaticReturnTypeOfFunctionDeclaration(FunctionDeclaration node) {
    TypeName A_returnType = node.returnType;
    if (A_returnType == null) {
      return _dynamicType;
    }
    return A_returnType.type;
  }
  DartType _computeStaticReturnTypeOfFunctionExpression(FunctionExpression node) {
    FunctionBody body = node.body;
    if (body is ExpressionFunctionBody) {
      return _getStaticType(body.expression);
    }
    return _dynamicType;
  }
  DartType _getElementNameAsType(LibraryElement library, String elementName, A_p.HashMap<String, String> nameMap) {
    if (elementName != null) {
      if (nameMap != null) {
        elementName = nameMap[elementName.toLowerCase()];
      }
      ClassElement A_returnType = library.getType(elementName);
      if (A_returnType != null) {
        return A_returnType.type;
      }
    }
    return null;
  }
  DartType _getFirstArgumentAsQuery(LibraryElement library, ArgumentList argumentList) {
    String argumentValue = _getFirstArgumentAsString(argumentList);
    if (argumentValue != null) {
      if (StringUtilities.indexOf1(argumentValue, 0, 0x20) >= 0) {
        return null;
      }
      String tag = argumentValue;
      tag = StringUtilities.substringBeforeChar(tag, 0x3A);
      tag = StringUtilities.substringBeforeChar(tag, 0x5B);
      tag = StringUtilities.substringBeforeChar(tag, 0x2E);
      tag = StringUtilities.substringBeforeChar(tag, 0x23);
      tag = _HTML_ELEMENT_TO_CLASS_MAP[tag.toLowerCase()];
      ClassElement A_returnType = library.getType(tag);
      if (A_returnType != null) {
        return A_returnType.type;
      }
    }
    return null;
  }
  String _getFirstArgumentAsString(ArgumentList argumentList) {
    NodeList<Expression> A_arguments = argumentList.arguments;
    if (A_arguments.length > 0) {
      Expression argument = A_arguments[0];
      if (argument is SimpleStringLiteral) {
        return argument.value;
      }
    }
    return null;
  }
  DartType _getFirstArgumentAsType(LibraryElement library, ArgumentList argumentList) => _getFirstArgumentAsTypeWithMap(library, argumentList, null);
  DartType _getFirstArgumentAsTypeWithMap(LibraryElement library, ArgumentList argumentList, A_p.HashMap<String, String> nameMap) => _getElementNameAsType(library, _getFirstArgumentAsString(argumentList), nameMap);
  DartType _getPropertyPropagatedType(A_Element A_element, DartType currentType) {
    if (A_element is PropertyAccessorElement) {
      PropertyAccessorElement accessor = A_element;
      if (accessor.isGetter) {
        PropertyInducingElement variable = accessor.variable;
        DartType propagatedType = variable.propagatedType;
        if (currentType == null || propagatedType != null && propagatedType.isMoreSpecificThan(currentType)) {
          return propagatedType;
        }
      }
    }
    return currentType;
  }
  DartType _getStaticType(Expression expression) {
    DartType A_type = expression.staticType;
    if (A_type == null) {
      return _dynamicType;
    }
    return A_type;
  }
  DartType A__getType(TypeName typeName) {
    DartType A_type = typeName.type;
    if (A_type == null) {
      return _dynamicType;
    }
    return A_type;
  }
  DartType _getTypeOfProperty(PropertyAccessorElement accessor, DartType context) {
    FunctionType A_functionType = accessor.type;
    if (A_functionType == null) {
      return _dynamicType;
    }
    if (accessor.isSetter) {
      List<DartType> A_parameterTypes = A_functionType.normalParameterTypes;
      if (A_parameterTypes != null && A_parameterTypes.length > 0) {
        return A_parameterTypes[0];
      }
      PropertyAccessorElement getter = accessor.variable.getter;
      if (getter != null) {
        A_functionType = getter.type;
        if (A_functionType != null) {
          return A_functionType.returnType;
        }
      }
      return _dynamicType;
    }
    DartType A_returnType = A_functionType.returnType;
    if (A_returnType is TypeParameterType && context is InterfaceType) {
      InterfaceType interfaceTypeContext = context;
      List<TypeParameterElement> typeParameterElements = interfaceTypeContext.element != null ? interfaceTypeContext.element.typeParameters : null;
      if (typeParameterElements != null) {
        for (int i = 0; i < typeParameterElements.length; i++) {
          TypeParameterElement typeParameterElement = typeParameterElements[i];
          if (A_returnType.name == typeParameterElement.name) {
            return interfaceTypeContext.typeArguments[i];
          }
        }
      }
    }
    return A_returnType;
  }
  bool _isAsyncFutureType(DartType A_type) => A_type is InterfaceType && A_type.name == "Future" && _isAsyncLibrary(A_type.element.library);
  bool _isAsyncLibrary(LibraryElement library) => library.name == "dart.async";
  bool _isHtmlLibrary(LibraryElement library) => library != null && "dart.dom.html" == library.name;
  bool _isNotTypeLiteral(Identifier node) {
    AstNode A_parent = node.parent;
    return A_parent is TypeName || (A_parent is PrefixedIdentifier && (A_parent.parent is TypeName || identical(A_parent.prefix, node))) || (A_parent is PropertyAccess && identical(A_parent.target, node)) || (A_parent is MethodInvocation && identical(node, A_parent.target));
  }
  void _recordPropagatedType(Expression expression, DartType A_type) {
    if (A_type != null && !A_type.isDynamic && !A_type.isBottom) {
      expression.propagatedType = A_type;
    }
  }
  void _recordPropagatedTypeOfFunction(ExecutableElement functionElement, FunctionBody body) {
    DartType propagatedReturnType = _computePropagatedReturnTypeOfFunction(body);
    if (propagatedReturnType == null) {
      return;
    }
    if (propagatedReturnType.isBottom) {
      return;
    }
    DartType staticReturnType = functionElement.returnType;
    if (!propagatedReturnType.isMoreSpecificThan(staticReturnType)) {
      return;
    }
    _propagatedReturnTypes[functionElement] = propagatedReturnType;
  }
  void _recordStaticType(Expression expression, DartType A_type) {
    if (A_type == null) {
      expression.staticType = _dynamicType;
    } else {
      expression.staticType = A_type;
    }
  }
  DartType _refineBinaryExpressionType(BinaryExpression node, DartType staticType) {
    A_TokenType operator = node.operator.type;
    if (operator == A_TokenType.AMPERSAND_AMPERSAND || operator == A_TokenType.BAR_BAR || operator == A_TokenType.EQ_EQ || operator == A_TokenType.BANG_EQ) {
      return B__typeProvider.boolType;
    }
    DartType intType = B__typeProvider.intType;
    if (_getStaticType(node.leftOperand) == intType) {
      if (operator == A_TokenType.MINUS || operator == A_TokenType.PERCENT || operator == A_TokenType.PLUS || operator == A_TokenType.STAR) {
        DartType doubleType = B__typeProvider.doubleType;
        if (_getStaticType(node.rightOperand) == doubleType) {
          return doubleType;
        }
      }
      if (operator == A_TokenType.MINUS || operator == A_TokenType.PERCENT || operator == A_TokenType.PLUS || operator == A_TokenType.STAR || operator == A_TokenType.TILDE_SLASH) {
        if (_getStaticType(node.rightOperand) == intType) {
          staticType = intType;
        }
      }
    }
    return staticType;
  }
}
class SubtypeManager {
  A_p.HashMap<ClassElement, A_p.HashSet<ClassElement>> _subtypeMap = new A_p.HashMap<ClassElement,A_p.HashSet<ClassElement>>();
  A_p.HashSet<LibraryElement> _visitedLibraries = new A_p.HashSet<LibraryElement>();
  A_p.HashSet<ClassElement> computeAllSubtypes(ClassElement classElement) {
    _computeSubtypesInLibrary(classElement.library);
    A_p.HashSet<ClassElement> allSubtypes = new A_p.HashSet<ClassElement>();
    _safelyComputeAllSubtypes(classElement, new A_p.HashSet<ClassElement>(), allSubtypes);
    return allSubtypes;
  }
  void ensureLibraryVisited(LibraryElement libraryElement) {
    _computeSubtypesInLibrary(libraryElement);
  }
  void _computeSubtypesInClass(ClassElement classElement) {
    InterfaceType supertypeType = classElement.supertype;
    if (supertypeType != null) {
      ClassElement supertypeElement = supertypeType.element;
      if (supertypeElement != null) {
        _putInSubtypeMap(supertypeElement, classElement);
      }
    }
    List<InterfaceType> interfaceTypes = classElement.interfaces;
    for (InterfaceType interfaceType in interfaceTypes) {
      ClassElement interfaceElement = interfaceType.element;
      if (interfaceElement != null) {
        _putInSubtypeMap(interfaceElement, classElement);
      }
    }
    List<InterfaceType> mixinTypes = classElement.mixins;
    for (InterfaceType mixinType in mixinTypes) {
      ClassElement mixinElement = mixinType.element;
      if (mixinElement != null) {
        _putInSubtypeMap(mixinElement, classElement);
      }
    }
  }
  void _computeSubtypesInCompilationUnit(CompilationUnitElement unitElement) {
    List<ClassElement> classElements = unitElement.types;
    for (ClassElement classElement in classElements) {
      _computeSubtypesInClass(classElement);
    }
  }
  void _computeSubtypesInLibrary(LibraryElement libraryElement) {
    if (libraryElement == null || _visitedLibraries.contains(libraryElement)) {
      return;
    }
    _visitedLibraries.add(libraryElement);
    _computeSubtypesInCompilationUnit(libraryElement.definingCompilationUnit);
    List<CompilationUnitElement> parts = libraryElement.parts;
    for (CompilationUnitElement part in parts) {
      _computeSubtypesInCompilationUnit(part);
    }
    List<LibraryElement> imports = libraryElement.importedLibraries;
    for (LibraryElement importElt in imports) {
      _computeSubtypesInLibrary(importElt.library);
    }
    List<LibraryElement> exports = libraryElement.exportedLibraries;
    for (LibraryElement exportElt in exports) {
      _computeSubtypesInLibrary(exportElt.library);
    }
  }
  void _putInSubtypeMap(ClassElement supertypeElement, ClassElement subtypeElement) {
    A_p.HashSet<ClassElement> subtypes = _subtypeMap[supertypeElement];
    if (subtypes == null) {
      subtypes = new A_p.HashSet<ClassElement>();
      _subtypeMap[supertypeElement] = subtypes;
    }
    subtypes.add(subtypeElement);
  }
  void _safelyComputeAllSubtypes(ClassElement classElement, A_p.HashSet<ClassElement> visitedClasses, A_p.HashSet<ClassElement> allSubtypes) {
    if (!visitedClasses.add(classElement)) {
      return;
    }
    A_p.HashSet<ClassElement> subtypes = _subtypeMap[classElement];
    if (subtypes == null) {
      return;
    }
    for (ClassElement subtype in subtypes) {
      _safelyComputeAllSubtypes(subtype, visitedClasses, allSubtypes);
    }
    allSubtypes.addAll(subtypes);
  }
}
class ToDoFinder {
  final ErrorReporter _errorReporter;
  ToDoFinder(this._errorReporter);
  void findIn(CompilationUnit unit) {
    _gatherTodoComments(unit.beginToken);
  }
  void _gatherTodoComments(A_Token token) {
    while (token != null && token.type != A_TokenType.A_EOF) {
      A_Token commentToken = token.precedingComments;
      while (commentToken != null) {
        if (commentToken.type == A_TokenType.SINGLE_LINE_COMMENT || commentToken.type == A_TokenType.MULTI_LINE_COMMENT) {
          _scrapeTodoComment(commentToken);
        }
        commentToken = commentToken.next;
      }
      token = token.next;
    }
  }
  void _scrapeTodoComment(A_Token commentToken) {
    JavaPatternMatcher matcher = new JavaPatternMatcher(TodoCode.TODO_REGEX, commentToken.lexeme);
    if (matcher.find()) {
      int A_offset = commentToken.offset + matcher.start() + matcher.group(1).length;
      int A_length = matcher.group(2).length;
      _errorReporter.reportErrorForOffset(TodoCode.TODO, A_offset, A_length, [matcher.group(2)]);
    }
  }
}
class TypeOverrideManager {
  TypeOverrideManager_TypeOverrideScope _currentScope;
  void applyOverrides(A_p.HashMap<A_Element, DartType> overrides) {
    if (_currentScope == null) {
      throw new IllegalStateException("Cannot apply overrides without a scope");
    }
    _currentScope.applyOverrides(overrides);
  }
  A_p.HashMap<A_Element, DartType> captureLocalOverrides() {
    if (_currentScope == null) {
      throw new IllegalStateException("Cannot capture local overrides without a scope");
    }
    return _currentScope.captureLocalOverrides();
  }
  A_p.HashMap<A_Element, DartType> captureOverrides(VariableDeclarationList variableList) {
    if (_currentScope == null) {
      throw new IllegalStateException("Cannot capture overrides without a scope");
    }
    return _currentScope.captureOverrides(variableList);
  }
  void enterScope() {
    _currentScope = new TypeOverrideManager_TypeOverrideScope(_currentScope);
  }
  void exitScope() {
    if (_currentScope == null) {
      throw new IllegalStateException("No scope to exit");
    }
    _currentScope = _currentScope._outerScope;
  }
  DartType getType(A_Element A_element) {
    if (_currentScope == null) {
      return null;
    }
    return _currentScope.getType(A_element);
  }
  void setType(A_Element A_element, DartType A_type) {
    if (_currentScope == null) {
      throw new IllegalStateException("Cannot override without a scope");
    }
    _currentScope.setType(A_element, A_type);
  }
}
class TypeOverrideManager_TypeOverrideScope {
  final TypeOverrideManager_TypeOverrideScope _outerScope;
  A_p.HashMap<A_Element, DartType> _overridenTypes = new A_p.HashMap<A_Element,DartType>();
  TypeOverrideManager_TypeOverrideScope(this._outerScope);
  void applyOverrides(A_p.HashMap<A_Element, DartType> overrides) {
    for (MapEntry<A_Element, DartType> A_entry in getMapEntrySet(overrides)) {
      _overridenTypes[A_entry.getKey()] = A_entry.getValue();
    }
  }
  A_p.HashMap<A_Element, DartType> captureLocalOverrides() => _overridenTypes;
  A_p.HashMap<A_Element, DartType> captureOverrides(VariableDeclarationList variableList) {
    A_p.HashMap<A_Element, DartType> overrides = new A_p.HashMap<A_Element,DartType>();
    if (variableList.isConst || variableList.isFinal) {
      for (VariableDeclaration variable in variableList.variables) {
        A_Element A_element = variable.element;
        if (A_element != null) {
          DartType A_type = _overridenTypes[A_element];
          if (A_type != null) {
            overrides[A_element] = A_type;
          }
        }
      }
    }
    return overrides;
  }
  DartType getType(A_Element A_element) {
    DartType A_type = _overridenTypes[A_element];
    if (A_type == null && A_element is PropertyAccessorElement) {
      A_type = _overridenTypes[A_element.variable];
    }
    if (A_type != null) {
      return A_type;
    } else if (_outerScope != null) {
      return _outerScope.getType(A_element);
    }
    return null;
  }
  void setType(A_Element A_element, DartType A_type) {
    _overridenTypes[A_element] = A_type;
  }
}
class TypeParameterScope extends EnclosedScope {
  TypeParameterScope(Scope enclosingScope, ClassElement typeElement) : super(enclosingScope) {
    if (typeElement == null) {
      throw new IllegalArgumentException("class element cannot be null");
    }
    _defineTypeParameters(typeElement);
  }
  void _defineTypeParameters(ClassElement typeElement) {
    for (TypeParameterElement typeParameter in typeElement.typeParameters) {
      define(typeParameter);
    }
  }
}
class TypePromotionManager {
  TypePromotionManager_TypePromoteScope _currentScope;
  void enterScope() {
    _currentScope = new TypePromotionManager_TypePromoteScope(_currentScope);
  }
  void exitScope() {
    if (_currentScope == null) {
      throw new IllegalStateException("No scope to exit");
    }
    _currentScope = _currentScope._outerScope;
  }
  Iterable<A_Element> get promotedElements => _currentScope.promotedElements;
  DartType A_getStaticType(VariableElement variable) {
    DartType staticType = getType(variable);
    if (staticType == null) {
      staticType = variable.type;
    }
    return staticType;
  }
  DartType getType(A_Element A_element) {
    if (_currentScope == null) {
      return null;
    }
    return _currentScope.getType(A_element);
  }
  void setType(A_Element A_element, DartType A_type) {
    if (_currentScope == null) {
      throw new IllegalStateException("Cannot promote without a scope");
    }
    _currentScope.setType(A_element, A_type);
  }
}
class TypePromotionManager_TypePromoteScope {
  final TypePromotionManager_TypePromoteScope _outerScope;
  A_p.HashMap<A_Element, DartType> _promotedTypes = new A_p.HashMap<A_Element,DartType>();
  TypePromotionManager_TypePromoteScope(this._outerScope);
  Iterable<A_Element> get promotedElements => _promotedTypes.keys.toSet();
  DartType getType(A_Element A_element) {
    DartType A_type = _promotedTypes[A_element];
    if (A_type == null && A_element is PropertyAccessorElement) {
      A_type = _promotedTypes[A_element.variable];
    }
    if (A_type != null) {
      return A_type;
    } else if (_outerScope != null) {
      return _outerScope.getType(A_element);
    }
    return null;
  }
  void setType(A_Element A_element, DartType A_type) {
    _promotedTypes[A_element] = A_type;
  }
}
abstract class TypeProvider {
  InterfaceType get boolType;
  DartType get bottomType;
  InterfaceType get doubleType;
  DartType get dynamicType;
  InterfaceType get functionType;
  InterfaceType get intType;
  InterfaceType get listType;
  InterfaceType get mapType;
  InterfaceType get nullType;
  InterfaceType get numType;
  InterfaceType get objectType;
  InterfaceType get stackTraceType;
  InterfaceType get stringType;
  InterfaceType get symbolType;
  InterfaceType get typeType;
}
class TypeProviderImpl implements TypeProvider {
  InterfaceType _boolType;
  DartType _bottomType;
  InterfaceType _doubleType;
  InterfaceType _deprecatedType;
  DartType _dynamicType;
  InterfaceType _functionType;
  InterfaceType _intType;
  InterfaceType _listType;
  InterfaceType _mapType;
  InterfaceType _nullType;
  InterfaceType _numType;
  InterfaceType _objectType;
  InterfaceType _stackTraceType;
  InterfaceType _stringType;
  InterfaceType _symbolType;
  InterfaceType _typeType;
  TypeProviderImpl(LibraryElement coreLibrary) {
    _initializeFrom(coreLibrary);
  }
  InterfaceType get boolType => _boolType;
  DartType get bottomType => _bottomType;
  InterfaceType get doubleType => _doubleType;
  DartType get dynamicType => _dynamicType;
  InterfaceType get functionType => _functionType;
  InterfaceType get intType => _intType;
  InterfaceType get listType => _listType;
  InterfaceType get mapType => _mapType;
  InterfaceType get nullType => _nullType;
  InterfaceType get numType => _numType;
  InterfaceType get objectType => _objectType;
  InterfaceType get stackTraceType => _stackTraceType;
  InterfaceType get stringType => _stringType;
  InterfaceType get symbolType => _symbolType;
  InterfaceType get typeType => _typeType;
  InterfaceType A__getType(Namespace namespace, String typeName) {
    A_Element A_element = namespace.get(typeName);
    if (A_element == null) {
      AnalysisEngine.A_instance.logger.logInformation("No definition of type ${typeName}");
      return null;
    }
    return (A_element as ClassElement).type;
  }
  void _initializeFrom(LibraryElement library) {
    Namespace namespace = new NamespaceBuilder().createPublicNamespaceForLibrary(library);
    _boolType = A__getType(namespace, "bool");
    _bottomType = BottomTypeImpl.instance;
    _deprecatedType = A__getType(namespace, "Deprecated");
    _doubleType = A__getType(namespace, "double");
    _dynamicType = DynamicTypeImpl.instance;
    _functionType = A__getType(namespace, "Function");
    _intType = A__getType(namespace, "int");
    _listType = A__getType(namespace, "List");
    _mapType = A__getType(namespace, "Map");
    _nullType = A__getType(namespace, "Null");
    _numType = A__getType(namespace, "num");
    _objectType = A__getType(namespace, "Object");
    _stackTraceType = A__getType(namespace, "StackTrace");
    _stringType = A__getType(namespace, "String");
    _symbolType = A__getType(namespace, "Symbol");
    _typeType = A__getType(namespace, "Type");
  }
}
class TypeResolverVisitor extends ScopedVisitor {
  static bool _isBuiltInIdentifier(TypeName node) {
    A_Token token = node.name.beginToken;
    return token.type == A_TokenType.A_KEYWORD;
  }
  static bool _isTypeAnnotation(TypeName node) {
    AstNode A_parent = node.parent;
    if (A_parent is VariableDeclarationList) {
      return identical(A_parent.type, node);
    }
    if (A_parent is FieldFormalParameter) {
      return identical(A_parent.type, node);
    }
    if (A_parent is SimpleFormalParameter) {
      return identical(A_parent.type, node);
    }
    return false;
  }
  DartType _dynamicType;
  bool _hasReferenceToSuper = false;
  TypeResolverVisitor.G_con1(Library library, Source A_source, TypeProvider typeProvider) : super.G_con1(library, A_source, typeProvider) {
    _dynamicType = typeProvider.dynamicType;
  }
  TypeResolverVisitor.B_con3(LibraryElement definingLibrary, Source A_source, TypeProvider typeProvider, Scope nameScope, AnalysisErrorListener errorListener) : super.B_con3(definingLibrary, A_source, typeProvider, nameScope, errorListener) {
    _dynamicType = typeProvider.dynamicType;
  }
  TypeResolverVisitor.A_con4(ResolvableLibrary library, Source A_source, TypeProvider typeProvider) : super.A_con4(library, A_source, typeProvider) {
    _dynamicType = typeProvider.dynamicType;
  }
  Object visitAnnotation(Annotation node) {
    super.visitAnnotation(node);
    Identifier identifier = node.name;
    if (identifier.name.endsWith(ElementAnnotationImpl.PROXY_VARIABLE_NAME) && node.parent is ClassDeclaration) {
      A_Element A_element = nameScope.lookup(identifier, definingLibrary);
      if (A_element != null && A_element.library.isDartCore && A_element is PropertyAccessorElement) {
        ClassDeclaration classDeclaration = node.parent as ClassDeclaration;
        ElementAnnotationImpl elementAnnotation = new ElementAnnotationImpl(A_element);
        node.elementAnnotation = elementAnnotation;
        (classDeclaration.element as ClassElementImpl).metadata = <ElementAnnotationImpl>[elementAnnotation];
      }
    }
    return null;
  }
  Object visitCatchClause(CatchClause node) {
    super.visitCatchClause(node);
    SimpleIdentifier exception = node.exceptionParameter;
    if (exception != null) {
      TypeName exceptionTypeName = node.exceptionType;
      DartType exceptionType;
      if (exceptionTypeName == null) {
        exceptionType = typeProvider.dynamicType;
      } else {
        exceptionType = A__getType(exceptionTypeName);
      }
      _recordType(exception, exceptionType);
      A_Element A_element = exception.staticElement;
      if (A_element is VariableElementImpl) {
        A_element.type = exceptionType;
      } else {}
    }
    SimpleIdentifier A_stackTrace = node.stackTraceParameter;
    if (A_stackTrace != null) {
      _recordType(A_stackTrace, typeProvider.stackTraceType);
    }
    return null;
  }
  Object visitClassDeclaration(ClassDeclaration node) {
    ExtendsClause extendsClause = node.extendsClause;
    WithClause withClause = node.withClause;
    ImplementsClause implementsClause = node.implementsClause;
    _hasReferenceToSuper = false;
    super.visitClassDeclaration(node);
    ClassElementImpl classElement = _getClassElement(node.name);
    InterfaceType superclassType = null;
    if (extendsClause != null) {
      ErrorCode A_errorCode = (withClause == null ? CompileTimeErrorCode.EXTENDS_NON_CLASS : CompileTimeErrorCode.MIXIN_WITH_NON_CLASS_SUPERCLASS);
      superclassType = _resolveType(extendsClause.superclass, A_errorCode, A_errorCode);
      if (!identical(superclassType, typeProvider.objectType)) {
        classElement.validMixin = false;
      }
    }
    if (classElement != null) {
      if (superclassType == null) {
        InterfaceType objectType = typeProvider.objectType;
        if (!identical(classElement.type, objectType)) {
          superclassType = objectType;
        }
      }
      classElement.supertype = superclassType;
      classElement.hasReferenceToSuper = _hasReferenceToSuper;
    }
    _resolve(classElement, withClause, implementsClause);
    return null;
  }
  Object visitClassTypeAlias(ClassTypeAlias node) {
    super.visitClassTypeAlias(node);
    ClassElementImpl classElement = _getClassElement(node.name);
    ErrorCode A_errorCode = CompileTimeErrorCode.MIXIN_WITH_NON_CLASS_SUPERCLASS;
    InterfaceType superclassType = _resolveType(node.superclass, A_errorCode, A_errorCode);
    if (superclassType == null) {
      superclassType = typeProvider.objectType;
    }
    if (classElement != null && superclassType != null) {
      classElement.supertype = superclassType;
      ClassElement superclassElement = superclassType.element;
      if (superclassElement != null) {
        List<ConstructorElement> constructors = superclassElement.constructors;
        int count = constructors.length;
        if (count > 0) {
          List<DartType> A_parameterTypes = TypeParameterTypeImpl.getTypes(superclassType.typeParameters);
          List<DartType> argumentTypes = _getArgumentTypes(node.superclass.typeArguments, A_parameterTypes);
          InterfaceType classType = classElement.type;
          List<ConstructorElement> implicitConstructors = new List<ConstructorElement>();
          for (int i = 0; i < count; i++) {
            ConstructorElement explicitConstructor = constructors[i];
            if (!explicitConstructor.isFactory) {
              implicitConstructors.add(_createImplicitContructor(classType, explicitConstructor, A_parameterTypes, argumentTypes));
            }
          }
          classElement.constructors = new List.from(implicitConstructors);
        }
      }
    }
    _resolve(classElement, node.withClause, node.implementsClause);
    return null;
  }
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    super.visitConstructorDeclaration(node);
    ExecutableElementImpl A_element = node.element as ExecutableElementImpl;
    if (A_element == null) {
      ClassDeclaration classNode = node.getAncestor((node) => node is ClassDeclaration);
      JavaStringBuilder A_builder = new JavaStringBuilder();
      A_builder.append("The element for the constructor ");
      A_builder.append(node.name == null ? "<unnamed>" : node.name.name);
      A_builder.append(" in ");
      if (classNode == null) {
        A_builder.append("<unknown class>");
      } else {
        A_builder.append(classNode.name.name);
      }
      A_builder.append(" in ");
      A_builder.append(source.fullName);
      A_builder.append(" was not set while trying to resolve types.");
      AnalysisEngine.A_instance.logger.logError2(A_builder.toString(), new AnalysisException());
    } else {
      ClassElement definingClass = A_element.enclosingElement as ClassElement;
      A_element.returnType = definingClass.type;
      FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(A_element);
      A_type.typeArguments = definingClass.type.typeArguments;
      A_element.type = A_type;
    }
    return null;
  }
  Object visitDeclaredIdentifier(DeclaredIdentifier node) {
    super.visitDeclaredIdentifier(node);
    DartType declaredType;
    TypeName typeName = node.type;
    if (typeName == null) {
      declaredType = _dynamicType;
    } else {
      declaredType = A__getType(typeName);
    }
    LocalVariableElementImpl A_element = node.element as LocalVariableElementImpl;
    A_element.type = declaredType;
    return null;
  }
  Object visitFieldFormalParameter(FieldFormalParameter node) {
    super.visitFieldFormalParameter(node);
    A_Element A_element = node.identifier.staticElement;
    if (A_element is ParameterElementImpl) {
      ParameterElementImpl parameter = A_element;
      FormalParameterList parameterList = node.parameters;
      if (parameterList == null) {
        DartType A_type;
        TypeName typeName = node.type;
        if (typeName == null) {
          A_type = _dynamicType;
          if (parameter is FieldFormalParameterElement) {
            FieldElement fieldElement = (parameter as FieldFormalParameterElement).field;
            if (fieldElement != null) {
              A_type = fieldElement.type;
            }
          }
        } else {
          A_type = A__getType(typeName);
        }
        parameter.type = A_type;
      } else {
        _setFunctionTypedParameterType(parameter, node.type, node.parameters);
      }
    } else {}
    return null;
  }
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    super.visitFunctionDeclaration(node);
    ExecutableElementImpl A_element = node.element as ExecutableElementImpl;
    if (A_element == null) {
      JavaStringBuilder A_builder = new JavaStringBuilder();
      A_builder.append("The element for the top-level function ");
      A_builder.append(node.name);
      A_builder.append(" in ");
      A_builder.append(source.fullName);
      A_builder.append(" was not set while trying to resolve types.");
      AnalysisEngine.A_instance.logger.logError2(A_builder.toString(), new AnalysisException());
    }
    A_element.returnType = _computeReturnType(node.returnType);
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(A_element);
    ClassElement definingClass = A_element.getAncestor((A_element) => A_element is ClassElement);
    if (definingClass != null) {
      A_type.typeArguments = definingClass.type.typeArguments;
    }
    A_element.type = A_type;
    return null;
  }
  Object visitFunctionTypeAlias(FunctionTypeAlias node) {
    super.visitFunctionTypeAlias(node);
    FunctionTypeAliasElementImpl A_element = node.element as FunctionTypeAliasElementImpl;
    A_element.returnType = _computeReturnType(node.returnType);
    return null;
  }
  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {
    super.visitFunctionTypedFormalParameter(node);
    A_Element A_element = node.identifier.staticElement;
    if (A_element is ParameterElementImpl) {
      _setFunctionTypedParameterType(A_element, node.returnType, node.parameters);
    } else {}
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    super.visitMethodDeclaration(node);
    ExecutableElementImpl A_element = node.element as ExecutableElementImpl;
    if (A_element == null) {
      ClassDeclaration classNode = node.getAncestor((node) => node is ClassDeclaration);
      JavaStringBuilder A_builder = new JavaStringBuilder();
      A_builder.append("The element for the method ");
      A_builder.append(node.name.name);
      A_builder.append(" in ");
      if (classNode == null) {
        A_builder.append("<unknown class>");
      } else {
        A_builder.append(classNode.name.name);
      }
      A_builder.append(" in ");
      A_builder.append(source.fullName);
      A_builder.append(" was not set while trying to resolve types.");
      AnalysisEngine.A_instance.logger.logError2(A_builder.toString(), new AnalysisException());
    }
    A_element.returnType = _computeReturnType(node.returnType);
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(A_element);
    ClassElement definingClass = A_element.getAncestor((A_element) => A_element is ClassElement);
    if (definingClass != null) {
      A_type.typeArguments = definingClass.type.typeArguments;
    }
    A_element.type = A_type;
    if (A_element is PropertyAccessorElement) {
      PropertyAccessorElement accessor = A_element as PropertyAccessorElement;
      PropertyInducingElementImpl variable = accessor.variable as PropertyInducingElementImpl;
      if (accessor.isGetter) {
        variable.type = A_type.returnType;
      } else if (variable.type == null) {
        List<DartType> A_parameterTypes = A_type.normalParameterTypes;
        if (A_parameterTypes != null && A_parameterTypes.length > 0) {
          variable.type = A_parameterTypes[0];
        }
      }
    }
    return null;
  }
  Object visitSimpleFormalParameter(SimpleFormalParameter node) {
    super.visitSimpleFormalParameter(node);
    DartType declaredType;
    TypeName typeName = node.type;
    if (typeName == null) {
      declaredType = _dynamicType;
    } else {
      declaredType = A__getType(typeName);
    }
    A_Element A_element = node.identifier.staticElement;
    if (A_element is ParameterElement) {
      (A_element as ParameterElementImpl).type = declaredType;
    } else {}
    return null;
  }
  Object visitSuperExpression(SuperExpression node) {
    _hasReferenceToSuper = true;
    return super.visitSuperExpression(node);
  }
  Object visitTypeName(TypeName node) {
    super.visitTypeName(node);
    Identifier typeName = node.name;
    TypeArgumentList argumentList = node.typeArguments;
    A_Element A_element = nameScope.lookup(typeName, definingLibrary);
    if (A_element == null) {
      if (typeName.name == _dynamicType.name) {
        _setElement(typeName, _dynamicType.element);
        if (argumentList != null) {}
        typeName.staticType = _dynamicType;
        node.type = _dynamicType;
        return null;
      }
      VoidTypeImpl voidType = VoidTypeImpl.instance;
      if (typeName.name == voidType.name) {
        if (argumentList != null) {}
        typeName.staticType = voidType;
        node.type = voidType;
        return null;
      }
      AstNode A_parent = node.parent;
      if (typeName is PrefixedIdentifier && A_parent is ConstructorName && argumentList == null) {
        ConstructorName A_name = A_parent;
        if (A_name.name == null) {
          PrefixedIdentifier prefixedIdentifier = typeName as PrefixedIdentifier;
          SimpleIdentifier prefix = prefixedIdentifier.prefix;
          A_element = nameScope.lookup(prefix, definingLibrary);
          if (A_element is PrefixElement) {
            if (A_parent.parent is InstanceCreationExpression && (A_parent.parent as InstanceCreationExpression).isConst) {
              reportErrorForNode(CompileTimeErrorCode.CONST_WITH_NON_TYPE, prefixedIdentifier.identifier, [prefixedIdentifier.identifier.name]);
            } else {
              reportErrorForNode(StaticWarningCode.NEW_WITH_NON_TYPE, prefixedIdentifier.identifier, [prefixedIdentifier.identifier.name]);
            }
            _setElement(prefix, A_element);
            return null;
          } else if (A_element != null) {
            A_name.name = prefixedIdentifier.identifier;
            A_name.period = prefixedIdentifier.period;
            node.name = prefix;
            typeName = prefix;
          }
        }
      }
    }
    bool elementValid = A_element is! MultiplyDefinedElement;
    if (elementValid && A_element is! ClassElement && _isTypeNameInInstanceCreationExpression(node)) {
      SimpleIdentifier typeNameSimple = _getTypeSimpleIdentifier(typeName);
      InstanceCreationExpression creation = node.parent.parent as InstanceCreationExpression;
      if (creation.isConst) {
        if (A_element == null) {
          reportErrorForNode(CompileTimeErrorCode.UNDEFINED_CLASS, typeNameSimple, [typeName]);
        } else {
          reportErrorForNode(CompileTimeErrorCode.CONST_WITH_NON_TYPE, typeNameSimple, [typeName]);
        }
        elementValid = false;
      } else {
        if (A_element != null) {
          reportErrorForNode(StaticWarningCode.NEW_WITH_NON_TYPE, typeNameSimple, [typeName]);
          elementValid = false;
        }
      }
    }
    if (elementValid && A_element == null) {
      SimpleIdentifier typeNameSimple = _getTypeSimpleIdentifier(typeName);
      RedirectingConstructorKind redirectingConstructorKind;
      if (_isBuiltInIdentifier(node) && _isTypeAnnotation(node)) {
        reportErrorForNode(CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE, typeName, [typeName.name]);
      } else if (typeNameSimple.name == "boolean") {
        reportErrorForNode(StaticWarningCode.UNDEFINED_CLASS_BOOLEAN, typeNameSimple, []);
      } else if (_isTypeNameInCatchClause(node)) {
        reportErrorForNode(StaticWarningCode.NON_TYPE_IN_CATCH_CLAUSE, typeName, [typeName.name]);
      } else if (_isTypeNameInAsExpression(node)) {
        reportErrorForNode(StaticWarningCode.CAST_TO_NON_TYPE, typeName, [typeName.name]);
      } else if (_isTypeNameInIsExpression(node)) {
        reportErrorForNode(StaticWarningCode.TYPE_TEST_NON_TYPE, typeName, [typeName.name]);
      } else if ((redirectingConstructorKind = _getRedirectingConstructorKind(node)) != null) {
        ErrorCode A_errorCode = (redirectingConstructorKind == RedirectingConstructorKind.A_CONST ? CompileTimeErrorCode.REDIRECT_TO_NON_CLASS : StaticWarningCode.REDIRECT_TO_NON_CLASS);
        reportErrorForNode(A_errorCode, typeName, [typeName.name]);
      } else if (_isTypeNameInTypeArgumentList(node)) {
        reportErrorForNode(StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT, typeName, [typeName.name]);
      } else {
        reportErrorForNode(StaticWarningCode.UNDEFINED_CLASS, typeName, [typeName.name]);
      }
      elementValid = false;
    }
    if (!elementValid) {
      if (A_element is MultiplyDefinedElement) {
        _setElement(typeName, A_element);
      } else {
        _setElement(typeName, _dynamicType.element);
      }
      typeName.staticType = _dynamicType;
      node.type = _dynamicType;
      return null;
    }
    DartType A_type = null;
    if (A_element is ClassElement) {
      _setElement(typeName, A_element);
      A_type = (A_element as ClassElement).type;
    } else if (A_element is FunctionTypeAliasElement) {
      _setElement(typeName, A_element);
      A_type = (A_element as FunctionTypeAliasElement).type;
    } else if (A_element is TypeParameterElement) {
      _setElement(typeName, A_element);
      A_type = (A_element as TypeParameterElement).type;
      if (argumentList != null) {}
    } else if (A_element is MultiplyDefinedElement) {
      List<A_Element> elements = (A_element as MultiplyDefinedElement).conflictingElements;
      A_type = _getTypeWhenMultiplyDefined(elements);
      if (A_type != null) {
        node.type = A_type;
      }
    } else {
      RedirectingConstructorKind redirectingConstructorKind;
      if (_isTypeNameInCatchClause(node)) {
        reportErrorForNode(StaticWarningCode.NON_TYPE_IN_CATCH_CLAUSE, typeName, [typeName.name]);
      } else if (_isTypeNameInAsExpression(node)) {
        reportErrorForNode(StaticWarningCode.CAST_TO_NON_TYPE, typeName, [typeName.name]);
      } else if (_isTypeNameInIsExpression(node)) {
        reportErrorForNode(StaticWarningCode.TYPE_TEST_NON_TYPE, typeName, [typeName.name]);
      } else if ((redirectingConstructorKind = _getRedirectingConstructorKind(node)) != null) {
        ErrorCode A_errorCode = (redirectingConstructorKind == RedirectingConstructorKind.A_CONST ? CompileTimeErrorCode.REDIRECT_TO_NON_CLASS : StaticWarningCode.REDIRECT_TO_NON_CLASS);
        reportErrorForNode(A_errorCode, typeName, [typeName.name]);
      } else if (_isTypeNameInTypeArgumentList(node)) {
        reportErrorForNode(StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT, typeName, [typeName.name]);
      } else {
        AstNode A_parent = typeName.parent;
        while (A_parent is TypeName) {
          A_parent = A_parent.parent;
        }
        if (A_parent is ExtendsClause || A_parent is ImplementsClause || A_parent is WithClause || A_parent is ClassTypeAlias) {} else {
          reportErrorForNode(StaticWarningCode.NOT_A_TYPE, typeName, [typeName.name]);
        }
      }
      _setElement(typeName, _dynamicType.element);
      typeName.staticType = _dynamicType;
      node.type = _dynamicType;
      return null;
    }
    if (argumentList != null) {
      NodeList<TypeName> A_arguments = argumentList.arguments;
      int argumentCount = A_arguments.length;
      List<DartType> A_parameters = _getTypeArguments(A_type);
      int parameterCount = A_parameters.length;
      List<DartType> typeArguments = new List<DartType>(parameterCount);
      if (argumentCount == parameterCount) {
        for (int i = 0; i < parameterCount; i++) {
          TypeName argumentTypeName = A_arguments[i];
          DartType argumentType = A__getType(argumentTypeName);
          if (argumentType == null) {
            argumentType = _dynamicType;
          }
          typeArguments[i] = argumentType;
        }
      } else {
        reportErrorForNode(_getInvalidTypeParametersErrorCode(node), node, [typeName.name, parameterCount, argumentCount]);
        for (int i = 0; i < parameterCount; i++) {
          typeArguments[i] = _dynamicType;
        }
      }
      if (A_type is InterfaceTypeImpl) {
        InterfaceTypeImpl interfaceType = A_type as InterfaceTypeImpl;
        A_type = interfaceType.substitute4(typeArguments);
      } else if (A_type is FunctionTypeImpl) {
        FunctionTypeImpl A_functionType = A_type as FunctionTypeImpl;
        A_type = A_functionType.substitute3(typeArguments);
      } else {}
    } else {
      List<DartType> A_parameters = _getTypeArguments(A_type);
      int parameterCount = A_parameters.length;
      if (parameterCount > 0) {
        DynamicTypeImpl dynamicType = DynamicTypeImpl.instance;
        List<DartType> A_arguments = new List<DartType>(parameterCount);
        for (int i = 0; i < parameterCount; i++) {
          A_arguments[i] = dynamicType;
        }
        A_type = A_type.substitute2(A_arguments, A_parameters);
      }
    }
    typeName.staticType = A_type;
    node.type = A_type;
    return null;
  }
  Object visitTypeParameter(TypeParameter node) {
    super.visitTypeParameter(node);
    TypeName A_bound = node.bound;
    if (A_bound != null) {
      TypeParameterElementImpl typeParameter = node.name.staticElement as TypeParameterElementImpl;
      if (typeParameter != null) {
        typeParameter.bound = A_bound.type;
      }
    }
    return null;
  }
  Object visitVariableDeclaration(VariableDeclaration node) {
    super.visitVariableDeclaration(node);
    DartType declaredType;
    TypeName typeName = (node.parent as VariableDeclarationList).type;
    if (typeName == null) {
      declaredType = _dynamicType;
    } else {
      declaredType = A__getType(typeName);
    }
    A_Element A_element = node.name.staticElement;
    if (A_element is VariableElement) {
      (A_element as VariableElementImpl).type = declaredType;
      if (A_element is PropertyInducingElement) {
        PropertyInducingElement variableElement = A_element;
        PropertyAccessorElementImpl getter = variableElement.getter as PropertyAccessorElementImpl;
        getter.returnType = declaredType;
        FunctionTypeImpl getterType = new FunctionTypeImpl.B_con1(getter);
        ClassElement definingClass = A_element.getAncestor((A_element) => A_element is ClassElement);
        if (definingClass != null) {
          getterType.typeArguments = definingClass.type.typeArguments;
        }
        getter.type = getterType;
        PropertyAccessorElementImpl setter = variableElement.setter as PropertyAccessorElementImpl;
        if (setter != null) {
          List<ParameterElement> A_parameters = setter.parameters;
          if (A_parameters.length > 0) {
            (A_parameters[0] as ParameterElementImpl).type = declaredType;
          }
          setter.returnType = VoidTypeImpl.instance;
          FunctionTypeImpl setterType = new FunctionTypeImpl.B_con1(setter);
          if (definingClass != null) {
            setterType.typeArguments = definingClass.type.typeArguments;
          }
          setter.type = setterType;
        }
      }
    } else {}
    return null;
  }
  void visitClassMembersInScope(ClassDeclaration node) {
    List<ClassMember> nonFields = new List<ClassMember>();
    node.visitChildren(new UnifyingAstVisitor_TypeResolverVisitor_visitClassMembersInScope(this, nonFields));
    int count = nonFields.length;
    for (int i = 0; i < count; i++) {
      nonFields[i].accept(this);
    }
  }
  DartType _computeReturnType(TypeName A_returnType) {
    if (A_returnType == null) {
      return _dynamicType;
    } else {
      return A_returnType.type;
    }
  }
  ConstructorElement _createImplicitContructor(InterfaceType classType, ConstructorElement explicitConstructor, List<DartType> A_parameterTypes, List<DartType> argumentTypes) {
    ConstructorElementImpl implicitConstructor = new ConstructorElementImpl(explicitConstructor.name, -1);
    implicitConstructor.synthetic = true;
    implicitConstructor.redirectedConstructor = explicitConstructor;
    implicitConstructor.const2 = explicitConstructor.isConst;
    implicitConstructor.returnType = classType;
    List<ParameterElement> explicitParameters = explicitConstructor.parameters;
    int count = explicitParameters.length;
    if (count > 0) {
      List<ParameterElement> implicitParameters = new List<ParameterElement>(count);
      for (int i = 0; i < count; i++) {
        ParameterElement explicitParameter = explicitParameters[i];
        ParameterElementImpl implicitParameter = new ParameterElementImpl(explicitParameter.name, -1);
        implicitParameter.const3 = explicitParameter.isConst;
        implicitParameter.final2 = explicitParameter.isFinal;
        implicitParameter.parameterKind = explicitParameter.parameterKind;
        implicitParameter.synthetic = true;
        implicitParameter.type = explicitParameter.type.substitute2(argumentTypes, A_parameterTypes);
        implicitParameters[i] = implicitParameter;
      }
      implicitConstructor.parameters = implicitParameters;
    }
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con1(implicitConstructor);
    A_type.typeArguments = classType.typeArguments;
    implicitConstructor.type = A_type;
    return implicitConstructor;
  }
  List<DartType> _getArgumentTypes(TypeArgumentList typeArguments, List<DartType> A_parameterTypes) {
    DynamicTypeImpl dynamic = DynamicTypeImpl.instance;
    int parameterCount = A_parameterTypes.length;
    List<DartType> A_types = new List<DartType>(parameterCount);
    if (typeArguments == null) {
      for (int i = 0; i < parameterCount; i++) {
        A_types[i] = dynamic;
      }
    } else {
      NodeList<TypeName> A_arguments = typeArguments.arguments;
      int argumentCount = Math.A_min(A_arguments.length, parameterCount);
      for (int i = 0; i < argumentCount; i++) {
        A_types[i] = A_arguments[i].type;
      }
      for (int i = argumentCount; i < parameterCount; i++) {
        A_types[i] = dynamic;
      }
    }
    return A_types;
  }
  ClassElementImpl _getClassElement(SimpleIdentifier identifier) {
    if (identifier == null) {
      return null;
    }
    A_Element A_element = identifier.staticElement;
    if (A_element is! ClassElementImpl) {
      return null;
    }
    return A_element as ClassElementImpl;
  }
  List<ParameterElement> _getElements(FormalParameterList parameterList) {
    List<ParameterElement> elements = new List<ParameterElement>();
    for (FormalParameter parameter in parameterList.parameters) {
      ParameterElement A_element = parameter.identifier.staticElement as ParameterElement;
      if (A_element != null) {
        elements.add(A_element);
      }
    }
    return new List.from(elements);
  }
  ErrorCode _getInvalidTypeParametersErrorCode(TypeName node) {
    AstNode A_parent = node.parent;
    if (A_parent is ConstructorName) {
      A_parent = A_parent.parent;
      if (A_parent is InstanceCreationExpression) {
        if ((A_parent as InstanceCreationExpression).isConst) {
          return CompileTimeErrorCode.CONST_WITH_INVALID_TYPE_PARAMETERS;
        } else {
          return StaticWarningCode.NEW_WITH_INVALID_TYPE_PARAMETERS;
        }
      }
    }
    return StaticTypeWarningCode.WRONG_NUMBER_OF_TYPE_ARGUMENTS;
  }
  RedirectingConstructorKind _getRedirectingConstructorKind(TypeName typeName) {
    AstNode A_parent = typeName.parent;
    if (A_parent is ConstructorName) {
      ConstructorName constructorName = A_parent as ConstructorName;
      A_parent = constructorName.parent;
      if (A_parent is ConstructorDeclaration) {
        ConstructorDeclaration constructorDeclaration = A_parent as ConstructorDeclaration;
        if (identical(constructorDeclaration.redirectedConstructor, constructorName)) {
          if (constructorDeclaration.constKeyword != null) {
            return RedirectingConstructorKind.A_CONST;
          }
          return RedirectingConstructorKind.NORMAL;
        }
      }
    }
    return null;
  }
  DartType A__getType(TypeName typeName) {
    DartType A_type = typeName.type;
    if (A_type == null) {
      return _dynamicType;
    }
    return A_type;
  }
  List<DartType> _getTypeArguments(DartType A_type) {
    if (A_type is InterfaceType) {
      return A_type.typeArguments;
    } else if (A_type is FunctionType) {
      return A_type.typeArguments;
    }
    return A_TypeImpl.B_EMPTY_ARRAY;
  }
  SimpleIdentifier _getTypeSimpleIdentifier(Identifier typeName) {
    if (typeName is SimpleIdentifier) {
      return typeName;
    } else {
      return (typeName as PrefixedIdentifier).identifier;
    }
  }
  InterfaceType _getTypeWhenMultiplyDefined(List<A_Element> elements) {
    InterfaceType A_type = null;
    for (A_Element A_element in elements) {
      if (A_element is ClassElement) {
        if (A_type != null) {
          return null;
        }
        A_type = A_element.type;
      }
    }
    return A_type;
  }
  bool _isTypeNameInAsExpression(TypeName typeName) {
    AstNode A_parent = typeName.parent;
    if (A_parent is AsExpression) {
      AsExpression asExpression = A_parent;
      return identical(asExpression.type, typeName);
    }
    return false;
  }
  bool _isTypeNameInCatchClause(TypeName typeName) {
    AstNode A_parent = typeName.parent;
    if (A_parent is CatchClause) {
      CatchClause catchClause = A_parent;
      return identical(catchClause.exceptionType, typeName);
    }
    return false;
  }
  bool _isTypeNameInInstanceCreationExpression(TypeName typeName) {
    AstNode A_parent = typeName.parent;
    if (A_parent is ConstructorName && A_parent.parent is InstanceCreationExpression) {
      ConstructorName constructorName = A_parent;
      return constructorName != null && identical(constructorName.type, typeName);
    }
    return false;
  }
  bool _isTypeNameInIsExpression(TypeName typeName) {
    AstNode A_parent = typeName.parent;
    if (A_parent is IsExpression) {
      IsExpression isExpression = A_parent;
      return identical(isExpression.type, typeName);
    }
    return false;
  }
  bool _isTypeNameInTypeArgumentList(TypeName typeName) => typeName.parent is TypeArgumentList;
  Object _recordType(Expression expression, DartType A_type) {
    if (A_type == null) {
      expression.staticType = _dynamicType;
    } else {
      expression.staticType = A_type;
    }
    return null;
  }
  void _resolve(ClassElementImpl classElement, WithClause withClause, ImplementsClause implementsClause) {
    if (withClause != null) {
      List<InterfaceType> mixinTypes = _resolveTypes(withClause.mixinTypes, CompileTimeErrorCode.MIXIN_OF_NON_CLASS, CompileTimeErrorCode.MIXIN_OF_NON_CLASS);
      if (classElement != null) {
        classElement.mixins = mixinTypes;
      }
    }
    if (implementsClause != null) {
      NodeList<TypeName> interfaces = implementsClause.interfaces;
      List<InterfaceType> interfaceTypes = _resolveTypes(interfaces, CompileTimeErrorCode.IMPLEMENTS_NON_CLASS, CompileTimeErrorCode.IMPLEMENTS_DYNAMIC);
      if (classElement != null) {
        classElement.interfaces = interfaceTypes;
      }
      List<TypeName> typeNames = new List.from(interfaces);
      List<bool> detectedRepeatOnIndex = new List<bool>.filled(typeNames.length, false);
      for (int i = 0; i < detectedRepeatOnIndex.length; i++) {
        detectedRepeatOnIndex[i] = false;
      }
      for (int i = 0; i < typeNames.length; i++) {
        TypeName typeName = typeNames[i];
        if (!detectedRepeatOnIndex[i]) {
          A_Element A_element = typeName.name.staticElement;
          for (int j = i + 1; j < typeNames.length; j++) {
            TypeName typeName2 = typeNames[j];
            Identifier identifier2 = typeName2.name;
            String name2 = identifier2.name;
            A_Element element2 = identifier2.staticElement;
            if (A_element != null && A_element == element2) {
              detectedRepeatOnIndex[j] = true;
              reportErrorForNode(CompileTimeErrorCode.IMPLEMENTS_REPEATED, typeName2, [name2]);
            }
          }
        }
      }
    }
  }
  InterfaceType _resolveType(TypeName typeName, ErrorCode nonTypeError, ErrorCode dynamicTypeError) {
    DartType A_type = typeName.type;
    if (A_type is InterfaceType) {
      return A_type;
    }
    Identifier A_name = typeName.name;
    if (A_name.name == Keyword.A_DYNAMIC.syntax) {
      reportErrorForNode(dynamicTypeError, A_name, [A_name.name]);
    } else {
      reportErrorForNode(nonTypeError, A_name, [A_name.name]);
    }
    return null;
  }
  List<InterfaceType> _resolveTypes(NodeList<TypeName> typeNames, ErrorCode nonTypeError, ErrorCode dynamicTypeError) {
    List<InterfaceType> A_types = new List<InterfaceType>();
    for (TypeName typeName in typeNames) {
      InterfaceType A_type = _resolveType(typeName, nonTypeError, dynamicTypeError);
      if (A_type != null) {
        A_types.add(A_type);
      }
    }
    return new List.from(A_types);
  }
  void _setElement(Identifier typeName, A_Element A_element) {
    if (A_element != null) {
      if (typeName is SimpleIdentifier) {
        typeName.staticElement = A_element;
      } else if (typeName is PrefixedIdentifier) {
        PrefixedIdentifier identifier = typeName;
        identifier.identifier.staticElement = A_element;
        SimpleIdentifier prefix = identifier.prefix;
        A_Element prefixElement = nameScope.lookup(prefix, definingLibrary);
        if (prefixElement != null) {
          prefix.staticElement = prefixElement;
        }
      }
    }
  }
  void _setFunctionTypedParameterType(ParameterElementImpl A_element, TypeName A_returnType, FormalParameterList parameterList) {
    List<ParameterElement> A_parameters = _getElements(parameterList);
    FunctionTypeAliasElementImpl aliasElement = new FunctionTypeAliasElementImpl(null);
    aliasElement.synthetic = true;
    aliasElement.shareParameters(A_parameters);
    aliasElement.returnType = _computeReturnType(A_returnType);
    aliasElement.enclosingElement = A_element.getAncestor((A_element) => A_element is CompilationUnitElement);
    FunctionTypeImpl A_type = new FunctionTypeImpl.B_con2(aliasElement);
    ClassElement definingClass = A_element.getAncestor((A_element) => A_element is ClassElement);
    if (definingClass != null) {
      aliasElement.shareTypeParameters(definingClass.typeParameters);
      A_type.typeArguments = definingClass.type.typeArguments;
    } else {
      FunctionTypeAliasElement alias = A_element.getAncestor((A_element) => A_element is FunctionTypeAliasElement);
      while (alias != null && alias.isSynthetic) {
        alias = alias.getAncestor((A_element) => A_element is FunctionTypeAliasElement);
      }
      if (alias != null) {
        aliasElement.typeParameters = alias.typeParameters;
        A_type.typeArguments = alias.type.typeArguments;
      } else {
        A_type.typeArguments = A_TypeImpl.B_EMPTY_ARRAY;
      }
    }
    A_element.type = A_type;
  }
}
class UnifyingAstVisitor_ElementBuilder_visitClassDeclaration extends UnifyingAstVisitor<Object> {
  final ElementBuilder ElementBuilder_this;
  List<ClassMember> nonFields;
  UnifyingAstVisitor_ElementBuilder_visitClassDeclaration(this.ElementBuilder_this, this.nonFields) : super();
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    nonFields.add(node);
    return null;
  }
  Object visitMethodDeclaration(MethodDeclaration node) {
    nonFields.add(node);
    return null;
  }
  Object visitNode(AstNode node) => node.accept(ElementBuilder_this);
}
class UnifyingAstVisitor_TypeResolverVisitor_visitClassMembersInScope extends UnifyingAstVisitor<Object> {
  final TypeResolverVisitor TypeResolverVisitor_this;
  List<ClassMember> nonFields;
  UnifyingAstVisitor_TypeResolverVisitor_visitClassMembersInScope(this.TypeResolverVisitor_this, this.nonFields) : super();
  Object visitConstructorDeclaration(ConstructorDeclaration node) {
    nonFields.add(node);
    return null;
  }
  Object visitExtendsClause(ExtendsClause node) => null;
  Object visitImplementsClause(ImplementsClause node) => null;
  Object visitMethodDeclaration(MethodDeclaration node) {
    nonFields.add(node);
    return null;
  }
  Object visitNode(AstNode node) => node.accept(TypeResolverVisitor_this);
  Object visitWithClause(WithClause node) => null;
}
class VariableResolverVisitor extends ScopedVisitor {
  ExecutableElement _enclosingFunction;
  VariableResolverVisitor.G_con1(Library library, Source A_source, TypeProvider typeProvider) : super.G_con1(library, A_source, typeProvider);
  VariableResolverVisitor.G_con2(LibraryElement definingLibrary, Source A_source, TypeProvider typeProvider, Scope nameScope, AnalysisErrorListener errorListener) : super.B_con3(definingLibrary, A_source, typeProvider, nameScope, errorListener);
  VariableResolverVisitor.B_con3(ResolvableLibrary library, Source A_source, TypeProvider typeProvider) : super.A_con4(library, A_source, typeProvider);
  Object visitFunctionDeclaration(FunctionDeclaration node) {
    ExecutableElement outerFunction = _enclosingFunction;
    try {
      _enclosingFunction = node.element;
      return super.visitFunctionDeclaration(node);
    } finally {
      _enclosingFunction = outerFunction;
    }
  }
  Object visitFunctionExpression(FunctionExpression node) {
    if (node.parent is! FunctionDeclaration) {
      ExecutableElement outerFunction = _enclosingFunction;
      try {
        _enclosingFunction = node.element;
        return super.visitFunctionExpression(node);
      } finally {
        _enclosingFunction = outerFunction;
      }
    } else {
      return super.visitFunctionExpression(node);
    }
  }
  Object visitSimpleIdentifier(SimpleIdentifier node) {
    if (node.staticElement != null) {
      return null;
    }
    AstNode A_parent = node.parent;
    if (A_parent is PrefixedIdentifier && identical(A_parent.identifier, node)) {
      return null;
    }
    if (A_parent is PropertyAccess && identical(A_parent.propertyName, node)) {
      return null;
    }
    if (A_parent is MethodInvocation && identical(A_parent.methodName, node)) {
      return null;
    }
    if (A_parent is ConstructorName) {
      return null;
    }
    if (A_parent is Label) {
      return null;
    }
    A_Element A_element = nameScope.lookup(node, definingLibrary);
    if (A_element is! VariableElement) {
      return null;
    }
    A_ElementKind kind = A_element.kind;
    if (kind == A_ElementKind.B_LOCAL_VARIABLE) {
      node.staticElement = A_element;
      if (node.inSetterContext()) {
        LocalVariableElementImpl variableImpl = A_element as LocalVariableElementImpl;
        variableImpl.markPotentiallyMutatedInScope();
        if (A_element.enclosingElement != _enclosingFunction) {
          variableImpl.markPotentiallyMutatedInClosure();
        }
      }
    } else if (kind == A_ElementKind.E_PARAMETER) {
      node.staticElement = A_element;
      if (node.inSetterContext()) {
        ParameterElementImpl parameterImpl = A_element as ParameterElementImpl;
        parameterImpl.markPotentiallyMutatedInScope();
        if (_enclosingFunction != null && (A_element.enclosingElement != _enclosingFunction)) {
          parameterImpl.markPotentiallyMutatedInClosure();
        }
      }
    }
    return null;
  }
}
class BeginToken extends A_Token {
  A_Token endToken;
  BeginToken(A_TokenType A_type, int A_offset) : super(A_type, A_offset) {
    assert((A_type == A_TokenType.OPEN_CURLY_BRACKET || A_type == A_TokenType.OPEN_PAREN || A_type == A_TokenType.OPEN_SQUARE_BRACKET || A_type == A_TokenType.STRING_INTERPOLATION_EXPRESSION));
  }
  A_Token copy() => new BeginToken(type, offset);
}
class BeginTokenWithComment extends BeginToken {
  final A_Token _precedingComment;
  BeginTokenWithComment(A_TokenType A_type, int A_offset, this._precedingComment) : super(A_type, A_offset);
  A_Token copy() => new BeginTokenWithComment(type, offset, copyComments(_precedingComment));
  A_Token get precedingComments => _precedingComment;
  void applyDelta(int delta) {
    super.applyDelta(delta);
    A_Token token = _precedingComment;
    while (token != null) {
      token.applyDelta(delta);
      token = token.next;
    }
  }
}
class CharSequenceReader implements CharacterReader {
  final String _sequence;
  int A__stringLength = 0;
  int A__charOffset = 0;
  CharSequenceReader(this._sequence) {
    this.A__stringLength = _sequence.length;
    this.A__charOffset = -1;
  }
  int advance() {
    if (A__charOffset + 1 >= A__stringLength) {
      return -1;
    }
    return _sequence.codeUnitAt(++A__charOffset);
  }
  int get offset => A__charOffset;
  String getString(int A_start, int endDelta) => _sequence.substring(A_start, A__charOffset + 1 + endDelta).toString();
  int peek() {
    if (A__charOffset + 1 >= _sequence.length) {
      return -1;
    }
    return _sequence.codeUnitAt(A__charOffset + 1);
  }
  void set offset(int A_offset) {
    A__charOffset = A_offset;
  }
}
abstract class CharacterReader {
  int advance();
  int get offset;
  String getString(int A_start, int endDelta);
  int peek();
  void set offset(int A_offset);
}
class IncrementalScanner extends Scanner {
  CharacterReader _reader;
  TokenMap B__tokenMap = new TokenMap();
  A_Token _leftToken;
  A_Token _rightToken;
  bool _hasNonWhitespaceChange = false;
  IncrementalScanner(Source A_source, CharacterReader reader, AnalysisErrorListener errorListener) : super(A_source, reader, errorListener) {
    this._reader = reader;
  }
  A_Token get leftToken => _leftToken;
  A_Token get rightToken => _rightToken;
  TokenMap get tokenMap => B__tokenMap;
  A_Token rescan(A_Token originalStream, int A_index, int removedLength, int insertedLength) {
    while (originalStream.type != A_TokenType.A_EOF && originalStream.end < A_index) {
      originalStream = _copyAndAdvance(originalStream, 0);
    }
    A_Token oldFirst = originalStream;
    A_Token oldLeftToken = originalStream.previous;
    _leftToken = tail;
    int removedEnd = A_index + (removedLength == 0 ? 0 : removedLength - 1);
    while (originalStream.type != A_TokenType.A_EOF && originalStream.offset <= removedEnd) {
      originalStream = originalStream.next;
    }
    A_Token oldLast;
    A_Token oldRightToken;
    if (originalStream.type != A_TokenType.A_EOF && removedEnd + 1 == originalStream.offset) {
      oldLast = originalStream;
      originalStream = originalStream.next;
      oldRightToken = originalStream;
    } else {
      oldLast = originalStream.previous;
      oldRightToken = originalStream;
    }
    int delta = insertedLength - removedLength;
    int scanStart = Math.A_min(oldFirst.offset, A_index);
    int oldEnd = oldLast.end + delta - 1;
    int newEnd = A_index + insertedLength - 1;
    int scanEnd = Math.A_max(newEnd, oldEnd);
    _reader.offset = scanStart - 1;
    int A_next = _reader.advance();
    while (A_next != -1 && _reader.offset <= scanEnd) {
      A_next = bigSwitch(A_next);
    }
    if (originalStream.type == A_TokenType.A_EOF) {
      _copyAndAdvance(originalStream, delta);
      _rightToken = tail;
      _rightToken.setNextWithoutSettingPrevious(_rightToken);
    } else {
      originalStream = _copyAndAdvance(originalStream, delta);
      _rightToken = tail;
      while (originalStream.type != A_TokenType.A_EOF) {
        originalStream = _copyAndAdvance(originalStream, delta);
      }
      A_Token eof = _copyAndAdvance(originalStream, delta);
      eof.setNextWithoutSettingPrevious(eof);
    }
    A_Token newFirst = _leftToken.next;
    while (!identical(newFirst, _rightToken) && !identical(oldFirst, oldRightToken) && newFirst.type != A_TokenType.A_EOF && _equalTokens(oldFirst, newFirst)) {
      B__tokenMap.put(oldFirst, newFirst);
      oldLeftToken = oldFirst;
      oldFirst = oldFirst.next;
      _leftToken = newFirst;
      newFirst = newFirst.next;
    }
    A_Token newLast = _rightToken.previous;
    while (!identical(newLast, _leftToken) && !identical(oldLast, oldLeftToken) && newLast.type != A_TokenType.A_EOF && _equalTokens(oldLast, newLast)) {
      B__tokenMap.put(oldLast, newLast);
      oldRightToken = oldLast;
      oldLast = oldLast.previous;
      _rightToken = newLast;
      newLast = newLast.previous;
    }
    _hasNonWhitespaceChange = !identical(_leftToken.next, _rightToken) || !identical(oldLeftToken.next, oldRightToken);
    return firstToken;
  }
  A_Token _copyAndAdvance(A_Token originalToken, int delta) {
    A_Token copiedToken = originalToken.copy();
    B__tokenMap.put(originalToken, copiedToken);
    copiedToken.applyDelta(delta);
    appendToken(copiedToken);
    A_Token originalComment = originalToken.precedingComments;
    A_Token copiedComment = originalToken.precedingComments;
    while (originalComment != null) {
      B__tokenMap.put(originalComment, copiedComment);
      originalComment = originalComment.next;
      copiedComment = copiedComment.next;
    }
    return originalToken.next;
  }
  bool _equalTokens(A_Token oldToken, A_Token newToken) => oldToken.type == newToken.type && oldToken.length == newToken.length && oldToken.lexeme == newToken.lexeme;
}
class Keyword extends Enum<Keyword> {
  static const Keyword ASSERT = const Keyword.H_con1('ASSERT', 0, "assert");
  static const Keyword BREAK = const Keyword.H_con1('BREAK', 1, "break");
  static const Keyword CASE = const Keyword.H_con1('CASE', 2, "case");
  static const Keyword CATCH = const Keyword.H_con1('CATCH', 3, "catch");
  static const Keyword D_CLASS = const Keyword.H_con1('CLASS', 4, "class");
  static const Keyword B_CONST = const Keyword.H_con1('CONST', 5, "const");
  static const Keyword A_CONTINUE = const Keyword.H_con1('CONTINUE', 6, "continue");
  static const Keyword A_DEFAULT = const Keyword.H_con1('DEFAULT', 7, "default");
  static const Keyword DO = const Keyword.H_con1('DO', 8, "do");
  static const Keyword ELSE = const Keyword.H_con1('ELSE', 9, "else");
  static const Keyword ENUM = const Keyword.H_con1('ENUM', 10, "enum");
  static const Keyword EXTENDS = const Keyword.H_con1('EXTENDS', 11, "extends");
  static const Keyword FALSE = const Keyword.H_con1('FALSE', 12, "false");
  static const Keyword A_FINAL = const Keyword.H_con1('FINAL', 13, "final");
  static const Keyword FINALLY = const Keyword.H_con1('FINALLY', 14, "finally");
  static const Keyword FOR = const Keyword.H_con1('FOR', 15, "for");
  static const Keyword IF = const Keyword.H_con1('IF', 16, "if");
  static const Keyword IN = const Keyword.H_con1('IN', 17, "in");
  static const Keyword IS = const Keyword.H_con1('IS', 18, "is");
  static const Keyword NEW = const Keyword.H_con1('NEW', 19, "new");
  static const Keyword A_NULL = const Keyword.H_con1('NULL', 20, "null");
  static const Keyword RETHROW = const Keyword.H_con1('RETHROW', 21, "rethrow");
  static const Keyword RETURN = const Keyword.H_con1('RETURN', 22, "return");
  static const Keyword SUPER = const Keyword.H_con1('SUPER', 23, "super");
  static const Keyword SWITCH = const Keyword.H_con1('SWITCH', 24, "switch");
  static const Keyword THIS = const Keyword.H_con1('THIS', 25, "this");
  static const Keyword THROW = const Keyword.H_con1('THROW', 26, "throw");
  static const Keyword TRUE = const Keyword.H_con1('TRUE', 27, "true");
  static const Keyword TRY = const Keyword.H_con1('TRY', 28, "try");
  static const Keyword VAR = const Keyword.H_con1('VAR', 29, "var");
  static const Keyword VOID = const Keyword.H_con1('VOID', 30, "void");
  static const Keyword WHILE = const Keyword.H_con1('WHILE', 31, "while");
  static const Keyword WITH = const Keyword.H_con1('WITH', 32, "with");
  static const Keyword A_ABSTRACT = const Keyword.H_con2('ABSTRACT', 33, "abstract", true);
  static const Keyword AS = const Keyword.H_con2('AS', 34, "as", true);
  static const Keyword A_DEFERRED = const Keyword.H_con2('DEFERRED', 35, "deferred", true);
  static const Keyword A_DYNAMIC = const Keyword.H_con2('DYNAMIC', 36, "dynamic", true);
  static const Keyword A_EXPORT = const Keyword.H_con2('EXPORT', 37, "export", true);
  static const Keyword EXTERNAL = const Keyword.H_con2('EXTERNAL', 38, "external", true);
  static const Keyword A_FACTORY = const Keyword.H_con2('FACTORY', 39, "factory", true);
  static const Keyword GET = const Keyword.H_con2('GET', 40, "get", true);
  static const Keyword IMPLEMENTS = const Keyword.H_con2('IMPLEMENTS', 41, "implements", true);
  static const Keyword B_IMPORT = const Keyword.H_con2('IMPORT', 42, "import", true);
  static const Keyword C_LIBRARY = const Keyword.H_con2('LIBRARY', 43, "library", true);
  static const Keyword OPERATOR = const Keyword.H_con2('OPERATOR', 44, "operator", true);
  static const Keyword PART = const Keyword.H_con2('PART', 45, "part", true);
  static const Keyword SET = const Keyword.H_con2('SET', 46, "set", true);
  static const Keyword A_STATIC = const Keyword.H_con2('STATIC', 47, "static", true);
  static const Keyword A_TYPEDEF = const Keyword.H_con2('TYPEDEF', 48, "typedef", true);
  static const List<Keyword> B_values = const[ASSERT, BREAK, CASE, CATCH, D_CLASS, B_CONST, A_CONTINUE, A_DEFAULT, DO, ELSE, ENUM, EXTENDS, FALSE, A_FINAL, FINALLY, FOR, IF, IN, IS, NEW, A_NULL, RETHROW, RETURN, SUPER, SWITCH, THIS, THROW, TRUE, TRY, VAR, VOID, WHILE, WITH, A_ABSTRACT, AS, A_DEFERRED, A_DYNAMIC, A_EXPORT, EXTERNAL, A_FACTORY, GET, IMPLEMENTS, B_IMPORT, C_LIBRARY, OPERATOR, PART, SET, A_STATIC, A_TYPEDEF];
  final String syntax;
  final bool isPseudoKeyword;
  static Map<String, Keyword> keywords = _createKeywordMap();
  static Map<String, Keyword> _createKeywordMap() {
    A_p.LinkedHashMap<String, Keyword> result = new A_p.LinkedHashMap<String,Keyword>();
    for (Keyword keyword in B_values) {
      result[keyword.syntax] = keyword;
    }
    return result;
  }
  const Keyword.H_con1(String A_name, int ordinal, String A_syntax) : this.H_con2(A_name, ordinal, A_syntax, false);
  const Keyword.H_con2(String A_name, int ordinal, this.syntax, this.isPseudoKeyword) : super(A_name, ordinal);
}
class KeywordState {
  static List<KeywordState> _EMPTY_TABLE = new List<KeywordState>(26);
  static KeywordState KEYWORD_STATE = _createKeywordStateTable();
  static KeywordState _computeKeywordStateTable(int A_start, List<String> strings, int A_offset, int A_length) {
    List<KeywordState> result = new List<KeywordState>(26);
    assert(A_length != 0);
    int chunk = 0x0;
    int chunkStart = -1;
    bool isLeaf = false;
    for (int i = A_offset; i < A_offset + A_length; i++) {
      if (strings[i].length == A_start) {
        isLeaf = true;
      }
      if (strings[i].length > A_start) {
        int c = strings[i].codeUnitAt(A_start);
        if (chunk != c) {
          if (chunkStart != -1) {
            result[chunk - 0x61] = _computeKeywordStateTable(A_start + 1, strings, chunkStart, i - chunkStart);
          }
          chunkStart = i;
          chunk = c;
        }
      }
    }
    if (chunkStart != -1) {
      assert(result[chunk - 0x61] == null);
      result[chunk - 0x61] = _computeKeywordStateTable(A_start + 1, strings, chunkStart, A_offset + A_length - chunkStart);
    } else {
      assert(A_length == 1);
      return new KeywordState(_EMPTY_TABLE, strings[A_offset]);
    }
    if (isLeaf) {
      return new KeywordState(result, strings[A_offset]);
    } else {
      return new KeywordState(result, null);
    }
  }
  static KeywordState _createKeywordStateTable() {
    List<Keyword> C_values = Keyword.B_values;
    List<String> strings = new List<String>(C_values.length);
    for (int i = 0; i < C_values.length; i++) {
      strings[i] = C_values[i].syntax;
    }
    strings.sort();
    return _computeKeywordStateTable(0, strings, 0, strings.length);
  }
  final List<KeywordState> A__table;
  Keyword _keyword;
  KeywordState(this.A__table, String syntax) {
    this._keyword = (syntax == null) ? null : Keyword.keywords[syntax];
  }
  Keyword keyword() => _keyword;
  KeywordState next(int c) => A__table[c - 0x61];
}
class KeywordToken extends A_Token {
  final Keyword keyword;
  KeywordToken(this.keyword, int A_offset) : super(A_TokenType.A_KEYWORD, A_offset);
  A_Token copy() => new KeywordToken(keyword, offset);
  String get lexeme => keyword.syntax;
  Keyword value() => keyword;
}
class KeywordTokenWithComment extends KeywordToken {
  final A_Token _precedingComment;
  KeywordTokenWithComment(Keyword keyword, int A_offset, this._precedingComment) : super(keyword, A_offset);
  A_Token copy() => new KeywordTokenWithComment(keyword, offset, copyComments(_precedingComment));
  A_Token get precedingComments => _precedingComment;
  void applyDelta(int delta) {
    super.applyDelta(delta);
    A_Token token = _precedingComment;
    while (token != null) {
      token.applyDelta(delta);
      token = token.next;
    }
  }
}
class Scanner {
  final Source source;
  final CharacterReader _reader;
  final AnalysisErrorListener E__errorListener;
  bool _preserveComments = true;
  A_Token A__tokens;
  A_Token B__tail;
  A_Token _firstComment;
  A_Token _lastComment;
  int _tokenStart = 0;
  List<int> A__lineStarts = new List<int>();
  List<BeginToken> _groupingStack = new List<BeginToken>();
  int _stackEnd = -1;
  bool _hasUnmatchedGroups = false;
  Scanner(this.source, this._reader, this.E__errorListener) {
    A__tokens = new A_Token(A_TokenType.A_EOF, -1);
    A__tokens.setNext(A__tokens);
    B__tail = A__tokens;
    _tokenStart = -1;
    A__lineStarts.add(0);
  }
  List<int> get lineStarts => A__lineStarts;
  void set preserveComments(bool A_preserveComments) {
    this._preserveComments = A_preserveComments;
  }
  void setSourceStart(int line, int column) {
    int A_offset = _reader.offset;
    if (line < 1 || column < 1 || A_offset < 0 || (line + column - 2) >= A_offset) {
      return;
    }
    for (int i = 2; i < line; i++) {
      A__lineStarts.add(1);
    }
    A__lineStarts.add(A_offset - column + 1);
  }
  A_Token tokenize() {
    InstrumentationBuilder instrumentation = Instrumentation.builder2("dart.engine.AbstractScanner.tokenize");
    int tokenCounter = 0;
    try {
      int A_next = _reader.advance();
      while (A_next != -1) {
        tokenCounter++;
        A_next = bigSwitch(A_next);
      }
      A__appendEofToken();
      instrumentation.metric2("tokensCount", tokenCounter);
      return firstToken;
    } finally {
      instrumentation.log2(2);
    }
  }
  void appendToken(A_Token token) {
    B__tail = B__tail.setNext(token);
  }
  int bigSwitch(int A_next) {
    _beginToken();
    if (A_next == 0xD) {
      A_next = _reader.advance();
      if (A_next == 0xA) {
        A_next = _reader.advance();
      }
      recordStartOfLine();
      return A_next;
    } else if (A_next == 0xA) {
      A_next = _reader.advance();
      recordStartOfLine();
      return A_next;
    } else if (A_next == 0x9 || A_next == 0x20) {
      return _reader.advance();
    }
    if (A_next == 0x72) {
      int peek = _reader.peek();
      if (peek == 0x22 || peek == 0x27) {
        int A_start = _reader.offset;
        return _tokenizeString(_reader.advance(), A_start, true);
      }
    }
    if (0x61 <= A_next && A_next <= 0x7A) {
      return _tokenizeKeywordOrIdentifier(A_next, true);
    }
    if ((0x41 <= A_next && A_next <= 0x5A) || A_next == 0x5F || A_next == 0x24) {
      return _tokenizeIdentifier(A_next, _reader.offset, true);
    }
    if (A_next == 0x3C) {
      return _tokenizeLessThan(A_next);
    }
    if (A_next == 0x3E) {
      return _tokenizeGreaterThan(A_next);
    }
    if (A_next == 0x3D) {
      return _tokenizeEquals(A_next);
    }
    if (A_next == 0x21) {
      return _tokenizeExclamation(A_next);
    }
    if (A_next == 0x2B) {
      return _tokenizePlus(A_next);
    }
    if (A_next == 0x2D) {
      return _tokenizeMinus(A_next);
    }
    if (A_next == 0x2A) {
      return _tokenizeMultiply(A_next);
    }
    if (A_next == 0x25) {
      return _tokenizePercent(A_next);
    }
    if (A_next == 0x26) {
      return _tokenizeAmpersand(A_next);
    }
    if (A_next == 0x7C) {
      return _tokenizeBar(A_next);
    }
    if (A_next == 0x5E) {
      return _tokenizeCaret(A_next);
    }
    if (A_next == 0x5B) {
      return _tokenizeOpenSquareBracket(A_next);
    }
    if (A_next == 0x7E) {
      return _tokenizeTilde(A_next);
    }
    if (A_next == 0x5C) {
      _appendTokenOfType(A_TokenType.A_BACKSLASH);
      return _reader.advance();
    }
    if (A_next == 0x23) {
      return _tokenizeTag(A_next);
    }
    if (A_next == 0x28) {
      _appendBeginToken(A_TokenType.OPEN_PAREN);
      return _reader.advance();
    }
    if (A_next == 0x29) {
      _appendEndToken(A_TokenType.CLOSE_PAREN, A_TokenType.OPEN_PAREN);
      return _reader.advance();
    }
    if (A_next == 0x2C) {
      _appendTokenOfType(A_TokenType.A_COMMA);
      return _reader.advance();
    }
    if (A_next == 0x3A) {
      _appendTokenOfType(A_TokenType.A_COLON);
      return _reader.advance();
    }
    if (A_next == 0x3B) {
      _appendTokenOfType(A_TokenType.SEMICOLON);
      return _reader.advance();
    }
    if (A_next == 0x3F) {
      _appendTokenOfType(A_TokenType.QUESTION);
      return _reader.advance();
    }
    if (A_next == 0x5D) {
      _appendEndToken(A_TokenType.CLOSE_SQUARE_BRACKET, A_TokenType.OPEN_SQUARE_BRACKET);
      return _reader.advance();
    }
    if (A_next == 0x60) {
      _appendTokenOfType(A_TokenType.BACKPING);
      return _reader.advance();
    }
    if (A_next == 0x7B) {
      _appendBeginToken(A_TokenType.OPEN_CURLY_BRACKET);
      return _reader.advance();
    }
    if (A_next == 0x7D) {
      _appendEndToken(A_TokenType.CLOSE_CURLY_BRACKET, A_TokenType.OPEN_CURLY_BRACKET);
      return _reader.advance();
    }
    if (A_next == 0x2F) {
      return _tokenizeSlashOrComment(A_next);
    }
    if (A_next == 0x40) {
      _appendTokenOfType(A_TokenType.AT);
      return _reader.advance();
    }
    if (A_next == 0x22 || A_next == 0x27) {
      return _tokenizeString(A_next, _reader.offset, false);
    }
    if (A_next == 0x2E) {
      return _tokenizeDotOrNumber(A_next);
    }
    if (A_next == 0x30) {
      return _tokenizeHexOrNumber(A_next);
    }
    if (0x31 <= A_next && A_next <= 0x39) {
      return _tokenizeNumber(A_next);
    }
    if (A_next == -1) {
      return -1;
    }
    C__reportError(ScannerErrorCode.ILLEGAL_CHARACTER, [A_next]);
    return _reader.advance();
  }
  A_Token get firstToken => A__tokens.next;
  A_Token get tail => B__tail;
  void recordStartOfLine() {
    A__lineStarts.add(_reader.offset);
  }
  void _appendBeginToken(A_TokenType A_type) {
    BeginToken token;
    if (_firstComment == null) {
      token = new BeginToken(A_type, _tokenStart);
    } else {
      token = new BeginTokenWithComment(A_type, _tokenStart, _firstComment);
      _firstComment = null;
      _lastComment = null;
    }
    B__tail = B__tail.setNext(token);
    _groupingStack.add(token);
    _stackEnd++;
  }
  void _appendCommentToken(A_TokenType A_type, String A_value) {
    if (!_preserveComments) {
      return;
    }
    if (_firstComment == null) {
      _firstComment = new StringToken(A_type, A_value, _tokenStart);
      _lastComment = _firstComment;
    } else {
      _lastComment = _lastComment.setNext(new StringToken(A_type, A_value, _tokenStart));
    }
  }
  void _appendEndToken(A_TokenType A_type, A_TokenType beginType) {
    A_Token token;
    if (_firstComment == null) {
      token = new A_Token(A_type, _tokenStart);
    } else {
      token = new TokenWithComment(A_type, _tokenStart, _firstComment);
      _firstComment = null;
      _lastComment = null;
    }
    B__tail = B__tail.setNext(token);
    if (_stackEnd >= 0) {
      BeginToken begin = _groupingStack[_stackEnd];
      if (begin.type == beginType) {
        begin.endToken = token;
        _groupingStack.removeAt(_stackEnd--);
      }
    }
  }
  void A__appendEofToken() {
    A_Token eofToken;
    if (_firstComment == null) {
      eofToken = new A_Token(A_TokenType.A_EOF, _reader.offset + 1);
    } else {
      eofToken = new TokenWithComment(A_TokenType.A_EOF, _reader.offset + 1, _firstComment);
      _firstComment = null;
      _lastComment = null;
    }
    eofToken.setNext(eofToken);
    B__tail = B__tail.setNext(eofToken);
    if (_stackEnd >= 0) {
      _hasUnmatchedGroups = true;
    }
  }
  void _appendKeywordToken(Keyword keyword) {
    if (_firstComment == null) {
      B__tail = B__tail.setNext(new KeywordToken(keyword, _tokenStart));
    } else {
      B__tail = B__tail.setNext(new KeywordTokenWithComment(keyword, _tokenStart, _firstComment));
      _firstComment = null;
      _lastComment = null;
    }
  }
  void _appendStringToken(A_TokenType A_type, String A_value) {
    if (_firstComment == null) {
      B__tail = B__tail.setNext(new StringToken(A_type, A_value, _tokenStart));
    } else {
      B__tail = B__tail.setNext(new StringTokenWithComment(A_type, A_value, _tokenStart, _firstComment));
      _firstComment = null;
      _lastComment = null;
    }
  }
  void _appendStringTokenWithOffset(A_TokenType A_type, String A_value, int A_offset) {
    if (_firstComment == null) {
      B__tail = B__tail.setNext(new StringToken(A_type, A_value, _tokenStart + A_offset));
    } else {
      B__tail = B__tail.setNext(new StringTokenWithComment(A_type, A_value, _tokenStart + A_offset, _firstComment));
      _firstComment = null;
      _lastComment = null;
    }
  }
  void _appendTokenOfType(A_TokenType A_type) {
    if (_firstComment == null) {
      B__tail = B__tail.setNext(new A_Token(A_type, _tokenStart));
    } else {
      B__tail = B__tail.setNext(new TokenWithComment(A_type, _tokenStart, _firstComment));
      _firstComment = null;
      _lastComment = null;
    }
  }
  void _appendTokenOfTypeWithOffset(A_TokenType A_type, int A_offset) {
    if (_firstComment == null) {
      B__tail = B__tail.setNext(new A_Token(A_type, A_offset));
    } else {
      B__tail = B__tail.setNext(new TokenWithComment(A_type, A_offset, _firstComment));
      _firstComment = null;
      _lastComment = null;
    }
  }
  void _beginToken() {
    _tokenStart = _reader.offset;
  }
  BeginToken _findTokenMatchingClosingBraceInInterpolationExpression() {
    while (_stackEnd >= 0) {
      BeginToken begin = _groupingStack[_stackEnd];
      if (begin.type == A_TokenType.OPEN_CURLY_BRACKET || begin.type == A_TokenType.STRING_INTERPOLATION_EXPRESSION) {
        return begin;
      }
      _hasUnmatchedGroups = true;
      _groupingStack.removeAt(_stackEnd--);
    }
    return null;
  }
  void C__reportError(ScannerErrorCode A_errorCode, List<Object> A_arguments) {
    E__errorListener.onError(new A_AnalysisError.D_con2(source, _reader.offset, 1, A_errorCode, A_arguments));
  }
  int _select(int choice, A_TokenType yesType, A_TokenType noType) {
    int A_next = _reader.advance();
    if (A_next == choice) {
      _appendTokenOfType(yesType);
      return _reader.advance();
    } else {
      _appendTokenOfType(noType);
      return A_next;
    }
  }
  int _selectWithOffset(int choice, A_TokenType yesType, A_TokenType noType, int A_offset) {
    int A_next = _reader.advance();
    if (A_next == choice) {
      _appendTokenOfTypeWithOffset(yesType, A_offset);
      return _reader.advance();
    } else {
      _appendTokenOfTypeWithOffset(noType, A_offset);
      return A_next;
    }
  }
  int _tokenizeAmpersand(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x26) {
      _appendTokenOfType(A_TokenType.AMPERSAND_AMPERSAND);
      return _reader.advance();
    } else if (A_next == 0x3D) {
      _appendTokenOfType(A_TokenType.AMPERSAND_EQ);
      return _reader.advance();
    } else {
      _appendTokenOfType(A_TokenType.A_AMPERSAND);
      return A_next;
    }
  }
  int _tokenizeBar(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x7C) {
      _appendTokenOfType(A_TokenType.BAR_BAR);
      return _reader.advance();
    } else if (A_next == 0x3D) {
      _appendTokenOfType(A_TokenType.BAR_EQ);
      return _reader.advance();
    } else {
      _appendTokenOfType(A_TokenType.BAR);
      return A_next;
    }
  }
  int _tokenizeCaret(int A_next) => _select(0x3D, A_TokenType.CARET_EQ, A_TokenType.CARET);
  int _tokenizeDotOrNumber(int A_next) {
    int A_start = _reader.offset;
    A_next = _reader.advance();
    if (0x30 <= A_next && A_next <= 0x39) {
      return _tokenizeFractionPart(A_next, A_start);
    } else if (0x2E == A_next) {
      return _select(0x2E, A_TokenType.PERIOD_PERIOD_PERIOD, A_TokenType.PERIOD_PERIOD);
    } else {
      _appendTokenOfType(A_TokenType.PERIOD);
      return A_next;
    }
  }
  int _tokenizeEquals(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x3D) {
      _appendTokenOfType(A_TokenType.EQ_EQ);
      return _reader.advance();
    } else if (A_next == 0x3E) {
      _appendTokenOfType(A_TokenType.D_FUNCTION);
      return _reader.advance();
    }
    _appendTokenOfType(A_TokenType.A_EQ);
    return A_next;
  }
  int _tokenizeExclamation(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x3D) {
      _appendTokenOfType(A_TokenType.BANG_EQ);
      return _reader.advance();
    }
    _appendTokenOfType(A_TokenType.BANG);
    return A_next;
  }
  int _tokenizeExponent(int A_next) {
    if (A_next == 0x2B || A_next == 0x2D) {
      A_next = _reader.advance();
    }
    bool hasDigits = false;
    while (true) {
      if (0x30 <= A_next && A_next <= 0x39) {
        hasDigits = true;
      } else {
        if (!hasDigits) {
          C__reportError(ScannerErrorCode.MISSING_DIGIT, []);
        }
        return A_next;
      }
      A_next = _reader.advance();
    }
  }
  int _tokenizeFractionPart(int A_next, int A_start) {
    bool A_done = false;
    bool hasDigit = false;
    LOOP:while (!A_done) {
      if (0x30 <= A_next && A_next <= 0x39) {
        hasDigit = true;
      } else if (0x65 == A_next || 0x45 == A_next) {
        hasDigit = true;
        A_next = _tokenizeExponent(_reader.advance());
        A_done = true;
        continue LOOP;
      } else {
        A_done = true;
        continue LOOP;
      }
      A_next = _reader.advance();
    }
    if (!hasDigit) {
      _appendStringToken(A_TokenType.INT, _reader.getString(A_start, -2));
      if (0x2E == A_next) {
        return _selectWithOffset(0x2E, A_TokenType.PERIOD_PERIOD_PERIOD, A_TokenType.PERIOD_PERIOD, _reader.offset - 1);
      }
      _appendTokenOfTypeWithOffset(A_TokenType.PERIOD, _reader.offset - 1);
      return bigSwitch(A_next);
    }
    _appendStringToken(A_TokenType.DOUBLE, _reader.getString(A_start, A_next < 0 ? 0 : -1));
    return A_next;
  }
  int _tokenizeGreaterThan(int A_next) {
    A_next = _reader.advance();
    if (0x3D == A_next) {
      _appendTokenOfType(A_TokenType.GT_EQ);
      return _reader.advance();
    } else if (0x3E == A_next) {
      A_next = _reader.advance();
      if (0x3D == A_next) {
        _appendTokenOfType(A_TokenType.GT_GT_EQ);
        return _reader.advance();
      } else {
        _appendTokenOfType(A_TokenType.GT_GT);
        return A_next;
      }
    } else {
      _appendTokenOfType(A_TokenType.A_GT);
      return A_next;
    }
  }
  int _tokenizeHex(int A_next) {
    int A_start = _reader.offset - 1;
    bool hasDigits = false;
    while (true) {
      A_next = _reader.advance();
      if ((0x30 <= A_next && A_next <= 0x39) || (0x41 <= A_next && A_next <= 0x46) || (0x61 <= A_next && A_next <= 0x66)) {
        hasDigits = true;
      } else {
        if (!hasDigits) {
          C__reportError(ScannerErrorCode.MISSING_HEX_DIGIT, []);
        }
        _appendStringToken(A_TokenType.HEXADECIMAL, _reader.getString(A_start, A_next < 0 ? 0 : -1));
        return A_next;
      }
    }
  }
  int _tokenizeHexOrNumber(int A_next) {
    int A_x = _reader.peek();
    if (A_x == 0x78 || A_x == 0x58) {
      _reader.advance();
      return _tokenizeHex(A_x);
    }
    return _tokenizeNumber(A_next);
  }
  int _tokenizeIdentifier(int A_next, int A_start, bool allowDollar) {
    while ((0x61 <= A_next && A_next <= 0x7A) || (0x41 <= A_next && A_next <= 0x5A) || (0x30 <= A_next && A_next <= 0x39) || A_next == 0x5F || (A_next == 0x24 && allowDollar)) {
      A_next = _reader.advance();
    }
    _appendStringToken(A_TokenType.IDENTIFIER, _reader.getString(A_start, A_next < 0 ? 0 : -1));
    return A_next;
  }
  int _tokenizeInterpolatedExpression(int A_next, int A_start) {
    _appendBeginToken(A_TokenType.STRING_INTERPOLATION_EXPRESSION);
    A_next = _reader.advance();
    while (A_next != -1) {
      if (A_next == 0x7D) {
        BeginToken begin = _findTokenMatchingClosingBraceInInterpolationExpression();
        if (begin == null) {
          _beginToken();
          _appendTokenOfType(A_TokenType.CLOSE_CURLY_BRACKET);
          A_next = _reader.advance();
          _beginToken();
          return A_next;
        } else if (begin.type == A_TokenType.OPEN_CURLY_BRACKET) {
          _beginToken();
          _appendEndToken(A_TokenType.CLOSE_CURLY_BRACKET, A_TokenType.OPEN_CURLY_BRACKET);
          A_next = _reader.advance();
          _beginToken();
        } else if (begin.type == A_TokenType.STRING_INTERPOLATION_EXPRESSION) {
          _beginToken();
          _appendEndToken(A_TokenType.CLOSE_CURLY_BRACKET, A_TokenType.STRING_INTERPOLATION_EXPRESSION);
          A_next = _reader.advance();
          _beginToken();
          return A_next;
        }
      } else {
        A_next = bigSwitch(A_next);
      }
    }
    return A_next;
  }
  int _tokenizeInterpolatedIdentifier(int A_next, int A_start) {
    _appendStringTokenWithOffset(A_TokenType.STRING_INTERPOLATION_IDENTIFIER, "\$", 0);
    if ((0x41 <= A_next && A_next <= 0x5A) || (0x61 <= A_next && A_next <= 0x7A) || A_next == 0x5F) {
      _beginToken();
      A_next = _tokenizeKeywordOrIdentifier(A_next, false);
    }
    _beginToken();
    return A_next;
  }
  int _tokenizeKeywordOrIdentifier(int A_next, bool allowDollar) {
    KeywordState state = KeywordState.KEYWORD_STATE;
    int A_start = _reader.offset;
    while (state != null && 0x61 <= A_next && A_next <= 0x7A) {
      state = state.next(A_next);
      A_next = _reader.advance();
    }
    if (state == null || state.keyword() == null) {
      return _tokenizeIdentifier(A_next, A_start, allowDollar);
    }
    if ((0x41 <= A_next && A_next <= 0x5A) || (0x30 <= A_next && A_next <= 0x39) || A_next == 0x5F || A_next == 0x24) {
      return _tokenizeIdentifier(A_next, A_start, allowDollar);
    } else if (A_next < 128) {
      _appendKeywordToken(state.keyword());
      return A_next;
    } else {
      return _tokenizeIdentifier(A_next, A_start, allowDollar);
    }
  }
  int _tokenizeLessThan(int A_next) {
    A_next = _reader.advance();
    if (0x3D == A_next) {
      _appendTokenOfType(A_TokenType.LT_EQ);
      return _reader.advance();
    } else if (0x3C == A_next) {
      return _select(0x3D, A_TokenType.LT_LT_EQ, A_TokenType.LT_LT);
    } else {
      _appendTokenOfType(A_TokenType.A_LT);
      return A_next;
    }
  }
  int _tokenizeMinus(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x2D) {
      _appendTokenOfType(A_TokenType.MINUS_MINUS);
      return _reader.advance();
    } else if (A_next == 0x3D) {
      _appendTokenOfType(A_TokenType.MINUS_EQ);
      return _reader.advance();
    } else {
      _appendTokenOfType(A_TokenType.MINUS);
      return A_next;
    }
  }
  int _tokenizeMultiLineComment(int A_next) {
    int nesting = 1;
    A_next = _reader.advance();
    while (true) {
      if (-1 == A_next) {
        C__reportError(ScannerErrorCode.UNTERMINATED_MULTI_LINE_COMMENT, []);
        _appendCommentToken(A_TokenType.MULTI_LINE_COMMENT, _reader.getString(_tokenStart, 0));
        return A_next;
      } else if (0x2A == A_next) {
        A_next = _reader.advance();
        if (0x2F == A_next) {
          --nesting;
          if (0 == nesting) {
            _appendCommentToken(A_TokenType.MULTI_LINE_COMMENT, _reader.getString(_tokenStart, 0));
            return _reader.advance();
          } else {
            A_next = _reader.advance();
          }
        }
      } else if (0x2F == A_next) {
        A_next = _reader.advance();
        if (0x2A == A_next) {
          A_next = _reader.advance();
          ++nesting;
        }
      } else if (A_next == 0xD) {
        A_next = _reader.advance();
        if (A_next == 0xA) {
          A_next = _reader.advance();
        }
        recordStartOfLine();
      } else if (A_next == 0xA) {
        recordStartOfLine();
        A_next = _reader.advance();
      } else {
        A_next = _reader.advance();
      }
    }
  }
  int _tokenizeMultiLineRawString(int quoteChar, int A_start) {
    int A_next = _reader.advance();
    outer:while (A_next != -1) {
      while (A_next != quoteChar) {
        A_next = _reader.advance();
        if (A_next == -1) {
          break outer;
        } else if (A_next == 0xD) {
          A_next = _reader.advance();
          if (A_next == 0xA) {
            A_next = _reader.advance();
          }
          recordStartOfLine();
        } else if (A_next == 0xA) {
          recordStartOfLine();
          A_next = _reader.advance();
        }
      }
      A_next = _reader.advance();
      if (A_next == quoteChar) {
        A_next = _reader.advance();
        if (A_next == quoteChar) {
          _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
          return _reader.advance();
        }
      }
    }
    C__reportError(ScannerErrorCode.UNTERMINATED_STRING_LITERAL, []);
    _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
    return _reader.advance();
  }
  int _tokenizeMultiLineString(int quoteChar, int A_start, bool A_raw) {
    if (A_raw) {
      return _tokenizeMultiLineRawString(quoteChar, A_start);
    }
    int A_next = _reader.advance();
    while (A_next != -1) {
      if (A_next == 0x24) {
        _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, -1));
        A_next = _tokenizeStringInterpolation(A_start);
        _beginToken();
        A_start = _reader.offset;
        continue;
      }
      if (A_next == quoteChar) {
        A_next = _reader.advance();
        if (A_next == quoteChar) {
          A_next = _reader.advance();
          if (A_next == quoteChar) {
            _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
            return _reader.advance();
          }
        }
        continue;
      }
      if (A_next == 0x5C) {
        A_next = _reader.advance();
        if (A_next == -1) {
          break;
        }
        if (A_next == 0xD) {
          A_next = _reader.advance();
          if (A_next == 0xA) {
            A_next = _reader.advance();
          }
          recordStartOfLine();
        } else if (A_next == 0xA) {
          recordStartOfLine();
          A_next = _reader.advance();
        } else {
          A_next = _reader.advance();
        }
      } else if (A_next == 0xD) {
        A_next = _reader.advance();
        if (A_next == 0xA) {
          A_next = _reader.advance();
        }
        recordStartOfLine();
      } else if (A_next == 0xA) {
        recordStartOfLine();
        A_next = _reader.advance();
      } else {
        A_next = _reader.advance();
      }
    }
    C__reportError(ScannerErrorCode.UNTERMINATED_STRING_LITERAL, []);
    if (A_start == _reader.offset) {
      _appendStringTokenWithOffset(A_TokenType.A_STRING, "", 1);
    } else {
      _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
    }
    return _reader.advance();
  }
  int _tokenizeMultiply(int A_next) => _select(0x3D, A_TokenType.STAR_EQ, A_TokenType.STAR);
  int _tokenizeNumber(int A_next) {
    int A_start = _reader.offset;
    while (true) {
      A_next = _reader.advance();
      if (0x30 <= A_next && A_next <= 0x39) {
        continue;
      } else if (A_next == 0x2E) {
        return _tokenizeFractionPart(_reader.advance(), A_start);
      } else if (A_next == 0x65 || A_next == 0x45) {
        return _tokenizeFractionPart(A_next, A_start);
      } else {
        _appendStringToken(A_TokenType.INT, _reader.getString(A_start, A_next < 0 ? 0 : -1));
        return A_next;
      }
    }
  }
  int _tokenizeOpenSquareBracket(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x5D) {
      return _select(0x3D, A_TokenType.INDEX_EQ, A_TokenType.INDEX);
    } else {
      _appendBeginToken(A_TokenType.OPEN_SQUARE_BRACKET);
      return A_next;
    }
  }
  int _tokenizePercent(int A_next) => _select(0x3D, A_TokenType.PERCENT_EQ, A_TokenType.PERCENT);
  int _tokenizePlus(int A_next) {
    A_next = _reader.advance();
    if (0x2B == A_next) {
      _appendTokenOfType(A_TokenType.PLUS_PLUS);
      return _reader.advance();
    } else if (0x3D == A_next) {
      _appendTokenOfType(A_TokenType.PLUS_EQ);
      return _reader.advance();
    } else {
      _appendTokenOfType(A_TokenType.PLUS);
      return A_next;
    }
  }
  int _tokenizeSingleLineComment(int A_next) {
    while (true) {
      A_next = _reader.advance();
      if (-1 == A_next) {
        _appendCommentToken(A_TokenType.SINGLE_LINE_COMMENT, _reader.getString(_tokenStart, 0));
        return A_next;
      } else if (0xA == A_next || 0xD == A_next) {
        _appendCommentToken(A_TokenType.SINGLE_LINE_COMMENT, _reader.getString(_tokenStart, -1));
        return A_next;
      }
    }
  }
  int _tokenizeSingleLineRawString(int A_next, int quoteChar, int A_start) {
    A_next = _reader.advance();
    while (A_next != -1) {
      if (A_next == quoteChar) {
        _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
        return _reader.advance();
      } else if (A_next == 0xD || A_next == 0xA) {
        C__reportError(ScannerErrorCode.UNTERMINATED_STRING_LITERAL, []);
        _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, -1));
        return _reader.advance();
      }
      A_next = _reader.advance();
    }
    C__reportError(ScannerErrorCode.UNTERMINATED_STRING_LITERAL, []);
    _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
    return _reader.advance();
  }
  int _tokenizeSingleLineString(int A_next, int quoteChar, int A_start) {
    while (A_next != quoteChar) {
      if (A_next == 0x5C) {
        A_next = _reader.advance();
      } else if (A_next == 0x24) {
        _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, -1));
        A_next = _tokenizeStringInterpolation(A_start);
        _beginToken();
        A_start = _reader.offset;
        continue;
      }
      if (A_next <= 0xD && (A_next == 0xA || A_next == 0xD || A_next == -1)) {
        C__reportError(ScannerErrorCode.UNTERMINATED_STRING_LITERAL, []);
        if (A_start == _reader.offset) {
          _appendStringTokenWithOffset(A_TokenType.A_STRING, "", 1);
        } else if (A_next == -1) {
          _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
        } else {
          _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, -1));
        }
        return _reader.advance();
      }
      A_next = _reader.advance();
    }
    _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, 0));
    return _reader.advance();
  }
  int _tokenizeSlashOrComment(int A_next) {
    A_next = _reader.advance();
    if (0x2A == A_next) {
      return _tokenizeMultiLineComment(A_next);
    } else if (0x2F == A_next) {
      return _tokenizeSingleLineComment(A_next);
    } else if (0x3D == A_next) {
      _appendTokenOfType(A_TokenType.SLASH_EQ);
      return _reader.advance();
    } else {
      _appendTokenOfType(A_TokenType.A_SLASH);
      return A_next;
    }
  }
  int _tokenizeString(int A_next, int A_start, bool A_raw) {
    int quoteChar = A_next;
    A_next = _reader.advance();
    if (quoteChar == A_next) {
      A_next = _reader.advance();
      if (quoteChar == A_next) {
        return _tokenizeMultiLineString(quoteChar, A_start, A_raw);
      } else {
        _appendStringToken(A_TokenType.A_STRING, _reader.getString(A_start, -1));
        return A_next;
      }
    }
    if (A_raw) {
      return _tokenizeSingleLineRawString(A_next, quoteChar, A_start);
    } else {
      return _tokenizeSingleLineString(A_next, quoteChar, A_start);
    }
  }
  int _tokenizeStringInterpolation(int A_start) {
    _beginToken();
    int A_next = _reader.advance();
    if (A_next == 0x7B) {
      return _tokenizeInterpolatedExpression(A_next, A_start);
    } else {
      return _tokenizeInterpolatedIdentifier(A_next, A_start);
    }
  }
  int _tokenizeTag(int A_next) {
    if (_reader.offset == 0) {
      if (_reader.peek() == 0x21) {
        do {
          A_next = _reader.advance();
        } while (A_next != 0xA && A_next != 0xD && A_next > 0);
        _appendStringToken(A_TokenType.SCRIPT_TAG, _reader.getString(_tokenStart, 0));
        return A_next;
      }
    }
    _appendTokenOfType(A_TokenType.HASH);
    return _reader.advance();
  }
  int _tokenizeTilde(int A_next) {
    A_next = _reader.advance();
    if (A_next == 0x2F) {
      return _select(0x3D, A_TokenType.TILDE_SLASH_EQ, A_TokenType.TILDE_SLASH);
    } else {
      _appendTokenOfType(A_TokenType.TILDE);
      return A_next;
    }
  }
}
class ScannerErrorCode extends Enum<ScannerErrorCode> implements ErrorCode {
  static const ScannerErrorCode ILLEGAL_CHARACTER = const ScannerErrorCode.H_con1('ILLEGAL_CHARACTER', 0, "Illegal character %x");
  static const ScannerErrorCode MISSING_DIGIT = const ScannerErrorCode.H_con1('MISSING_DIGIT', 1, "Decimal digit expected");
  static const ScannerErrorCode MISSING_HEX_DIGIT = const ScannerErrorCode.H_con1('MISSING_HEX_DIGIT', 2, "Hexidecimal digit expected");
  static const ScannerErrorCode UNTERMINATED_MULTI_LINE_COMMENT = const ScannerErrorCode.H_con1('UNTERMINATED_MULTI_LINE_COMMENT', 4, "Unterminated multi-line comment");
  static const ScannerErrorCode UNTERMINATED_STRING_LITERAL = const ScannerErrorCode.H_con1('UNTERMINATED_STRING_LITERAL', 5, "Unterminated string literal");
  final String message;
  final String correction;
  const ScannerErrorCode.H_con1(String A_name, int ordinal, String A_message) : this.H_con2(A_name, ordinal, A_message, null);
  const ScannerErrorCode.H_con2(String A_name, int ordinal, this.message, this.correction) : super(A_name, ordinal);
  ErrorSeverity get errorSeverity => ErrorSeverity.D_ERROR;
  ErrorType get type => ErrorType.SYNTACTIC_ERROR;
}
class StringToken extends A_Token {
  String E__value;
  StringToken(A_TokenType A_type, String A_value, int A_offset) : super(A_type, A_offset) {
    this.E__value = StringUtilities.intern(A_value);
  }
  A_Token copy() => new StringToken(type, E__value, offset);
  String get lexeme => E__value;
  String value() => E__value;
}
class StringTokenWithComment extends StringToken {
  final A_Token _precedingComment;
  StringTokenWithComment(A_TokenType A_type, String A_value, int A_offset, this._precedingComment) : super(A_type, A_value, A_offset);
  A_Token copy() => new StringTokenWithComment(type, lexeme, offset, copyComments(_precedingComment));
  A_Token get precedingComments => _precedingComment;
  void applyDelta(int delta) {
    super.applyDelta(delta);
    A_Token token = _precedingComment;
    while (token != null) {
      token.applyDelta(delta);
      token = token.next;
    }
  }
}
class SubSequenceReader extends CharSequenceReader {
  final int _offsetDelta;
  SubSequenceReader(String sequence, this._offsetDelta) : super(sequence);
  int get offset => _offsetDelta + super.offset;
  String getString(int A_start, int endDelta) => super.getString(A_start - _offsetDelta, endDelta);
  void set offset(int A_offset) {
    super.offset = A_offset - _offsetDelta;
  }
}
class SyntheticStringToken extends StringToken {
  SyntheticStringToken(A_TokenType A_type, String A_value, int A_offset) : super(A_type, A_value, A_offset);
  bool get isSynthetic => true;
}
class A_Token {
  final A_TokenType type;
  int offset = 0;
  A_Token previous;
  A_Token B__next;
  A_Token(this.type, int A_offset) {
    this.offset = A_offset;
  }
  A_Token copy() => new A_Token(type, offset);
  int get end => offset + length;
  int get length => lexeme.length;
  String get lexeme => type.lexeme;
  A_Token get next => B__next;
  A_Token get precedingComments => null;
  bool get isOperator => type.isOperator;
  bool get isSynthetic => length == 0;
  bool get isUserDefinableOperator => type.isUserDefinableOperator;
  bool matchesAny(List<A_TokenType> A_types) {
    for (A_TokenType A_type in A_types) {
      if (this.type == A_type) {
        return true;
      }
    }
    return false;
  }
  A_Token setNext(A_Token token) {
    B__next = token;
    token.previous = this;
    return token;
  }
  A_Token setNextWithoutSettingPrevious(A_Token token) {
    B__next = token;
    return token;
  }
  String toString() => lexeme;
  Object value() => type.lexeme;
  void applyDelta(int delta) {
    offset += delta;
  }
  A_Token copyComments(A_Token token) {
    if (token == null) {
      return null;
    }
    A_Token A_head = token.copy();
    A_Token tail = A_head;
    token = token.next;
    while (token != null) {
      tail = tail.setNext(token.copy());
      token = token.next;
    }
    return A_head;
  }
}
class TokenClass extends Enum<TokenClass> {
  static const TokenClass NO_CLASS = const TokenClass.H_con1('NO_CLASS', 0);
  static const TokenClass ADDITIVE_OPERATOR = const TokenClass.H_con2('ADDITIVE_OPERATOR', 1, 12);
  static const TokenClass ASSIGNMENT_OPERATOR = const TokenClass.H_con2('ASSIGNMENT_OPERATOR', 2, 1);
  static const TokenClass BITWISE_AND_OPERATOR = const TokenClass.H_con2('BITWISE_AND_OPERATOR', 3, 10);
  static const TokenClass BITWISE_OR_OPERATOR = const TokenClass.H_con2('BITWISE_OR_OPERATOR', 4, 8);
  static const TokenClass BITWISE_XOR_OPERATOR = const TokenClass.H_con2('BITWISE_XOR_OPERATOR', 5, 9);
  static const TokenClass CASCADE_OPERATOR = const TokenClass.H_con2('CASCADE_OPERATOR', 6, 2);
  static const TokenClass CONDITIONAL_OPERATOR = const TokenClass.H_con2('CONDITIONAL_OPERATOR', 7, 3);
  static const TokenClass EQUALITY_OPERATOR = const TokenClass.H_con2('EQUALITY_OPERATOR', 8, 6);
  static const TokenClass LOGICAL_AND_OPERATOR = const TokenClass.H_con2('LOGICAL_AND_OPERATOR', 9, 5);
  static const TokenClass LOGICAL_OR_OPERATOR = const TokenClass.H_con2('LOGICAL_OR_OPERATOR', 10, 4);
  static const TokenClass MULTIPLICATIVE_OPERATOR = const TokenClass.H_con2('MULTIPLICATIVE_OPERATOR', 11, 13);
  static const TokenClass RELATIONAL_OPERATOR = const TokenClass.H_con2('RELATIONAL_OPERATOR', 12, 7);
  static const TokenClass SHIFT_OPERATOR = const TokenClass.H_con2('SHIFT_OPERATOR', 13, 11);
  static const TokenClass UNARY_POSTFIX_OPERATOR = const TokenClass.H_con2('UNARY_POSTFIX_OPERATOR', 14, 15);
  static const TokenClass UNARY_PREFIX_OPERATOR = const TokenClass.H_con2('UNARY_PREFIX_OPERATOR', 15, 14);
  final int precedence;
  const TokenClass.H_con1(String A_name, int ordinal) : this.H_con2(A_name, ordinal, 0);
  const TokenClass.H_con2(String A_name, int ordinal, this.precedence) : super(A_name, ordinal);
}
class A_TokenType extends Enum<A_TokenType> {
  static const A_TokenType A_EOF = const A_TokenType_EOF('EOF', 0, TokenClass.NO_CLASS, "");
  static const A_TokenType DOUBLE = const A_TokenType.H_con1('DOUBLE', 1);
  static const A_TokenType HEXADECIMAL = const A_TokenType.H_con1('HEXADECIMAL', 2);
  static const A_TokenType IDENTIFIER = const A_TokenType.H_con1('IDENTIFIER', 3);
  static const A_TokenType INT = const A_TokenType.H_con1('INT', 4);
  static const A_TokenType A_KEYWORD = const A_TokenType.H_con1('KEYWORD', 5);
  static const A_TokenType MULTI_LINE_COMMENT = const A_TokenType.H_con1('MULTI_LINE_COMMENT', 6);
  static const A_TokenType SCRIPT_TAG = const A_TokenType.H_con1('SCRIPT_TAG', 7);
  static const A_TokenType SINGLE_LINE_COMMENT = const A_TokenType.H_con1('SINGLE_LINE_COMMENT', 8);
  static const A_TokenType A_STRING = const A_TokenType.H_con1('STRING', 9);
  static const A_TokenType A_AMPERSAND = const A_TokenType.H_con2('AMPERSAND', 10, TokenClass.BITWISE_AND_OPERATOR, "&");
  static const A_TokenType AMPERSAND_AMPERSAND = const A_TokenType.H_con2('AMPERSAND_AMPERSAND', 11, TokenClass.LOGICAL_AND_OPERATOR, "&&");
  static const A_TokenType AMPERSAND_EQ = const A_TokenType.H_con2('AMPERSAND_EQ', 12, TokenClass.ASSIGNMENT_OPERATOR, "&=");
  static const A_TokenType AT = const A_TokenType.H_con2('AT', 13, TokenClass.NO_CLASS, "@");
  static const A_TokenType BANG = const A_TokenType.H_con2('BANG', 14, TokenClass.UNARY_PREFIX_OPERATOR, "!");
  static const A_TokenType BANG_EQ = const A_TokenType.H_con2('BANG_EQ', 15, TokenClass.EQUALITY_OPERATOR, "!=");
  static const A_TokenType BAR = const A_TokenType.H_con2('BAR', 16, TokenClass.BITWISE_OR_OPERATOR, "|");
  static const A_TokenType BAR_BAR = const A_TokenType.H_con2('BAR_BAR', 17, TokenClass.LOGICAL_OR_OPERATOR, "||");
  static const A_TokenType BAR_EQ = const A_TokenType.H_con2('BAR_EQ', 18, TokenClass.ASSIGNMENT_OPERATOR, "|=");
  static const A_TokenType A_COLON = const A_TokenType.H_con2('COLON', 19, TokenClass.NO_CLASS, ":");
  static const A_TokenType A_COMMA = const A_TokenType.H_con2('COMMA', 20, TokenClass.NO_CLASS, ",");
  static const A_TokenType CARET = const A_TokenType.H_con2('CARET', 21, TokenClass.BITWISE_XOR_OPERATOR, "^");
  static const A_TokenType CARET_EQ = const A_TokenType.H_con2('CARET_EQ', 22, TokenClass.ASSIGNMENT_OPERATOR, "^=");
  static const A_TokenType CLOSE_CURLY_BRACKET = const A_TokenType.H_con2('CLOSE_CURLY_BRACKET', 23, TokenClass.NO_CLASS, "}");
  static const A_TokenType CLOSE_PAREN = const A_TokenType.H_con2('CLOSE_PAREN', 24, TokenClass.NO_CLASS, ")");
  static const A_TokenType CLOSE_SQUARE_BRACKET = const A_TokenType.H_con2('CLOSE_SQUARE_BRACKET', 25, TokenClass.NO_CLASS, "]");
  static const A_TokenType A_EQ = const A_TokenType.H_con2('EQ', 26, TokenClass.ASSIGNMENT_OPERATOR, "=");
  static const A_TokenType EQ_EQ = const A_TokenType.H_con2('EQ_EQ', 27, TokenClass.EQUALITY_OPERATOR, "==");
  static const A_TokenType D_FUNCTION = const A_TokenType.H_con2('FUNCTION', 28, TokenClass.NO_CLASS, "=>");
  static const A_TokenType A_GT = const A_TokenType.H_con2('GT', 29, TokenClass.RELATIONAL_OPERATOR, ">");
  static const A_TokenType GT_EQ = const A_TokenType.H_con2('GT_EQ', 30, TokenClass.RELATIONAL_OPERATOR, ">=");
  static const A_TokenType GT_GT = const A_TokenType.H_con2('GT_GT', 31, TokenClass.SHIFT_OPERATOR, ">>");
  static const A_TokenType GT_GT_EQ = const A_TokenType.H_con2('GT_GT_EQ', 32, TokenClass.ASSIGNMENT_OPERATOR, ">>=");
  static const A_TokenType HASH = const A_TokenType.H_con2('HASH', 33, TokenClass.NO_CLASS, "#");
  static const A_TokenType INDEX = const A_TokenType.H_con2('INDEX', 34, TokenClass.UNARY_POSTFIX_OPERATOR, "[]");
  static const A_TokenType INDEX_EQ = const A_TokenType.H_con2('INDEX_EQ', 35, TokenClass.UNARY_POSTFIX_OPERATOR, "[]=");
  static const A_TokenType A_LT = const A_TokenType.H_con2('LT', 37, TokenClass.RELATIONAL_OPERATOR, "<");
  static const A_TokenType LT_EQ = const A_TokenType.H_con2('LT_EQ', 38, TokenClass.RELATIONAL_OPERATOR, "<=");
  static const A_TokenType LT_LT = const A_TokenType.H_con2('LT_LT', 39, TokenClass.SHIFT_OPERATOR, "<<");
  static const A_TokenType LT_LT_EQ = const A_TokenType.H_con2('LT_LT_EQ', 40, TokenClass.ASSIGNMENT_OPERATOR, "<<=");
  static const A_TokenType MINUS = const A_TokenType.H_con2('MINUS', 41, TokenClass.ADDITIVE_OPERATOR, "-");
  static const A_TokenType MINUS_EQ = const A_TokenType.H_con2('MINUS_EQ', 42, TokenClass.ASSIGNMENT_OPERATOR, "-=");
  static const A_TokenType MINUS_MINUS = const A_TokenType.H_con2('MINUS_MINUS', 43, TokenClass.UNARY_PREFIX_OPERATOR, "--");
  static const A_TokenType OPEN_CURLY_BRACKET = const A_TokenType.H_con2('OPEN_CURLY_BRACKET', 44, TokenClass.NO_CLASS, "{");
  static const A_TokenType OPEN_PAREN = const A_TokenType.H_con2('OPEN_PAREN', 45, TokenClass.UNARY_POSTFIX_OPERATOR, "(");
  static const A_TokenType OPEN_SQUARE_BRACKET = const A_TokenType.H_con2('OPEN_SQUARE_BRACKET', 46, TokenClass.UNARY_POSTFIX_OPERATOR, "[");
  static const A_TokenType PERCENT = const A_TokenType.H_con2('PERCENT', 47, TokenClass.MULTIPLICATIVE_OPERATOR, "%");
  static const A_TokenType PERCENT_EQ = const A_TokenType.H_con2('PERCENT_EQ', 48, TokenClass.ASSIGNMENT_OPERATOR, "%=");
  static const A_TokenType PERIOD = const A_TokenType.H_con2('PERIOD', 49, TokenClass.UNARY_POSTFIX_OPERATOR, ".");
  static const A_TokenType PERIOD_PERIOD = const A_TokenType.H_con2('PERIOD_PERIOD', 50, TokenClass.CASCADE_OPERATOR, "..");
  static const A_TokenType PLUS = const A_TokenType.H_con2('PLUS', 51, TokenClass.ADDITIVE_OPERATOR, "+");
  static const A_TokenType PLUS_EQ = const A_TokenType.H_con2('PLUS_EQ', 52, TokenClass.ASSIGNMENT_OPERATOR, "+=");
  static const A_TokenType PLUS_PLUS = const A_TokenType.H_con2('PLUS_PLUS', 53, TokenClass.UNARY_PREFIX_OPERATOR, "++");
  static const A_TokenType QUESTION = const A_TokenType.H_con2('QUESTION', 54, TokenClass.CONDITIONAL_OPERATOR, "?");
  static const A_TokenType SEMICOLON = const A_TokenType.H_con2('SEMICOLON', 55, TokenClass.NO_CLASS, ";");
  static const A_TokenType A_SLASH = const A_TokenType.H_con2('SLASH', 56, TokenClass.MULTIPLICATIVE_OPERATOR, "/");
  static const A_TokenType SLASH_EQ = const A_TokenType.H_con2('SLASH_EQ', 57, TokenClass.ASSIGNMENT_OPERATOR, "/=");
  static const A_TokenType STAR = const A_TokenType.H_con2('STAR', 58, TokenClass.MULTIPLICATIVE_OPERATOR, "*");
  static const A_TokenType STAR_EQ = const A_TokenType.H_con2('STAR_EQ', 59, TokenClass.ASSIGNMENT_OPERATOR, "*=");
  static const A_TokenType STRING_INTERPOLATION_EXPRESSION = const A_TokenType.H_con2('STRING_INTERPOLATION_EXPRESSION', 60, TokenClass.NO_CLASS, "\${");
  static const A_TokenType STRING_INTERPOLATION_IDENTIFIER = const A_TokenType.H_con2('STRING_INTERPOLATION_IDENTIFIER', 61, TokenClass.NO_CLASS, "\$");
  static const A_TokenType TILDE = const A_TokenType.H_con2('TILDE', 62, TokenClass.UNARY_PREFIX_OPERATOR, "~");
  static const A_TokenType TILDE_SLASH = const A_TokenType.H_con2('TILDE_SLASH', 63, TokenClass.MULTIPLICATIVE_OPERATOR, "~/");
  static const A_TokenType TILDE_SLASH_EQ = const A_TokenType.H_con2('TILDE_SLASH_EQ', 64, TokenClass.ASSIGNMENT_OPERATOR, "~/=");
  static const A_TokenType BACKPING = const A_TokenType.H_con2('BACKPING', 65, TokenClass.NO_CLASS, "`");
  static const A_TokenType A_BACKSLASH = const A_TokenType.H_con2('BACKSLASH', 66, TokenClass.NO_CLASS, "\\");
  static const A_TokenType PERIOD_PERIOD_PERIOD = const A_TokenType.H_con2('PERIOD_PERIOD_PERIOD', 67, TokenClass.NO_CLASS, "...");
  final TokenClass _tokenClass;
  final String lexeme;
  const A_TokenType.H_con1(String A_name, int ordinal) : this.H_con2(A_name, ordinal, TokenClass.NO_CLASS, null);
  const A_TokenType.H_con2(String A_name, int ordinal, this._tokenClass, this.lexeme) : super(A_name, ordinal);
  int get precedence => _tokenClass.precedence;
  bool get isAdditiveOperator => _tokenClass == TokenClass.ADDITIVE_OPERATOR;
  bool get isAssignmentOperator => _tokenClass == TokenClass.ASSIGNMENT_OPERATOR;
  bool get isEqualityOperator => _tokenClass == TokenClass.EQUALITY_OPERATOR;
  bool get isIncrementOperator => identical(lexeme, "++") || identical(lexeme, "--");
  bool get isMultiplicativeOperator => _tokenClass == TokenClass.MULTIPLICATIVE_OPERATOR;
  bool get isOperator => _tokenClass != TokenClass.NO_CLASS && this != OPEN_PAREN && this != OPEN_SQUARE_BRACKET && this != PERIOD;
  bool get isRelationalOperator => _tokenClass == TokenClass.RELATIONAL_OPERATOR;
  bool get isShiftOperator => _tokenClass == TokenClass.SHIFT_OPERATOR;
  bool get isUserDefinableOperator => identical(lexeme, "==") || identical(lexeme, "~") || identical(lexeme, "[]") || identical(lexeme, "[]=") || identical(lexeme, "*") || identical(lexeme, "/") || identical(lexeme, "%") || identical(lexeme, "~/") || identical(lexeme, "+") || identical(lexeme, "-") || identical(lexeme, "<<") || identical(lexeme, ">>") || identical(lexeme, ">=") || identical(lexeme, ">") || identical(lexeme, "<=") || identical(lexeme, "<") || identical(lexeme, "&") || identical(lexeme, "^") || identical(lexeme, "|");
}
class A_TokenType_EOF extends A_TokenType {
  const A_TokenType_EOF(String A_name, int ordinal, TokenClass arg0, String arg1) : super.H_con2(A_name, ordinal, arg0, arg1);
  String toString() => "-eof-";
}
class TokenWithComment extends A_Token {
  final A_Token _precedingComment;
  TokenWithComment(A_TokenType A_type, int A_offset, this._precedingComment) : super(A_type, A_offset);
  A_Token copy() => new TokenWithComment(type, offset, _precedingComment);
  A_Token get precedingComments => _precedingComment;
}
abstract class DartSdk {
  static final String DART_ASYNC = "dart:async";
  static final String DART_CORE = "dart:core";
  static final String DART_HTML = "dart:html";
  Source fromFileUri(Uri A_uri);
  AnalysisContext get context;
  List<SdkLibrary> get sdkLibraries;
  SdkLibrary getSdkLibrary(String dartUri);
  List<String> get uris;
  Source mapDartUri(String dartUri);
}
class LibraryMap {
  A_p.HashMap<String, SdkLibraryImpl> B__libraryMap = new A_p.HashMap<String,SdkLibraryImpl>();
  SdkLibrary getLibrary(String dartUri) => B__libraryMap[dartUri];
  List<SdkLibrary> get sdkLibraries => new List.from(B__libraryMap.values);
  List<String> get uris => new List.from(B__libraryMap.keys.toSet());
  void setLibrary(String dartUri, SdkLibraryImpl library) {
    B__libraryMap[dartUri] = library;
  }
  int size() => B__libraryMap.length;
}
class SdkLibrariesReader_LibraryBuilder extends RecursiveAstVisitor<Object> {
  static String _LIBRARY_PREFIX = "dart:";
  static String _IMPLEMENTATION = "implementation";
  static String _DART2JS_PATH = "dart2jsPath";
  static String _DOCUMENTED = "documented";
  static String _CATEGORY = "category";
  static String _PLATFORMS = "platforms";
  static String _VM_PLATFORM = "VM_PLATFORM";
  final bool _useDart2jsPaths;
  LibraryMap _librariesMap = new LibraryMap();
  SdkLibrariesReader_LibraryBuilder(this._useDart2jsPaths);
  LibraryMap get librariesMap => _librariesMap;
  Object visitMapLiteralEntry(MapLiteralEntry node) {
    String A_libraryName = null;
    Expression A_key = node.key;
    if (A_key is SimpleStringLiteral) {
      A_libraryName = "${_LIBRARY_PREFIX}${A_key.value}";
    }
    Expression A_value = node.value;
    if (A_value is InstanceCreationExpression) {
      SdkLibraryImpl library = new SdkLibraryImpl(A_libraryName);
      List<Expression> A_arguments = A_value.argumentList.arguments;
      for (Expression argument in A_arguments) {
        if (argument is SimpleStringLiteral) {
          library.path = argument.value;
        } else if (argument is NamedExpression) {
          String A_name = argument.name.label.name;
          Expression expression = argument.expression;
          if (A_name == _CATEGORY) {
            library.category = (expression as SimpleStringLiteral).value;
          } else if (A_name == _IMPLEMENTATION) {
            library.implementation = (expression as BooleanLiteral).value;
          } else if (A_name == _DOCUMENTED) {
            library.documented = (expression as BooleanLiteral).value;
          } else if (A_name == _PLATFORMS) {
            if (expression is SimpleIdentifier) {
              String identifier = expression.name;
              if (identifier == _VM_PLATFORM) {
                library.setVmLibrary();
              } else {
                library.setDart2JsLibrary();
              }
            }
          } else if (_useDart2jsPaths && A_name == _DART2JS_PATH) {
            if (expression is SimpleStringLiteral) {
              library.path = expression.value;
            }
          }
        }
      }
      _librariesMap.setLibrary(A_libraryName, library);
    }
    return null;
  }
}
abstract class SdkLibrary {
  String get category;
  String get path;
  String get shortName;
  bool get isInternal;
}
class SdkLibraryImpl implements SdkLibrary {
  String _shortName = null;
  String path = null;
  String category = "Shared";
  bool _documented = true;
  bool _implementation = false;
  int _platforms = 0;
  static int DART2JS_PLATFORM = 1;
  static int VM_PLATFORM = 2;
  SdkLibraryImpl(String A_name) {
    this._shortName = A_name;
  }
  String get shortName => _shortName;
  bool get isInternal => "Internal" == category;
  void setDart2JsLibrary() {
    _platforms |= DART2JS_PLATFORM;
  }
  void set documented(bool A_documented) {
    this._documented = A_documented;
  }
  void set implementation(bool A_implementation) {
    this._implementation = A_implementation;
  }
  void setVmLibrary() {
    _platforms |= VM_PLATFORM;
  }
}
class DirectoryBasedDartSdk implements DartSdk {
  InternalAnalysisContext A__analysisContext;
  JavaFile _sdkDirectory;
  String _sdkVersion;
  JavaFile _dart2jsExecutable;
  JavaFile _dartFmtExecutable;
  JavaFile _dartiumExecutable;
  JavaFile _pubExecutable;
  JavaFile _vmExecutable;
  LibraryMap C__libraryMap;
  static String _BIN_DIRECTORY_NAME = "bin";
  static String _DEFAULT_DIRECTORY_PROPERTY_NAME = "com.google.dart.sdk";
  static String _INTERNAL_DIR = "_internal";
  static String _LIB_DIRECTORY_NAME = "lib";
  static String _LIBRARIES_FILE = "libraries.dart";
  static String _PUB_EXECUTABLE_NAME_WIN = "pub.bat";
  static String _PUB_EXECUTABLE_NAME = "pub";
  static DirectoryBasedDartSdk get defaultSdk {
    JavaFile sdkDirectory = defaultSdkDirectory;
    if (sdkDirectory == null) {
      return null;
    }
    return new DirectoryBasedDartSdk(sdkDirectory);
  }
  static JavaFile get defaultSdkDirectory {
    String sdkProperty = JavaSystemIO.A_getProperty(_DEFAULT_DIRECTORY_PROPERTY_NAME);
    if (sdkProperty == null) {
      return null;
    }
    JavaFile sdkDirectory = new JavaFile(sdkProperty);
    if (!sdkDirectory.exists()) {
      return null;
    }
    return sdkDirectory;
  }
  DirectoryBasedDartSdk(JavaFile sdkDirectory, [bool useDart2jsPaths = false]) {
    this._sdkDirectory = sdkDirectory.getAbsoluteFile();
    C__libraryMap = initialLibraryMap(useDart2jsPaths);
  }
  Source fromFileUri(Uri A_uri) {
    JavaFile A_file = new JavaFile.B_fromUri(A_uri);
    String filePath = A_file.getAbsolutePath();
    String libPath = libraryDirectory.getAbsolutePath();
    if (!filePath.startsWith("${libPath}${JavaFile.separator}")) {
      return null;
    }
    filePath = filePath.substring(libPath.length + 1);
    for (SdkLibrary library in C__libraryMap.sdkLibraries) {
      String libraryPath = library.path;
      if (filePath.replaceAll('\\', '/') == libraryPath) {
        String A_path = library.shortName;
        try {
          return new FileBasedSource.I_con2(parseUriWithException(A_path), A_file);
        }on URISyntaxException  catch (exception) {
          AnalysisEngine.A_instance.logger.logInformation2("Failed to create URI: ${A_path}", exception);
          return null;
        }
      }
      libraryPath = new JavaFile(libraryPath).getParent();
      if (filePath.startsWith("${libraryPath}${JavaFile.separator}")) {
        String A_path = "${library.shortName}/${filePath.substring(libraryPath.length + 1)}";
        try {
          return new FileBasedSource.I_con2(parseUriWithException(A_path), A_file);
        }on URISyntaxException  catch (exception) {
          AnalysisEngine.A_instance.logger.logInformation2("Failed to create URI: ${A_path}", exception);
          return null;
        }
      }
    }
    return null;
  }
  AnalysisContext get context {
    if (A__analysisContext == null) {
      A__analysisContext = new SdkAnalysisContext();
      SourceFactory factory = new SourceFactory([new DartUriResolver(this)]);
      A__analysisContext.sourceFactory = factory;
      List<String> A_uris = this.uris;
      ChangeSet changeSet = new ChangeSet();
      for (String A_uri in A_uris) {
        changeSet.addedSource(factory.forUri(A_uri));
      }
      A__analysisContext.applyChanges(changeSet);
    }
    return A__analysisContext;
  }
  JavaFile get directory => _sdkDirectory;
  JavaFile get libraryDirectory => new JavaFile.A_relative(_sdkDirectory, _LIB_DIRECTORY_NAME);
  JavaFile get pubExecutable {
    if (_pubExecutable == null) {
      _pubExecutable = _verifyExecutable(new JavaFile.A_relative(new JavaFile.A_relative(_sdkDirectory, _BIN_DIRECTORY_NAME), OSUtilities.A_isWindows() ? _PUB_EXECUTABLE_NAME_WIN : _PUB_EXECUTABLE_NAME));
    }
    return _pubExecutable;
  }
  List<SdkLibrary> get sdkLibraries => C__libraryMap.sdkLibraries;
  SdkLibrary getSdkLibrary(String dartUri) => C__libraryMap.getLibrary(dartUri);
  List<String> get uris => C__libraryMap.uris;
  Source mapDartUri(String dartUri) {
    String A_libraryName;
    String relativePath;
    int A_index = dartUri.indexOf('/');
    if (A_index >= 0) {
      A_libraryName = dartUri.substring(0, A_index);
      relativePath = dartUri.substring(A_index + 1);
    } else {
      A_libraryName = dartUri;
      relativePath = "";
    }
    SdkLibrary library = getSdkLibrary(A_libraryName);
    if (library == null) {
      return null;
    }
    try {
      JavaFile A_file = new JavaFile.A_relative(libraryDirectory, library.path);
      if (!relativePath.isEmpty) {
        A_file = A_file.getParentFile();
        A_file = new JavaFile.A_relative(A_file, relativePath);
      }
      return new FileBasedSource.I_con2(parseUriWithException(dartUri), A_file);
    }on URISyntaxException  catch (exception) {
      return null;
    }
  }
  LibraryMap initialLibraryMap(bool useDart2jsPaths) {
    JavaFile librariesFile = new JavaFile.A_relative(new JavaFile.A_relative(libraryDirectory, _INTERNAL_DIR), _LIBRARIES_FILE);
    try {
      String contents = librariesFile.readAsStringSync();
      return new SdkLibrariesReader(useDart2jsPaths).readFromFile(librariesFile, contents);
    } catch (exception) {
      AnalysisEngine.A_instance.logger.logError2("Could not initialize the library map from ${librariesFile.getAbsolutePath()}", exception);
      return new LibraryMap();
    }
  }
  JavaFile _verifyExecutable(JavaFile A_file) => A_file.isExecutable() ? A_file : null;
}
class SdkLibrariesReader {
  final bool A__useDart2jsPaths;
  SdkLibrariesReader(this.A__useDart2jsPaths);
  LibraryMap readFromFile(JavaFile A_file, String libraryFileContents) => readFromSource(new FileBasedSource.I_con1(A_file), libraryFileContents);
  LibraryMap readFromSource(Source A_source, String libraryFileContents) {
    BooleanErrorListener errorListener = new BooleanErrorListener();
    Scanner scanner = new Scanner(A_source, new CharSequenceReader(libraryFileContents), errorListener);
    Parser parser = new Parser(A_source, errorListener);
    CompilationUnit unit = parser.parseCompilationUnit(scanner.tokenize());
    SdkLibrariesReader_LibraryBuilder libraryBuilder = new SdkLibrariesReader_LibraryBuilder(A__useDart2jsPaths);
    if (!errorListener.errorReported) {
      unit.accept(libraryBuilder);
    }
    return libraryBuilder.librariesMap;
  }
}
class ContentCache {
  A_p.HashMap<Source, String> _contentMap = new A_p.HashMap<Source,String>();
  A_p.HashMap<Source, int> _stampMap = new A_p.HashMap<Source,int>();
  String getContents(Source A_source) => _contentMap[A_source];
  int getModificationStamp(Source A_source) => _stampMap[A_source];
  String setContents(Source A_source, String contents) {
    if (contents == null) {
      _stampMap.remove(A_source);
      return _contentMap.remove(A_source);
    } else {
      int newStamp = JavaSystem.currentTimeMillis();
      int oldStamp = javaMapPut(_stampMap, A_source, newStamp);
      if (newStamp == oldStamp) {
        _stampMap[A_source] = newStamp + 1;
      }
      return javaMapPut(_contentMap, A_source, contents);
    }
  }
}
class DartUriResolver extends UriResolver {
  static bool isDartExtUri(String uriContent) => uriContent != null && uriContent.startsWith(B__DART_EXT_SCHEME);
  final DartSdk _sdk;
  static String DART_SCHEME = "dart";
  static String B__DART_EXT_SCHEME = "dart-ext:";
  static bool isDartUri(Uri A_uri) => DART_SCHEME == A_uri.scheme;
  DartUriResolver(this._sdk);
  DartSdk get dartSdk => _sdk;
  Source resolveAbsolute(Uri A_uri) {
    if (!isDartUri(A_uri)) {
      return null;
    }
    return _sdk.mapDartUri(A_uri.toString());
  }
}
class LineInfo {
  final List<int> B__lineStarts;
  LineInfo(this.B__lineStarts) {
    if (B__lineStarts == null) {
      throw new IllegalArgumentException("lineStarts must be non-null");
    } else if (B__lineStarts.length < 1) {
      throw new IllegalArgumentException("lineStarts must be non-empty");
    }
  }
  LineInfo_Location getLocation(int A_offset) {
    int lineCount = B__lineStarts.length;
    for (int i = 1; i < lineCount; i++) {
      if (A_offset < B__lineStarts[i]) {
        return new LineInfo_Location(i, A_offset - B__lineStarts[i - 1] + 1);
      }
    }
    return new LineInfo_Location(lineCount, A_offset - B__lineStarts[lineCount - 1] + 1);
  }
}
class LineInfo_Location {
  final int lineNumber;
  final int columnNumber;
  LineInfo_Location(this.lineNumber, this.columnNumber);
}
abstract class LocalSourcePredicate {
  static final LocalSourcePredicate NOT_SDK = new LocalSourcePredicate_NOT_SDK();
}
class LocalSourcePredicate_NOT_SDK implements LocalSourcePredicate {}
class NonExistingSource implements Source {
  final String E__name;
  final UriKind uriKind;
  NonExistingSource(this.E__name, this.uriKind);
  bool operator==(Object obj) {
    if (obj is NonExistingSource) {
      NonExistingSource other = obj;
      return other.uriKind == uriKind && (other.E__name == E__name);
    }
    return false;
  }
  bool exists() => false;
  TimestampedData<String> get contents {
    throw new UnsupportedOperationException("${E__name}does not exist.");
  }
  String get encoding {
    throw new UnsupportedOperationException("${E__name}does not exist.");
  }
  String get fullName => E__name;
  int get modificationStamp => 0;
  String get shortName => E__name;
  Uri get uri => null;
  int get hashCode => E__name.hashCode;
  bool get isInSystemLibrary => false;
  Uri resolveRelativeUri(Uri relativeUri) {
    throw new UnsupportedOperationException("${E__name}does not exist.");
  }
}
abstract class Source {
  static final List<Source> F_EMPTY_ARRAY = new List<Source>(0);
  bool operator==(Object object);
  bool exists();
  TimestampedData<String> get contents;
  String get encoding;
  String get fullName;
  int get modificationStamp;
  String get shortName;
  Uri get uri;
  UriKind get uriKind;
  int get hashCode;
  bool get isInSystemLibrary;
  Uri resolveRelativeUri(Uri relativeUri);
}
abstract class SourceContainer {}
class SourceFactory {
  AnalysisContext context;
  final List<UriResolver> _resolvers;
  LocalSourcePredicate _localSourcePredicate = LocalSourcePredicate.NOT_SDK;
  SourceFactory(this._resolvers);
  Source forUri(String absoluteUri) {
    try {
      Uri A_uri = parseUriWithException(absoluteUri);
      if (A_uri.isAbsolute) {
        return _internalResolveUri(null, A_uri);
      }
    } catch (exception) {
      AnalysisEngine.A_instance.logger.logError2("Could not resolve URI: ${absoluteUri}", exception);
    }
    return null;
  }
  Source forUri2(Uri absoluteUri) {
    if (absoluteUri.isAbsolute) {
      try {
        return _internalResolveUri(null, absoluteUri);
      }on AnalysisException  catch (exception, A_stackTrace) {
        AnalysisEngine.A_instance.logger.logError2("Could not resolve URI: ${absoluteUri}", new CaughtException(exception, A_stackTrace));
      }
    }
    return null;
  }
  Source fromEncoding(String A_encoding) {
    Source A_source = forUri(A_encoding);
    if (A_source == null) {
      throw new IllegalArgumentException("Invalid source encoding: ${A_encoding}");
    }
    return A_source;
  }
  DartSdk get dartSdk {
    for (UriResolver resolver in _resolvers) {
      if (resolver is DartUriResolver) {
        DartUriResolver dartUriResolver = resolver;
        return dartUriResolver.dartSdk;
      }
    }
    return null;
  }
  Source resolveUri(Source containingSource, String containedUri) {
    if (containedUri == null || containedUri.isEmpty) {
      return null;
    }
    try {
      return _internalResolveUri(containingSource, parseUriWithException(containedUri));
    } catch (exception) {
      AnalysisEngine.A_instance.logger.logError2("Could not resolve URI (${containedUri}) relative to source (${containingSource.fullName})", exception);
      return null;
    }
  }
  Uri restoreUri(Source A_source) {
    for (UriResolver resolver in _resolvers) {
      Uri A_uri = resolver.restoreAbsolute(A_source);
      if (A_uri != null) {
        return A_uri;
      }
    }
    return null;
  }
  Source _internalResolveUri(Source containingSource, Uri containedUri) {
    if (!containedUri.isAbsolute) {
      if (containingSource == null) {
        throw new AnalysisException("Cannot resolve a relative URI without a containing source: ${containedUri}");
      }
      containedUri = containingSource.resolveRelativeUri(containedUri);
    }
    for (UriResolver resolver in _resolvers) {
      Source result = resolver.resolveAbsolute(containedUri);
      if (result != null) {
        return result;
      }
    }
    return null;
  }
}
class SourceKind extends Enum<SourceKind> {
  static const SourceKind C_HTML = const SourceKind('HTML', 0);
  static const SourceKind D_LIBRARY = const SourceKind('LIBRARY', 1);
  static const SourceKind A_PART = const SourceKind('PART', 2);
  static const SourceKind D_UNKNOWN = const SourceKind('UNKNOWN', 3);
  const SourceKind(String A_name, int ordinal) : super(A_name, ordinal);
}
class SourceRange {
  final int offset;
  final int length;
  SourceRange(this.offset, this.length);
  bool contains(int A_x) => offset <= A_x && A_x < offset + length;
  bool operator==(Object obj) {
    if (obj is! SourceRange) {
      return false;
    }
    SourceRange sourceRange = obj as SourceRange;
    return sourceRange.offset == offset && sourceRange.length == length;
  }
  int get end => offset + length;
  SourceRange getTranslated(int delta) => new SourceRange(offset + delta, length);
  int get hashCode => 31 * offset + length;
  String toString() {
    JavaStringBuilder A_builder = new JavaStringBuilder();
    A_builder.append("[offset=");
    A_builder.append(offset);
    A_builder.append(", length=");
    A_builder.append(length);
    A_builder.append("]");
    return A_builder.toString();
  }
}
class UriKind extends Enum<UriKind> {
  static const UriKind DART_URI = const UriKind('DART_URI', 0, 0x64);
  static const UriKind FILE_URI = const UriKind('FILE_URI', 1, 0x66);
  static const UriKind PACKAGE_URI = const UriKind('PACKAGE_URI', 2, 0x70);
  final int encoding;
  const UriKind(String A_name, int ordinal, this.encoding) : super(A_name, ordinal);
}
abstract class UriResolver {
  Source resolveAbsolute(Uri A_uri);
  Uri restoreAbsolute(Source A_source) => null;
}
class FileBasedSource implements Source {
  final Uri uri;
  final JavaFile file;
  String A__encoding;
  FileBasedSource.I_con1(JavaFile A_file) : this.I_con2(A_file.toURI(), A_file);
  FileBasedSource.I_con2(this.uri, this.file);
  bool operator==(Object object) => object != null && object is FileBasedSource && file == object.file;
  bool exists() => file.isFile();
  TimestampedData<String> get contents {
    TimeCounter_TimeCounterHandle handle = PerformanceStatistics.io.start();
    try {
      return contentsFromFile;
    } finally {
      _reportIfSlowIO(handle.stop());
    }
  }
  String get encoding {
    if (A__encoding == null) {
      A__encoding = uri.toString();
    }
    return A__encoding;
  }
  String get fullName => file.getAbsolutePath();
  int get modificationStamp => file.lastModified();
  String get shortName => file.getName();
  UriKind get uriKind {
    String A_scheme = uri.scheme;
    if (A_scheme == PackageUriResolver.A_PACKAGE_SCHEME) {
      return UriKind.PACKAGE_URI;
    } else if (A_scheme == DartUriResolver.DART_SCHEME) {
      return UriKind.DART_URI;
    } else if (A_scheme == FileUriResolver.FILE_SCHEME) {
      return UriKind.FILE_URI;
    }
    return UriKind.FILE_URI;
  }
  int get hashCode => file.hashCode;
  bool get isInSystemLibrary => uri.scheme == DartUriResolver.DART_SCHEME;
  Uri resolveRelativeUri(Uri containedUri) {
    try {
      Uri baseUri = uri;
      bool isOpaque = uri.isAbsolute && !uri.path.startsWith('/');
      if (isOpaque) {
        String A_scheme = uri.scheme;
        String part = uri.path;
        if (A_scheme == DartUriResolver.DART_SCHEME && part.indexOf('/') < 0) {
          part = "${part}/${part}.dart";
        }
        baseUri = parseUriWithException("${A_scheme}:/${part}");
      }
      Uri result = baseUri.resolveUri(containedUri);
      if (isOpaque) {
        result = parseUriWithException("${result.scheme}:${result.path.substring(1)}");
      }
      return result;
    } catch (exception, A_stackTrace) {
      throw new AnalysisException("Could not resolve URI (${containedUri}) relative to source (${uri})", new CaughtException(exception, A_stackTrace));
    }
  }
  String toString() {
    if (file == null) {
      return "<unknown source>";
    }
    return file.getAbsolutePath();
  }
  TimestampedData<String> get contentsFromFile {
    return new TimestampedData<String>(file.lastModified(), file.readAsStringSync());
  }
  void _reportIfSlowIO(int nanos) {
    if (nanos > 10 * TimeCounter.NANOS_PER_MILLI) {
      InstrumentationBuilder A_builder = Instrumentation.builder2("SlowIO");
      try {
        A_builder.data3("fileName", fullName);
        A_builder.metric2("IO-Time-Nanos", nanos);
      } finally {
        A_builder.log();
      }
    }
  }
}
class FileUriResolver extends UriResolver {
  static String FILE_SCHEME = "file";
}
class PackageUriResolver extends UriResolver {
  static String A_PACKAGE_SCHEME = "package";
}
class BooleanArray {
  static bool A_get(int array, int A_index) {
    A__checkIndex(A_index);
    return (array & (1 << A_index)) > 0;
  }
  static bool getEnum(int array, Enum A_index) => A_get(array, A_index.ordinal);
  static int A_set(int array, int A_index, bool A_value) {
    A__checkIndex(A_index);
    if (A_value) {
      return array | (1 << A_index);
    } else {
      return array & ~(1 << A_index);
    }
  }
  static int setEnum(int array, Enum A_index, bool A_value) => A_set(array, A_index.ordinal, A_value);
  static void A__checkIndex(int A_index) {
    if (A_index < 0 || A_index > 30) {
      throw new RangeError("Index not between 0 and 30: ${A_index}");
    }
  }
}
class DirectedGraph<N> {
  A_p.HashMap<N, A_p.HashSet<N>> _edges = new A_p.HashMap<N,A_p.HashSet<N>>();
  void addEdge(N A_head, N tail) {
    if (_edges[tail] == null) {
      _edges[tail] = new A_p.HashSet<N>();
    }
    A_p.HashSet<N> tails = _edges[A_head];
    if (tails == null) {
      tails = new A_p.HashSet<N>();
      _edges[A_head] = tails;
    }
    tails.add(tail);
  }
  void addNode(N node) {
    A_p.HashSet<N> tails = _edges[node];
    if (tails == null) {
      _edges[node] = new A_p.HashSet<N>();
    }
  }
  List<List<N>> computeTopologicalSort() {
    DirectedGraph_SccFinder<N> finder = new DirectedGraph_SccFinder<N>(this);
    return finder.computeTopologicalSort();
  }
  List<N> findCycleContaining(N node) {
    if (node == null) {
      throw new IllegalArgumentException();
    }
    DirectedGraph_SccFinder<N> finder = new DirectedGraph_SccFinder<N>(this);
    return finder.componentContaining(node);
  }
  bool get isEmpty => _edges.isEmpty;
  void removeNode(N node) {
    _edges.remove(node);
    for (A_p.HashSet<N> tails in _edges.values) {
      tails.remove(node);
    }
  }
}
class DirectedGraph_NodeInfo<N> {
  int index = 0;
  int lowlink = 0;
  bool onStack = false;
  List<N> component;
  DirectedGraph_NodeInfo(int depth) {
    index = depth;
    lowlink = depth;
    onStack = false;
  }
}
class DirectedGraph_SccFinder<N> {
  final DirectedGraph<N> _graph;
  int D__index = 0;
  List<N> _stack = new List<N>();
  A_p.HashMap<N, DirectedGraph_NodeInfo<N>> _nodeMap = new A_p.HashMap<N,DirectedGraph_NodeInfo<N>>();
  List<List<N>> _allComponents = new List<List<N>>();
  DirectedGraph_SccFinder(this._graph) : super();
  List<N> componentContaining(N node) => _strongConnect(node).component;
  List<List<N>> computeTopologicalSort() {
    for (N node in _graph._edges.keys.toSet()) {
      DirectedGraph_NodeInfo<N> nodeInfo = _nodeMap[node];
      if (nodeInfo == null) {
        _strongConnect(node);
      }
    }
    return _allComponents;
  }
  N _pop() {
    N node = _stack.removeAt(_stack.length - 1);
    _nodeMap[node].onStack = false;
    return node;
  }
  void _push(N node) {
    _nodeMap[node].onStack = true;
    _stack.add(node);
  }
  DirectedGraph_NodeInfo<N> _strongConnect(N v) {
    DirectedGraph_NodeInfo<N> vInfo = new DirectedGraph_NodeInfo<N>(D__index++);
    _nodeMap[v] = vInfo;
    _push(v);
    A_p.HashSet<N> tails = _graph._edges[v];
    if (tails != null) {
      for (N A_w in tails) {
        DirectedGraph_NodeInfo<N> wInfo = _nodeMap[A_w];
        if (wInfo == null) {
          wInfo = _strongConnect(A_w);
          vInfo.lowlink = Math.A_min(vInfo.lowlink, wInfo.lowlink);
        } else if (wInfo.onStack) {
          vInfo.lowlink = Math.A_min(vInfo.lowlink, wInfo.index);
        }
      }
    }
    if (vInfo.lowlink == vInfo.index) {
      List<N> component = new List<N>();
      N A_w;
      do {
        A_w = _pop();
        component.add(A_w);
        _nodeMap[A_w].component = component;
      } while (!identical(A_w, v));
      _allComponents.add(component);
    }
    return vInfo;
  }
}
class ListUtilities {
  static void A_addAll(List A_list, List<Object> elements) {
    int count = elements.length;
    for (int i = 0; i < count; i++) {
      A_list.add(elements[i]);
    }
  }
}
abstract class MapIterator<A_K, A_V> {
  A_K get key;
  A_V get value;
  bool moveNext();
  void set value(A_V newValue);
}
class MultipleMapIterator<A_K, A_V> implements MapIterator<A_K, A_V> {
  List<MapIterator<A_K, A_V>> _iterators;
  int _iteratorIndex = -1;
  MapIterator<A_K, A_V> _currentIterator;
  MultipleMapIterator(List<Map<A_K, A_V>> maps) {
    int count = maps.length;
    _iterators = new List<MapIterator>(count);
    for (int i = 0; i < count; i++) {
      _iterators[i] = new SingleMapIterator<A_K,A_V>(maps[i]);
    }
  }
  A_K get key {
    if (_currentIterator == null) {
      throw new NoSuchElementException();
    }
    return _currentIterator.key;
  }
  A_V get value {
    if (_currentIterator == null) {
      throw new NoSuchElementException();
    }
    return _currentIterator.value;
  }
  bool moveNext() {
    if (_iteratorIndex < 0) {
      if (_iterators.length == 0) {
        _currentIterator = null;
        return false;
      }
      if (_advanceToNextIterator()) {
        return true;
      } else {
        _currentIterator = null;
        return false;
      }
    }
    if (_currentIterator.moveNext()) {
      return true;
    } else if (_advanceToNextIterator()) {
      return true;
    } else {
      _currentIterator = null;
      return false;
    }
  }
  void set value(A_V newValue) {
    if (_currentIterator == null) {
      throw new NoSuchElementException();
    }
    _currentIterator.value = newValue;
  }
  bool _advanceToNextIterator() {
    _iteratorIndex++;
    while (_iteratorIndex < _iterators.length) {
      MapIterator<A_K, A_V> A_iterator = _iterators[_iteratorIndex];
      if (A_iterator.moveNext()) {
        _currentIterator = A_iterator;
        return true;
      }
      _iteratorIndex++;
    }
    return false;
  }
}
class TokenMap {
  A_p.HashMap<A_Token, A_Token> C__map = new A_p.HashMap<A_Token,A_Token>();
  A_Token get(A_Token A_key) => C__map[A_key];
  void put(A_Token A_key, A_Token A_value) {
    C__map[A_key] = A_value;
  }
}
class SingleMapIterator<A_K, A_V> implements MapIterator<A_K, A_V> {
  final Map<A_K, A_V> C__map;
  Iterator<A_K> _keyIterator;
  A_K _currentKey;
  A_V _currentValue;
  SingleMapIterator(this.C__map) {
    this._keyIterator = C__map.keys.iterator;
  }
  A_K get key {
    if (_currentKey == null) {
      throw new NoSuchElementException();
    }
    return _currentKey;
  }
  A_V get value {
    if (_currentKey == null) {
      throw new NoSuchElementException();
    }
    return _currentValue;
  }
  bool moveNext() {
    if (_keyIterator.moveNext()) {
      _currentKey = _keyIterator.current;
      _currentValue = C__map[_currentKey];
      return true;
    } else {
      _currentKey = null;
      return false;
    }
  }
  void set value(A_V newValue) {
    if (_currentKey == null) {
      throw new NoSuchElementException();
    }
    _currentValue = newValue;
    C__map[_currentKey] = newValue;
  }
}
class ParameterKind extends Enum<ParameterKind> {
  static const ParameterKind REQUIRED = const ParameterKind('REQUIRED', 0, false);
  static const ParameterKind POSITIONAL = const ParameterKind('POSITIONAL', 1, true);
  static const ParameterKind NAMED = const ParameterKind('NAMED', 2, true);
  final bool isOptional;
  const ParameterKind(String A_name, int ordinal, this.isOptional) : super(A_name, ordinal);
}
class TimeCounter {
  static final int NANOS_PER_MILLI = 1000 * 1000;
  static final int NANOS_PER_MICRO = 1000;
  static TimeCounter A__current = null;
  final Stopwatch _sw = new Stopwatch();
  int get result => _sw.elapsedMilliseconds;
  TimeCounter_TimeCounterHandle start() {
    return new TimeCounter_TimeCounterHandle(this);
  }
}
class TimeCounter_TimeCounterHandle {
  final TimeCounter _counter;
  int _startMicros;
  TimeCounter A__prev;
  TimeCounter_TimeCounterHandle(this._counter) {
    A__prev = TimeCounter.A__current;
    if (A__prev != null) {
      A__prev._sw.stop();
    }
    TimeCounter.A__current = _counter;
    _startMicros = _counter._sw.elapsedMicroseconds;
    _counter._sw.start();
  }
  int stop() {
    _counter._sw.stop();
    int A_elapsed = (_counter._sw.elapsedMicroseconds - _startMicros) * TimeCounter.NANOS_PER_MICRO;
    TimeCounter.A__current = A__prev;
    if (A__prev != null) {
      A__prev._sw.start();
    }
    return A_elapsed;
  }
}
class ArgParser {
  final Map<String, Option> A__options;
  final Map<String, ArgParser> _commands;
  final Map<String, Option> options;
  final Map<String, ArgParser> commands;
  final bool allowTrailingOptions;
  factory ArgParser({bool allowTrailingOptions}) => new ArgParser.D__(<String, Option>{}, <String, ArgParser>{}, allowTrailingOptions: allowTrailingOptions);
  ArgParser.D__(Map<String, Option> A_options, Map<String, ArgParser> A_commands, {bool allowTrailingOptions}) : this.A__options = A_options, this.options = new A_UnmodifiableMapView(A_options), this._commands = A_commands, this.commands = new A_UnmodifiableMapView(A_commands), this.allowTrailingOptions = allowTrailingOptions != null ? allowTrailingOptions : false;
  void addFlag(String A_name, {String abbr, String help, bool defaultsTo: false, bool negatable: true, void callback(bool value), bool hide: false}) {
    _addOption(A_name, abbr, help, null, null, defaultsTo, callback, isFlag: true, negatable: negatable, hide: hide);
  }
  void addOption(String A_name, {String abbr, String help, List<String> allowed, Map<String, String> allowedHelp, String defaultsTo, void callback(value), bool allowMultiple: false, bool hide: false}) {
    _addOption(A_name, abbr, help, allowed, allowedHelp, defaultsTo, callback, isFlag: false, allowMultiple: allowMultiple, hide: hide);
  }
  void _addOption(String A_name, String abbr, String help, List<String> allowed, Map<String, String> allowedHelp, defaultsTo, void A_callback(value), {bool isFlag, bool negatable: false, bool allowMultiple: false, bool hide: false}) {
    if (A__options.containsKey(A_name)) {
      throw new ArgumentError('Duplicate option "${A_name}".');
    }
    if (abbr != null) {
      var existing = findByAbbreviation(abbr);
      if (existing != null) {
        throw new ArgumentError('Abbreviation "${abbr}" is already used by "${existing.name}".');
      }
    }
    A__options[A_name] = new Option(A_name, abbr, help, allowed, allowedHelp, defaultsTo, A_callback, isFlag: isFlag, negatable: negatable, allowMultiple: allowMultiple, hide: hide);
  }
  ArgResults parse(List<String> args) => new A_Parser(null, this, args.toList(), null, null).parse();
  String getUsage() => new Usage(this).generate();
  Option findByAbbreviation(String abbr) {
    return options.values.firstWhere((option) => option.abbreviation == abbr, orElse: () => null);
  }
}
class ArgResults {
  final Map<String, dynamic> A__options;
  final String name;
  final ArgResults command;
  final List<String> rest;
  ArgResults(this.A__options, this.name, this.command, List<String> A_rest) : this.rest = new A_p.UnmodifiableListView(A_rest);
  operator[](String A_name) {
    if (!A__options.containsKey(A_name)) {
      throw new ArgumentError('Could not find an option named "${A_name}".');
    }
    return A__options[A_name];
  }
  Iterable<String> get options => A__options.keys;
}
class Option {
  final String name;
  final String abbreviation;
  final List<String> allowed;
  final defaultValue;
  final Function callback;
  final String help;
  final Map<String, String> allowedHelp;
  final bool isFlag;
  final bool negatable;
  final bool allowMultiple;
  final bool hide;
  Option(this.name, this.abbreviation, this.help, List<String> A_allowed, Map<String, String> A_allowedHelp, this.defaultValue, this.callback, {this.isFlag, this.negatable, this.allowMultiple: false, this.hide: false}) : this.allowed = A_allowed == null ? null : new A_p.UnmodifiableListView(A_allowed), this.allowedHelp = A_allowedHelp == null ? null : new A_UnmodifiableMapView(A_allowedHelp) {
    if (name.isEmpty) {
      throw new ArgumentError('Name cannot be empty.');
    } else if (name.startsWith('-')) {
      throw new ArgumentError('Name ${name} cannot start with "-".');
    }
    if (_invalidChars.hasMatch(name)) {
      throw new ArgumentError('Name "${name}" contains invalid characters.');
    }
    if (abbreviation != null) {
      if (abbreviation.length != 1) {
        throw new ArgumentError('Abbreviation must be null or have length 1.');
      } else if (abbreviation == '-') {
        throw new ArgumentError('Abbreviation cannot be "-".');
      }
      if (_invalidChars.hasMatch(abbreviation)) {
        throw new ArgumentError('Abbreviation is an invalid character.');
      }
    }
  }
  static final _invalidChars = new RegExp(r'''[ \t\r\n"'\\/]''');
}
final _SOLO_OPT = new RegExp(r'^-([a-zA-Z0-9])$');
final _ABBR_OPT = new RegExp(r'^-([a-zA-Z0-9]+)(.*)$');
final _LONG_OPT = new RegExp(r'^--([a-zA-Z\-_0-9]+)(=(.*))?$');
class A_Parser {
  final String commandName;
  final A_Parser parent;
  final ArgParser grammar;
  final List<String> args;
  final rest = <String>[];
  final Map<String, dynamic> results = <String, dynamic>{};
  A_Parser(this.commandName, this.grammar, this.args, this.parent, A_rest) {
    if (A_rest != null) this.rest.addAll(A_rest);
  }
  String get current => args[0];
  ArgResults parse() {
    var commandResults = null;
    grammar.options.forEach((A_name, option) {
      if (option.allowMultiple) {
        results[A_name] = [];
      } else {
        results[A_name] = option.defaultValue;
      }
    });
    while (args.length > 0) {
      if (current == '--') {
        args.removeAt(0);
        break;
      }
      var command = grammar.commands[current];
      if (command != null) {
        validate(rest.isEmpty, 'Cannot specify arguments before a command.');
        var A_commandName = args.removeAt(0);
        var commandParser = new A_Parser(A_commandName, command, args, this, rest);
        commandResults = commandParser.parse();
        rest.clear();
        break;
      }
      if (parseSoloOption()) continue;
      if (parseAbbreviation(this)) continue;
      if (parseLongOption()) continue;
      if (!grammar.allowTrailingOptions) break;
      rest.add(args.removeAt(0));
    }
    grammar.options.forEach((A_name, option) {
      if (option.allowMultiple && results[A_name].length == 0 && option.defaultValue != null) {
        results[A_name].add(option.defaultValue);
      }
      if (option.callback != null) option.callback(results[A_name]);
    });
    rest.addAll(args);
    args.clear();
    return new ArgResults(results, commandName, commandResults, rest);
  }
  void readNextArgAsValue(Option option) {
    validate(args.length > 0, 'Missing argument for "${option.name}".');
    validate(!_ABBR_OPT.hasMatch(current) && !_LONG_OPT.hasMatch(current), 'Missing argument for "${option.name}".');
    setOption(results, option, current);
    args.removeAt(0);
  }
  bool parseSoloOption() {
    var soloOpt = _SOLO_OPT.firstMatch(current);
    if (soloOpt == null) return false;
    var option = grammar.findByAbbreviation(soloOpt[1]);
    if (option == null) {
      validate(parent != null, 'Could not find an option or flag "-${soloOpt[1]}".');
      return parent.parseSoloOption();
    }
    args.removeAt(0);
    if (option.isFlag) {
      setOption(results, option, true);
    } else {
      readNextArgAsValue(option);
    }
    return true;
  }
  bool parseAbbreviation(A_Parser innermostCommand) {
    var abbrOpt = _ABBR_OPT.firstMatch(current);
    if (abbrOpt == null) return false;
    var c = abbrOpt[1].substring(0, 1);
    var A_first = grammar.findByAbbreviation(c);
    if (A_first == null) {
      validate(parent != null, 'Could not find an option with short name "-${c}".');
      return parent.parseAbbreviation(innermostCommand);
    } else if (!A_first.isFlag) {
      var A_value = '${abbrOpt[1].substring(1)}${abbrOpt[2]}';
      setOption(results, A_first, A_value);
    } else {
      validate(abbrOpt[2] == '', 'Option "-${c}" is a flag and cannot handle value ' '"${abbrOpt[1].substring(1)}${abbrOpt[2]}".');
      for (var i = 0; i < abbrOpt[1].length; i++) {
        var c = abbrOpt[1].substring(i, i + 1);
        innermostCommand.parseShortFlag(c);
      }
    }
    args.removeAt(0);
    return true;
  }
  void parseShortFlag(String c) {
    var option = grammar.findByAbbreviation(c);
    if (option == null) {
      validate(parent != null, 'Could not find an option with short name "-${c}".');
      parent.parseShortFlag(c);
      return;
    }
    validate(option.isFlag, 'Option "-${c}" must be a flag to be in a collapsed "-".');
    setOption(results, option, true);
  }
  bool parseLongOption() {
    var longOpt = _LONG_OPT.firstMatch(current);
    if (longOpt == null) return false;
    var A_name = longOpt[1];
    var option = grammar.options[A_name];
    if (option != null) {
      args.removeAt(0);
      if (option.isFlag) {
        validate(longOpt[3] == null, 'Flag option "${A_name}" should not be given a value.');
        setOption(results, option, true);
      } else if (longOpt[3] != null) {
        setOption(results, option, longOpt[3]);
      } else {
        readNextArgAsValue(option);
      }
    } else if (A_name.startsWith('no-')) {
      A_name = A_name.substring('no-'.length);
      option = grammar.options[A_name];
      if (option == null) {
        validate(parent != null, 'Could not find an option named "${A_name}".');
        return parent.parseLongOption();
      }
      args.removeAt(0);
      validate(option.isFlag, 'Cannot negate non-flag option "${A_name}".');
      validate(option.negatable, 'Cannot negate option "${A_name}".');
      setOption(results, option, false);
    } else {
      validate(parent != null, 'Could not find an option named "${A_name}".');
      return parent.parseLongOption();
    }
    return true;
  }
  void validate(bool condition, String A_message) {
    if (!condition) throw new FormatException(A_message);
  }
  void setOption(Map A_results, Option option, A_value) {
    if (option.allowed != null) {
      validate(option.allowed.any((allow) => allow == A_value), '"${A_value}" is not an allowed value for option "${option.name}".');
    }
    if (option.allowMultiple) {
      A_results[option.name].add(A_value);
    } else {
      A_results[option.name] = A_value;
    }
  }
}
class Usage {
  static const NUM_COLUMNS = 3;
  final ArgParser args;
  StringBuffer buffer;
  int currentColumn = 0;
  List<int> columnWidths;
  int numHelpLines = 0;
  int newlinesNeeded = 0;
  Usage(this.args);
  String generate() {
    buffer = new StringBuffer();
    calculateColumnWidths();
    args.options.forEach((A_name, option) {
      if (option.hide) return;
      write(0, getAbbreviation(option));
      write(1, getLongOption(option));
      if (option.help != null) write(2, option.help);
      if (option.allowedHelp != null) {
        var allowedNames = option.allowedHelp.keys.toList(growable: false);
        allowedNames.sort();
        newline();
        for (var A_name in allowedNames) {
          write(1, getAllowedTitle(A_name));
          write(2, option.allowedHelp[A_name]);
        }
        newline();
      } else if (option.allowed != null) {
        write(2, buildAllowedList(option));
      } else if (option.defaultValue != null) {
        if (option.isFlag && option.defaultValue == true) {
          write(2, '(defaults to on)');
        } else if (!option.isFlag) {
          write(2, '(defaults to "${option.defaultValue}")');
        }
      }
      if (numHelpLines > 1) newline();
    });
    return buffer.toString();
  }
  String getAbbreviation(Option option) {
    if (option.abbreviation != null) {
      return '-${option.abbreviation}, ';
    } else {
      return '';
    }
  }
  String getLongOption(Option option) {
    if (option.negatable) {
      return '--[no-]${option.name}';
    } else {
      return '--${option.name}';
    }
  }
  String getAllowedTitle(String allowed) {
    return '      [${allowed}]';
  }
  void calculateColumnWidths() {
    int abbr = 0;
    int title = 0;
    args.options.forEach((A_name, option) {
      if (option.hide) return;
      abbr = D_p.max(abbr, getAbbreviation(option).length);
      title = D_p.max(title, getLongOption(option).length);
      if (option.allowedHelp != null) {
        for (var allowed in option.allowedHelp.keys) {
          title = D_p.max(title, getAllowedTitle(allowed).length);
        }
      }
    });
    title += 4;
    columnWidths = [abbr, title];
  }
  void newline() {
    newlinesNeeded++;
    currentColumn = 0;
    numHelpLines = 0;
  }
  void write(int column, String text) {
    var lines = text.split('\n');
    while (lines.length > 0 && lines[0].trim() == '') {
      lines.removeRange(0, 1);
    }
    while (lines.length > 0 && lines[lines.length - 1].trim() == '') {
      lines.removeLast();
    }
    for (var line in lines) {
      writeLine(column, line);
    }
  }
  void writeLine(int column, String text) {
    while (newlinesNeeded > 0) {
      buffer.write('\n');
      newlinesNeeded--;
    }
    while (currentColumn != column) {
      if (currentColumn < NUM_COLUMNS - 1) {
        buffer.write(A_padRight('', columnWidths[currentColumn]));
      } else {
        buffer.write('\n');
      }
      currentColumn = (currentColumn + 1) % NUM_COLUMNS;
    }
    if (column < columnWidths.length) {
      buffer.write(A_padRight(text, columnWidths[column]));
    } else {
      buffer.write(text);
    }
    currentColumn = (currentColumn + 1) % NUM_COLUMNS;
    if (column == NUM_COLUMNS - 1) newlinesNeeded++;
    if (column == NUM_COLUMNS - 1) {
      numHelpLines++;
    } else {
      numHelpLines = 0;
    }
  }
  String buildAllowedList(Option option) {
    var allowedBuffer = new StringBuffer();
    allowedBuffer.write('[');
    bool A_first = true;
    for (var allowed in option.allowed) {
      if (!A_first) allowedBuffer.write(', ');
      allowedBuffer.write(allowed);
      if (allowed == option.defaultValue) {
        allowedBuffer.write(' (default)');
      }
      A_first = false;
    }
    allowedBuffer.write(']');
    return allowedBuffer.toString();
  }
}
String A_padRight(String A_source, int A_length) {
  final result = new StringBuffer();
  result.write(A_source);
  while (result.length < A_length) {
    result.write(' ');
  }
  return result.toString();
}
class A_UnmodifiableMapView<B_K, B_V> extends DelegatingMap<B_K, B_V> with UnmodifiableMapMixin<B_K, B_V> {
  A_UnmodifiableMapView(Map<B_K, B_V> baseMap) : super(baseMap);
}
abstract class UnmodifiableMapMixin<B_K, B_V> implements Map<B_K, B_V> {
  static _throw() {
    throw new UnsupportedError("Cannot modify an unmodifiable Map");
  }
  void operator[]=(B_K A_key, B_V A_value) => _throw();
  B_V putIfAbsent(B_K A_key, B_V ifAbsent()) => _throw();
  void addAll(Map<B_K, B_V> other) => _throw();
  B_V remove(B_K A_key) => _throw();
  void clear() => _throw();
}
class DelegatingMap<B_K, B_V> implements Map<B_K, B_V> {
  final Map<B_K, B_V> _base;
  const DelegatingMap(Map<B_K, B_V> A_base) : _base = A_base;
  B_V operator[](Object A_key) => _base[A_key];
  void operator[]=(B_K A_key, B_V A_value) {
    _base[A_key] = A_value;
  }
  void addAll(Map<B_K, B_V> other) {
    _base.addAll(other);
  }
  void clear() {
    _base.clear();
  }
  bool containsKey(Object A_key) => _base.containsKey(A_key);
  bool containsValue(Object A_value) => _base.containsValue(A_value);
  void forEach(void f(B_K key, B_V value)) {
    _base.forEach(f);
  }
  bool get isEmpty => _base.isEmpty;
  bool get isNotEmpty => _base.isNotEmpty;
  Iterable<B_K> get keys => _base.keys;
  int get length => _base.length;
  B_V putIfAbsent(B_K A_key, B_V ifAbsent()) => _base.putIfAbsent(A_key, ifAbsent);
  B_V remove(Object A_key) => _base.remove(A_key);
  Iterable<B_V> get values => _base.values;
  String toString() => _base.toString();
}
const A__MASK_8 = 0xff;
const A__MASK_32 = 0xffffffff;
class SHA1 extends A__HashBase {
  SHA1() : A__w = new List(80), super(16, 5, true) {
    A__h[0] = 0x67452301;
    A__h[1] = 0xEFCDAB89;
    A__h[2] = 0x98BADCFE;
    A__h[3] = 0x10325476;
    A__h[4] = 0xC3D2E1F0;
  }
  void A__updateHash(List<int> m) {
    assert(m.length == 16);
    var a = A__h[0];
    var b = A__h[1];
    var c = A__h[2];
    var d = A__h[3];
    var e = A__h[4];
    for (var i = 0; i < 80; i++) {
      if (i < 16) {
        A__w[i] = m[i];
      } else {
        var n = A__w[i - 3] ^ A__w[i - 8] ^ A__w[i - 14] ^ A__w[i - 16];
        A__w[i] = A__rotl32(n, 1);
      }
      var t = A__add32(A__add32(A__rotl32(a, 5), e), A__w[i]);
      if (i < 20) {
        t = A__add32(A__add32(t, (b & c) | (~b & d)), 0x5A827999);
      } else if (i < 40) {
        t = A__add32(A__add32(t, (b ^ c ^ d)), 0x6ED9EBA1);
      } else if (i < 60) {
        t = A__add32(A__add32(t, (b & c) | (b & d) | (c & d)), 0x8F1BBCDC);
      } else {
        t = A__add32(A__add32(t, b ^ c ^ d), 0xCA62C1D6);
      }
      e = d;
      d = c;
      c = A__rotl32(b, 30);
      b = a;
      a = t & A__MASK_32;
    }
    A__h[0] = A__add32(a, A__h[0]);
    A__h[1] = A__add32(b, A__h[1]);
    A__h[2] = A__add32(c, A__h[2]);
    A__h[3] = A__add32(d, A__h[3]);
    A__h[4] = A__add32(e, A__h[4]);
  }
  List<int> A__w;
}
const A__BITS_PER_BYTE = 8;
const A__BYTES_PER_WORD = 4;
int A__rotl32(int val, int shift) {
  var mod_shift = shift & 31;
  return ((val << mod_shift) & A__MASK_32) | ((val & A__MASK_32) >> (32 - mod_shift));
}
abstract class A__HashBase implements Hash {
  A__HashBase(int chunkSizeInWords, int digestSizeInWords, bool this.A__bigEndianWords) : A__pendingData = [], A__currentChunk = new List(chunkSizeInWords), A__h = new List(digestSizeInWords), A__chunkSizeInWords = chunkSizeInWords, A__digestSizeInWords = digestSizeInWords;
  void add(List<int> A_data) {
    if (A__digestCalled) {
      throw new StateError('Hash update method called after digest was retrieved');
    }
    A__lengthInBytes += A_data.length;
    A__pendingData.addAll(A_data);
    A__iterate();
  }
  List<int> close() {
    if (A__digestCalled) {
      return A__resultAsBytes();
    }
    A__digestCalled = true;
    A__finalizeData();
    A__iterate();
    assert(A__pendingData.length == 0);
    return A__resultAsBytes();
  }
  void A__updateHash(List<int> m);
  int A__add32(A_x, A_y) => (A_x + A_y) & A__MASK_32;
  int A__roundUp(val, n) => (val + n - 1) & -n;
  List<int> A__resultAsBytes() {
    var result = [];
    for (var i = 0; i < A__h.length; i++) {
      result.addAll(A__wordToBytes(A__h[i]));
    }
    return result;
  }
  void A__bytesToChunk(List<int> A_data, int dataIndex) {
    assert((A_data.length - dataIndex) >= (A__chunkSizeInWords * A__BYTES_PER_WORD));
    for (var wordIndex = 0; wordIndex < A__chunkSizeInWords; wordIndex++) {
      var w3 = A__bigEndianWords ? A_data[dataIndex] : A_data[dataIndex + 3];
      var w2 = A__bigEndianWords ? A_data[dataIndex + 1] : A_data[dataIndex + 2];
      var w1 = A__bigEndianWords ? A_data[dataIndex + 2] : A_data[dataIndex + 1];
      var w0 = A__bigEndianWords ? A_data[dataIndex + 3] : A_data[dataIndex];
      dataIndex += 4;
      var word = (w3 & 0xff) << 24;
      word |= (w2 & A__MASK_8) << 16;
      word |= (w1 & A__MASK_8) << 8;
      word |= (w0 & A__MASK_8);
      A__currentChunk[wordIndex] = word;
    }
  }
  List<int> A__wordToBytes(int word) {
    List<int> bytes = new List(A__BYTES_PER_WORD);
    bytes[0] = (word >> (A__bigEndianWords ? 24 : 0)) & A__MASK_8;
    bytes[1] = (word >> (A__bigEndianWords ? 16 : 8)) & A__MASK_8;
    bytes[2] = (word >> (A__bigEndianWords ? 8 : 16)) & A__MASK_8;
    bytes[3] = (word >> (A__bigEndianWords ? 0 : 24)) & A__MASK_8;
    return bytes;
  }
  void A__iterate() {
    var len = A__pendingData.length;
    var chunkSizeInBytes = A__chunkSizeInWords * A__BYTES_PER_WORD;
    if (len >= chunkSizeInBytes) {
      var A_index = 0;
      for (; (len - A_index) >= chunkSizeInBytes; A_index += chunkSizeInBytes) {
        A__bytesToChunk(A__pendingData, A_index);
        A__updateHash(A__currentChunk);
      }
      A__pendingData = A__pendingData.sublist(A_index, len);
    }
  }
  void A__finalizeData() {
    A__pendingData.add(0x80);
    var contentsLength = A__lengthInBytes + 9;
    var chunkSizeInBytes = A__chunkSizeInWords * A__BYTES_PER_WORD;
    var finalizedLength = A__roundUp(contentsLength, chunkSizeInBytes);
    var zeroPadding = finalizedLength - contentsLength;
    for (var i = 0; i < zeroPadding; i++) {
      A__pendingData.add(0);
    }
    var lengthInBits = A__lengthInBytes * A__BITS_PER_BYTE;
    assert(lengthInBits < D_p.pow(2, 32));
    if (A__bigEndianWords) {
      A__pendingData.addAll(A__wordToBytes(0));
      A__pendingData.addAll(A__wordToBytes(lengthInBits & A__MASK_32));
    } else {
      A__pendingData.addAll(A__wordToBytes(lengthInBits & A__MASK_32));
      A__pendingData.addAll(A__wordToBytes(0));
    }
  }
  final int A__chunkSizeInWords;
  final int A__digestSizeInWords;
  final bool A__bigEndianWords;
  int A__lengthInBytes = 0;
  List<int> A__pendingData;
  final List<int> A__currentChunk;
  final List<int> A__h;
  bool A__digestCalled = false;
}
abstract class Hash {
  void add(List<int> A_data);
  List<int> close();
}
bool hierarchicalLoggingEnabled = false;
Level _rootLevel = Level.A_INFO;
class A_Logger {
  final String name;
  String get fullName => (parent == null || parent.name == '') ? name : '${parent.fullName}.${name}';
  final A_Logger parent;
  Level _level;
  final Map<String, A_Logger> _children;
  final Map<String, A_Logger> children;
  p.StreamController<LogRecord> A__controller;
  factory A_Logger(String A_name) {
    return _loggers.putIfAbsent(A_name, () => new A_Logger._named(A_name));
  }
  factory A_Logger._named(String A_name) {
    if (A_name.startsWith('.')) {
      throw new ArgumentError("name shouldn't start with a '.'");
    }
    int dot = A_name.lastIndexOf('.');
    A_Logger A_parent = null;
    String thisName;
    if (dot == -1) {
      if (A_name != '') A_parent = new A_Logger('');
      thisName = A_name;
    } else {
      A_parent = new A_Logger(A_name.substring(0, dot));
      thisName = A_name.substring(dot + 1);
    }
    return new A_Logger.A__internal(thisName, A_parent, new Map<String,A_Logger>());
  }
  A_Logger.A__internal(this.name, this.parent, Map<String, A_Logger> A_children) : this._children = A_children, this.children = new A_UnmodifiableMapView(A_children) {
    if (parent != null) parent._children[name] = this;
  }
  Level get level {
    if (hierarchicalLoggingEnabled) {
      if (_level != null) return _level;
      if (parent != null) return parent.level;
    }
    return _rootLevel;
  }
  p.Stream<LogRecord> get onRecord => _getStream();
  bool isLoggable(Level A_value) => (A_value >= level);
  void log(Level logLevel, String A_message, [Object A_error, StackTrace A_stackTrace]) {
    if (isLoggable(logLevel)) {
      var record = new LogRecord(logLevel, A_message, fullName, A_error, A_stackTrace);
      if (hierarchicalLoggingEnabled) {
        var A_target = this;
        while (A_target != null) {
          A_target._publish(record);
          A_target = A_target.parent;
        }
      } else {
        root._publish(record);
      }
    }
  }
  void info(String A_message, [Object A_error, StackTrace A_stackTrace]) => log(Level.A_INFO, A_message, A_error, A_stackTrace);
  void severe(String A_message, [Object A_error, StackTrace A_stackTrace]) => log(Level.SEVERE, A_message, A_error, A_stackTrace);
  p.Stream<LogRecord> _getStream() {
    if (hierarchicalLoggingEnabled || parent == null) {
      if (A__controller == null) {
        A__controller = new p.StreamController<LogRecord>.broadcast(sync: true);
      }
      return A__controller.stream;
    } else {
      return root._getStream();
    }
  }
  void _publish(LogRecord record) {
    if (A__controller != null) {
      A__controller.add(record);
    }
  }
  static A_Logger get root => new A_Logger('');
  static final Map<String, A_Logger> _loggers = <String, A_Logger>{};
}
class Level implements Comparable<Level> {
  final String name;
  final int value;
  const Level(this.name, this.value);
  static const Level A_INFO = const Level('INFO', 800);
  static const Level SEVERE = const Level('SEVERE', 1000);
  bool operator==(Object other) => other is Level && value == other.value;
  bool operator<(Level other) => value < other.value;
  bool operator<=(Level other) => value <= other.value;
  bool operator>(Level other) => value > other.value;
  bool operator>=(Level other) => value >= other.value;
  int compareTo(Level other) => value - other.value;
  int get hashCode => value;
  String toString() => name;
}
class LogRecord {
  final Level level;
  final String message;
  final String loggerName;
  final DateTime time;
  final int sequenceNumber;
  static int _nextNumber = 0;
  final Object error;
  final StackTrace stackTrace;
  LogRecord(this.level, this.message, this.loggerName, [this.error, this.stackTrace]) : time = new DateTime.now(), sequenceNumber = LogRecord._nextNumber++;
  String toString() => '[${level.name}] ${loggerName}: ${message}';
}
final posix = new Context(style: Style.A_posix);
final windows = new Context(style: Style.A_windows);
Uri _lastBaseUri;
Context get _context {
  if (_cachedContext != null && Uri.base == _lastBaseUri) return _cachedContext;
  _lastBaseUri = Uri.base;
  _cachedContext = new Context();
  return _cachedContext;
}
Context _cachedContext;
String get A_current {
  var A_uri = Uri.base;
  if (Style.platform == Style.url) {
    return A_uri.resolve('.').toString();
  } else {
    var A_path = A_uri.toFilePath();
    int lastIndex = A_path.length - 1;
    assert(A_path[lastIndex] == '/' || A_path[lastIndex] == '\\');
    return A_path.substring(0, lastIndex);
  }
}
String A_absolute(String part1, [String part2, String part3, String part4, String part5, String part6, String part7]) => _context.absolute(part1, part2, part3, part4, part5, part6, part7);
String basename(String A_path) => _context.A_basename(A_path);
String dirname(String A_path) => _context.A_dirname(A_path);
bool isRelative(String A_path) => _context.A_isRelative(A_path);
String B_join(String part1, [String part2, String part3, String part4, String part5, String part6, String part7, String part8]) => _context.join(part1, part2, part3, part4, part5, part6, part7, part8);
List<String> B_split(String A_path) => _context.split(A_path);
String normalize(String A_path) => _context.A_normalize(A_path);
String relative(String A_path, {String from}) => _context.A_relative(A_path, from: from);
bool isWithin(String A_parent, String child) => _context.A_isWithin(A_parent, child);
String A_fromUri(A_uri) => _context.fromUri(A_uri);
Uri toUri(String A_path) => _context.A_toUri(A_path);
const A_PLUS = 0x2b;
const A_MINUS = 0x2d;
const A_PERIOD = 0x2e;
const B_SLASH = 0x2f;
const A_ZERO = 0x30;
const NINE = 0x39;
const B_COLON = 0x3a;
const UPPER_A = 0x41;
const UPPER_Z = 0x5a;
const LOWER_A = 0x61;
const LOWER_Z = 0x7a;
const B_BACKSLASH = 0x5c;
class Context {
  factory Context({Style style, String current}) {
    if (current == null) {
      if (style == null) {
        current = A_current;
      } else {
        current = ".";
      }
    }
    if (style == null) {
      style = Style.platform;
    } else if (style is! InternalStyle) {
      throw new ArgumentError("Only styles defined by the path package are " "allowed.");
    }
    return new Context.E__(style, current);
  }
  Context.E__(this.style, this.current);
  final InternalStyle style;
  final String current;
  String get A_separator => style.A_separator;
  String absolute(String part1, [String part2, String part3, String part4, String part5, String part6, String part7]) {
    return join(current, part1, part2, part3, part4, part5, part6, part7);
  }
  String A_basename(String A_path) => A__parse(A_path).A_basename;
  String A_dirname(String A_path) {
    var parsed = A__parse(A_path);
    parsed.removeTrailingSeparators();
    if (parsed.parts.isEmpty) return parsed.A_root == null ? '.' : parsed.A_root;
    if (parsed.parts.length == 1) {
      return parsed.A_root == null ? '.' : parsed.A_root;
    }
    parsed.parts.removeLast();
    parsed.separators.removeLast();
    parsed.removeTrailingSeparators();
    return parsed.toString();
  }
  String rootPrefix(String A_path) {
    var A_root = A__parse(A_path).A_root;
    return A_root == null ? '' : A_root;
  }
  bool isAbsolute(String A_path) => A__parse(A_path).isAbsolute;
  bool A_isRelative(String A_path) => !this.isAbsolute(A_path);
  bool isRootRelative(String A_path) => A__parse(A_path).isRootRelative;
  String join(String part1, [String part2, String part3, String part4, String part5, String part6, String part7, String part8]) {
    var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
    _validateArgList("join", parts);
    return joinAll(parts.where((part) => part != null));
  }
  String joinAll(Iterable<String> parts) {
    var A_buffer = new StringBuffer();
    var needsSeparator = false;
    var isAbsoluteAndNotRootRelative = false;
    for (var part in parts.where((part) => part != '')) {
      if (this.isRootRelative(part) && isAbsoluteAndNotRootRelative) {
        var parsed = A__parse(part);
        parsed.A_root = this.rootPrefix(A_buffer.toString());
        if (style.needsSeparator(parsed.A_root)) {
          parsed.separators[0] = style.A_separator;
        }
        A_buffer.clear();
        A_buffer.write(parsed.toString());
      } else if (this.isAbsolute(part)) {
        isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
        A_buffer.clear();
        A_buffer.write(part);
      } else {
        if (part.length > 0 && style.containsSeparator(part[0])) {} else if (needsSeparator) {
          A_buffer.write(A_separator);
        }
        A_buffer.write(part);
      }
      needsSeparator = style.needsSeparator(part);
    }
    return A_buffer.toString();
  }
  List<String> split(String A_path) {
    var parsed = A__parse(A_path);
    parsed.parts = parsed.parts.where((part) => !part.isEmpty).toList();
    if (parsed.A_root != null) parsed.parts.insert(0, parsed.A_root);
    return parsed.parts;
  }
  String A_normalize(String A_path) {
    var parsed = A__parse(A_path);
    parsed.A_normalize();
    return parsed.toString();
  }
  String A_relative(String A_path, {String from}) {
    from = from == null ? current : this.join(current, from);
    if (this.A_isRelative(from) && this.isAbsolute(A_path)) {
      return this.A_normalize(A_path);
    }
    if (this.A_isRelative(A_path) || this.isRootRelative(A_path)) {
      A_path = this.absolute(A_path);
    }
    if (this.A_isRelative(A_path) && this.isAbsolute(from)) {
      throw new PathException('Unable to find a path to "${A_path}" from "${from}".');
    }
    var fromParsed = A__parse(from)
        ..A_normalize();
    var pathParsed = A__parse(A_path)
        ..A_normalize();
    if (fromParsed.parts.length > 0 && fromParsed.parts[0] == '.') {
      return pathParsed.toString();
    }
    if (fromParsed.A_root != pathParsed.A_root && ((fromParsed.A_root == null || pathParsed.A_root == null) || fromParsed.A_root.toLowerCase().replaceAll('/', '\\') != pathParsed.A_root.toLowerCase().replaceAll('/', '\\'))) {
      return pathParsed.toString();
    }
    while (fromParsed.parts.length > 0 && pathParsed.parts.length > 0 && fromParsed.parts[0] == pathParsed.parts[0]) {
      fromParsed.parts.removeAt(0);
      fromParsed.separators.removeAt(1);
      pathParsed.parts.removeAt(0);
      pathParsed.separators.removeAt(1);
    }
    if (fromParsed.parts.length > 0 && fromParsed.parts[0] == '..') {
      throw new PathException('Unable to find a path to "${A_path}" from "${from}".');
    }
    pathParsed.parts.insertAll(0, new List.filled(fromParsed.parts.length, '..'));
    pathParsed.separators[0] = '';
    pathParsed.separators.insertAll(1, new List.filled(fromParsed.parts.length, style.A_separator));
    if (pathParsed.parts.length == 0) return '.';
    if (pathParsed.parts.length > 1 && pathParsed.parts.last == '.') {
      pathParsed.parts.removeLast();
      pathParsed.separators
          ..removeLast()
          ..removeLast()
          ..add('');
    }
    pathParsed.A_root = '';
    pathParsed.removeTrailingSeparators();
    return pathParsed.toString();
  }
  bool A_isWithin(String A_parent, String child) {
    var A_relative;
    try {
      A_relative = this.A_relative(child, from: A_parent);
    }on PathException  catch (E__) {
      return false;
    }
    var parts = this.split(A_relative);
    return this.A_isRelative(A_relative) && parts.first != '..' && parts.first != '.';
  }
  String fromUri(A_uri) {
    if (A_uri is String) A_uri = Uri.parse(A_uri);
    return style.pathFromUri(A_uri);
  }
  Uri A_toUri(String A_path) {
    if (A_isRelative(A_path)) {
      return style.relativePathToUri(A_path);
    } else {
      return style.absolutePathToUri(join(current, A_path));
    }
  }
  ParsedPath A__parse(String A_path) => new ParsedPath.B_parse(A_path, style);
}
_validateArgList(String A_method, List<String> args) {
  for (var i = 1; i < args.length; i++) {
    if (args[i] == null || args[i - 1] != null) continue;
    var numArgs;
    for (numArgs = args.length; numArgs >= 1; numArgs--) {
      if (args[numArgs - 1] != null) break;
    }
    var A_message = new StringBuffer();
    A_message.write("${A_method}(");
    A_message.write(args.take(numArgs).map((arg) => arg == null ? "null" : '"${arg}"').join(", "));
    A_message.write("): part ${i - 1} was null, but part ${i} was not.");
    throw new ArgumentError(A_message.toString());
  }
}
abstract class InternalStyle extends Style {
  String get A_separator;
  bool containsSeparator(String A_path);
  bool isSeparator(int codeUnit);
  bool needsSeparator(String A_path);
  String getRoot(String A_path);
  String getRelativeRoot(String A_path);
  String pathFromUri(Uri A_uri);
  Uri relativePathToUri(String A_path) => new Uri(pathSegments: context.split(A_path));
  Uri absolutePathToUri(String A_path);
}
class ParsedPath {
  InternalStyle style;
  String A_root;
  bool isRootRelative;
  List<String> parts;
  List<String> separators;
  bool get isAbsolute => A_root != null;
  factory ParsedPath.B_parse(String A_path, InternalStyle A_style) {
    var before = A_path;
    var A_root = A_style.getRoot(A_path);
    var A_isRootRelative = A_style.getRelativeRoot(A_path) != null;
    if (A_root != null) A_path = A_path.substring(A_root.length);
    var A_parts = [];
    var A_separators = [];
    var A_start = 0;
    if (A_path.isNotEmpty && A_style.isSeparator(A_path.codeUnitAt(0))) {
      A_separators.add(A_path[0]);
      A_start = 1;
    } else {
      A_separators.add('');
    }
    for (var i = A_start; i < A_path.length; i++) {
      if (A_style.isSeparator(A_path.codeUnitAt(i))) {
        A_parts.add(A_path.substring(A_start, i));
        A_separators.add(A_path[i]);
        A_start = i + 1;
      }
    }
    if (A_start < A_path.length) {
      A_parts.add(A_path.substring(A_start));
      A_separators.add('');
    }
    return new ParsedPath.F__(A_style, A_root, A_isRootRelative, A_parts, A_separators);
  }
  ParsedPath.F__(this.style, this.A_root, this.isRootRelative, this.parts, this.separators);
  String get A_basename {
    var A_copy = this.clone();
    A_copy.removeTrailingSeparators();
    if (A_copy.parts.isEmpty) return A_root == null ? '' : A_root;
    return A_copy.parts.last;
  }
  bool get hasTrailingSeparator => !parts.isEmpty && (parts.last == '' || separators.last != '');
  void removeTrailingSeparators() {
    while (!parts.isEmpty && parts.last == '') {
      parts.removeLast();
      separators.removeLast();
    }
    if (separators.length > 0) separators[separators.length - 1] = '';
  }
  void A_normalize() {
    var leadingDoubles = 0;
    var newParts = [];
    for (var part in parts) {
      if (part == '.' || part == '') {} else if (part == '..') {
        if (newParts.length > 0) {
          newParts.removeLast();
        } else {
          leadingDoubles++;
        }
      } else {
        newParts.add(part);
      }
    }
    if (!isAbsolute) {
      newParts.insertAll(0, new List.filled(leadingDoubles, '..'));
    }
    if (newParts.length == 0 && !isAbsolute) {
      newParts.add('.');
    }
    var newSeparators = new List.generate(newParts.length, (F__) => style.A_separator, growable: true);
    newSeparators.insert(0, isAbsolute && newParts.length > 0 && style.needsSeparator(A_root) ? style.A_separator : '');
    parts = newParts;
    separators = newSeparators;
    if (A_root != null && style == Style.A_windows) {
      A_root = A_root.replaceAll('/', '\\');
    }
    removeTrailingSeparators();
  }
  String toString() {
    var A_builder = new StringBuffer();
    if (A_root != null) A_builder.write(A_root);
    for (var i = 0; i < parts.length; i++) {
      A_builder.write(separators[i]);
      A_builder.write(parts[i]);
    }
    A_builder.write(separators.last);
    return A_builder.toString();
  }
  ParsedPath clone() => new ParsedPath.F__(style, A_root, isRootRelative, new List.from(parts), new List.from(separators));
}
class PathException implements Exception {
  String message;
  PathException(this.message);
  String toString() => "PathException: ${message}";
}
abstract class Style {
  static final A_posix = new PosixStyle();
  static final A_windows = new WindowsStyle();
  static final url = new UrlStyle();
  static final platform = _getPlatformStyle();
  static Style _getPlatformStyle() {
    if (Uri.base.scheme != 'file') return Style.url;
    if (!Uri.base.path.endsWith('/')) return Style.url;
    if (new Uri(path: 'a/b').toFilePath() == 'a\\b') return Style.A_windows;
    return Style.A_posix;
  }
  String get name;
  Context get context => new Context(style: this);
  String get A_separator;
  String getRoot(String A_path);
  String getRelativeRoot(String A_path);
  String pathFromUri(Uri A_uri);
  Uri relativePathToUri(String A_path);
  Uri absolutePathToUri(String A_path);
  String toString() => name;
}
class PosixStyle extends InternalStyle {
  PosixStyle();
  final name = 'posix';
  final A_separator = '/';
  final separators = const['/'];
  final separatorPattern = new RegExp(r'/');
  final needsSeparatorPattern = new RegExp(r'[^/]$');
  final rootPattern = new RegExp(r'^/');
  final relativeRootPattern = null;
  bool containsSeparator(String A_path) => A_path.contains('/');
  bool isSeparator(int codeUnit) => codeUnit == B_SLASH;
  bool needsSeparator(String A_path) => A_path.isNotEmpty && !isSeparator(A_path.codeUnitAt(A_path.length - 1));
  String getRoot(String A_path) {
    if (A_path.isNotEmpty && isSeparator(A_path.codeUnitAt(0))) return '/';
    return null;
  }
  String getRelativeRoot(String A_path) => null;
  String pathFromUri(Uri A_uri) {
    if (A_uri.scheme == '' || A_uri.scheme == 'file') {
      return Uri.decodeComponent(A_uri.path);
    }
    throw new ArgumentError("Uri ${A_uri} must have scheme 'file:'.");
  }
  Uri absolutePathToUri(String A_path) {
    var parsed = new ParsedPath.B_parse(A_path, this);
    if (parsed.parts.isEmpty) {
      parsed.parts.addAll(["", ""]);
    } else if (parsed.hasTrailingSeparator) {
      parsed.parts.add("");
    }
    return new Uri(scheme: 'file', pathSegments: parsed.parts);
  }
}
class UrlStyle extends InternalStyle {
  UrlStyle();
  final name = 'url';
  final A_separator = '/';
  final separators = const['/'];
  final separatorPattern = new RegExp(r'/');
  final needsSeparatorPattern = new RegExp(r"(^[a-zA-Z][-+.a-zA-Z\d]*://|[^/])$");
  final rootPattern = new RegExp(r"[a-zA-Z][-+.a-zA-Z\d]*://[^/]*");
  final relativeRootPattern = new RegExp(r"^/");
  bool containsSeparator(String A_path) => A_path.contains('/');
  bool isSeparator(int codeUnit) => codeUnit == B_SLASH;
  bool needsSeparator(String A_path) {
    if (A_path.isEmpty) return false;
    if (!isSeparator(A_path.codeUnitAt(A_path.length - 1))) return true;
    var A_root = _getRoot(A_path);
    return A_root != null && A_root.endsWith('://');
  }
  String getRoot(String A_path) {
    var A_root = _getRoot(A_path);
    return A_root == null ? getRelativeRoot(A_path) : A_root;
  }
  String getRelativeRoot(String A_path) {
    if (A_path.isEmpty) return null;
    return isSeparator(A_path.codeUnitAt(0)) ? "/" : null;
  }
  String pathFromUri(Uri A_uri) => A_uri.toString();
  Uri relativePathToUri(String A_path) => Uri.parse(A_path);
  Uri absolutePathToUri(String A_path) => Uri.parse(A_path);
  String _getRoot(String A_path) {
    if (A_path.isEmpty) return null;
    if (!isAlphabetic(A_path.codeUnitAt(0))) return null;
    var A_start = 1;
    for (; A_start < A_path.length; A_start++) {
      var char = A_path.codeUnitAt(A_start);
      if (isAlphabetic(char)) continue;
      if (isNumeric(char)) continue;
      if (char == A_MINUS || char == A_PLUS || char == A_PERIOD) {
        continue;
      }
      break;
    }
    if (A_start + 3 > A_path.length) return null;
    if (A_path.substring(A_start, A_start + 3) != '://') return null;
    A_start += 3;
    while (A_start < A_path.length && !isSeparator(A_path.codeUnitAt(A_start))) {
      A_start++;
    }
    return A_path.substring(0, A_start);
  }
}
class WindowsStyle extends InternalStyle {
  WindowsStyle();
  final name = 'windows';
  final A_separator = '\\';
  final separators = const['/', '\\'];
  final separatorPattern = new RegExp(r'[/\\]');
  final needsSeparatorPattern = new RegExp(r'[^/\\]$');
  final rootPattern = new RegExp(r'^(\\\\[^\\]+\\[^\\/]+|[a-zA-Z]:[/\\])');
  final relativeRootPattern = new RegExp(r"^[/\\](?![/\\])");
  bool containsSeparator(String A_path) => A_path.contains('/');
  bool isSeparator(int codeUnit) => codeUnit == B_SLASH || codeUnit == B_BACKSLASH;
  bool needsSeparator(String A_path) {
    if (A_path.isEmpty) return false;
    return !isSeparator(A_path.codeUnitAt(A_path.length - 1));
  }
  String getRoot(String A_path) {
    var A_root = A__getRoot(A_path);
    return A_root == null ? getRelativeRoot(A_path) : A_root;
  }
  String getRelativeRoot(String A_path) {
    if (A_path.isEmpty) return null;
    if (!isSeparator(A_path.codeUnitAt(0))) return null;
    if (A_path.length > 1 && isSeparator(A_path.codeUnitAt(1))) return null;
    return A_path[0];
  }
  String pathFromUri(Uri A_uri) {
    if (A_uri.scheme != '' && A_uri.scheme != 'file') {
      throw new ArgumentError("Uri ${A_uri} must have scheme 'file:'.");
    }
    var A_path = A_uri.path;
    if (A_uri.host == '') {
      if (A_path.startsWith('/')) A_path = A_path.replaceFirst("/", "");
    } else {
      A_path = '\\\\${A_uri.host}${A_path}';
    }
    return Uri.decodeComponent(A_path.replaceAll("/", "\\"));
  }
  Uri absolutePathToUri(String A_path) {
    var parsed = new ParsedPath.B_parse(A_path, this);
    if (parsed.A_root.startsWith(r'\\')) {
      var rootParts = parsed.A_root.split('\\').where((part) => part != '');
      parsed.parts.insert(0, rootParts.last);
      if (parsed.hasTrailingSeparator) {
        parsed.parts.add("");
      }
      return new Uri(scheme: 'file', host: rootParts.first, pathSegments: parsed.parts);
    } else {
      if (parsed.parts.length == 0 || parsed.hasTrailingSeparator) {
        parsed.parts.add("");
      }
      parsed.parts.insert(0, parsed.A_root.replaceAll("/", "").replaceAll("\\", ""));
      return new Uri(scheme: 'file', pathSegments: parsed.parts);
    }
  }
  String A__getRoot(String A_path) {
    if (A_path.length < 3) return null;
    if (isAlphabetic(A_path.codeUnitAt(0))) {
      if (A_path.codeUnitAt(1) != B_COLON) return null;
      if (!isSeparator(A_path.codeUnitAt(2))) return null;
      return A_path.substring(0, 3);
    }
    if (!A_path.startsWith('\\\\')) return null;
    var A_start = 2;
    while (A_start < A_path.length && A_path.codeUnitAt(A_start) != B_BACKSLASH) {
      A_start++;
    }
    if (A_start == 2 || A_start == A_path.length) return null;
    A_start += 1;
    if (A_path.codeUnitAt(A_start) == B_BACKSLASH) return null;
    A_start += 1;
    while (A_start < A_path.length && A_path.codeUnitAt(A_start) != B_BACKSLASH) {
      A_start++;
    }
    return A_path.substring(0, A_start);
  }
}
bool isAlphabetic(int char) => (char >= UPPER_A && char <= UPPER_Z) || (char >= LOWER_A && char <= LOWER_Z);
bool isNumeric(int char) => char >= A_ZERO && char <= NINE;
class Chain implements StackTrace {
  static StackZoneSpecification get _currentSpec => p.Zone.current[#stack_trace.stack_zone.spec];
  static track(futureOrStream) {
    if (_currentSpec == null) return futureOrStream;
    if (futureOrStream is p.Future) {
      return _currentSpec.trackFuture(futureOrStream, 1);
    } else {
      return _currentSpec.trackStream(futureOrStream, 1);
    }
  }
}
class StackZoneSpecification {}
typedef p.Future ItemProcessor<A_T>(A_T item);
class AsyncQueue<A_T> {
  final A__items = new A_p.Queue<A_T>();
  bool _isProcessing = false;
  final ItemProcessor<A_T> _processor;
  final Function _errorHandler;
  AsyncQueue(this._processor, {Function onError}) : _errorHandler = onError;
  void add(A_T item) {
    A__items.add(item);
    if (_isProcessing) return;
    _isProcessing = true;
    _processNextItem().catchError(_errorHandler);
  }
  void clear() {
    A__items.clear();
  }
  p.Future _processNextItem() {
    var item = A__items.removeFirst();
    return _processor(item).then((M__) {
      if (A__items.isNotEmpty) return _processNextItem();
      _isProcessing = false;
    });
  }
}
abstract class _ConstructableFileSystemEvent implements C_p.FileSystemEvent {
  final bool isDirectory;
  final String path;
  int get type;
  _ConstructableFileSystemEvent(this.path, this.isDirectory);
}
class ConstructableFileSystemCreateEvent extends _ConstructableFileSystemEvent implements C_p.FileSystemCreateEvent {
  final type = C_p.FileSystemEvent.CREATE;
  ConstructableFileSystemCreateEvent(String A_path, bool A_isDirectory) : super(A_path, A_isDirectory);
  String toString() => "FileSystemCreateEvent('${path}')";
}
class ConstructableFileSystemDeleteEvent extends _ConstructableFileSystemEvent implements C_p.FileSystemDeleteEvent {
  final type = C_p.FileSystemEvent.DELETE;
  ConstructableFileSystemDeleteEvent(String A_path, bool A_isDirectory) : super(A_path, A_isDirectory);
  String toString() => "FileSystemDeleteEvent('${path}')";
}
class ConstructableFileSystemModifyEvent extends _ConstructableFileSystemEvent implements C_p.FileSystemModifyEvent {
  final bool contentChanged;
  final type = C_p.FileSystemEvent.MODIFY;
  ConstructableFileSystemModifyEvent(String A_path, bool A_isDirectory, this.contentChanged) : super(A_path, A_isDirectory);
  String toString() => "FileSystemModifyEvent('${path}', contentChanged=${contentChanged})";
}
abstract class DirectoryWatcher {
  String get directory;
  p.Stream<WatchEvent> get events;
  bool get isReady;
  p.Future get ready;
  factory DirectoryWatcher(String A_directory, {Duration pollingDelay}) {
    if (C_p.Platform.isLinux) return new LinuxDirectoryWatcher(A_directory);
    if (C_p.Platform.isMacOS) return new MacOSDirectoryWatcher(A_directory);
    return new PollingDirectoryWatcher(A_directory, pollingDelay: pollingDelay);
  }
}
class LinuxDirectoryWatcher extends ResubscribableDirectoryWatcher {
  LinuxDirectoryWatcher(String directory) : super(directory, () => new _LinuxDirectoryWatcher(directory));
}
class _LinuxDirectoryWatcher implements ManuallyClosedDirectoryWatcher {
  final String directory;
  p.Stream<WatchEvent> get events => _eventsController.stream;
  final _eventsController = new p.StreamController<WatchEvent>.broadcast();
  bool get isReady => _readyCompleter.isCompleted;
  p.Future get ready => _readyCompleter.future;
  final _readyCompleter = new p.Completer();
  final B__entries = new Map<String,_EntryState>();
  final _subWatchers = new Map<String,_LinuxDirectoryWatcher>();
  final _subscriptions = new Set<p.StreamSubscription>();
  _LinuxDirectoryWatcher(String A_directory) : directory = A_directory {
    var innerStream = Chain.track(new C_p.Directory(A_directory).watch()).transform(new BatchedStreamTransformer<C_p.FileSystemEvent>());
    _listen(innerStream, _onBatch, onError: _eventsController.addError, onDone: A__onDone);
    _listen(Chain.track(new C_p.Directory(A_directory).list()), (entity) {
      B__entries[entity.path] = new _EntryState(entity is C_p.Directory);
      if (entity is! C_p.Directory) return;
      _watchSubdir(entity.path);
    }, onError: (A_error, A_stackTrace) {
      _eventsController.addError(A_error, A_stackTrace);
      close();
    }, onDone: () {
      _waitUntilReady().then((G__) => _readyCompleter.complete());
    }, cancelOnError: true);
  }
  p.Future _waitUntilReady() {
    return p.Future.wait(_subWatchers.values.map((watcher) => watcher.ready)).then((G__) {
      if (_subWatchers.values.every((watcher) => watcher.isReady)) return null;
      return _waitUntilReady();
    });
  }
  void close() {
    for (var A_subscription in _subscriptions) {
      A_subscription.cancel();
    }
    for (var watcher in _subWatchers.values) {
      watcher.close();
    }
    _subWatchers.clear();
    _subscriptions.clear();
    _eventsController.close();
  }
  Set<String> get _allFiles {
    var files = new Set<String>();
    _getAllFiles(files);
    return files;
  }
  void _getAllFiles(Set<String> files) {
    files.addAll(B__entries.keys.where((A_path) => B__entries[A_path] == _EntryState.B_FILE).toSet());
    for (var watcher in _subWatchers.values) {
      watcher._getAllFiles(files);
    }
  }
  void _watchSubdir(String A_path) {
    if (_subWatchers.containsKey(A_path)) return;
    var watcher = new _LinuxDirectoryWatcher(A_path);
    _subWatchers[A_path] = watcher;
    _listen(watcher.events, (event) {
      if (isReady) _eventsController.add(event);
    }, onError: (A_error, A_stackTrace) {
      _eventsController.addError(A_error, A_stackTrace);
      _eventsController.close();
    }, onDone: () {
      if (_subWatchers[A_path] == watcher) _subWatchers.remove(A_path);
      if (new C_p.Directory(A_path).existsSync()) _watchSubdir(A_path);
    });
    watcher.ready.then((G__) {
      if (!isReady || _eventsController.isClosed) return;
      _listen(Chain.track(new C_p.Directory(A_path).list(recursive: true)), (A_entry) {
        if (A_entry is C_p.Directory) return;
        _eventsController.add(new WatchEvent(ChangeType.ADD, A_entry.path));
      }, onError: (A_error, A_stackTrace) {
        if (A_error is C_p.FileSystemException) return;
        _eventsController.addError(A_error, A_stackTrace);
        close();
      }, cancelOnError: true);
    });
  }
  void _onBatch(List<C_p.FileSystemEvent> batch) {
    var changedEntries = new Set<String>();
    var oldEntries = new Map.from(B__entries);
    for (var event in batch) {
      if (event.path == directory) continue;
      changedEntries.add(event.path);
      if (event is C_p.FileSystemMoveEvent) {
        changedEntries.add(event.destination);
        _changeEntryState(event.path, ChangeType.REMOVE, event.isDirectory);
        _changeEntryState(event.destination, ChangeType.ADD, event.isDirectory);
      } else {
        _changeEntryState(event.path, _changeTypeFor(event), event.isDirectory);
      }
    }
    for (var A_path in changedEntries) {
      emitEvent(ChangeType A_type) {
        if (isReady) _eventsController.add(new WatchEvent(A_type, A_path));
      }
      var oldState = oldEntries[A_path];
      var newState = B__entries[A_path];
      if (oldState != _EntryState.B_FILE && newState == _EntryState.B_FILE) {
        emitEvent(ChangeType.ADD);
      } else if (oldState == _EntryState.B_FILE && newState == _EntryState.B_FILE) {
        emitEvent(ChangeType.A_MODIFY);
      } else if (oldState == _EntryState.B_FILE && newState != _EntryState.B_FILE) {
        emitEvent(ChangeType.REMOVE);
      }
      if (oldState == _EntryState.A_DIRECTORY) {
        var watcher = _subWatchers.remove(A_path);
        if (watcher == null) continue;
        for (var A_path in watcher._allFiles) {
          _eventsController.add(new WatchEvent(ChangeType.REMOVE, A_path));
        }
        watcher.close();
      }
      if (newState == _EntryState.A_DIRECTORY) _watchSubdir(A_path);
    }
  }
  void _changeEntryState(String A_path, ChangeType A_change, bool isDir) {
    if (A_change == ChangeType.ADD || A_change == ChangeType.A_MODIFY) {
      B__entries[A_path] = new _EntryState(isDir);
    } else {
      assert(A_change == ChangeType.REMOVE);
      B__entries.remove(A_path);
    }
  }
  ChangeType _changeTypeFor(C_p.FileSystemEvent event) {
    if (event is C_p.FileSystemDeleteEvent) return ChangeType.REMOVE;
    if (event is C_p.FileSystemCreateEvent) return ChangeType.ADD;
    assert(event is C_p.FileSystemModifyEvent);
    return ChangeType.A_MODIFY;
  }
  void A__onDone() {
    if (isReady) {
      B__entries.forEach((A_path, state) {
        if (state == _EntryState.A_DIRECTORY) return;
        _eventsController.add(new WatchEvent(ChangeType.REMOVE, A_path));
      });
    }
    p.Future.wait(_subWatchers.values.map((watcher) {
      try {
        return watcher.events.toList();
      }on StateError  catch (G__) {
        return new p.Future.value();
      }
    })).then((G__) => close());
  }
  void _listen(p.Stream A_stream, void A_onData(event), {Function onError, void onDone(), bool cancelOnError}) {
    var A_subscription;
    A_subscription = A_stream.listen(A_onData, onError: onError, onDone: () {
      _subscriptions.remove(A_subscription);
      if (onDone != null) onDone();
    }, cancelOnError: cancelOnError);
    _subscriptions.add(A_subscription);
  }
}
class _EntryState {
  final String F__name;
  static const B_FILE = const _EntryState.G__("file");
  static const A_DIRECTORY = const _EntryState.G__("directory");
  const _EntryState.G__(this.F__name);
  factory _EntryState(bool isDir) => isDir ? _EntryState.A_DIRECTORY : _EntryState.B_FILE;
  String toString() => F__name;
}
class MacOSDirectoryWatcher extends ResubscribableDirectoryWatcher {
  static var logDebugInfo = false;
  static var A__count = 0;
  MacOSDirectoryWatcher(String directory) : super(directory, () => new _MacOSDirectoryWatcher(directory, A__count++));
}
class _MacOSDirectoryWatcher implements ManuallyClosedDirectoryWatcher {
  static var A__count = 0;
  final String A__id;
  final String directory;
  p.Stream<WatchEvent> get events => A__eventsController.stream;
  final A__eventsController = new p.StreamController<WatchEvent>.broadcast();
  bool get isReady => A__readyCompleter.isCompleted;
  p.Future get ready => A__readyCompleter.future;
  final A__readyCompleter = new p.Completer();
  int batches = 0;
  final PathSet A__files;
  p.StreamSubscription<C_p.FileSystemEvent> _watchSubscription;
  final A__subscriptions = new Set<p.StreamSubscription>();
  _MacOSDirectoryWatcher(String A_directory, int parentId) : directory = A_directory, A__files = new PathSet(A_directory), A__id = "${parentId}/${A__count++}" {
    _startWatch();
    A__listen(Chain.track(new C_p.Directory(A_directory).list(recursive: true)), (entity) {
      if (entity is! C_p.Directory) A__files.add(entity.path);
    }, onError: _emitError, onDone: () {
      if (MacOSDirectoryWatcher.logDebugInfo) {
        print("[${A__id}] watcher is ready, known files:");
        for (var A_file in A__files.toSet()) {
          print("[${A__id}]   ${relative(A_file, from: A_directory)}");
        }
      }
      A__readyCompleter.complete();
    }, cancelOnError: true);
  }
  void close() {
    if (MacOSDirectoryWatcher.logDebugInfo) {
      print("[${A__id}] watcher is closed");
    }
    for (var A_subscription in A__subscriptions) {
      A_subscription.cancel();
    }
    A__subscriptions.clear();
    if (_watchSubscription != null) _watchSubscription.cancel();
    _watchSubscription = null;
    A__eventsController.close();
  }
  void A__onBatch(List<C_p.FileSystemEvent> batch) {
    if (MacOSDirectoryWatcher.logDebugInfo) {
      print("[${A__id}] ======== batch:");
      for (var event in batch) {
        print("[${A__id}]   ${_formatEvent(event)}");
      }
      print("[${A__id}] known files:");
      for (var A_file in A__files.toSet()) {
        print("[${A__id}]   ${relative(A_file, from: directory)}");
      }
    }
    batches++;
    _sortEvents(batch).forEach((A_path, A_events) {
      var relativePath = relative(A_path, from: directory);
      if (MacOSDirectoryWatcher.logDebugInfo) {
        print("[${A__id}] events for ${relativePath}:\n");
        for (var event in A_events) {
          print("[${A__id}]   ${_formatEvent(event)}");
        }
      }
      var canonicalEvent = _canonicalEvent(A_events);
      A_events = canonicalEvent == null ? _eventsBasedOnFileSystem(A_path) : [canonicalEvent];
      if (MacOSDirectoryWatcher.logDebugInfo) {
        print("[${A__id}] canonical event for ${relativePath}: " "${_formatEvent(canonicalEvent)}");
        print("[${A__id}] actionable events for ${relativePath}: " "${A_events.map(_formatEvent)}");
      }
      for (var event in A_events) {
        if (event is C_p.FileSystemCreateEvent) {
          if (!event.isDirectory) {
            if (A__files.contains(A_path)) continue;
            _emitEvent(ChangeType.ADD, A_path);
            A__files.add(A_path);
            continue;
          }
          if (A__files.containsDir(A_path)) continue;
          A__listen(Chain.track(new C_p.Directory(A_path).list(recursive: true)), (entity) {
            if (entity is C_p.Directory) return;
            _emitEvent(ChangeType.ADD, entity.path);
            A__files.add(entity.path);
          }, onError: (e, A_stackTrace) {
            if (MacOSDirectoryWatcher.logDebugInfo) {
              print("[${A__id}] got error listing ${relativePath}: ${e}");
            }
            _emitError(e, A_stackTrace);
          }, cancelOnError: true);
        } else if (event is C_p.FileSystemModifyEvent) {
          assert(!event.isDirectory);
          _emitEvent(ChangeType.A_MODIFY, A_path);
        } else {
          assert(event is C_p.FileSystemDeleteEvent);
          for (var removedPath in A__files.remove(A_path)) {
            _emitEvent(ChangeType.REMOVE, removedPath);
          }
        }
      }
    });
    if (MacOSDirectoryWatcher.logDebugInfo) {
      print("[${A__id}] ======== batch complete");
    }
  }
  Map<String, Set<C_p.FileSystemEvent>> _sortEvents(List<C_p.FileSystemEvent> batch) {
    var eventsForPaths = {};
    batch = batch.where((event) => event.path != directory).toList();
    var directories = unionAll(batch.map((event) {
      if (!event.isDirectory) return new Set();
      if (event is! C_p.FileSystemMoveEvent) return new Set.from([event.path]);
      return new Set.from([event.path, event.destination]);
    }));
    isInModifiedDirectory(A_path) => directories.any((dir) => A_path != dir && A_path.startsWith(dir));
    addEvent(A_path, event) {
      if (isInModifiedDirectory(A_path)) return;
      var B_set = eventsForPaths.putIfAbsent(A_path, () => new Set());
      B_set.add(event);
    }
    for (var event in batch) {
      assert(event is! C_p.FileSystemMoveEvent);
      addEvent(event.path, event);
    }
    return eventsForPaths;
  }
  C_p.FileSystemEvent _canonicalEvent(Set<C_p.FileSystemEvent> batch) {
    if (batch.isEmpty) return null;
    var A_type = batch.first.type;
    var isDir = batch.first.isDirectory;
    var hadModifyEvent = false;
    for (var event in batch.skip(1)) {
      if (isDir != event.isDirectory) return null;
      if (event is C_p.FileSystemModifyEvent) {
        hadModifyEvent = true;
        continue;
      }
      assert(event is C_p.FileSystemCreateEvent || event is C_p.FileSystemDeleteEvent);
      if (A_type == C_p.FileSystemEvent.MODIFY) {
        A_type = event.type;
        continue;
      }
      assert(A_type == C_p.FileSystemEvent.CREATE || A_type == C_p.FileSystemEvent.DELETE);
      if (A_type != event.type) return null;
    }
    if (A_type == C_p.FileSystemEvent.CREATE && hadModifyEvent && A__files.contains(batch.first.path)) {
      A_type = C_p.FileSystemEvent.MODIFY;
    }
    switch (A_type) {
      case C_p.FileSystemEvent.CREATE:
        return new ConstructableFileSystemCreateEvent(batch.first.path, isDir);

      case C_p.FileSystemEvent.DELETE:
        if (isDir) return null;
        return new ConstructableFileSystemCreateEvent(batch.first.path, false);

      case C_p.FileSystemEvent.MODIFY:
        return new ConstructableFileSystemModifyEvent(batch.first.path, isDir, false);

      default:
        assert(false);
    }
  }
  List<C_p.FileSystemEvent> _eventsBasedOnFileSystem(String A_path) {
    var fileExisted = A__files.contains(A_path);
    var dirExisted = A__files.containsDir(A_path);
    var fileExists = new C_p.File(A_path).existsSync();
    var dirExists = new C_p.Directory(A_path).existsSync();
    if (MacOSDirectoryWatcher.logDebugInfo) {
      print("[${A__id}] file existed: ${fileExisted}");
      print("[${A__id}] dir existed: ${dirExisted}");
      print("[${A__id}] file exists: ${fileExists}");
      print("[${A__id}] dir exists: ${dirExists}");
    }
    var A_events = [];
    if (fileExisted) {
      if (fileExists) {
        A_events.add(new ConstructableFileSystemModifyEvent(A_path, false, false));
      } else {
        A_events.add(new ConstructableFileSystemDeleteEvent(A_path, false));
      }
    } else if (dirExisted) {
      if (dirExists) {
        A_events.add(new ConstructableFileSystemDeleteEvent(A_path, true));
        A_events.add(new ConstructableFileSystemCreateEvent(A_path, true));
      } else {
        A_events.add(new ConstructableFileSystemDeleteEvent(A_path, true));
      }
    }
    if (!fileExisted && fileExists) {
      A_events.add(new ConstructableFileSystemCreateEvent(A_path, false));
    } else if (!dirExisted && dirExists) {
      A_events.add(new ConstructableFileSystemCreateEvent(A_path, true));
    }
    return A_events;
  }
  void B__onDone() {
    _watchSubscription = null;
    if (batches < 2 && new C_p.Directory(directory).existsSync()) {
      _startWatch();
      return;
    }
    for (var A_file in A__files.toSet()) {
      _emitEvent(ChangeType.REMOVE, A_file);
    }
    A__files.clear();
    close();
  }
  void _startWatch() {
    var innerStream = Chain.track(new C_p.Directory(directory).watch(recursive: true)).transform(new BatchedStreamTransformer<C_p.FileSystemEvent>());
    _watchSubscription = innerStream.listen(A__onBatch, onError: A__eventsController.addError, onDone: B__onDone);
  }
  void _emitEvent(ChangeType A_type, String A_path) {
    if (!isReady) return;
    if (MacOSDirectoryWatcher.logDebugInfo) {
      print("[${A__id}] emitting ${A_type} ${relative(A_path, from: directory)}");
    }
    A__eventsController.add(new WatchEvent(A_type, A_path));
  }
  void _emitError(A_error, StackTrace A_stackTrace) {
    A__eventsController.addError(A_error, A_stackTrace);
    close();
  }
  void A__listen(p.Stream A_stream, void A_onData(event), {Function onError, void onDone(), bool cancelOnError}) {
    var A_subscription;
    A_subscription = A_stream.listen(A_onData, onError: onError, onDone: () {
      A__subscriptions.remove(A_subscription);
      if (onDone != null) onDone();
    }, cancelOnError: cancelOnError);
    A__subscriptions.add(A_subscription);
  }
  String _formatEvent(C_p.FileSystemEvent event) {
    if (event == null) return 'null';
    var A_path = relative(event.path, from: directory);
    var A_type = event.isDirectory ? 'directory' : 'file';
    if (event is C_p.FileSystemCreateEvent) {
      return "create ${A_type} ${A_path}";
    } else if (event is C_p.FileSystemDeleteEvent) {
      return "delete ${A_type} ${A_path}";
    } else if (event is C_p.FileSystemModifyEvent) {
      return "modify ${A_type} ${A_path}";
    } else if (event is C_p.FileSystemMoveEvent) {
      return "move ${A_type} ${A_path} to " "${relative(event.destination, from: directory)}";
    }
  }
}
class PollingDirectoryWatcher extends ResubscribableDirectoryWatcher {
  PollingDirectoryWatcher(String directory, {Duration pollingDelay}) : super(directory, () {
    return new _PollingDirectoryWatcher(directory, pollingDelay != null ? pollingDelay : new Duration(seconds: 1));
  });
}
class _PollingDirectoryWatcher implements ManuallyClosedDirectoryWatcher {
  final String directory;
  p.Stream<WatchEvent> get events => _events.stream;
  final _events = new p.StreamController<WatchEvent>.broadcast();
  bool get isReady => _ready.isCompleted;
  p.Future get ready => _ready.future;
  final _ready = new p.Completer();
  final Duration _pollingDelay;
  final _statuses = new Map<String,_FileStatus>();
  p.StreamSubscription<C_p.FileSystemEntity> _listSubscription;
  AsyncQueue<String> _filesToProcess;
  final _polledFiles = new Set<String>();
  _PollingDirectoryWatcher(this.directory, this._pollingDelay) {
    _filesToProcess = new AsyncQueue<String>(_processFile, onError: (e, A_stackTrace) {
      if (!_events.isClosed) _events.addError(e, A_stackTrace);
    });
    _poll();
  }
  void close() {
    _events.close();
    if (_listSubscription != null) _listSubscription.cancel();
    _filesToProcess.clear();
    _polledFiles.clear();
    _statuses.clear();
  }
  void _poll() {
    _filesToProcess.clear();
    _polledFiles.clear();
    endListing() {
      assert(!_events.isClosed);
      _listSubscription = null;
      _filesToProcess.add(null);
    }
    var A_stream = Chain.track(new C_p.Directory(directory).list(recursive: true));
    _listSubscription = A_stream.listen((entity) {
      assert(!_events.isClosed);
      if (entity is! C_p.File) return;
      _filesToProcess.add(entity.path);
    }, onError: (A_error, A_stackTrace) {
      if (!isDirectoryNotFoundException(A_error)) {
        _events.addError(A_error, A_stackTrace);
      }
      endListing();
    }, onDone: endListing, cancelOnError: true);
  }
  p.Future _processFile(String A_file) {
    if (A_file == null) return _completePoll();
    return getModificationTime(A_file).then((A_modified) {
      if (_events.isClosed) return null;
      var lastStatus = _statuses[A_file];
      if (lastStatus != null && lastStatus.modified == A_modified) {
        _polledFiles.add(A_file);
        return null;
      }
      return _hashFile(A_file).then((hash) {
        if (_events.isClosed) return;
        var status = new _FileStatus(A_modified, hash);
        _statuses[A_file] = status;
        _polledFiles.add(A_file);
        if (!isReady) return;
        var A_changed = lastStatus == null || !_sameHash(lastStatus.hash, hash);
        if (!A_changed) return;
        var A_type = lastStatus == null ? ChangeType.ADD : ChangeType.A_MODIFY;
        _events.add(new WatchEvent(A_type, A_file));
      });
    });
  }
  p.Future _completePoll() {
    var removedFiles = _statuses.keys.toSet().difference(_polledFiles);
    for (var removed in removedFiles) {
      if (isReady) _events.add(new WatchEvent(ChangeType.REMOVE, removed));
      _statuses.remove(removed);
    }
    if (!isReady) _ready.complete();
    return new p.Future.delayed(_pollingDelay).then((N__) {
      if (_events.isClosed) return;
      _poll();
    });
  }
  p.Future<List<int>> _hashFile(String A_path) {
    return Chain.track(new C_p.File(A_path).readAsBytes()).then((bytes) {
      var sha1 = new SHA1();
      sha1.add(bytes);
      return sha1.close();
    });
  }
  bool _sameHash(List<int> a, List<int> b) {
    assert(a.length == b.length);
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}
class _FileStatus {
  DateTime modified;
  List<int> hash;
  _FileStatus(this.modified, this.hash);
}
typedef ManuallyClosedDirectoryWatcher WatcherFactory();
abstract class ResubscribableDirectoryWatcher implements DirectoryWatcher {
  final WatcherFactory _factory;
  final String directory;
  p.Stream<WatchEvent> get events => B__eventsController.stream;
  p.StreamController<WatchEvent> B__eventsController;
  bool get isReady => B__readyCompleter.isCompleted;
  p.Future get ready => B__readyCompleter.future;
  var B__readyCompleter = new p.Completer();
  ResubscribableDirectoryWatcher(this.directory, this._factory) {
    var watcher;
    var A_subscription;
    B__eventsController = new p.StreamController<WatchEvent>.broadcast(onListen: () {
      watcher = _factory();
      A_subscription = watcher.events.listen(B__eventsController.add, onError: B__eventsController.addError, onDone: B__eventsController.close);
      watcher.ready.then(B__readyCompleter.complete);
    }, onCancel: () {
      A_subscription.cancel();
      watcher.close();
      B__readyCompleter = new p.Completer();
    }, sync: true);
  }
}
abstract class ManuallyClosedDirectoryWatcher implements DirectoryWatcher {
  void close();
}
class PathSet {
  final String A_root;
  final C__entries = new Map<String,Map>();
  final _paths = new Set<String>();
  PathSet(this.A_root);
  void add(String A_path) {
    A_path = A__normalize(A_path);
    _paths.add(A_path);
    var parts = _split(A_path);
    var dir = C__entries;
    for (var part in parts) {
      dir = dir.putIfAbsent(part, () => {});
    }
  }
  Set<String> remove(String A_path) {
    A_path = A__normalize(A_path);
    var parts = new A_p.Queue.from(_split(A_path));
    recurse(dir, partialPath) {
      if (parts.length > 1) {
        var part = parts.removeFirst();
        var A_entry = dir[part];
        if (A_entry.isEmpty) return new Set();
        partialPath = B_join(partialPath, part);
        var paths = recurse(A_entry, partialPath);
        if (A_entry.isEmpty && !_paths.contains(partialPath)) dir.remove(part);
        return paths;
      }
      var A_entry = dir.remove(parts.first);
      if (A_entry == null) return new Set();
      if (A_entry.isEmpty) {
        _paths.remove(A_path);
        return new Set.from([A_path]);
      }
      var B_set = _removePathsIn(A_entry, A_path);
      if (_paths.contains(A_path)) {
        _paths.remove(A_path);
        B_set.add(A_path);
      }
      return B_set;
    }
    return recurse(C__entries, A_root);
  }
  Set<String> _removePathsIn(Map dir, String A_root) {
    var removedPaths = new Set();
    recurse(dir, A_path) {
      dir.forEach((A_name, A_entry) {
        var entryPath = B_join(A_path, A_name);
        if (_paths.remove(entryPath)) removedPaths.add(entryPath);
        recurse(A_entry, entryPath);
      });
    }
    recurse(dir, A_root);
    return removedPaths;
  }
  bool contains(String A_path) => _paths.contains(A__normalize(A_path));
  bool containsDir(String A_path) {
    A_path = A__normalize(A_path);
    var dir = C__entries;
    for (var part in _split(A_path)) {
      dir = dir[part];
      if (dir == null) return false;
    }
    return !dir.isEmpty;
  }
  Set<String> toSet() => _paths.toSet();
  void clear() {
    _paths.clear();
    C__entries.clear();
  }
  String toString() => _paths.toString();
  String A__normalize(String A_path) {
    var A_relative = relative(normalize(A_path), from: A_root);
    var parts = B_split(A_relative);
    if (!isRelative(A_relative) || parts.first == '..' || parts.first == '.') {
      throw new ArgumentError('Path "${A_path}" is not inside "${A_root}".');
    }
    return B_join(A_root, A_relative);
  }
  List<String> _split(String A_path) => B_split(relative(A_path, from: A_root));
}
typedef DateTime MockTimeCallback(String path);
MockTimeCallback _mockTimeCallback;
p.Future<DateTime> getModificationTime(String A_path) {
  if (_mockTimeCallback != null) {
    return new p.Future.value(_mockTimeCallback(A_path));
  }
  return Chain.track(C_p.FileStat.stat(A_path)).then((A_stat) => A_stat.modified);
}
bool isDirectoryNotFoundException(A_error) {
  if (A_error is! C_p.FileSystemException) return false;
  var notFoundCode = C_p.Platform.operatingSystem == "windows" ? 3 : 2;
  return A_error.osError.errorCode == notFoundCode;
}
Set unionAll(Iterable<Set> sets) => sets.fold(new Set(), (A_union, B_set) => A_union.union(B_set));
class BatchedStreamTransformer<B_T> implements p.StreamTransformer<B_T, List<B_T>> {
  p.Stream<List<B_T>> bind(p.Stream<B_T> A_input) {
    var batch = new A_p.Queue();
    return new p.StreamTransformer<B_T,List<B_T>>.fromHandlers(handleData: (event, A_sink) {
      batch.add(event);
      p.Timer.run(() {
        if (batch.isEmpty) return;
        A_sink.add(batch.toList());
        batch.clear();
      });
    }, handleDone: (A_sink) {
      if (batch.isNotEmpty) {
        A_sink.add(batch.toList());
        batch.clear();
      }
      A_sink.close();
    }).bind(A_input);
  }
}
class WatchEvent {
  final ChangeType type;
  final String path;
  WatchEvent(this.type, this.path);
  String toString() => "${type} ${path}";
}
class ChangeType {
  static const ADD = const ChangeType("add");
  static const REMOVE = const ChangeType("remove");
  static const A_MODIFY = const ChangeType("modify");
  final String G__name;
  const ChangeType(this.G__name);
  String toString() => G__name;
}
